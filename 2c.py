"""2c.py  -- Python-to-C compiler"""
Author = "Bulatov Vladislav"

## 2c.py is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## 2c.py is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

import cmath
import csv
import difflib                
from dis import findlinestarts   
from distutils import sysconfig    
from distutils.ccompiler import new_compiler
##import distutils.core
import glob
import inspect
from itertools import groupby
import math
from opcode import HAVE_ARGUMENT, hasjrel as hasjrel2, opname, EXTENDED_ARG, hasconst as hasconst2, hasname as hasname2, haslocal as haslocal2, hascompare as hascompare2, hasfree as hasfree2, cmp_op, hasjabs
import operator
from optparse import OptionParser, OptionGroup
import os
import os.path
import sys
import time
import types
import subprocess        


global check_calcref 
check_calcref = False

## is_pypy = False #'PyPy' in sys.version

## is_pypy18 = False #'PyPy' in sys.version

py_version = 27
 
if py_version <= 28:
    MInt = sys.maxint
else:
    MInt = sys.maxsize    

assert py_version != 50

cnt__init__1 = 0
cnt_disassemble_base = 0

def Len(t):
    le = 0
    if type(t) is int:
        le = 5
    elif type(t) is long:
        le = 10
    elif type(t) is float:
        le = 10
    elif type(t) is bool:
        le = 5
    elif type(t) is type:
        le = 15
    elif type(t) is tuple:
        le = 2 + sum([Len(x) for x in t])
        if len(t) > 1:
            le += 2 * (len(t) - 1)
    elif type(t) is list:
        le = 2 + sum([Len(x) for x in t])
        if len(t) > 1:
            le += 2 * (len(t) - 1)
    elif type(t) is set:
        le = 2 + sum([Len(x) for x in t])
        if len(t) > 1:
            le += 2 * (len(t) - 1)
    elif type(t) is frozenset:
        le = 2 + sum([Len(x) for x in t])
        if len(t) > 1:
            le += 2 * (len(t) - 1)
    elif type(t) is Out:
        le = 2 + sum([Len(x) for x in t])
        if len(t) > 1:
            le += 2 * (len(t) - 1)
    elif type(t) is dict:
        le = 2 + sum([Len(x) + Len(y) + 2 for x,y in t.iteritems()])
        if len(t) > 1:
            le += 2 * (len(t) - 1)
    elif type(t) is str:
        le = len(t) + 3
    else:
        le = len(repr(t))

    assert type(le) is int
    if le > 1000000:
        return 100000
    assert le >= 0 and le < 1000000
    return le

global is_code_ext
is_code_ext = False
if hasattr(Len, "func_code") and hasattr(Len.func_code, "co_cfunc"):
    is_code_ext = True

def pp(*tupl):
    sys.stdout.write(" ".join([str(x) for x in tupl]) + '\n')

def pp_out(out, *tupl):
    out.write(" ".join([str(x) for x in tupl]) + '\n')


def pprint(object, indent=1, width=80):
    assert type(indent) is int and indent >= -1 and indent <= (MInt / 10)
    assert type(width) is int and width > 0 and width <= (MInt / 10)
    printer = PrettyPrinter(indent, width, [''])
    printer.pprint(object)
    for s in printer._stream:
        pp(s)
        

def pprint_to_f(f, object, indent=1, width=80):
    assert type(indent) is int and indent >= -1 and indent <= (MInt / 10)
    assert type(width) is int and width > 0 and width <= (MInt / 10) 
    printer = PrettyPrinter(indent, width, [''])
    printer.pprint(object)
    for s in printer._stream:
        f.write(s) 
        f.write('\n')
        
class PrettyPrinter(object):
    def __init__(self, indent, width, stream ):
        
        assert type(indent) is int and indent >= -1 and indent <= (MInt / 10)
        assert type(width) is int and width > 0 and width <= (MInt / 10)
        assert type(indent) is int and indent >= 0 and indent <= 255
        self._indent_per_level = indent
        self._width = width
        self._stream = stream

    def pprint(self, object):
        self._format(object, self._stream, 0, 0, 0)
        self._stream.append('')

    def _format(self, object, stream, indent, allowance, level):
        assert type(level) is int 
        assert type(indent) is int and indent >= -1 and indent <= (MInt / 10) 

        assert type(allowance) is int and allowance >= 0
        
        assert level >= 0
        
        assert indent >= 0
        assert type(stream) is list        
        
        level = level + 1


 
        if type(object) is dict:
            stream[-1] += ('{')
            if self._indent_per_level > 1:
                stream[-1] += ((self._indent_per_level - 1) * ' ')
            length = len(object)
            if length:
                indent = indent + self._indent_per_level
                items = object.items()
                key, ent = items[0]
                rep = repr(key)
                stream[-1] += (rep)
                stream[-1] += (': ')
                self._format(ent, stream, indent + len(rep) + 2,
                              allowance + 1, level)
                if length > 1:
                    sepLines = Len(object) > (self._width - 1 - indent - allowance)                    
                    for key, ent in items[1:]:
                        rep = repr(key)
                        if sepLines:
                            stream[-1] += ','
                            stream.append('%s%s: ' % (' '*indent, rep))
                        else:
                            stream[-1] += (', %s: ' % rep)
                        self._format(ent, stream, indent + len(rep) + 2,
                                      allowance + 1, level)
                indent = indent - self._indent_per_level
            stream[-1] += ('}')
            return

        if (type(object) is list or type(object) is Out or type(object) is tuple or type(object) is set or type(object) is frozenset):
            length = len(object)
            if type(object) is list or type(object) is Out:
                stream[-1] += ('[')
                endchar = ']'
            elif type(object) is set:
                if not length:
                    stream[-1] += ('set()')
                    return
                stream[-1] += ('set([')
                endchar = '])'
                indent += 4
                object = list(object)
                object.sort()
            elif type(object) is frozenset:
                if not length:
                    stream[-1] += ('frozenset()')
                    return
                stream[-1] += ('frozenset([')
                endchar = '])'
                indent += 10
                object = list(object)
                object.sort()
            else:
                stream[-1] += ('(')
                endchar = ')'
            sepLines = Len(object) > (self._width - 1 - indent - allowance)                      
            if self._indent_per_level > 1 and sepLines:
                stream[-1] += ((self._indent_per_level - 1) * ' ')
            if length:
                indent = indent + self._indent_per_level
                self._format(object[0], stream, indent, allowance + 1,
                             level)
                if length > 1:
                    for ent in object[1:]:
                        if sepLines:
                            stream[-1] += (',')
                            stream.append(' '*indent)
                        else:
                            stream[-1] += (', ')
                        self._format(ent, stream, indent,
                                      allowance + 1, level)
                indent = indent - self._indent_per_level
            if type(object) is tuple and length == 1:
                stream[-1] += (',')
            stream[-1] += (endchar)
            return

        stream[-1] += repr(object)

 

d_built = {'ArithmeticError': ArithmeticError,
'AssertionError': AssertionError,
'AttributeError': AttributeError,
'BaseException': BaseException,
'DeprecationWarning': DeprecationWarning,
'EOFError': EOFError,
'Ellipsis': Ellipsis,
'EnvironmentError': EnvironmentError,
'Exception': Exception,
'False': False,
'FloatingPointError': FloatingPointError,
'FutureWarning': FutureWarning,
'GeneratorExit': GeneratorExit,
'IOError': IOError,
'ImportError': ImportError,
'ImportWarning': ImportWarning,
'IndentationError': IndentationError,
'IndexError': IndexError,
'KeyError': KeyError,
'KeyboardInterrupt': KeyboardInterrupt,
'LookupError': LookupError,
'MemoryError': MemoryError,
'NameError': NameError,
'None': None,
'NotImplemented': NotImplemented,
'NotImplementedError': NotImplementedError,
'OSError': OSError,
'OverflowError': OverflowError,
'PendingDeprecationWarning': PendingDeprecationWarning,
'ReferenceError': ReferenceError,
'RuntimeError': RuntimeError,
'RuntimeWarning': RuntimeWarning,
'StopIteration': StopIteration,
'SyntaxError': SyntaxError,
'SyntaxWarning': SyntaxWarning,
'SystemError': SystemError,
'SystemExit': SystemExit,
'TabError': TabError,
'True': True,
'TypeError': TypeError,
'UnboundLocalError': UnboundLocalError,
'UnicodeDecodeError': UnicodeDecodeError,
'UnicodeEncodeError': UnicodeEncodeError,
'UnicodeError': UnicodeError,
'UnicodeTranslateError': UnicodeTranslateError,
'UnicodeWarning': UnicodeWarning,
'UserWarning': UserWarning,
'ValueError': ValueError,
'Warning': Warning,
'ZeroDivisionError': ZeroDivisionError,
'__import__': __import__,
'abs': abs,
'all': all,
'any': any,
'bool': bool,
'callable': callable,
'chr': chr,
'classmethod': classmethod,
'compile': compile,
'complex': complex,
'copyright': copyright,
'credits': credits,
'delattr': delattr,
'dict': dict,
'dir': dir,
'divmod': divmod,
'enumerate': enumerate,
'eval': eval,
'exit': exit,
'filter': filter,
'float': float,
'frozenset': frozenset,
'getattr': getattr,
'globals': globals,
'hasattr': hasattr,
'hash': hash,
'help': help,
'hex': hex,
'id': id,
'input': input,
'int': int,
'isinstance': isinstance,
'issubclass': issubclass,
'iter': iter,
'len': len,
'license': license,
'list': list,
'locals': locals,
'map': map,
'max': max,
'min': min,
'object': object,
'oct': oct,
'open': open,
'ord': ord,
'pow': pow,
'property': property,
'quit': quit,
'range': range,
'repr': repr,
'reversed': reversed,
'round': round,
'set': set,
'setattr': setattr,
'slice': slice,
'sorted': sorted,
'staticmethod': staticmethod,
'str': str,
'sum': sum,
'super': super,
'tuple': tuple,
'type': type,
'vars': vars,
'zip': zip}

if py_version < 30:
    d_built['StandardError'] = StandardError
    d_built['apply'] = apply   
    d_built['basestring'] = basestring
    d_built['buffer'] = buffer
    d_built['cmp'] = cmp
    d_built['coerce'] = coerce
    d_built['execfile'] = execfile
    d_built['file'] = file
    d_built['intern'] = intern
    d_built['long'] = long
    d_built['raw_input'] = raw_input
    d_built['reduce'] = reduce
    d_built['reload'] = reload
    d_built['unichr'] = unichr
    d_built['unicode'] = unicode
    d_built['xrange'] = xrange
     
if py_version > 25:
    d_built['BufferError'] = BufferError
    d_built['BytesWarning'] = BytesWarning
    d_built['bin'] = bin
    d_built['bytearray'] = bytearray
    d_built['bytes'] = bytes
    d_built['next'] = next

if py_version > 26:
    d_built['memoryview'] = memoryview

d_built_inv = dict([(_y_,_x_) for _x_,_y_ in d_built.items()])

out = -1
out3 = -1
debug = False
filename = ""

global Pass
global Prev_Time
global Prev_Pass
global Pass_Exit 
Pass = {}
Prev_Time = None
Prev_Pass = None
Pass_Exit = None

restart = False

tags_one_step_expr = ('CONST', 'FAST', 'BUILTIN', 'TYPED_TEMP', \
                      'LOAD_CLOSURE', 'PY_TEMP', \
                      'f->f_locals', \
                      'bdict', 'CALC_CONST', 'PY_TYPE')

TRUE = ('CONST', True)
pos__a = pos__b = pos__c = pos__d = pos__e = pos__f = pos__g = pos__h = pos__i = pos__j = pos__k = pos__l = ""

call = ('CALL_FUNCTION_VAR', 'CALL_FUNCTION_KW', 'CALL_FUNCTION_VAR_KW', 'CALL_FUNCTION', 'CALL_METHOD')

set_var = ('STORE_FAST', 'STORE_NAME', 'STORE_GLOBAL', 'STORE_DEREF')
set_any = set(set_var + ('PyObject_SetAttr', 'PyObject_SetItem','STORE_SLICE_LV+0',\
                     'STORE_SLICE_LV+1', 'STORE_SLICE_LV+2','STORE_SLICE_LV+3',\
                      'SET_VARS'))
                      
## set_not_attempt = set(('CONST', 'FAST', '!BUILD_LIST', 'CALC_CONST', ##'!LOAD_BUILTIN', 
                    ## ##'!STR_CONCAT', '!STR_CONCAT_N', '!STR_CONCAT2', '!STR_CONCAT3',
                    ## '!BUILD_TUPLE', '!CALL_CALC_CONST', '!IMPORT_NAME', 'LOAD_BUILTIN', '!LOAD_BUILTIN', 
                    ## 'CALL_CALC_CONST_INDIRECT', '!CALL_CALC_CONST_INDIRECT', '!PySet_New', 'PySet_New', 
                    ## 'PyString_Format', '!PyString_Format', '!PyDict_New', 'PyDict_New',
                    ## 'LIST_COMPR', '!LIST_COMPR', 'NCMP', '!NCMP', 'CLASS_CALC_CONST_NEW', '!CLASS_CALC_CONST_NEW',
                    ## '!PyDict_Keys', 'PyDict_Keys',  'SET_COMPR', '!SET_COMPR',
                    ## '!PyDict_Items', 'PyDict_Items', 'PyList_AsTuple', '!PyList_AsTuple',
                    ## ## '!_PyEval_ApplySlice', '_PyEval_ApplySlice', '!PyTuple_GetSlice', 'PyTuple_GetSlice',
                    ## ## '!PySequence_GetSlice', 'PySequence_GetSlice', '!PyList_GetSlice', 'PyList_GetSlice', 
                    ## 'CALL_CALC_CONST', 'COND_METH_EXPR', '!COND_METH_EXPR', 
                    ## 'BUILD_MAP ', '!BUILD_MAP',
                    ## '!PyDict_Values', 'PyDict_Values', '!PyDict_Copy', 'PyDict_Copy', 'CALL_CALC_CONST',
                    ## '!PyInt_Type.tp_str', 'PyInt_Type.tp_str', '!PyObject_Dir', 'PyObject_Dir',          
                    ## '!PyObject_Str', 'PyObject_Str', '!PyObject_Repr', 'PyObject_Repr', '!PySequence_List', 'PySequence_List',  
                    ## '!PySequence_Tuple', 'PySequence_Tuple', '!CALL_CALC_CONST', 'CALL_CALC_CONST',
                    ## '!_PyString_Join', '_PyString_Join', 'LOAD_DEREF', '!LOAD_DEREF', 
                    ## 'range', 'xrange', '!PySequence_Repeat', 'PySequence_Repeat', 'round', 'LOAD_GLOBAL', '!LOAD_GLOBAL',
                    ## '!LOAD_GLOBAL', '!LOAD_NAME', '!MK_FUNK', '!CALL_CALC_CONST', 'BUILD_LIST', '!BUILD_LIST', '!BUILD_TUPLE', 'BUILD_TUPLE'))

set_not_attempt = set(('CONST', 'FAST', 
                    '!BUILD_LIST', 
                    'CALC_CONST', ##'!LOAD_BUILTIN', 
                    '!BUILD_TUPLE', 
                    '!CALL_CALC_CONST', 
                    ##'!IMPORT_NAME', 
                    'LOAD_BUILTIN', '!LOAD_BUILTIN', 
                    ##'CALL_CALC_CONST_INDIRECT', '!CALL_CALC_CONST_INDIRECT', 
                    ##'!PySet_New', 'PySet_New', 
                    ##'PyString_Format', '!PyString_Format', '!PyDict_New', 'PyDict_New',
                    ##'LIST_COMPR', '!LIST_COMPR', 
                    'NCMP', '!NCMP', 
                    ##'CLASS_CALC_CONST_NEW', '!CLASS_CALC_CONST_NEW',
                    ##'!PyDict_Keys', 'PyDict_Keys',  'SET_COMPR', '!SET_COMPR',
                    ##'!PyDict_Items', 'PyDict_Items', 'PyList_AsTuple', '!PyList_AsTuple',
                    ##'CALL_CALC_CONST', 
                    'COND_METH_EXPR', '!COND_METH_EXPR', 
                    'BUILD_MAP ', '!BUILD_MAP',
                    ##'!PyDict_Values', 'PyDict_Values', '!PyDict_Copy', 'PyDict_Copy', 'CALL_CALC_CONST',
                    ##'!PyInt_Type.tp_str', 'PyInt_Type.tp_str', '!PyObject_Dir', 'PyObject_Dir',          
                    ##'!PyObject_Str', 'PyObject_Str', '!PyObject_Repr', 'PyObject_Repr', '!PySequence_List', 'PySequence_List',  
                    ##'!PySequence_Tuple', 'PySequence_Tuple', '!CALL_CALC_CONST', 'CALL_CALC_CONST',
                    ##'!_PyString_Join', '_PyString_Join', 
                    'LOAD_DEREF', '!LOAD_DEREF', 
                    ##'range', 'xrange', '!PySequence_Repeat', 'PySequence_Repeat', 'round', 
                    'LOAD_GLOBAL', '!LOAD_GLOBAL', ##'!COND_EXPR', 'COND_EXPR', 
                    '!LOAD_GLOBAL', '!LOAD_NAME', '!MK_FUNK', 
                    ##'!CALL_CALC_CONST' ##, 
                    'BUILD_LIST', '!BUILD_LIST', 
                    '!BUILD_TUPLE', 'BUILD_TUPLE'
                    ))
build_executable = False
fast_globals = False
attempt_import_info = True
no_compiled = {}
detect_attr_type = True # for fix test_ast.py
detected_attr_type = {}
detected_return_type = {}
default_args = {}
val_direct_code = {}
direct_code = {}
list_import = {}
global start_sys_modules
start_sys_modules = None

redefined_builtin = {}
redefined_attribute = True
all_trin = {}
all_meth = []
all_derived = {}

ImportedM = {}

global Line2Addr
Line2Addr = []

global direct_args
direct_args = {}
redefined_all = False
count_define_set = {}
count_define_get = {}
matched_tail_label = ''
self_attr_type = {}
IS_CFUNC = 0x1
IS_DIRECT = 0x2
IS_CODEFUNC = 0x4
IS_PCODE = 0x8
IS_DICTIONABLE_CFUNC = 0x10
IS_ANY_CFUNC = (IS_CFUNC | IS_DICTIONABLE_CFUNC)
IS_CALLABLE_COMPILABLE = (IS_CFUNC | IS_CODEFUNC | IS_DICTIONABLE_CFUNC)
global is_current
is_current = 0
type_def = {}

compile_generators = False

codegen_notexist = 0
codegen_notfound = 0
codegen_found = 0
codegen_type = 0
count_bigpass = 1
n_bigpass = 0
fast_slots = False
auto_slots = False
using_slots = False

list_cname_exe = []


is_can_be_codefunc = True
def _3(nm, attr, value):
    global all_trin
    all_trin[(nm,attr,value)] = True


flag_stat = False

stat_3 = {}

def Val3(nm, attr):
    if flag_stat:
        if not (attr in stat_3):
            stat_3[attr] = 0
        stat_3[attr] += 1    
    for a,b,c in all_trin.keys():
        if nm is not None and a != nm:
            continue
        if attr is not None and b != attr:
            continue
        return c
    return None

def Is3(nm, attr, value=None):
    for a,b,c in all_trin.keys():
        if nm is not None and a != nm:
            continue
        if attr is not None and b != attr:
            continue
        if value is not None and c != value:
            continue
        return True
    return False

def Iter3(nm, attr, value):
    if flag_stat:
        if not (attr in stat_3):
            stat_3[attr] = 0
        stat_3[attr] += 1
    ret = []
    for a,b,c in all_trin.keys():
        if nm is not None and a != nm:
            continue
        if attr is not None and b != attr:
            continue
        if value is not None and c != value:
            continue
        ret.append((a,b,c))
    return ret

linear_debug = True

def HideDebug(*args):
    pass

uniq_debug_messages = {}

def Debug(*args):
    if hide_debug:
        return
    if linear_debug:
        s = ' '.join([repr(v) for v in args])
        s = s.replace('\"', '\'')
        uniq_debug_messages[s] = None 
    else:
        pp(list(args))
        ## return
        ## stream = ['']
        ## for v in args:
            ## pprint(v, stream, 1)
        ## ls = stream
        ## if ls[-1] == '':
            ## del ls[-1]
        ## ls.insert(0, '<<<')
        ## ls.append('>>>')
        ## for iit in ls:
            ## pp('-- ' + iit)
    
def FlushDebug():
    li = uniq_debug_messages.keys()
    li.sort()
    for s in li:    
        pp('-- ' + s)
    uniq_debug_messages.clear()   
        
def Fatal(msg, *args):
    FlushDebug()
    pp(msg +  ' ' + str(args))
    assert False

T_ANY_CL_TYP = 'AnyClassType'
T_ANY_CL_INST = 'AnyClassInstance'
T_OLD_CL_TYP = 'OldClassType'
T_OLD_CL_INST = 'OldClassInstance'
T_NEW_CL_TYP = 'NewClassType'
T_NEW_CL_INST = 'NewClassInstance'

def Int(a,b):
    if a > b:
        pp(type(a), type(b), a, b)
    assert a <= b
    return (int, (a, b))

Kl_All = ('all', None)
Kl_Undefined = ('undefined', None)
Kl_Int = Int((-MInt)-1,MInt)
Kl_SymmetricInt = Int((-MInt),MInt)
assert type(Kl_Int[1][0]) is int

_short_rng = (-((256*256)-1), (256*256)-1)
Kl_Short = Int(-((256*256)-1), (256*256)-1)
Kl_ShortPlus = Int(-((256*256*256)-1), (256*256*256)-1)
Kl_ShortChar = Int(-127, 127)
Kl_Cardinal = Int(0, MInt)
Kl_FromMinusOne = Int(-1, MInt/10)
Kl_ShortCardinal = Int(0, 0xffff)
Kl_CodeChar = Int(0, 255)

Kl_Reversed = (reversed, None)



def IsModule(t):
    return type(t) is tuple and t[0] is types.ModuleType

def IsInt(t):
    return type(t) is tuple and len(t) == 2 and t[0] is int        
 
def IsCardinal(t):
    return type(t) is tuple and len(t) == 2 and t[0] is int and type(t[1]) is tuple and t[1][0] >= 0

def IsNegInt(t):
    return type(t) is tuple and len(t) == 2 and t[0] is int and type(t[1]) is tuple and t[1][1] < 0
    
def IsShort(t):
    if type(t) is tuple and t[0] is int and type(t[1]) is tuple and \
       type(t[1][0]) is int and t[1][0] >= Kl_Short[1][0] and \
       type(t[1][1]) is int and t[1][1] <= Kl_Short[1][1]:
        assert IsInt(t)
        return True
    return False

def IsCardinalChar(t):
    return type(t) is tuple and len(t) == 2 and t[0] is int and type(t[1]) is tuple and t[1][0] >= 0 and t[1][1] <= 255

def IsStr(t):
    if type(t) is tuple and t[0] is str:
        return True
    return False

def IsUnicode(t):
    if type(t) is tuple and t[0] is unicode:
        return True
    return False

def IsLong(t):
    if type(t) is tuple and t[0] is long:
        return True
    return False

def IsSet(t):
    if type(t) is tuple and t[0] is set:
        return True
    return False

def IsFrozenSet(t):
    if type(t) is tuple and t[0] is frozenset:
        return True
    return False

def IsChar(t):
    if type(t) is tuple and t[0] is str and ((type(t[1]) is int and t[1] == 1) or (type(t[1]) is str and len(t[1]) == 1)):
        return True
    return False

def IsUnicodeChar(t):
    if type(t) is tuple and t[0] is unicode and ((type(t[1]) is int and t[1] == 1) or (type(t[1]) is unicode and len(t[1]) == 1)):
        return True
    return False

def IsIntInAnotherInt(t1, t2):
    assert type(t1) is tuple
    assert type(t2) is tuple
    if not IsInt(t1) or not IsInt(t2):
        assert False
    s1 = t1[1]
    s2 = t2[1]
    if s1 is None and s2 is None:
        return True
    if s1 is None and s2 is not None:
        return False
    if s1 is not None and s2 is None:
        return True
    assert type(s1) is tuple and type(s2) is tuple
    if s1[0] is None and s2[0] is not None:
        return False
    if s1[1] is None and s2[1] is not None:
        return False
    if s1[0] is not None and s2[0] is not None:
        if s1[0] < s2[0]:
            return False
    if s1[1] is not None and s2[1] is not None:
        if s1[1] > s2[1]:
            return False
    return True

def IsBool(t):
    return bool(type(t) is tuple and t[0] is bool)

def IsFloat(t):
    return bool(type(t) is tuple and t[0] is float)

def IsComplex(t):
    return bool(type(t) is tuple and t[0] is complex)

def IsNoneOrInt(t):
    return bool(t is None or t[0] is int)

def IsNoneOrIntOrFloat(t):
    return bool(t is None or t[0] is int or t[0] is float)

def IsKlNone(t):
    return bool(type(t) is tuple and t[0] is type(None))

def IsIntOrFloat(t):
    return bool(type(t) is tuple and (t[0] is int or t[0] is float))

def IsIntUndefSize(t):
    return bool(type(t) is tuple and (t[0] == 'IntOrLong'))

def IsTuple(t):
    return bool(type(t) is tuple and t[0] is tuple)

def IsFile(t):
    if type(t) is tuple and t[0] == Kl_File[0]:
        return True
    return False

def IsInTupleInd(t, ind):
    assert type(t) is tuple
    t2 = t[1]
    assert type(ind) is int and ind >= 0
    if type(t2) is int and ind < t2:
        return True
    if type(t2) is tuple and ind < len(t2):
        return True
    return False

def IsList(t):
    if type(t) is tuple and t[0] is list:
        return True
    return False

def IsListAll(t, check_redef = None):
    if t is None:
        return False
    assert type(t) is tuple
    if t[0] is list:
        return True
    if t[0] == T_NEW_CL_INST and t[1] in calculated_const and ('!LOAD_BUILTIN', 'list') in calculated_const[t[1]].derived_from:
        if check_redef is None:
            return True
        for a, b, c, isstaticmeth, isclassmeth, isderived in all_meth:
            if a == t[1] and b in check_redef:
                return False
        return True
    return False

def IsDict(t):
    return bool(type(t) is tuple and t[0] is dict)

def IsMayBeFloat(t):
    if type(t) is tuple and type(t[0]) is str and t[0] == 'MayBe' and IsFloat(t[1]):
        return True
    return False

def IsMayBe(t):
    return bool(type(t) is tuple and type(t[0]) is str and t[0] == 'MayBe')

def IsSequence(t):
    if t is None:
        return False
    assert type(t) is tuple
    t0 = t[0]
    if t0 == 'Sequence' or IsListAll(t) or t0 == str or t0 == tuple:
        return True
    if py_version < 30 and t0 == unicode:
        return True
    return False

def IsType(t):
    return bool(type(t) is tuple and t[0] is type)

#Kl_Sequence = ('Sequence', None)
Kl_String = (str, None)
Kl_Unicode = (str, None)
Kl_None = (type(None), None)
Kl_IntUndefSize = ('IntOrLong', None)
if py_version < 30:
    Kl_Unicode = (unicode, None)
    Kl_UnicodeChar = (unicode, 1)
    Kl_File = (types.FileType, None)
    Kl_Slice = (types.SliceType, None)
    Kl_Buffer = (types.BufferType, None)
    Kl_XRange = (types.XRangeType, None)
    Kl_Long = (long, None)

Kl_ByteArray = (bytearray, None)
Kl_Type = (type, None)
Kl_Char = (str, 1)
##Kl_Or = ('Or', ())
Kl_Float = (float, None)
Kl_MayBe = ('MayBe', None)
Kl_List = (list, None)
Kl_Tuple      = (tuple, None)
Kl_TupleOne   = (tuple, 1)
Kl_TuplePair  = (tuple, 2)
Kl_TuplePairString  = (tuple, (Kl_String, Kl_String))
Kl_TuplePairStringNone  = (tuple, (Kl_String, Kl_None))
Kl_TuplePairTypeNone  = (tuple, (Kl_Type, Kl_None))
Kl_TupleThree = (tuple, 3)
Kl_Dict = (dict, None)    
Kl_Set = (set, None)    
Kl_FrozenSet = (frozenset, None)    
Kl_Set = (set, None)
Kl_Boolean = (bool, None)
Kl_BuiltFunc = (types.BuiltinFunctionType, None)
Kl_Code = (types.CodeType, None)
Kl_Array = ('array', None)
Kl_Function = (types.FunctionType, None)
Kl_StaticMethod = (types.MethodType, 'static')
Kl_ClassMethod = (types.MethodType, 'class')
Kl_Method = (types.MethodType, 'instance')
Kl_Generator = (types.GeneratorType, None)
Kl_Complex = (complex, None)
Kl_BaseObject = (object, None)

Kl_OldType = (T_OLD_CL_TYP, None)
Kl_OldInst = (T_OLD_CL_INST, None)
Kl_NewType = (T_NEW_CL_TYP, None)
Kl_NewInst = (T_NEW_CL_INST, None)
Kl_RegexObject = (T_OLD_CL_INST, 'RegexObject')
Kl_MatchObject = (T_OLD_CL_INST, 'MatchObject')

def IsBuffer(t):
    return type(t) is tuple and len(t) == 2 and bool(t[0] == Kl_Buffer[0])

def IsCode(t):
    return type(t) is tuple and len(t) == 2 and bool(t[0] == Kl_Code[0])

def IsArray(t):
    return type(t) is tuple and len(t) == 2 and bool(t[0] == Kl_Array[0])

def IsBuiltFunc(t):
    return type(t) is tuple and t[0] is Kl_BuiltFunc[0]

def IsFunction(t):
    return type(t) is tuple and t[0] is Kl_Function[0]

def IsNewType(t):
    if type(t) is tuple and t[0] == T_NEW_CL_TYP:
        return True
    return False

def IsNewInst(t):
    if type(t) is tuple and t[0] == T_NEW_CL_INST:
        return True
    return False

def IsOldType(t):
    if type(t) is tuple and t[0] == T_OLD_CL_TYP:
        return True
    return False

def IsOldInst(t):
    if type(t) is tuple and t[0] == T_OLD_CL_INST:
        return True
    return False 
   
def New_Kl_Module(a):
    return (types.ModuleType, a)

def NewMayBe(a):
    assert type(a) is tuple and a[0] != 'MayBe'
    return ('MayBe', a)

_char_kl_string = tuple([(str, chr(x)) for x in range(256)])

if py_version < 30:
    _Kl_Simples = set((Kl_List, Kl_Tuple, Kl_Int, Kl_Short, Kl_Cardinal, Kl_String, Kl_Char, Kl_Dict, 
                Kl_Float, Kl_Boolean, Kl_None, Kl_File, Kl_Complex, Kl_Buffer, (bool, True), (bool, False),
                Kl_Char, Kl_Long, Kl_Type, Kl_RegexObject, Kl_Set,
                Kl_Short, Kl_Cardinal, 'Kl_Unicode') + _char_kl_string)
else:
    _Kl_Simples = set((Kl_List, Kl_Tuple, Kl_Int, Kl_Short, Kl_Cardinal, Kl_String, Kl_Char, Kl_Dict, 
                Kl_Float, Kl_Boolean, Kl_None, Kl_Complex,  (bool, True), (bool, False),
                Kl_Char, Kl_Long, Kl_Type, Kl_RegexObject, Kl_Set,
                Kl_Short, Kl_Cardinal, 'Kl_Unicode') + _char_kl_string)
_Kl_Simples |= set(((type, (Kl_Code, None)),
    (type, (types.ModuleType, None)),
    (type, (types.NoneType, None)),
    (type, (types.FunctionType, None)),
    (type, (types.InstanceType, None)),
    (type, (types.EllipsisType, None))))
matched_i = None
matched_p = None
matched_len = -1

jump = ('JUMP', 'JUMP_CONTINUE', 'JUMP_BREAK')
global _n2c
_n2c = {}
global seqcode
all_co = {}
seqcode = []

def subroutine_can_be_direct(nm, cnt_args):
    global direct_call
    co = N2C(nm)
    assert type(co) is code_extended
    if co.decompile_fail:
        co.can_be_direct_call = False
    if co.can_be_direct_call is None:
        co.can_be_direct_call = can_be_direct_call(co.cmds[1])
    if co.can_be_direct_call is True:
        if co.co_flags & 0x28 == 0 and len(co.co_cellvars) == 0 and len(co.co_freevars) == 0:
            if co.co_flags & 0x4 == 0:
                return match_count_args(nm, cnt_args)
            return True
    return False

def match_count_args(nm, cnt_args):
    c_args = N2C(nm).co_argcount
    if cnt_args > c_args:
        return False
    if cnt_args < c_args:
        if nm in default_args:
            defau = default_args[nm]
            if defau is None or len(defau) == 0:
                pass
            elif defau[0] in ('CONST', '!BUILD_TUPLE'):
                cnt_args += len(defau[1])
            else:
                Fatal('Strange match_count_args', nm, defau)
                assert False
            if cnt_args < c_args :
                return False
        else:
            return False    
    return True        

Kl_OperatorMethodCaller = (operator.methodcaller, None)

calculated_const = {}
pregenerated = []

known_modules = ('math', 'cmath', 'operator', 'string', 
                 'binascii', 'marshal', 're', 'struct', 'sys', 'os', 'types', 
                 'array', 'exceptions', 'Tkinter', 'ctypes', 'time', 
                 'code', 'new')

CFuncFloatOfFloat = {('math', 'exp'):'exp', ('math', 'sin'):'sin', ('math', 'cos'):'cos', ('math', 'sqrt'):'sqrt', 
                     ('math', 'sinh'):'sinh', ('math', 'cosh'):'cosh',
                     ('math', 'asin'):'asin', ('math', 'acos'):'acos', ('math', 'tan'):'tan',
                     ('math', 'atan'):'atan', ('math', 'tanh'):'tanh', ('math', 'fabs'):'fabs'}

t_imp = {}



def add_math_float(a):
    global t_imp
    for f in a:
        t_imp[('math', f, '()')] = Kl_Float
    
add_math_float(('fabs', 'factorial', 'fmod', 'fsum', 'ldexp', 'exp', 'expm1', \
                'log', 'log1p', 'log10', 'pow', 'sqrt', 'acos', 'asin', 'atan', \
                'atan2', 'hypot', 'cos', 'sin', 'tan', 'degrees', 'radians', \
                'acosh', 'asinh', 'atanh', 'cosh', 'sinh', 'tanh', 'floor',
                'erf', 'erfc', 'ldexp', 'fsum'))
    
t_imp[('math', 'frexp', '()')] = (tuple, (Kl_Float, Kl_Int))               
t_imp[('math', 'isnan', '()')] = Kl_Boolean                
t_imp[('math', 'isinf', '()')] = Kl_Boolean                
t_imp[('math', 'isnan', 'val')] = (types.BuiltinFunctionType, ('math', 'isnan'))               
t_imp[('math', 'isinf', 'val')] = (types.BuiltinFunctionType, ('math', 'isinf')) 

t_imp[('types', 'CodeType', 'val')]     = (type, (types.CodeType, None))
t_imp[('types', 'ModuleType', 'val')]   = (type, (types.ModuleType, None))
t_imp[('types', 'NoneType', 'val')]     = (type, (types.NoneType, None))
t_imp[('types', 'FunctionType', 'val')] = (type, (types.FunctionType, None))
t_imp[('types', 'InstanceType', 'val')] = (type, (types.InstanceType, None))
t_imp[('types', 'EllipsisType', 'val')] = (type, (types.EllipsisType, None))

t_imp[('types', 'BufferType', 'val')] = (type, (types.BufferType, None))
t_imp[('types', 'BuiltinFunctionType', 'val')] = (type, (types.BuiltinFunctionType, None))
t_imp[('types', 'ClassType', 'val')] = (type, (types.ClassType, None))
t_imp[('types', 'FileType', 'val')] = (type, (types.FileType, None))
t_imp[('types', 'FrameType', 'val')] = (type, (types.FrameType, None))
t_imp[('types', 'GeneratorType', 'val')] = (type, (types.GeneratorType, None))
t_imp[('types', 'MethodType', 'val')] = (type, (types.MethodType, None))
t_imp[('types', 'SliceType', 'val')] = (type, (types.SliceType, None))
t_imp[('types', 'XRangeType', 'val')] = (type, (types.XRangeType, None))


t_imp[('types', 'StringTypes', 'val')] = (tuple, ((type, (str, None)), (type, (unicode, None))))

t_imp[('operator', 'methodcaller', 'val')] = Kl_OperatorMethodCaller

t_imp[('random', 'random', '()')] = Kl_Float 

t_imp[('re', 'compile', '()')] = Kl_RegexObject 
t_imp[('re', 'sub', '()')] = Kl_String 
t_imp[('re', 'subn', '()')] = Kl_Tuple 
t_imp[('re', 'search', '()')] = None 
t_imp[('re', 'match', '()')] = None 

t_imp[('tempfile', 'mktemp', '()')] = Kl_String               

t_imp[('zipfile', 'ZipFile', 'val')] = (T_NEW_CL_TYP, 'ZipFile')             
t_imp[('zipfile', 'ZipFile', '()')] = (T_NEW_CL_INST, 'ZipFile')             

t_imp[('cStringIO', 'StringIO', 'val')] = (T_NEW_CL_TYP, 'StringIO')  
      
t_imp[('inspect', 'getsourcefile', '()')] = Kl_String             
t_imp[('inspect', 'getmembers', '()')] = Kl_List    
t_imp[('inspect', 'getmodule', '()')] = None    
t_imp[('inspect', 'currentframe', '()')] = (types.FrameType, None)

t_imp[('getopt', 'getopt', '()')] = Kl_Tuple    
t_imp[('locale', 'getdefaultlocale', '()')] = Kl_Tuple  
t_imp[('locale', 'getpreferredencoding', '()')] = Kl_String    
t_imp[('codecs', 'lookup', '()')] = (T_NEW_CL_INST, 'CodecInfo')
t_imp[('tarfile', 'open', '()')] = (T_NEW_CL_INST, 'TarFile')

t_imp[('string', 'atoi', '()')] = Kl_Int               
t_imp[('string', 'atof', '()')] = Kl_Float
t_imp[('string', 'atol', '()')] = Kl_Long               
t_imp[('string', 'split', '()')] = Kl_List               
t_imp[('string', 'rsplit', '()')] = Kl_List               
t_imp[('string', 'replace', '()')] = Kl_String                
t_imp[('string', 'upper', '()')] = Kl_String                
t_imp[('string', 'lower', '()')] = Kl_String                
t_imp[('string', 'strip', '()')] = Kl_String                
t_imp[('string', 'rstrip', '()')] = Kl_String                
t_imp[('string', 'rfind', '()')] = Kl_FromMinusOne             
t_imp[('string', 'find', '()')] = Kl_FromMinusOne                
t_imp[('string', 'rindex', '()')] = Kl_Cardinal         
t_imp[('string', 'index', '()')] = Kl_Cardinal               
t_imp[('string', 'rjust', '()')] = Kl_String                
t_imp[('string', 'ljust', '()')] = Kl_String                

t_imp[('code', 'InteractiveInterpreter', 'val')] = (T_NEW_CL_TYP, 'InteractiveInterpreter')               
t_imp[('code', 'InteractiveConsole', 'val')] = (T_NEW_CL_TYP, 'InteractiveConsole')               

t_imp[('cPickle', 'load', '()')] = None  
t_imp[('glob', 'glob', '()')] = Kl_List  

t_imp[('imp', 'load_source', '()')] = None  

t_imp[('copy', 'copy', '()')] = None  
t_imp[('copy', 'deepcopy', '()')] = None  
t_imp[('subprocess', 'Popen', 'val')] = (T_NEW_CL_TYP, 'Popen') 
t_imp[('tempfile', 'gettempprefix', '()')] = Kl_String  
t_imp[('tempfile', 'mkdtemp', '()')] = Kl_String  

t_imp[('doctest', 'testmod', '()')] = Kl_Tuple  

t_imp[('time', 'ctime', '()')] = Kl_String

t_imp[('repr', 'repr', '()')] = Kl_String

t_imp[('array', 'array', '()')] = Kl_Array

t_imp[('os', 'system', '()')] = Kl_Int  
t_imp[('os', 'uname', '()')] = Kl_Tuple  
t_imp[('os', 'listdir', '()')] = Kl_List 
if py_version < 30:
    t_imp[('os', 'popen', '()')] = Kl_File  
t_imp[('os', 'getenv', '()')] = None  
t_imp[('os', 'getpid', '()')] = None  
t_imp[('os', 'getcwd', '()')] = Kl_String  
t_imp[('os.path', 'split', '()')] = Kl_Tuple  
t_imp[('os.path', 'join', '()')] = Kl_String  
t_imp[('os.path', 'abspath', '()')] = Kl_String 
t_imp[('os.path', 'dirname', '()')] = Kl_String  
t_imp[('os.path', 'exists', '()')] = Kl_Boolean  
t_imp[('os.path', 'isdir', '()')] = Kl_Boolean 
t_imp[('os.path', 'isfile', '()')] = Kl_Boolean 
t_imp[('urllib', 'urlretrieve', '()')] = Kl_Tuple  

t_imp[('time', 'time', '()')] = Kl_Float   
t_imp[('time', 'clock', '()')] = Kl_Float   
t_imp[('tempfile', 'gettempdir', '()')] = Kl_String   
t_imp[('parser', 'expr', '()')] = None   
t_imp[('parser', 'suite', '()')] = None   
      
t_imp[('ctypes', 'pointer', 'val')] = (T_NEW_CL_TYP, 'ctypes_pointer')   
t_imp[('ctypes', 'POINTER', '()')] = (T_NEW_CL_INST, 'ctypes_pointer')   
t_imp[('ctypes', 'sizeof', '()')] = Kl_Cardinal 
t_imp[('ctypes', 'create_string_buffer', '()')] = None 
t_imp[('ctypes', 'c_void_p', 'val')] = (T_NEW_CL_TYP, 'ctypes_c_c_void_p')   
t_imp[('ctypes', 'c_int', 'val')] = (T_NEW_CL_TYP, 'ctypes_c_int')   
t_imp[('ctypes', 'c_uint', 'val')] = (T_NEW_CL_TYP, 'ctypes_c_uint')   
t_imp[('ctypes', 'CFUNCTYPE', 'val')] = (T_NEW_CL_TYP, 'ctypes_CFUNCTYPE')   
t_imp[('ctypes', 'Structure', 'val')] = (T_NEW_CL_TYP, 'ctypes_Structure')   
      
             
t_imp[('random', 'random', '()')] = Kl_Float                
t_imp[('binascii', 'hexlify', '()')] = Kl_String                
t_imp[('binascii', 'unhexlify', '()')] = Kl_String                
t_imp[('marshal', 'loads', '()')] = None                
t_imp[('struct', 'pack', '()')] = Kl_String                
t_imp[('struct', 'unpack', '()')] = Kl_Tuple                
t_imp[('struct', 'calcsize', '()')] = Kl_Cardinal  
if py_version < 30:  
    t_imp[('sys', 'stdin', 'val')] = Kl_File    
    t_imp[('sys', 'stdout', 'val')] = Kl_File    
    t_imp[('sys', 'stderr', 'val')] = Kl_File    
t_imp[('sys', 'modules', 'val')] = Kl_Dict    
t_imp[('sys', 'exc_info', '()')] = Kl_Tuple  
t_imp[('sys', 'gettotalrefcount', '()')] = Kl_Cardinal  
t_imp[('sys', 'exit', '()')] = Kl_None  
 
t_imp[('random', 'choice', '()')] = None
   
t_imp[('math', 'pi', 'val')] = Kl_Float   
t_imp[('exceptions', 'Exception', 'val')] = Kl_NewType   
t_imp[('struct', 'calcsize', '()')] = Kl_Cardinal                


_unjump_cmds = ('.:', '3CMP_BEG_3', 'BASE_LIST_COMPR', 'BUILD_LIST', 'BASE_SET_COMPR',
 'BUILD_MAP', 'BUILD_TUPLE', 'CALL_FUNCTION_1', 'CALL_FUNCTION_KW_1',
 'CALL_FUNCTION_VAR_1', 'CALL_FUNCTION_VAR_KW_1', 'CHECK_EXCEPTION',
 'COMPARE_OP', 'CONTINUE_LOOP', 'DUP_TOP', 'END_FINALLY', 'GET_ITER',
 'IMPORT_AND_STORE_AS', 'LIST_APPEND', 'LOAD_ATTR_1', 'PyObject_GetAttr',
 'LOAD_CLOSURE', 'LOAD_CODEFUNC', 'LOAD_DEREF', 'LOAD_GLOBAL',
 'LOAD_LOCALS', 'LOAD_NAME', 'MAKE_CLOSURE', 'MAKE_FUNCTION',
 'MK_CLOSURE', 'MK_FUNK', 'POP_BLOCK', 'POP_TOP', 'POP_TOP3',
 'PRINT_ITEM_0', 'PRINT_ITEM_TO_0', 'PRINT_NEWLINE_TO_0', 'ROT_THREE',
 'ROT_TWO', 'SEQ_ASSIGN_0', 'SET_VARS', 'STORE_MAP', 'STORE_SLICE+1',
 'STORE_SLICE+2', 'STORE_SLICE+3', 'STORE_SLICE+0', 'STORE_SUBSCR_0', 'STORE_ATTR_1',
 'UNPACK_SEQ_AND_STORE', 'WITH_CLEANUP', 'CONST', 'FAST', 'PyList_Append', 
 '(EXCEPT', ')(EXCEPT', ')ENDEXCEPT', '(EXCEPT1',
 'YIELD_VALUE', 'BUILD_SET', 'DUP_TOP_TWO', 'INPLACE_SUBTRACT', 'INPLACE_ADD', 'INPLACE_MULTIPLY')                

anagr = {}

def set_anagr(a,b):
    global anagr
    anagr[a] = b
    anagr[b] = a
    
set_anagr('JUMP_IF2_FALSE_POP_CONTINUE', 'JUMP_IF2_TRUE_POP_CONTINUE')
set_anagr('JUMP_IF_FALSE_POP_CONTINUE', 'JUMP_IF_TRUE_POP_CONTINUE')
set_anagr('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP')
set_anagr('JUMP_IF_FALSE_POP', 'JUMP_IF_TRUE_POP')
set_anagr('JUMP_IF_FALSE', 'JUMP_IF_TRUE')

used_cmpl = {}
used_cmp = {}
used_line = {}

matched_cmpl = {}
matched_cmp = {}
matched_line = {}

op_2_c_op = {'<':'Py_LT', '<=':'Py_LE', '==':'Py_EQ', '!=':'Py_NE',
             '>':'Py_GT', '>=':'Py_GE'}
c_2_op_op = {'Py_LT':'<', 'Py_LE':'<=', 'Py_EQ':'==', 'Py_NE':'!=',
             'Py_GT':'>', 'Py_GE':'>='}             

recode_binary = {'BINARY_POWER': 'PyNumber_Power+Py_None', 'BINARY_MULTIPLY':'PyNumber_Multiply',
                 'BINARY_DIVIDE':'PyNumber_Divide', 'BINARY_TRUE_DIVIDE':'PyNumber_TrueDivide',
                 'BINARY_FLOOR_DIVIDE':'PyNumber_FloorDivide', 'BINARY_MODULO':'PyNumber_Remainder',
                 'BINARY_ADD':'PyNumber_Add', 'BINARY_SUBTRACT':'PyNumber_Subtract',
                 'BINARY_SUBSCR':'PyObject_GetItem', 'BINARY_LSHIFT':'PyNumber_Lshift',
                 'BINARY_RSHIFT':'PyNumber_Rshift', 'BINARY_AND':'PyNumber_And',
                 'BINARY_XOR':'PyNumber_Xor', 'BINARY_OR':'PyNumber_Or'}

recode_unary = {'UNARY_POSITIVE':'PyNumber_Positive', 'UNARY_NEGATIVE':'PyNumber_Negative',
                'UNARY_CONVERT':'PyObject_Repr', 'UNARY_INVERT':'PyNumber_Invert'}

recode_inplace = {'INPLACE_POWER':'PyNumber_InPlacePower+',
                'INPLACE_MULTIPLY':'PyNumber_InPlaceMultiply',
                'INPLACE_ADD':'PyNumber_InPlaceAdd',
                'INPLACE_SUBTRACT':'PyNumber_InPlaceSubtract',
                'INPLACE_DIVIDE':'PyNumber_InPlaceDivide',
                'INPLACE_TRUE_DIVIDE':'PyNumber_InPlaceTrueDivide',
                'INPLACE_FLOOR_DIVIDE':'PyNumber_InPlaceFloorDivide',
                'INPLACE_MODULO':'PyNumber_InPlaceRemainder',
                'INPLACE_LSHIFT':'PyNumber_InPlaceLshift',
                'INPLACE_RSHIFT':'PyNumber_InPlaceRshift',
                'INPLACE_AND':'PyNumber_InPlaceAnd',
                'INPLACE_XOR':'PyNumber_InPlaceXor',
                'INPLACE_OR':'PyNumber_InPlaceOr'}

hasjrel = set(hasjrel2)
hasconst = set(hasconst2)
hasname = set(hasname2)
haslocal = set(haslocal2)
hascompare = set(hascompare2)
hasfree = set(hasfree2)

detect_float = True
full_pycode = True
print_cline = False
print_pyline = False
print_pycmd = False
opt_flag = []
stat_func = None #'Init_filename'
range2for = True
enumerate2for = True
calc_ref_total = False
recalc_refcnt = False
direct_call = True
no_fastlocals = False
separate_global = False
no_generate_comment = False
dirty_iteritems = False
hide_debug = True
added_pass_subscr = False
check_recursive_call = True
expand_BINARY_SUBSCR = False
make_indent = False
line_number = True
no_build = False
inline_flag = False
print_tree_node = False
c_name = '?'
hash_compile = 0
checkmaxref = 0
package = ''

try_jump_context = [False]
dropped_temp = []

filename = ""
genfilename = ''
func = ""
g_co = None

tempgen = []
typed_gen = []

labels = []    
labl = ''

CO_GENERATOR = 0x0020


len_family = set(('!PyObject_Size', '!PyString_GET_SIZE', '!PyString_Size', 
              '!PySet_GET_SIZE', '!PySet_Size', '!PyList_GET_SIZE',
              '!PyList_Size', '!PyTuple_GET_SIZE', '!PyTuple_Size', 
              '!PyDict_Size', '!PyUnicode_GET_SIZE', '!PyUnicode_GetSize',
              '!PyByteArray_GET_SIZE', '!PyByteArray_Size'))

CFuncNeedINCREF = set(('PyDict_GetItem', 'PyList_GET_ITEM', \
                   'PyTuple_GetItem', 'PyList_GetItem', 'PyTuple_GET_ITEM'))
CFuncNotNeedINCREF = set(('PyObject_GetAttr', 'PyObject_GetItem', \
                      'PyDict_New', 'PyNumber_Add', \
           'PyCell_Get', \
           'PyNumber_Divide', 'PyNumber_TrueDivide', 'PyNumber_Multiply', 'PyNumber_Negative', \
           'PyNumber_Power', 'PyNumber_Remainder', 'PyNumber_Subtract',\
           'PyNumber_Positive',\
           'PyNumber_Absolute',\
           'PyNumber_And', 'PyNumber_Or', 'PyNumber_Rshift', 'PyNumber_Lshift',\
           'PyNumber_InPlaceSubtract', 'PyNumber_InPlaceAdd', 'PyNumber_InPlaceAnd', \
           'PyNumber_Invert', 'PyNumber_FloorDivide', \
           'PyNumber_InPlaceMultiply', 'PyNumber_FloorDivide', 'PyNumber_Xor',\
           'PyNumber_InPlaceDivide', 'PyNumber_InPlaceTrueDivide',\
           'PyNumber_InPlaceOr', 'PyNumber_InPlaceFloorDivide',\
           'PyNumber_InPlacePower',\
           'PyNumber_InPlaceRshift',\
           'PyNumber_InPlaceLshift',\
           'PyNumber_InPlaceRemainder',\
           'PyNumber_InPlaceXor', '_GET_ITEM_2', '_GET_ITEM_1', '_GET_ITEM_0', '_GET_ITEM_LAST',\
           'PyNumber_Int', 'PyNumber_Long', 'PyNumber_Float',\
           'PyObject_Dir', 'PyObject_Format', \
           'PySlice_New', '_PyEval_ApplySlice', \
           'PyTuple_Pack', 'PyObject_Call', 'PyObject_GetIter', 'PyIter_Next',\
           'Py2CFunction_New', 'PyFunction_New', \
           'PyObject_RichCompare', 'c_LOAD_NAME',\
           'c_LOAD_GLOBAL', 'PyNumber_InPlaceAdd', '_PyEval_BuildClass',\
           'PyList_GetSlice', 'PyTuple_GetSlice', 'PySequence_GetSlice', \
           'PyInt_FromSsize_t', 'PyEval_CallObject',
           'from_ceval_BINARY_SUBSCR', 'Py_CLEAR', 'Py_BuildValue', \
           '_PyDict_NewPresized', 'PyInt_FromSsize_t', 'PyTuple_New', 'PyList_New',\
           'from_ceval_BINARY_ADD_Int', 'from_ceval_BINARY_SUBTRACT_Int',\
           'PyDict_New', 'PyDict_Copy', 'PyBool_FromLong', 'PyObject_Type', 'PyObject_Repr',\
           'PyObject_Dir', 'PySet_New', 'PyFrozenSet_New', 'PySequence_Tuple', 'PySequence_List',\
           'PyFloat_FromDouble', 'PyObject_Str', 'PyCFunction_Call', \
           'PyLong_FromVoidPtr', 'PyNumber_ToBase', 'PyInt_Type.tp_str', \
           'PyComplex_Type.tp_new',
           'PyInt_Type.tp_new', 'PyLong_Type.tp_new', 'PyFloat_Type.tp_new', \
           'PyBool_Type.tp_new', 'PyBaseObject_Type.tp_new', 'PyUnicode_Type.tp_new', \
           'PyString_FromStringAndSize', 'PyInt_FromLong', 'PyString_Format', \
           'STR_CONCAT2', 'STR_CONCAT3', 'STR_CONCAT', 'STR_CONCAT_N', \
           'PySequence_Repeat', 'FirstCFunctionCall', 'FastCall', 'FastCall0',\
           'UNICODE_CONCAT2', 'UNICODE_CONCAT3', 'c_BINARY_SUBSCR_2_Int',\
           '_c_BINARY_SUBSCR_Int', '_c_BINARY_SUBSCR_ADDED_INT',\
           'PyInstance_New', 'PyInstance_NewRaw', '_PyString_Join', '_PyList_Extend', 'PyList_AsTuple',\
           'PyDict_Keys', 'PyDict_Items', 'PyDict_Values', 'PyFile_FromString',\
           '_PyInt_Format', '_PyList_Pop', 'PyImport_Import'))
           
CFuncVoid =    set(('PyFrame_FastToLocals', 'PyFrame_LocalsToFast', 'SETLOCAL', 'LETLOCAL', 'SETSTATIC', \
           'PyList_SET_ITEM', 'SET_CODE_C_FUNC', \
           '_PyEval_DoRaise', 'printf', 'Py_INCREF', 'Py_CLEAR', \
           'PyTuple_SET_ITEM', 'PyFrame_BlockSetup', 'PyFrame_BlockPop',\
           'PyErr_Restore', 'PyErr_Fetch', 'PyErr_NormalizeException',\
           '_PyEval_set_exc_info', '_PyEval_reset_exc_info', 'PyDict_Clear'))     
CFuncNoCheck = set(('SETLOCAL', 'LETLOCAL', 'SETSTATIC', 'PyList_SET_ITEM', 'SET_CODE_C_FUNC',\
            '_PyEval_DoRaise', 'PyIter_Next', 'printf', 'Py_INCREF', 'Py_CLEAR',\
            'PyInt_AsSsize_t', 'PyTuple_SET_ITEM', 'PyObject_HasAttr',\
            'PyFrame_FastToLocals', 'PyFrame_LocalsToFast', 'PyErr_ExceptionMatches',\
            'PyFloat_AS_DOUBLE', 'PyInt_AsLong', 'PyInt_AS_LONG', 'PyFloat_AsDouble',\
            '(double)PyInt_AsLong'))
CFuncPyObjectRef = set(('FirstCFunctionCall', 'FastCall', 'FastCall0', 'GETLOCAL', 'PyBaseObject_Type.tp_new',\
 'PyBool_FromLong', 'PyBool_Type.tp_new', 'PyCFunction_Call', 'PyCell_Get', \
 'PyDict_GetItem', 'PyDict_Items', 'PyDict_Keys', 'PyDict_New', 'PyDict_Values', 'PyDict_Copy',\
 'PyEval_CallObject', 'PyFile_FromString',\
 'PyFloat_FromDouble', 'PyFloat_Type.tp_new',\
 'PyFrozenSet_New', 'PyFunction_New',  'Py2CFunction_New', \
 'PyInstance_New', 'PyInstance_NewRaw',\
 'PyInt_FromLong', 'PyInt_FromSsize_t', 'PyInt_Type.tp_new', 'PyComplex_Type.tp_new',\
 'PyList_GET_ITEM', 'PyList_GetItem', 'PyList_New', 'PyList_AsTuple', \
 'PyLong_FromSsize_t', 'PyLong_FromVoidPtr', 'PyLong_Type.tp_new',\
 'PyNumber_Absolute', 'PyNumber_Add', 'PyNumber_And', 'PyNumber_Divide',\
 'PyNumber_FloorDivide', 'PyNumber_InPlaceAdd', 'PyNumber_InPlaceAdd',\
 'PyNumber_InPlaceAnd', 'PyNumber_InPlaceDivide', 'PyNumber_InPlaceFloorDivide',\
 'PyNumber_InPlaceLshift', 'PyNumber_InPlaceMultiply', 'PyNumber_InPlaceOr',\
 'PyNumber_InPlacePower', 'PyNumber_InPlaceRemainder', 'PyNumber_InPlaceRshift',\
 'PyNumber_InPlaceSubtract', 'PyNumber_InPlaceTrueDivide', 'PyNumber_InPlaceXor',\
 'PyNumber_Invert', 'PyNumber_Lshift', 'PyNumber_Multiply', 'PyNumber_Negative',\
 'PyNumber_Or', 'PyNumber_Positive', 'PyNumber_Power', 'PyNumber_Remainder',\
 'PyNumber_Rshift', 'PyNumber_Subtract', 'PyNumber_ToBase', 'PyNumber_TrueDivide',\
 'PyNumber_Xor', '_GET_ITEM_2', '_GET_ITEM_1', '_GET_ITEM_0', '_GET_ITEM_LAST', \
 'PyNumber_Int', 'PyNumber_Long', 'PyNumber_Float',\
 'PyObject_Call', 'PyObject_Dir', 'PyObject_GetAttr', 'PyObject_GetItem',\
 'PyObject_GetIter', 'PyObject_Repr', 'PyObject_RichCompare', 'PyObject_Str',\
 'PyObject_Type', 'PyObject_Dir', 'PyObject_Format', 'PyInt_Type.tp_str', \
 'PySequence_GetSlice', 'PySequence_List', 'PySequence_Repeat', 'PySequence_Tuple',\
 'PySet_New', 'PySlice_New', 'PyList_GetSlice', 'PyTuple_GetSlice',\
 'PyString_Format',  'PyString_FromStringAndSize',\
 'PyTuple_GET_ITEM',  'PyTuple_GetItem', 'PyTuple_New', 'PyTuple_Pack',\
 'PyUnicode_Type.tp_new', 'Py_BuildValue', \
 'STR_CONCAT2', 'STR_CONCAT3', 'STR_CONCAT', 'STR_CONCAT_N', 'UNICODE_CONCAT2', 'UNICODE_CONCAT3',\
 '_PyDict_NewPresized', '_PyEval_ApplySlice', '_PyEval_BuildClass',\
 '_PyList_Extend',  '_PyString_Join',\
 '_c_BINARY_SUBSCR_ADDED_INT', '_c_BINARY_SUBSCR_Int', 'c_BINARY_SUBSCR_2_Int',\
 'from_ceval_BINARY_ADD_Int', 'from_ceval_BINARY_SUBSCR', 'from_ceval_BINARY_SUBTRACT_Int',\
 'c_LOAD_GLOBAL', 'c_LOAD_NAME', '_PyInt_Format', '_PyList_Pop', 'PyImport_Import'))

CFuncIntCheck_ = ('PyCell_Set', 'PySequence_DelSlice', \
'PyDict_DelItem', 'PyDict_SetItem', 'PyDict_Size', 'PyDict_Update', 'PyDict_Contains',\
'PyDict_MergeFromSeq2', 'PyDict_DelItem', \
'PyFunction_SetClosure', 'PyFunction_SetDefaults',\
'Py2CFunction_SetClosure', 'Py2CFunction_SetDefaults',\
'PyList_Append', 'PyList_GET_SIZE', 'PyList_Insert', 'PyList_Reverse', \
'PyList_SetItem', 'PyList_SetSlice', 'PyList_Sort', \
'PyObject_DelItem', 'PyObject_IsInstance', 'PyObject_IsSubclass', \
'PyObject_IsTrue', 'PyObject_Not', 'PyObject_RichCompareBool',\
'PyObject_SetAttr', 'PyObject_SetItem', 'PyObject_Size',\
'PySequence_Contains', 'PySet_Contains', \
'PyString_GET_SIZE', 'PyTuple_GET_SIZE', 'PySet_Size', \
'PyUnicode_GetSize', 'PySet_Add', \
'_PyEval_AssignSlice', '_PyEval_ExecStatement', '_PyEval_ImportAllFrom',\
'_PyEval_PRINT_ITEM_1', '_PyEval_PRINT_ITEM_TO_2', '_PyEval_PRINT_NEWLINE_TO_1',\
'c_Py_EQ_Int', 'c_Py_EQ_String', 'c_Py_GE_Int', 'c_Py_GE_String',\
'c_Py_GT_Int', 'c_Py_GT_String', 'c_Py_LE_Int', 'c_Py_LE_String',\
'c_Py_LT_Int', 'c_Py_LT_String', 'c_Py_NE_Int', 'c_Py_NE_String',\
'PyString_AsStringAndSize', 'PyObject_Cmp', '_PyInt_Rshift')
CFuncIntCheck = set(CFuncIntCheck_)

len_fam_not_check = ('PyList_GET_SIZE', 'PyString_GET_SIZE', 'PyTuple_GET_SIZE', '!PyList_GET_SIZE', '!PyString_GET_SIZE', '!PyTuple_GET_SIZE', 'len')

API_cmp_2_PyObject = ('!PySequence_Contains', '!PyObject_HasAttr', \
               '!PyObject_IsSubclass', '!PyObject_IsInstance', '!PyDict_Contains', '!PySet_Contains')

CFuncIntNotCheck = ('PyInt_AsSsize_t', 'PyObject_HasAttr', 'PyErr_ExceptionMatches')
CFuncFloatNotCheck = ('PyFloat_AS_DOUBLE', 'PyFloat_AsDouble', '(double)PyInt_AsLong')
CFuncLongNotCheck = ('PyInt_AsLong', 'PyInt_AS_LONG')
CFuncLongCheck = ('PyObject_Hash', )
               

set_IntCheck = set(CFuncIntCheck_ + CFuncLongCheck)
consts = []
consts_dict = {}
loaded_builtin = []

def nmrecode(n):
    if n == '<genexpr>':
        n = 'genexpr__'
    if n == '<genexp>':
        n = 'genexpr__'
    elif n == '<module>':
        n = 'Init_filename'
    elif n[:8] == '<lambda>':
        n = 'lambda_' + n[8:]
    elif n == '<dictcomp>':
        n = 'dict_comp__'
    elif n == '<setcomp>':
        n = 'set_comp__'
    elif n == '<listcomp>':
        n = 'list_comp__'
    return n    
    

def N2C(n):
    co = _n2c[n]
    assert type(co) is code_extended
    return co

def dis(x=None):
    """Disassemble classes, methods, functions, or code.
    With no argument, disassemble the last traceback.
    """
    if hasattr(x, 'im_func'):
        x = x.im_func
    if hasattr(x, 'func_code'):
        x = x.func_code
    if hasattr(x, '__dict__'):
        items = x.__dict__.items()
        items.sort()
        for name, x1 in items:
            if type(x1) in (types.MethodType,
                            types.FunctionType,
                            types.CodeType,
                            types.ClassType):
                    dis(x1)
    elif hasattr(x, 'co_code'):
        pre_disassemble(x)
    else:
        pp( "don't know how to disassemble %s objects" % type(x).__name__)
        assert False

global nm_pass
nm_pass = {}

def line2addr(co):
    pairs = list(findlinestarts(co))
    pairs.sort()
    lines = {}
    for addr, line in pairs:
        if line not in lines:
            lines[line] = addr
    return lines        

prev_refcnt = 0
def SetPass(p):
    global seqcode
    global prev_refcnt
    global Pass, Prev_Pass, Prev_Time, Pass_Exit

        
    if p == Pass_Exit:
        Fatal('Cancelled at pass %s' % p)   
        assert False
    if p in nm_pass:
        p = nm_pass[p]
    else:
        s = str(len(nm_pass))
        if len(s) < 2:
            s = '0' + s
        nm_pass[p] = s + ':' + p
        p = nm_pass[p] 
    ti = time.clock()
    if Prev_Time is not None:
        Pass[Prev_Pass] = ti - Prev_Time
        if flag_stat:
            pp(p, Pass[Prev_Pass])
    if flag_stat and hasattr(sys, 'gettotalrefcount'):
        refcnt = sys.gettotalrefcount()  
        ## pp('After ' + str(Prev_Pass) + ' ' + str(refcnt) + ' delta = ' + str(refcnt - prev_refcnt))
        prev_refcnt = refcnt
    Prev_Time = ti
    Prev_Pass = p
     
def findlabels(code):
    """Detect all offsets in a byte code which are jump targets.

    Return the list of offsets.

    """
    assert type(code) is str
    labels = []
    n = len(code)
    i = 0
    extended_arg = 0
    while i < n:
        assert type(i) is int
        assert i >= 0
        assert i < 1024 * 1024
        c = code[i]
        op = ord(c)
##        pos = i
        i = i+1
        if op >= HAVE_ARGUMENT:
            oparg = ord(code[i]) + ord(code[i+1])*256  + extended_arg
            extended_arg = 0
            i = i+2
            if op == EXTENDED_ARG:
                extended_arg = oparg*65536            
            label = -1
            if op in hasjrel:
                label = i+oparg
            elif op in hasjabs:
                label = oparg
            if label >= 0:
                if label not in labels:
                    labels.append(label)
    return labels     
     
def disassemble_base(co):
    """Disassemble a code object."""
    code = co.co_code
    assert type(code) is str
    labels = set(findlabels(code))
    linestarts = dict(findlinestarts(co))
    n = len(code)
    i = 0
    extended_arg = 0
    free = None
    cmds = []
##    listref = []
    N = co.c_name
    cmds.append(('(BEGIN_DEF', N))
    while i < n:
        assert type(i) is int
        assert i >= 0
        assert i < 1024 * 1024        
        label = -1
        nline = -1
        opcmd, codearg, arg = (None,None,None)
        c = code[i]
        if py_version < 30:
          op = ord(c)
        else:
            op = c
        if i in linestarts:
            nline = linestarts[i]
        if i in labels: 
            label = i
        

        opcmd = opname[op] #.ljust(20),
        i = i+1
        recalc = False
        if op >= HAVE_ARGUMENT:
            if py_version < 30:
                oparg = ord(code[i]) + ord(code[i+1])*256 + extended_arg
            else:
                oparg = code[i] + code[i+1]*256 + extended_arg
            extended_arg = 0
            i = i+2            
            if op == EXTENDED_ARG:
                extended_arg = oparg*65536
            codearg = oparg  
            recalc = False
            if op in hasconst:
                arg = co.co_consts[oparg]  
                recalc = True
            elif op in hasname:
                arg = co.co_names[oparg]  
                recalc = True
            elif op in hasjrel:
                arg = i + oparg  
                recalc = True
            elif op in haslocal:
                arg = co.co_varnames[oparg]  
                recalc = True
            elif op in hascompare:
                arg = cmp_op[oparg]   
                recalc = True
            elif op in hasfree:
                if free is None:
                    free = co.co_cellvars + co.co_freevars
                arg = free[oparg]  
                recalc = True
        if label != -1:        
            cmds.append(('.:', label))
        if nline != -1:       
            cmds.append(('.L', nline ))
        if opcmd == 'JUMP_ABSOLUTE' or opcmd == 'JUMP_FORWARD':
            opcmd = 'JUMP'
        if opcmd == 'FOR_ITER':
            opcmd = 'J_FOR_ITER'   
        if opcmd == 'SETUP_LOOP':
            opcmd = 'J_SETUP_LOOP'   
        if opcmd == 'SETUP_EXCEPT':
            opcmd = 'J_SETUP_EXCEPT'   
        if opcmd == 'SETUP_FINALLY':
            opcmd = 'J_SETUP_FINALLY'   
        if opcmd == 'PRINT_ITEM':
            opcmd = 'PRINT_ITEM_0'   
        if opcmd == 'PRINT_ITEM_TO':
            opcmd = 'PRINT_ITEM_TO_0'   
        if opcmd == 'PRINT_NEWLINE_TO':
            opcmd = 'PRINT_NEWLINE_TO_0'   
        if opcmd == 'STORE_SUBSCR':
            opcmd = 'STORE_SUBSCR_0'   
        if opcmd == 'STORE_ATTR':
            opcmd = 'STORE_ATTR_1'   
        if opcmd == 'DELETE_ATTR':
            opcmd = 'DELETE_ATTR_1'  
        if opcmd == 'LOAD_ATTR':
            opcmd = 'LOAD_ATTR_1'   
        if opcmd == 'LOOKUP_METHOD':
            opcmd = 'LOAD_ATTR_1'   
            arg = co.co_names[oparg]
            recalc = True
        if opcmd == 'CONTINUE_LOOP':
            opcmd = 'JUMP_CONTINUE'
        if opcmd == 'POP_JUMP_IF_FALSE':
            opcmd = 'JUMP_IF_FALSE_POP'
        if opcmd == 'POP_JUMP_IF_TRUE':
            opcmd = 'JUMP_IF_TRUE_POP'
        if opcmd == 'SETUP_WITH':
            opcmd = 'J_SETUP_WITH'
            cmds.append((opcmd, arg))
        elif opcmd == 'JUMP_IF_FALSE_OR_POP': 
            cmds.append(('JUMP_IF_FALSE', codearg))
                        
            cmds.append(('POP_TOP', ))
        elif opcmd == 'JUMP_IF_TRUE_OR_POP': 
            cmds.append(('JUMP_IF_TRUE', codearg))
            
            cmds.append(('POP_TOP', ))
        elif recalc:
            assert opcmd != 'EXTENDED_ARG'
            cmds.append((opcmd, arg))
        elif arg is None and codearg is None:   
            assert opcmd != 'EXTENDED_ARG'
            cmds.append((opcmd,))
        elif arg is None: # and opcmd != 'LOAD_CONST':
            if opcmd in call:
                if opcmd == 'CALL_FUNCTION':
                    opcmd = 'CALL_FUNCTION_1'
                if opcmd == 'CALL_METHOD':
                    opcmd = 'CALL_FUNCTION_1'
                cmds.append((opcmd, codearg & 255, (), codearg >> 8, ()))
            else:     
                    
                if opcmd != 'EXTENDED_ARG':
                    cmds.append((opcmd,codearg))
        else:   
            assert opcmd != 'EXTENDED_ARG'
            cmds.append((opcmd, codearg, arg ))
        if len(cmds) > 0 and cmds[-1][0][0] == 'J':
            assert cmds[-1][1] > 0
    co.cmds[:] = cmds 

def find_redefined_builtin(cmds):
    global redefined_all, count_define_set, count_define_get
    assert type(cmds) is list
    for i,cmd in enumerate(cmds):
        cmd0 = cmd[0]
        if type(cmd0) is not str:
            continue
        if cmd0 in ('DELETE_GLOBAL', 'STORE_GLOBAL', 'DELETE_NAME', 'STORE_NAME') and \
           cmd[1] in d_built and cmd[1] != '__doc__':
            redefined_builtin[cmd[1]] = True
        if cmd0 in ('LOAD_GLOBAL', 'LOAD_NAME'): #, 'LOAD_DEREF', 'LOAD_CLOSURE'):
            if not (cmd[1] in count_define_get):
                count_define_get[cmd[1]] = 1
            else:    
                count_define_get[cmd[1]] += 1
            if not (cmd[1] in count_define_set):
                count_define_set[cmd[1]] = 2.0
        if cmd0 == 'STORE_GLOBAL' or (cmd0 == 'STORE_NAME' and g_co.c_name == 'Init_filename'):
            if cmd[1] in count_define_set:
                count_define_set[cmd[1]] += 1
            else:
                count_define_set[cmd[1]] = 1    
        if cmd0 == 'DELETE_GLOBAL' or (cmd0 == 'DELETE_NAME' and g_co.c_name == 'Init_filename'):
            if cmd[1] in count_define_set:
                count_define_set[cmd[1]] += 2
            else:
                count_define_set[cmd[1]] = 2.0    
        if cmd == ('IMPORT_NAME', '__builtin__') and g_co.co_filename not in ('2c.py', '2c.pyc', '2c.pyo'):
            redefined_all = True
        if cmd0 == 'IMPORT_NAME' and cmds[i+1][0] == 'IMPORT_STAR':
            CheckExistListImport(cmd[1])
            if cmd[1] in list_import:
                for x in list_import[cmd[1]]:
                    if x in count_define_set:
                        count_define_set[x] += 1
                    else:
                        count_define_set[x] = 1    

def light_opt_at_cmd_level(cmds):
    global g_co
    assert type(cmds) is list
    for i,cmd in enumerate(cmds):
        if cmd[0] == 'LOAD_CONST':
            preco = cmd[1]
            if type(preco) is types.CodeType:
                if preco in all_co:
                    cod = all_co[preco]
                else:
                    cod = code_extended(preco)
                assert type(cod) is code_extended
                cmds[i] = ('LOAD_CODEFUNC', cod.c_name)
                cod.created_from = g_co
    find_redefined_builtin(cmds)        
    NoGoToGo(cmds)
    revert_conditional_jump_over_uncond_jump(cmds)
    NoGoToGo(cmds)

def clear_module(nm):
    assert nm != 'sys'
    assert nm != '__name__'
    if sys.modules[nm] is None:
        del sys.modules[nm]
        return
    v = sys.modules[nm]        
    todel = []
    for k1,v1 in v.__dict__.items():
        if type(v1) is types.ModuleType:
            todel.append(k1)
    for k1 in todel: 
        del v.__dict__[k1]        
    del sys.modules[nm]
    if nm in list_import:
        del list_import[nm]
    if nm in imported_modules:
        del imported_modules[nm]

def clear_after_all_files():
    global start_sys_modules
    clear_one_file()
    list_import.clear()
    self_attr_type.clear()
    
    imported_modules.clear()
    start_sys_modules.clear()         
    del list_cname_exe[:]

    
def clear_one_file():
    global redefined_all
    global Pass, Prev_Time, Prev_Pass, start_sys_modules, seqcode, loop_else_context, dcl_stat_refcalc, using_slots

    loop_else_context = []
    direct_args.clear()
    all_co.clear()
    _n2c.clear()  
    all_trin.clear()
    del all_meth[:]
    all_derived.clear()
    redefined_all = False
    count_define_set.clear()
    count_define_get.clear()
    del consts[:]
    consts_dict.clear()
    del pregenerated[:]
    del loaded_builtin[:]
    calculated_const.clear()
    Pass.clear()
    Prev_Time = None
    Prev_Pass = None
    no_compiled.clear()
    detected_attr_type.clear()
    detected_return_type.clear()
    default_args.clear()
    direct_code.clear()
    val_direct_code.clear()
    redefined_builtin.clear()
    redefined_all = False
    uniq_debug_messages.clear()
    type_def.clear()
    fastglob.clear()
    global_type.clear()
    local_type.clear()
    detected_global_type.clear()
    predeclared_chars.clear()
    clear_noglob()
    attr_instance.clear()
    used_libr.clear()
    ImportedM.clear()
    dcl_stat_refcalc.clear()
    del try_jump_context[:]
    try_jump_context.append(False)
    del dropped_temp[:]
    del tempgen[:]
    del typed_gen[:]
    del labels[:]
    del g_acc2[:]
    del g_refs2[:]
    del g_len_acc[:]
    del seqcode[:]
    end_sys_modules = sys.modules.copy()

    self_attr_type.clear()
    SetAttr('__dict__', Kl_Dict)
    SetAttr('__file__', Kl_String)
    SetAttr('__name__', Kl_String)
    detected_slots.clear()
    compiled_slots.clear()
    inverted_compiled_slots.clear()
    using_slots = False
    
      
def dump(obj):
    if not print_pycmd:
        return
    print_to(out, 'Code ' + obj.co_name)
    for attr in dir(obj):
        assert type(attr) is str
        if attr.startswith('co_') and attr not in ( 'co_code', 'co_lnotab', 'co_original'):
            val = getattr(obj, attr)
            if attr == 'co_flags':
                print_to(out,"\t" + attr + ' ' + hex(val))
            elif attr in ('co_consts', 'co_name'):
                pass
            else:    
                print_to(out,"\t" + attr + ' ' + repr(val))
        
class code_extended(object):   
    def __init__(self, co, copy = False):
        assert type(co) is types.CodeType
        if hasattr(sys, 'gettotalrefcount'):
            refcnt = sys.gettotalrefcount()
        else:
            refcnt = -1
        if co in all_co and not copy:
            pp(co)
            pp(dir(co))
            assert type(co) is not code_extended
            ## self.__dict__ = all_co[co].__dict__
            pp('not copy code extended', co.co_name)
            assert False
            return
        if copy:
            assert False
        assert type(self) is code_extended
        self.no_codefunc = False    
            
        self.co_argcount = co.co_argcount
        self.co_nlocals = co.co_nlocals
        self.co_stacksize = co.co_stacksize
        self.co_flags = co.co_flags
        self.co_code = co.co_code
        self.co_consts = co.co_consts
        self.co_names = co.co_names
        self.co_varnames = list(co.co_varnames) ## for .index method at pypy
        self.d_varnames = dict([(v, i) for i,v in enumerate(co.co_varnames)])
        self.co_freevars = co.co_freevars
        self.co_cellvars = co.co_cellvars
        self.co_filename = co.co_filename
        self.co_name = co.co_name
        self.co_firstlineno = co.co_firstlineno
        self.co_lnotab = co.co_lnotab        
        self.co_original = co
        self.have_temp = True
        self.co_varnames_direct = []

        self.created_from = None
        self.method_class = None
        self.is_class_creator = None
        self.new_stacksize = 0
        self.dict_getattr_used = {}
        self.detected_type = {}
        self.detected_type_may_be = {}
        self.typed_arg_direct = {}
        self.typed_arg_direct_changed = {}
        self.cmds = []
        self.direct_cmds = None
        self.returns_direct = {}
        self.returns_cfunc = {}
        self.return_cnt = 0
        self.used_return_labels = {}    
        self.used_fastlocals = {}   
        self.list_compr_in_progress = False
        self.used_label = {}
        self.is_partly_executed = False
        self.to_exception = {}
        self.hidden_arg_direct = []
        self.unused_fast_var = {}
        self.recursive = None
        self.decompile_fail = False # update after recompile
        for i in range(co.co_argcount + bool(co.co_flags & 0x4)):
            self.used_fastlocals[co.co_varnames[i]] = True
            self.used_fastlocals[nmvar_to_loc(co.co_varnames[i])] = True
        nm = nmrecode(co.co_name)
        for i in range(1000):
            if i == 0:
                nm2 = nm
            else:
                nm2 = nm + repr(i)
            if nm2 not in _n2c:         
                self.c_name = nm2
                _n2c[nm2] = self   
                break
        all_co[co] = self
        if len(seqcode) == 0:
            seqcode.append((self, self.cmds))
        else:
            i = max(len(seqcode) - 1, 0)
            assert type(i) is int
            while i >= 0:
                assert type(i) is int
                if self.co_firstlineno >= seqcode[i][0].co_firstlineno:
                    seqcode.insert(i+1, (self, self.cmds))
                    break
                i -= 1
            if i < 0:
                seqcode.insert(0, (self, self.cmds))
        if refcnt != -1:
            global cnt__init__1
            cnt__init__1 += sys.gettotalrefcount() - refcnt 
        self.yield_labels = []
        self.store_and_delete_and_fast = {}
        
        self.can_be_direct_call = None
        self.direct_call_args = None
        self.fast_used_at_list_compr = {}

    def DetectFastToLocalListCompr(self):
        d = {}
        for nm in self.co_varnames:
            d[nm] = 0
        detect_fast_to_local_list_compr(self.cmds[1], d, False)
        l = [(k, v) for k,v in d.iteritems() if v == 3 and self.d_varnames[k] >= self.co_argcount]
        self.fast_used_at_list_compr = dict(l) 
        
    def find_unused_fast_var(self):
        assert type(self) is code_extended
        if accurate_frame(self.cmds):
            return
        for v in self.co_varnames:
            if expr_in_expr(('FAST', v), self.cmds):
                pass
            else:
                self.unused_fast_var[v] = True
        
    def __str__(self):
        assert type(self) is code_extended
        return 'code_extended('+self.co_name+')'   
    def __repr__(self):
        assert type(self) is code_extended
        return 'code_extended('+self.co_name+')'   
    def Use_all_fastlocals(self):
        assert type(self) is code_extended
        for i in range(len(self.co_varnames)):
            self.used_fastlocals[self.co_varnames[i]] = True
            self.used_fastlocals[nmvar_to_loc(self.co_varnames[i])] = True
            
    def default_args_nm(self):
        assert type(self) is code_extended
        return 'default_arg_' + self.c_name + hex(hash_compile)[2:].strip()
        
    def can_be_codefunc(self):
        global compile_generators
        assert type(self) is code_extended
        if self.decompile_fail:
            return False
        n = self.c_name
        if n in no_compiled:
            return False
        assert type(n) is str
        if n[0] == '_' and (n.startswith('__new__')  or n.startswith('__del__')):
            return False
        if self.co_flags & CO_GENERATOR and not compile_generators:
            return False
        return True
    
    def can_be_cfunc(self):
        global compile_generators
        global no_cfunc
        assert type(self) is code_extended
        if self.decompile_fail:
            return False        
        if no_cfunc:
            return False
        n = self.c_name
        if n in no_compiled:
            return False
        if self.co_flags & CO_GENERATOR and not compile_generators:
            return False
        if self.co_flags & 0x8:
            return False        
        if can_be_direct_call(self.cmds[1]) != True:
            if can_be_dictionable_cfunc(self.cmds[1]) and self.co_argcount == 0 and len(self.co_cellvars + self.co_freevars) == 0: # and n != 'Init_filename':
                if self.created_from is not None:
                    return self.created_from.can_C()
                return True
            return False
        if len(self.co_cellvars + self.co_freevars) > 0:
            return False

        if self.created_from is not None:
            return self.created_from.can_C()
        return True
    
    def can_C(self):
        assert type(self) is code_extended
        if self.decompile_fail:
            return False
        if self.can_be_cfunc():
            return True
        if self.can_be_codefunc():
            return True
        return False
    
    def strip_unused_fast(self):
        assert type(self) is code_extended
        if len(self.co_cellvars) == 0 and len(self.co_freevars) == 0:
            cmds = self.cmds[1]
            if not tag_in_expr('STORE_FAST', cmds) and not tag_in_expr('DELETE_FAST', cmds):
                i = len(self.co_varnames)
                changed = False
                while i > self.co_argcount:
                    i -= 1
                    nm = self.co_varnames[i]
                    if not expr_in_expr(('FAST', nm), cmds):
                        self.co_nlocals -= 1
                        del self.co_varnames[i]        
                        changed = True
                if changed:
                    self.d_varnames = dict([(v, i) for i,v in enumerate(co.co_varnames)])
                return changed
        return False
    
    def mark_method_class(self):
        assert type(self) is code_extended
        if len(self.co_varnames) > 0 and self.co_varnames[0] == 'self' and \
                self.co_argcount > 0 and \
                len(self.co_cellvars) == 0 and \
                len(self.co_freevars) == 0:
            li = [(cl, slot, nmcode) for cl, slot, nmcode, isstaticmeth, isclassmeth, isderived in all_meth if not isstaticmeth and not isclassmeth and nmcode == self.c_name]
            if len(li) == 1:
                cl = li[0][0]
                self.method_class = cl
                return
            Debug('One body method', li)

    def TypeVar(self, it):
        assert type(self) is code_extended
        typ = None
        if type(it) is tuple and it[0] == 'FAST':
            dete = self.detected_type
            it1 = it[1]
            if it1 in dete:
                typ = dete[it1] 
            if is_current & IS_DIRECT:
                typed_arg = self.typed_arg_direct
                pos = -1
                if it1 in self.d_varnames:
                    pos = self.d_varnames[it1]
                if pos != -1 and pos in typed_arg:
                    typ = typed_arg[pos] 
        return typ

    def IsIntVar(self, it):
        return IsInt(self.TypeVar(it))
    
    def IsBoolVar(self, it):
        return IsBool(self.TypeVar(it))
    
    def IsCharVar(self, it):
        return bool(IsChar(self.TypeVar(it)))

    def IsUnicodeCharVar(self, it):
        return bool(IsUnicodeChar(self.TypeVar(it)))
    
    def IsRealVar(self, it):
        return IsFloat(self.TypeVar(it))
    
    def IsCVar(self, it):
        assert type(self) is code_extended
        return IsCType(self.TypeVar(it)) and CVarName(it) is not None

    def ReturnType(self):
        assert type(self) is code_extended
        if self.c_name in detected_return_type:
            return detected_return_type[self.c_name]
        return None

    def IsRetVoid(self):
        assert type(self) is code_extended
        return self.c_name in detected_return_type and IsKlNone(detected_return_type[self.c_name])

    def IsRetBool(self):
        assert type(self) is code_extended
        return self.c_name in detected_return_type and IsBool(detected_return_type[self.c_name])

    def IsRetInt(self):
        assert type(self) is code_extended
        return self.c_name in detected_return_type and IsInt(detected_return_type[self.c_name])

    def IsRetFloat(self):
        assert type(self) is code_extended
        return self.c_name in detected_return_type and IsFloat(detected_return_type[self.c_name])

    def IsRetChar(self):
        assert type(self) is code_extended
        return self.c_name in detected_return_type and IsChar(detected_return_type[self.c_name])

    def IsUnicodeRetChar(self):
        assert type(self) is code_extended
        return self.c_name in detected_return_type and IsUnicodeChar(detected_return_type[self.c_name])
    
def IsCType(t): 
##    global Kl_C
    return bool(type(t) is tuple and (t[0] is int or t[0] is bool or t[0] is float or t[0] == 'C' or IsChar(t)))
##    return bool(IsInt(t)) or bool(IsChar(t)) or bool(IsBool(t)) or bool(IsFloat(t)) or t == Kl_C

def detect_fast_to_local_list_compr(it, d, is_compr):
    if type(it) is list:
        [detect_fast_to_local_list_compr(x, d, is_compr) for x in it]
        return
    if type(it) is tuple:
        if len(it) == 0:
            return
        if it[0] == 'CONST':
            return
        if it[0] == '!LIST_COMPR':    
            [detect_fast_to_local_list_compr(x, d, True) for x in it[1:]]
            return
        if is_compr:
            if it[0] == 'FAST':
                d[it[1]] = d[it[1]] | 1
            elif it[0] == 'STORE_FAST':
                d[it[1]] = d[it[1]] | 2
        else:
            if it[0] == 'FAST':
                d[it[1]] = d[it[1]] | 4
            elif it[0] == 'STORE_FAST':
                d[it[1]] = d[it[1]] | 8
        [detect_fast_to_local_list_compr(x, d, is_compr) for x in it]
        return
    return
      

def Type2CType(t):
    if IsInt(t):
        return 'long'
    if IsBool(t):
        return 'int'
    if IsFloat(t):
        return 'double'
    if IsChar(t):
        return 'char'
    assert False
    
def CType2Py(o, ref2, cnm, t):
    if IsInt(t):        
        o.PushInt(ref2, cnm)
    elif IsFloat(t):  
        o.Raw(ref2, ' = PyFloat_FromDouble (', cnm, ');')
    elif IsBool(t):        
        o.Raw(ref2, ' = PyBool_FromLong(', cnm, ');')
    elif IsChar(t):        
        o.Raw(ref2, ' = PyString_FromStringAndSize((char *)&', cnm, ', 1);')
    return ref2  

def pre_disassemble(_co):
    global g_co
    if _co not in all_co:
        g_co = code_extended(_co)
    else:
        g_co = all_co[_co]
    disassemble_base(g_co)
    light_opt_at_cmd_level(g_co.cmds)
    
## dict_frame_tag = {
    ## 'EXEC_STMT':1,
    ## 'IMPORT_STAR':1,
    ## 'EXEC_STMT_3':1,
    ## 'EXEC_STMT_2':1,
    ## 'EXEC_STMT_1':1,
    ## '(TRY':1,
    ## '(TRY_FINALLY':1,
    ## 'YIELD_STMT':1,
    ## ('!LOAD_BUILTIN', 'eval'):1,
    ## '(WITH':1}
    
str_dict_tag = frozenset((
    '!IMPORT_NAME',        
    'IMPORT_FROM_AS',        
    'LOAD_NAME',        
    'DELETE_NAME',        
    '!LOAD_NAME',        
    'STORE_NAME'))  
## if False:
    ## del dict_frame_tag['(TRY']
    ## del dict_frame_tag['(TRY_FINALLY']    
    ## del dict_frame_tag[('!LOAD_BUILTIN', 'eval')]
    

exprs_accurate_frame = {
                        ('!LOAD_BUILTIN', 'eval'):True,
                        ('!LOAD_BUILTIN', 'dir'):True,
                        ('!LOAD_BUILTIN', 'locals'):True,
                        ('!LOAD_BUILTIN', 'vars'):True}
tags_accurate_frame = frozenset(('!MK_CLOSURE',
                        'LOAD_CLOSURE',
                        'DELETE_FAST',
                        'YIELD_STMT',
                        'EXEC_STMT',
                        'EXEC_STMT_3',
                        'EXEC_STMT_2',
                        'EXEC_STMT_1'))

def accurate_frame(cmds):
    global automate_option
    if need_accurate_frame or exprs_in_expr(exprs_accurate_frame, cmds) or str_tags_in_expr(tags_accurate_frame, cmds):
        if type(cmds[0]) is tuple and len(cmds[0]) == 2 and cmds[0][0] == '(BEGIN_DEF':
            if not need_accurate_frame:
                Debug('def ' + cmds[0][1] + '(), need accurate frame')
        return True
    return False
    
def can_be_direct_call(it):
    global dict_frame_tag, str_dict_tag
    global direct_call
    if not direct_call:
        return False
    is_dict = False
    is_frame = False
    if frame_op_in_expr(it):
        is_frame = True
    if str_tags_in_expr(str_dict_tag, it):
        is_dict = True
    return not is_dict and not is_frame       
 
def can_be_dictionable_cfunc(it):
    global dict_frame_tag, str_dict_tag
    is_dict = False
    is_frame = False
    if frame_op_in_expr(it):
        is_frame = True
    if str_tags_in_expr(str_dict_tag, it):
        is_dict = True
    return is_dict and not is_frame   

def IsBegEnd(tag):
    return type(tag) is str and tag[0] in ')('

def IsBeg(tag):
    return type(tag) is str and tag[0] == '('

def join_str(a,b):
    assert IsStr(a)
    assert IsStr(b)
    if a == b:
        return a
    if IsChar(a) and IsChar(b):
        return Kl_Char
    return Kl_String

def join_int(a,b):
    assert IsInt(a)
    assert IsInt(b)
    return Int(min(a[1][0], b[1][0]), max(a[1][1], b[1][1]))

def intersect_int(a,b):
    assert IsInt(a)
    assert IsInt(b)
    return Int(max(a[1][0], b[1][0]), min(a[1][1], b[1][1]))


def uniq_list_type(_v):
    assert type(_v) is list
    v = _v
    if len(v) == 1:
        return v
    v = dict.fromkeys(v).keys()
    v_tu = [x for x in v if x is not None and x[0] is tuple]
    if len(v_tu) > 1:
        v_ntu = [x for x in v if x is None or x[0] is not tuple]
        if Kl_Tuple in v_tu:
            v_tu = [Kl_Tuple]
        else:
            sdsc = [x[1] for x in v_tu]
            ls = []
            for x in sdsc:
                if type(x) is tuple:
                    x = len(x)
                ls.append(x)
            if max(ls) != min(ls):
                if min(ls) > 0:
                    v_tu = [(tuple, min(ls))]
                else:
                    v_tu = [Kl_Tuple]
            else:   
                l0 = ls[0]
                if l0 in sdsc:
                    v_tu = [(tuple, l0)]
                else:
                    ty = [{} for i_0 in range(l0)]
                    for tu in sdsc:
                        for i in range(l0):
                            ty[i][tu[i]] = None
                    ret = []
                    for dic in ty: 
                        assert type(dic) is dict
                        if len(dic) == 1:
                            ret.append(dic.keys()[0])
                        else:
                            ret.append(None)    
                    ret = tuple(ret)
                    v_tu = [(tuple, ret)]
        v = v_tu + v_ntu
    assert type(v) is list
    v_int = [x for x in v if x is not None and x[0] is int]
    if len(v_int) > 1:
        v_nint = [x for x in v if x is None or x[0] is not int]
        if Kl_Int in v_int:
            v_int = [Kl_Int]
        else:
            v_int = [Int(min([x[1][0] for x in v_int]), max([x[1][1] for x in v_int]) )]
        v = v_int + v_nint
    assert type(v) is list
    if len([x for x in v if x is not None and x[0] is bool]) > 1:
        v = [Kl_Boolean] + [x for x in v if x is None or x[0] is not bool]
    assert type(v) is list
    if len([x for x in v if x is not None and IsChar(x)]) > 1:
        v = [Kl_Char] + [x for x in v if x is None or not IsChar(x)]
    assert type(v) is list
    if len([x for x in v if x is not None and IsStr(x)]) > 1:
        v = [Kl_String] + [x for x in v if x is None or not IsStr(x)]
    assert type(v) is list
    if len([x for x in v if x is not None and IsUnicodeChar(x)]) > 1:
        v = [Kl_UnicodeChar] + [x for x in v if x is None or not IsUnicodeChar(x)]
    assert type(v) is list
    if len([x for x in v if x is not None and IsUnicode(x)]) > 1:
        v = [Kl_Unicode] + [x for x in v if x is None or not IsUnicode(x)]
    assert type(v) is list
    if len(v) == 3:
        if IsChar(v[0]) and IsChar(v[1]) and IsChar(v[2]):
            return [Kl_Char]
        if IsUnicodeChar(v[0]) and IsUnicodeChar(v[1]) and IsUnicodeChar(v[2]):
            return [Kl_UnicodeChar]
        if IsStr(v[0]) and IsStr(v[1]) and IsStr(v[2]):
            return [Kl_String]
        if IsUnicode(v[0]) and IsUnicode(v[1]) and IsUnicode(v[2]):
            return [Kl_Unicode]
        if IsInt(v[0]) and IsInt(v[1]) and IsInt(v[2]):
            return [join_int(join_int(v[0], v[1]), v[2])]
        if IsInt(v[0]) and IsIntUndefSize(v[1]) and IsInt(v[2]):
            return [Kl_IntUndefSize]
        if IsIntUndefSize(v[0]) and IsInt(v[1]) and IsInt(v[2]):
            return [Kl_IntUndefSize]
        if IsInt(v[0]) and IsInt(v[1]) and IsIntUndefSize(v[2]):
            return [Kl_IntUndefSize]
        if IsInt(v[0]) and IsIntUndefSize(v[1]):
            v = [Kl_IntUndefSize, v[2]]        
        elif IsInt(v[1]) and IsIntUndefSize(v[0]):
            v = [Kl_IntUndefSize, v[2]]        
        elif IsInt(v[0]) and IsIntUndefSize(v[2]):
            v = [Kl_IntUndefSize, v[1]]        
        elif IsInt(v[2]) and IsIntUndefSize(v[0]):
            v = [Kl_IntUndefSize, v[1]]        
        elif IsInt(v[1]) and IsIntUndefSize(v[2]):
            v = [Kl_IntUndefSize, v[0]]        
        elif IsInt(v[2]) and IsIntUndefSize(v[1]):
            v = [Kl_IntUndefSize, v[0]] 

    assert type(v) is list
    if len(v) == 2:
        if IsMayBe(v[0]) and IsMayBe(v[1]):   
            v3 = [v[0][1], v[1][1]]
            v3 = uniq_list_type(v3)
            if len(v3) == 1:
                assert not IsMayBe(v3[0])
                return [('MayBe', v3[0])]
        if IsMayBe(v[0]) and not IsMayBe(v[1]):
            assert not IsMayBe(v[0][1])
            v3 = [v[0][1], v[1]]
            v3 = uniq_list_type(v3)
            if len(v3) == 1:
                if IsMayBe(v3[0]):
                    return v3
                return [('MayBe', v3[0])]
        if IsMayBe(v[1]) and not IsMayBe(v[0]):
            assert not IsMayBe(v[1][1])
            v3 = [v[1][1], v[0]]
            v3 = uniq_list_type(v3)
            if len(v3) == 1:
                if IsMayBe(v3[0]):
                    return v3
                return [('MayBe', v3[0])]
        if IsChar(v[0]) and IsChar(v[1]):
            return [Kl_Char ]
        if IsUnicodeChar(v[0]) and IsUnicodeChar(v[1]):
            return [Kl_UnicodeChar ]
        if IsStr(v[0]) and IsStr(v[1]):
            return [Kl_String ]
        if IsUnicode(v[0]) and IsUnicode(v[1]):
            return [Kl_Unicode ]
        if IsInt(v[0]) and IsInt(v[1]):
            return [join_int(v[0], v[1])]                
        if IsIntUndefSize(v[0]) and IsInt(v[1]):
            return [Kl_IntUndefSize]
        if IsInt(v[0]) and IsIntUndefSize(v[1]):
            return [Kl_IntUndefSize]
        if IsKlNone(v[0]) and v[1] is not None:
            if IsMayBe(v[1]):
                return [v[1]]
            return [NewMayBe(v[1])]
        if IsKlNone(v[1]) and v[0] is not None:
            if IsMayBe(v[0]):
                return [v[0]]
            return [NewMayBe(v[0])]
        ## if IsListAll(v[0]) and IsTuple(v[1]):
            ## return [Kl_Sequence]    
        ## if IsListAll(v[1]) and IsTuple(v[0]):
            ## return [Kl_Sequence]     
        ## if IsStr(v[0]) and IsTuple(v[1]):
            ## return [Kl_Sequence]    
        ## if IsStr(v[1]) and IsTuple(v[0]):
            ## return [Kl_Sequence]   
        if IsList(v[0]) and IsList(v[1]):
            return [Kl_List]
        ## if v[0] == Kl_Sequence and IsSequence(v[1]):      
            ## return [Kl_Sequence]        
        ## if v[1] == Kl_Sequence and IsSequence(v[0]):      
            ## return [Kl_Sequence]  
    return v

tags_redefined_all = frozenset(('IMPORT_STAR', 'EXEC_STMT_3', \
                                    'EXEC_STMT_2', 'EXEC_STMT_1', \
                                    'EXEC_STMT_0', 'EXEC_STMT'))

def post_disassemble():
    global no_build, redefined_all, g_co, Line2Addr, detected_global_type, seqcode, is_current, g_typed_stack, is_can_be_codefunc, count_bigpass, n_bigpass
    global check_calcref
    global restart
    SetPass('HalfRecompile')
    is_current = IS_CALLABLE_COMPILABLE
    check_calcref = False
    for g_co, _cmds in seqcode:
        ## assert cmds is not None
        assert g_co.cmds is not None
        jump_to_continue_and_break(g_co.cmds)
        half_recompile(g_co.cmds, g_co)
    check_calcref = False

    SetPass('ParseClasses-0')

    for g_co, _cmds in seqcode:
        
        if ident_in_expr('__metaclass__' , g_co.cmds[1]):
            _3(g_co.c_name, 'HaveMetaClass', '???')

    SetPass('FindUnusedFastVar')
    for g_co, _cmds in seqcode:
        
        g_co.find_unused_fast_var()
        
    SetPass('FirstRepl')

    single_define = [k for k,v in count_define_set.items() \
                           if v == 1 and (k in count_define_get or k == '__all__')]
                           
    only_define = [k for k,v in count_define_set.items() \
                           if v == 1 and (k not in count_define_get or k == '__all__')] 
                                                     
    no_define = [k for k,v in count_define_get.items() \
                           if (k not in count_define_set or k == '__all__' or 
                               (k in count_define_set and type(count_define_set[k]) is float and count_define_set[k] == 2.0))]
    check_calcref = True
    for g_co, _cmds in seqcode:
        
        is_can_be_codefunc = current_can_be_codefunc()
        g_co.cmds[1] = ortogonal(g_co.cmds[1], repl) 
        
    check_calcref = False

    SetPass('FindCalcConst')
    initcod = None
    for g_co, _cmds in seqcode:
        
        if g_co.c_name == 'Init_filename':            
            initcod = g_co.cmds[1]

    do_del = []        
 
    if initcod is not None:
        initcod = [st for st in initcod if type(st) is tuple and \
                   len(st) > 0 and not IsBegEnd(st[0])]
        for st in initcod:
            for k in single_define:
                p = find_statement_calculate_const(st, k) 
                if p != False:
                    filter_founded_calc_const(p, k, do_del)
    for k in do_del:       
        if k in single_define:
            del single_define[single_define.index(k)] 
    for k in only_define:
        add_noglob(k)             
    for k in no_define:
        add_noglob(k)  
            
    for n_bigpass in range(count_bigpass):            
        SetPass('ImportManipulation')

        for g_co, _cmds in seqcode:
            
            if str_tags_in_expr(tags_redefined_all, g_co.cmds[1]):
                redefined_all = True
            if g_co.c_name != 'Init_filename' and tag_in_expr('!_PyEval_BuildClass' , g_co.cmds[1]): 
                redefined_all = True

        SetPass('UpgardeOp')
     
        for g_co, _cmds in seqcode:
            
            is_can_be_codefunc = current_can_be_codefunc()
            g_co.cmds[1] = tree_pass_upgrade_op(g_co.cmds[1], None, g_co.c_name) 
            

        SetPass('UpgardeOp2')

        for g_co, _cmds in seqcode:
             
            is_can_be_codefunc = current_can_be_codefunc()
            g_co.cmds[1] = tree_pass_upgrade_op2(g_co.cmds[1], None, g_co.c_name) 
            

        SetPass('DetectCDefClass')
        initcmd = []
        for g_co, _cmds in seqcode:
            
            if g_co.c_name == 'Init_filename':            
                initcmd = g_co.cmds[1]
                break
        pass_detect_cdef_class(initcmd, g_co) 


        global type_def, self_attr_type, self_attr_store, self_attr_use
        type_def.clear()
     
        SetPass('RecursiveTypeDetect-1')

        for g_co, _cmds in seqcode:             
            is_can_be_codefunc = bool(g_co.can_be_codefunc()  )
            g_co.cmds[1] = recursive_type_detect(g_co.cmds[1], g_co.c_name) 
            

        SetPass('UpgradeRepl-3')
        for g_co, _cmds in seqcode:            
            is_can_be_codefunc = current_can_be_codefunc()
            g_co.cmds[1] = tree_pass_upgrade_repl(g_co.cmds[1],  None, g_co.c_name) 
            
        
        SetPass('UpgardeOp3')

        for g_co, _cmds in seqcode:
              
            is_can_be_codefunc = bool(g_co.can_be_codefunc() )    
            g_co.cmds[1] = tree_pass_upgrade_op2(g_co.cmds[1], None, g_co.c_name) 
            
        
        SetPass('CollectTypeReturn')
        pass_detect_return_type()
     
        SetPass('ParseClasses')

        global all_meth
        for g_co, _cmds in seqcode:
            
            is_can_be_codefunc = current_can_be_codefunc()
            if g_co.is_class_creator is not None: 
                add_derived(g_co.c_name)
                parse_class_def(g_co.c_name, g_co.cmds[1][:-1])
                parse_for_special_slot_class(g_co.c_name, g_co.cmds[1][:-1], g_co.is_class_creator)
                all_meth = [x for x in all_meth if x[2] is not None]
            tree_pass(g_co.cmds[1], collect_default_args, None, g_co.c_name)

        SetPass('UpgardeRepl-1')
        for g_co, _cmds in seqcode:
               
            is_can_be_codefunc = bool(g_co.can_be_codefunc() )   
            g_co.cmds[1] = tree_pass_upgrade_repl(g_co.cmds[1], None, g_co.c_name) 
            

        SetPass('CollectSetAttr')
        
        pas_collect_set_attr(seqcode)    

        SetPass('CollectSetAttr-2')
         
        pas_collect_set_attr(seqcode)    
                       
        SetPass('RecursiveTypeDetect-2')
        for g_co, _cmds in seqcode:            
            is_can_be_codefunc = bool(g_co.can_be_codefunc() )    
            g_co.cmds[1] = recursive_type_detect(g_co.cmds[1], g_co.c_name) 
            

        SetPass('CollectTypeLocal1')
        pass_local_type_detect()

        SetPass('CollectTypeGlobal')
        pass_global_type_detect()

        SetPass('CollectTypeLocal2')
        pass_local_type_detect() 
        
        SetPass('ReplaceLocalConstDetected')
        for g_co, _cmds in seqcode:            
            if accurate_frame(g_co.cmds):
                continue
            is_can_be_codefunc = bool(g_co.can_be_codefunc() )       
            g_co.cmds[1] = replace_local_const_detect(g_co.cmds[1], g_co.c_name) 

        SetPass('UpgradeRepl-4')
        for g_co, _cmds in seqcode:                  
            is_can_be_codefunc = current_can_be_codefunc()
            g_co.cmds[1] = tree_pass_upgrade_repl(g_co.cmds[1], None, g_co.c_name) 
            
        if direct_call:
            SetPass('ConcretizeDirectCall-1')
            concretize_direct_call(1)
            
            SetPass('SetCondMethCall-0')

            for g_co, _cmds in seqcode:
                is_can_be_codefunc = current_can_be_codefunc()
                if g_co.can_be_codefunc():                
                    is_current = IS_CALLABLE_COMPILABLE
                    g_co.cmds[1] = tree_pass__(g_co.cmds[1], upgrade_repl_if_type_direct_call, None, g_co.c_name) 
                    
                    g_co.cmds[1] = tree_pass_upgrade_op(g_co.cmds[1], None, g_co.c_name) 
                    
                    is_current = IS_DIRECT              
                    
                    g_co.direct_cmds = tree_pass__(g_co.direct_cmds, upgrade_repl_if_type_direct_call, None, g_co.c_name)
                    
                    g_co.direct_cmds = tree_pass_upgrade_op(g_co.direct_cmds, None, g_co.c_name) 
                    
            is_current = IS_CALLABLE_COMPILABLE

            SetPass('ConcretizeDirectCall-2')
            concretize_direct_call(2)
            if build_executable:
                SetPass('SupressUnusedCodefunc')
                supress_unused_codefunc()
                SetPass('ConcretizeDirectCall-3')
                concretize_direct_call(3)

        ## SetPass('SplitDirectCall-1')
        ## split_direct_call()
            
        SetPass('CollectTypeLocal3')
        pass_local_type_detect()

        SetPass('CollectTypeGlobal3')
        pass_global_type_detect()

        SetPass('CollectTypeLocal4')
        pass_local_type_detect()

        SetPass('CollectTypeReturn-3')
        pass_detect_return_type()

        SetPass('CollectSetAttr-3')
         
        pas_collect_set_attr(seqcode)    


        SetPass('UpgradeRepl-5')
        for g_co, _cmds in seqcode:
                  
            is_can_be_codefunc = current_can_be_codefunc()
            ##assert not (expr_in_expr(  ('PY_TYPE', 'NewClassInstance', 'code_extended', ('!COND_METH_EXPR', ('!LOAD_GLOBAL', 'g_co'), ('!PyObject_GetAttr', ('!LOAD_GLOBAL', 'g_co'), ('CONST', 'hidden_arg_direct')), ((('NewClassInstance', 'code_extended'), ('!PyObject_GetAttr', ('PY_TYPE', 'NewClassInstance', 'code_extended', ('!LOAD_GLOBAL', 'g_co'), None), ('CONST', 'hidden_arg_direct'))),)), None), g_co.direct_cmds) and IsList(TypeExpr(('!COND_METH_EXPR', ('!LOAD_GLOBAL', 'g_co'), ('!PyObject_GetAttr', ('!LOAD_GLOBAL', 'g_co'), ('CONST', 'hidden_arg_direct')), ((('NewClassInstance', 'code_extended'), ('!PyObject_GetAttr', ('PY_TYPE', 'NewClassInstance', 'code_extended', ('!LOAD_GLOBAL', 'g_co'), None), ('CONST', 'hidden_arg_direct'))),)))))
            
            g_co.cmds[1] = tree_pass_upgrade_repl(g_co.cmds[1], None, g_co.c_name) 
            g_co.direct_cmds = tree_pass_upgrade_repl(g_co.direct_cmds, None, g_co.c_name)
            
            


        if direct_call:
            SetPass('ConcretizeDirectCall-5')
            concretize_direct_call(4)

            SetPass('CollectTypeLocal5')
            pass_local_type_detect()
        
            SetPass('CollectTypeGlobal5')
            pass_global_type_detect()
        
            SetPass('CollectTypeLocal6')
            pass_local_type_detect()
        
            SetPass('CollectTypeReturn-5')
            pass_detect_return_type(True)

            SetPass('CollectSetAttr-4')
             
            pas_collect_set_attr(seqcode)    

        SetPass('LabelMethod')
        for g_co, _cmds in seqcode:
            g_co.mark_method_class()
            
        SetPass('CollectNoGlob')
        pass_find_noglob()

        SetPass('DetectFastToLocalListCompr')
        for g_co, _cmds in seqcode:
            g_co.DetectFastToLocalListCompr()
            
        if restart:
            return
                   
    SetPass('Formire')   
    for g_co, _cmds in seqcode:
        dump(g_co)
        print_cmds(g_co.cmds)
        g_typed_stack = []
        if g_co.direct_cmds is not None:
            if len(g_co.hidden_arg_direct) == 0 and g_co.direct_cmds == g_co.cmds[1]:
                pass
            elif print_pycmd:
                out.write('Hidden args '+ str(g_co.hidden_arg_direct) + '\n')
                print_cmds([('(DIRECT_DEF', g_co.c_name), g_co.direct_cmds])
        if g_co.decompile_fail:
            continue
        if g_co.no_codefunc:
            Line2Addr = line2addr(g_co)
        else:
            g_co.store_and_delete_and_fast = {}
            collect_store_and_delete_and_fast(g_co.cmds[1], g_co.store_and_delete_and_fast)
            generate(g_co.cmds, g_co, filename)
        g_typed_stack = []
        is_current = IS_DIRECT
        if g_co.direct_cmds is not None:
            g_co.store_and_delete_and_fast = {}
            collect_store_and_delete_and_fast(g_co.direct_cmds, g_co.store_and_delete_and_fast)
        generate_direct(g_co.cmds, g_co, filename)  
        is_current = IS_CALLABLE_COMPILABLE

            
    c_fname, nmmodule = Pynm2Cnm(filename)
    SetPass('WriteAsC')
    
    if restart:
        return
    
    write_as_c(out3, nmmodule)   
    out3.close()
    
    FlushDebug()

    ## if make_indent:
        ## SetPass('Indent')
        ## os.system('indent ' + c_fname)
    if no_build:
        pass
    else:    
        SetPass('Compile')
        compile_c(filename, c_fname)
    SetPass('WorkDone')
    global Pass
    global Tx_cnt
    global Tx_cnt2
    global patt_TCmp
    if flag_stat:
        pp('Passess...')
        its = Pass.items()
        its.sort()
        for k,v in its:
            assert type(v) is float
            pp('  ' + str(k) + ' ' + str(round(v, 3)))
        pprint(Tx_cnt)
        sta = [(Tx_lin[k], v, Tx_cnt2[k]) for k,v in Tx_cnt.items()]
        sta.sort()
        pprint(sta)
#        pprint(Tx_cnt2)
#        pprint(Tx_lin)
        ## sta = [(k, Tx_cnt2[k], Tx_lin[k],v) for k,v in Tx_cnt.items() if Tx_cnt2[k] != 0 or Tx_cnt2[k] == 0]
        ## sta.sort()
        ## pp('--- patterns ---')
        ## for k, used, l, s in sta:



            ## pp('  ' , s)
        return None

def pas_collect_set_attr(seqcode):
    global g_co
    global self_attr_type
    self_attr_type.clear()
    for g_co, _cmds in seqcode:           
        g_co.cmds[1] = tree_pass(g_co.cmds[1], collect_set_attr, None, g_co.c_name) 
        
    for g_co, _cmds in seqcode:         
        g_co.cmds[1] = tree_pass(g_co.cmds[1], collect_set_attr, None, g_co.c_name) 
        

    for k1, v in self_attr_type.items():
        ## if len(v) != 1:

        if len(v) == 2 and IsInt(v[0]) and IsInt(v[1]):
            detected_attr_type[k1] = join_int(v[0], v[1]) 
        elif len(v) > 1:
            v = [Kl_Function if x is not None and x[0] == Kl_Function[0] else x for x in v]
            v = dict.fromkeys(v).keys()            
        if len(v) == 1 and v[0] is not None and v[0] != Kl_None:
            detected_attr_type[k1] = v[0]
        elif len(v) == 2 and IsInt(v[0]) and IsInt(v[1]):
            detected_attr_type[k1] = join_int(v[0], v[1])                       
        else:            
            Debug('Not detected attr type', k1, v)    
    

def current_can_be_codefunc():
    return bool(g_co.can_be_codefunc())

def collect_setattr(cod, d2):
    if type(cod) is list:
        for it in cod:
            collect_setattr(it, d2)
    if type(cod) is tuple:
        if len(cod) > 0 and cod[0] == 'CONST':
            return
        v = []
        if TCmp(cod, v, ('PyObject_SetAttr', ('FAST', 'self'), ('CONST', '?')) ):
            d2[v[0]] = True
        for it in cod:
            collect_setattr(it, d2)
            
def collect_setatt_all(d, d2):
    for it in d.itervalues():
        if it[0] == '!MK_FUNK':
            cod = N2C(it[1]).cmds[1]
            collect_setattr(cod, d2)    
    return
            
detected_slots = {}
compiled_slots = {}
inverted_compiled_slots = {}

def pass_detect_cdef_class(initcmd, g_co):
    global compiled_slots
    global inverted_compiled_slots
    global redefined_attribute
    global using_slots
    global detected_slots

    for i, st in enumerate(initcmd):
        v = []
        ## v2 = []
        if type(st) is not tuple:
            continue

        if TCmp(st, v, ( 'STORE', 
           (('STORE_CALC_CONST', ('?', '?')),), 
           ( ( '!_PyEval_BuildClass', 
               ( '!BUILD_MAP', '?'),
               ('!BUILD_TUPLE', ('?',)), 
               ('CONST', '?')),)) ):
            pass
        if len(v) > 0 and \
               v[0] in ('STORE_GLOBAL', 'STORE_NAME') and \
               all([a[0] == 'CONST' and a[1] != '__dict__' for a,b in v[2]]):
            d = {a[1]:b for a,b in v[2]}
            list_slots = None
            prev = None
            nm = v[1]
            if '__slots__' not in d and auto_slots:
                if v[3] is None or (v[3][0] == '!LOAD_BUILTIN' and v[3][1] in ('object', 'dict')): 
                    d2 = {}
                    collect_setatt_all(d, d2)
                    list_slots = d2.keys()
                    list_slots.sort()
                    if '__dict__' not in d2:
                        list_slots.append('__dict__')
                    d['__slots__'] = ('!BUILD_LIST', tuple([('CONST', x) for x in list_slots]))
                    lis = []
                    for a, b in d.iteritems():
                        lis.append((('CONST', a), b)) 
                    if v[3] is None:
                        defparent = ('CONST', ())
                    else:
                        defparent = ('!BUILD_TUPLE', (v[3],))
                    initcmd[i] = ( 'STORE', 
                       (('STORE_CALC_CONST', (v[0], v[1])),), 
                       ( ( '!_PyEval_BuildClass', 
                           ( '!BUILD_MAP', tuple(lis)),
                           defparent, 
                           ('CONST', v[1])),))                     
                    list_slots = set(list_slots)
                elif v[3][0] == 'CALC_CONST':
                    prev = v[3][1]
                    d2 = {}
                    collect_setatt_all(d, d2)
                    list_slots = set(d2.keys())
                    if v[3][1] in detected_slots:
                        list_slots |= detected_slots[v[3][1]]  
                    if v[3][1] in detected_slots:
                        if '__dict__' not in detected_slots[v[3][1]]:
                            list_slots.add('__dict__')
                        else:
                            list_slots.remove('__dict__')
                    else:
                        list_slots.add('__dict__')
                    li = [x for x in list_slots if x != '__dict__']
                    if '__dict__' in list_slots:
                        li.append('__dict__')
                    d['__slots__'] = ('!BUILD_LIST', tuple([('CONST', x) for x in li]))
                    lis = []
                    for a, b in d.iteritems():
                        lis.append((('CONST', a), b)) 
                    initcmd[i] = ( 'STORE', 
                       (('STORE_CALC_CONST', (v[0], v[1])),), 
                       ( ( '!_PyEval_BuildClass', 
                           ( '!BUILD_MAP', tuple(lis)),
                           ('!BUILD_TUPLE', (v[3],)), 
                           ('CONST', v[1])),))   
                # else:
                #     if st[0] == 'STORE' and '!_PyEval_BuildClass' == st[2][0][0]:
                #         pprint(st)
                #         pp('/1', st[2][0])
                                     
            if '__slots__' in d:
                using_slots = True
                ##assert False
                ##continue
                slots = d['__slots__']
                
                if slots[0] == 'CONST' and type(slots[1]) is tuple:
                    list_slots = set([('CONST', x) for x in slots[1]])
                elif slots[0] != '!BUILD_LIST' or not all([x[0] == 'CONST' for x in slots[1]]):
                    pprint(slots)
                    assert False
                else:
                    list_slots = set([x[1] for x in slots[1]])
                list_slots = set([x[1] if x[0] == 'CONST' else x for x in list_slots])
                if prev is not None and prev in detected_slots:
                    list_slots |= detected_slots[prev]
            if list_slots is None or len(list_slots) == 0:
                continue   
            detected_slots[v[1]] = list_slots 

            if fast_slots:
                compiled_slots[v[1]] = list_slots
        else:
            if st[0] == 'STORE' and '!_PyEval_BuildClass' == st[2][0][0]: ## in repr(st):
                if st[2][0][2] == ('CONST', ()):
                    pass
                elif st[2][0][1][0] == '!PyObject_Call':
                    Debug('Not BUILD_MAP and class create', st)
                else:
                    pprint(st)
                    pp('/22', st[2][0])
    inverted_compiled_slots = {}
    if fast_slots:
        for k,v in compiled_slots.iteritems():
            for nm in v:
                if nm not in inverted_compiled_slots:
                    inverted_compiled_slots[nm] = [k]
                else:
                    inverted_compiled_slots[nm].append(k)

def pass_detect_return_type(debug_message_rettype = False):
    global g_co, is_current, seqcode
    len_detected_return_type = len(detected_return_type)
    while True:
        type_def.clear()
        for g_co, _cmds in seqcode:
            if g_co.co_flags & CO_GENERATOR:
                detected_return_type[g_co.c_name] = Kl_Generator 
            else:                   
                is_current = IS_CALLABLE_COMPILABLE               
                if g_co.no_codefunc:
                    pass
                else:
                    tree_pass_collect_type_return(g_co.cmds[1], g_co.c_name) 
                
                is_current = IS_DIRECT                
                tree_pass_collect_type_return(g_co.direct_cmds, g_co.c_name)  
                is_current = IS_CALLABLE_COMPILABLE               
    
        for k1, v1 in type_def.items():           
            assert type(v1) is dict
            v = v1.keys()
            v.sort()
            v = uniq_list_type(v)           
            if len(v) == 1 and v[0] is not None:
                detected_return_type[k1] = v[0] 
                if debug_message_rettype:
                    Debug('Detected return type', k1, '!!!', detected_return_type[k1]) 
            elif len(v) == 2:
                if IsStr(v[0]) and IsStr(v[1]):
                    detected_return_type[k1] = Kl_String 
                    if debug_message_rettype:
                        Debug('Detected return type', k1, '!!!', detected_return_type[k1]) 
                elif IsUnicode(v[0]) and IsUnicode(v[1]):
                    detected_return_type[k1] = Kl_Unicode 
                    if debug_message_rettype:
                        Debug('Detected return type', k1, '!!!', detected_return_type[k1]) 
                elif IsKlNone(v[0]) and v[1] is not None:
                    detected_return_type[k1] = NewMayBe(v[1]) 
                    if debug_message_rettype:
                        Debug('Detected return type', k1, '!!!', detected_return_type[k1]) 
                elif IsKlNone(v[1]) and v[0] is not None:
                    detected_return_type[k1] = NewMayBe(v[0])
                    if debug_message_rettype:
                        Debug('Detected return type', k1, '!!!', detected_return_type[k1]) 
                else: 
                    if debug_message_rettype:    
                        Debug('Detected return type', k1, '###{', v)    
            else:
                if debug_message_rettype:
                    Debug('Detected return type', k1, '###{', v)   
        if len_detected_return_type == len(detected_return_type):
            break
        len_detected_return_type = len(detected_return_type) 
    type_def.clear()
    
def tree_pass_global_type_detect(a, up, nm): 
    global print_tree_node
    if print_tree_node:
        pp('>> tree_pass_global_type_detect', nm, up, a)
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return a
        if collect_set_global(a,nm):
            return
        [tree_pass_global_type_detect(v, a, nm) for v in a]
    if type(a) is list:
        assert len(a) > 0 
        [tree_pass_global_type_detect(v, a, nm) for v in a]

def pass_global_type_detect():
    global global_type, detected_global_type, g_co, is_current, seqcode, is_can_be_codefunc
    global_type.clear()
    for g_co, _cmds in seqcode:
        is_can_be_codefunc = current_can_be_codefunc()
        is_current = IS_CALLABLE_COMPILABLE
        if g_co.no_codefunc:
            pass
        else:
            tree_pass_global_type_detect(g_co.cmds[1], None, g_co.c_name) 
        is_current = IS_DIRECT                
        tree_pass_global_type_detect(g_co.direct_cmds, None, g_co.c_name)          
        is_current = IS_CALLABLE_COMPILABLE               
 
    for k1, v1 in global_type.items():
        assert type(v1) is dict
        v = v1.keys()
        v = uniq_list_type(v)
        if len(v) == 1 and v[0] is not None:
            detected_global_type[k1] = v[0] 
        elif len(v) == 2:
            if IsStr(v[0]) and IsStr(v[1]):
                detected_global_type[k1] = Kl_String 
            elif IsUnicode(v[0]) and IsUnicode(v[1]):
                detected_global_type[k1] = Kl_Unicode 
            elif IsKlNone(v[0]) and v[1] is not None:
                detected_global_type[k1] = NewMayBe(v[1]) 
            elif IsKlNone(v[1]) and v[0] is not None:
                detected_global_type[k1] = NewMayBe(v[0])
            else:     
                Debug('Not detected global type', k1, v)    
        else:
            Debug('Not detected global type', k1, v)   
    for k, v in detected_global_type.iteritems():
        Debug('Detected global type var', k, v)    

def pass_local_type_detect():
    global local_type, g_co, is_current, seqcode, is_can_be_codefunc
    for g_co, _cmds in seqcode:
        if accurate_frame(g_co.cmds):
            continue
        is_can_be_codefunc = current_can_be_codefunc()
        local_type.clear()
        if not g_co.can_be_codefunc():
            continue
        is_current = IS_CALLABLE_COMPILABLE              
        if g_co.no_codefunc:
            pass
        else:
            collect_set_local( g_co.cmds[1], g_co.c_name) 
        is_current = IS_DIRECT               
        collect_set_local( g_co.direct_cmds, g_co.c_name)  
        is_current = IS_CALLABLE_COMPILABLE              
        for k1, v1 in local_type.items():
            assert type(v1) is dict
            v = v1.keys()
            v = uniq_list_type(v)
            if len(v) == 2:
                if IsStr(v[0]) and IsStr(v[1]):
                    v = [Kl_String ]
                elif IsUnicode(v[0]) and IsUnicode(v[1]):
                    v = [Kl_Unicode]
                elif IsKlNone(v[0]) and v[1] is not None:
                    v = [NewMayBe(v[1])]
                elif IsKlNone(v[1]) and v[0] is not None:
                    v = [NewMayBe(v[0])]
            if len(v) != 1 or v[0] is None:
                Debug('def %s(-), var %s -- local type not detected (%s)' % (g_co.c_name, k1, v))
                continue
            if k1 in g_co.co_varnames[:g_co.co_argcount + bool(g_co.co_flags & 0x4)]:
                Debug('def %s(-), var %s -- local type may be detected (%s)' % (g_co.c_name, k1, v))
                
                g_co.detected_type_may_be[k1] = v[0] 
                continue
            g_co.detected_type[k1] = v[0] 
        changed_arg_type_detect(g_co)             
        if len(g_co.detected_type) > 0:
            for k, v in g_co.detected_type.items():
                Debug('def %s(+), var %s -- local type detected (%s)' % (g_co.c_name, k, v))

def changed_arg_type_detect(co):
    return None
    if len(co.detected_type_may_be) > 0 and len(co.typed_arg_direct_changed) > 0:
##        todel = {}
        for nm, kl in co.detected_type_may_be.items():
            ind = co.d_varnames[nm]
            if ind in co.typed_arg_direct_changed:
                li = uniq_list_type([co.typed_arg_direct_changed[ind], kl])
                if len(li) == 1 and li[0] is not None:
                   co.typed_arg_direct[ind] = li[0]
                   ## del co.typed_arg_direct_changed[ind]
                   ## todel[nm] = True
        ## for nm in todel.iterkeys():
            ## del co.detected_type_may_be[nm]           

def type_fast_changed_arg_type_detect(co, nm, ind):
    if nm in co.detected_type_may_be and len(co.typed_arg_direct_changed) > 0:
        kl = co.detected_type_may_be[nm]
        if ind in co.typed_arg_direct_changed:
            li = uniq_list_type([co.typed_arg_direct_changed[ind], kl])
            if len(li) == 1 and li[0] is not None:
                return li[0]
    return None

global list_calcconst_codefunc
used_calcconst_codefunc = {}

def supress_unused_codefunc():
    global g_co, seqcode
    initcod = None
    assert len(seqcode) > 0
    initcmds = None
    for g_co, initcmds in seqcode:
        if g_co.c_name == 'Init_filename':
            initcod = initcmds[1]
            break
 
    if initcod is None:
        return
    used_calcconst_codefunc.clear()
    for st in initcod:
        v = []
        if type(st) is tuple and len(st) == 3 and type(st[0]) is str and st[0] == 'STORE' and\
            TCmp(st, v, ('STORE', \
                           (('STORE_CALC_CONST', \
                                 ('STORE_NAME', '?')),), \
                            (('!MK_FUNK', '?', ('CONST', '?')),))) and v[0] == v[1]:
            used_calcconst_codefunc[v[0]] = False
    for g_co, _cmds in seqcode:
        tree_pass(g_co.cmds[1], find_use_calcconst_codefunc, None, g_co.c_name) 
    for nmcodefunc, used in used_calcconst_codefunc.items():
        if not used:
            co = N2C(nmcodefunc)     
            co.no_codefunc = True
            if co.direct_cmds is None:
                co.cmds = [('(BEGIN_DEF', nmcodefunc), [('PASS',)]]
            else:
                co.cmds = [('(BEGIN_DEF', nmcodefunc), co.direct_cmds]
            assert type(co.cmds[1]) is list
    new_initcod = []
    for st in initcod:
        v = []
        if type(st) is tuple and len(st) == 3 and type(st[0]) is str and st[0] == 'STORE' and\
              TCmp(st, v, ('STORE', \
                           (('STORE_CALC_CONST', \
                                 ('STORE_NAME', '?')),), \
                            (('!MK_FUNK', '?', ('CONST', '?')),))) and \
            v[0] in used_calcconst_codefunc and \
            not used_calcconst_codefunc[v[0]]:
                calculated_const[v[0]].generate = False
        else:
            new_initcod.append(st)
    initcmds[1] = new_initcod        

def find_use_calcconst_codefunc(it, nm):
    if type(it) is tuple and len(it) >= 2 and type(it[0]) is str:
        if it[0] in ('!CALL_CALC_CONST', 'STORE_NAME', 'STORE_GLOBAL', '!MK_FUNK', 'FAST', 'STORE_FAST', 'IMPORT_FROM_AS'):
            pass
        elif it[1] in used_calcconst_codefunc:
            used_calcconst_codefunc[it[1]] = True
    return it      

def concretize_direct_call(n):
    global g_co, is_current, seqcode
    global list_cmds, prev_list_cmds, is_can_be_codefunc
    list_cmds = [None]
    prev_list_cmds = []
    first = True
    q = 0
    while True:
        direct_args.clear()
        q += 1
        for g_co, _cmds in seqcode:       
                
            is_can_be_codefunc = current_can_be_codefunc()
            if is_can_be_codefunc:   
                is_current = IS_CALLABLE_COMPILABLE              
                if g_co.no_codefunc:
                    pass
                else:
                    tree_pass_readonly(g_co.cmds[1], None, g_co.c_name) 
                is_current = IS_DIRECT             

                tree_pass_readonly(g_co.direct_cmds, None, g_co.c_name) 
                is_current = IS_CALLABLE_COMPILABLE              

        prev_list_cmds = list_cmds
        list_cmds = [(co,_cmds) for co, _cmds in seqcode \
                    if _cmds[0][1] in direct_args and (co.can_be_codefunc() or co.can_be_direct_call)] 
        if list_cmds == prev_list_cmds:
            break

        for g_co, cmds in list_cmds: 
            
            is_can_be_codefunc = current_can_be_codefunc()
            if g_co.no_codefunc: ## or g_co.direct_cmds is not None:
                seq = g_co.direct_cmds
            else:
                seq = g_co.cmds[1]

            concretize_code_direct_call(g_co.c_name, seq, g_co, n) 
            if g_co.no_codefunc:
                for i, (co2, cmds2) in enumerate(seqcode):
                    if co2 is g_co:
                        seqcode[i] = (g_co, (cmds[0], g_co.direct_cmds))
                        break 
            changed_arg_type_detect(g_co)
##        first = False
    
def split_direct_call():
    global g_co, is_current, seqcode
    global list_cmds, prev_list_cmds, is_can_be_codefunc
    list_cmds = [None]
    prev_list_cmds = []
    direct_args.clear()
    
    for g_co, _cmds in seqcode:
        
        
        is_can_be_codefunc = current_can_be_codefunc()
        if is_can_be_codefunc:   
            is_current = IS_CALLABLE_COMPILABLE              
            if g_co.no_codefunc:
                pass
            else:
                tree_pass_readonly(g_co.cmds[1], None, g_co.c_name) 
            is_current = IS_DIRECT               
            tree_pass_readonly(g_co.direct_cmds, None, g_co.c_name) 
            is_current = IS_CALLABLE_COMPILABLE              

    prev_list_cmds = list_cmds
    list_cmds = [(co,_cmds) for co, _cmds in seqcode \
                if _cmds[0][1] in direct_args and (co.can_be_codefunc() or co.can_be_direct_call)] 
    li = []
    for g_co, cmds in list_cmds: 
        
        
        is_can_be_codefunc = current_can_be_codefunc()
        if g_co.no_codefunc: ## or g_co.direct_cmds is not None:
            seq = g_co.direct_cmds
        else:
            seq = g_co.cmds[1]
        li2 = split_code_direct_call(g_co.c_name, seq, g_co) 
        li.extend(li2)
    for co in li:
        seqcode.append((co, co.cmds))

        
def is_const_value1(v):
    if v[0] == 'CONST':
        return True
    if v[0] == '!LOAD_NAME' and (type(v[1]) is float or v[1] in ('nan', 'inf')):
        return True
    if v[0] == 'CALC_CONST':
        return True
    if v[0] == '!CLASS_CALC_CONST':
        return True
    if v[0] == '!CLASS_CALC_CONST_NEW':
        return True    
    if v[0] == '!BUILD_LIST' and all([is_const_value1(x) for x in v[1]]):
        return True
    if v[0] == '!BUILD_TUPLE' and all([is_const_value1(x) for x in v[1]]):
        return True
    if v[0] == '!PyObject_GetAttr' and is_const_value1(v[1]) and is_const_value1(v[2]):
        return True
    if v == ('!PyDict_New',):
        return True
    if v[0] in ('!LOAD_BUILTIN',):
        return True
    if v[0] == '!MK_FUNK' and is_const_value1(v[2]):
        return True
    if v[0] == '!PyObject_Type':
        return is_const_value1(v[1])
    return False
    
def is_const_default_value(v):
    if v[0] == 'CONST':
        return True
    if v[0] == '!BUILD_TUPLE' and all([is_const_value1(x) for x in v[1]]):
        return True
    if v[0] == '!PyDict_New' and len(v) == 1:
        Fatal('??? where ???', v)
        assert False
        return True    
    Debug('not const', v)
    return False  

def get_default_value1(v):
    return v

def is_simple_attr(expr):
    t = TypeExpr(expr)
    if t is not None and (t in _Kl_Simples or IsInt(t) or t[0] in (types.ModuleType, T_OLD_CL_TYP, T_NEW_CL_TYP, T_ANY_CL_TYP)):                 
        return True
    if expr[0].startswith('PyNumber_'):
        if len(expr) == 3 and (is_simple_attr(expr[1]) or is_simple_attr(expr[2])):
            return True
        if len(expr) == 4 and (is_simple_attr(expr[1]) or is_simple_attr(expr[2]) or is_simple_attr(expr[2])):
            return True
        if len(expr) == 2 and is_simple_attr(expr[1]):
            return True
    return False    

def get_nmcode(nmcl, expr):
    if expr is None:
        return None
    nm_code = None
    if expr[0] == '!MK_FUNK':
        nm_code = expr[1]
        default_arg = expr[2]
        if is_const_default_value(default_arg):
            default = get_default_value1(default_arg)
            default_args[nm_code] = default
            return nm_code
        Debug('*Not const default args  meth|attr', expr)        
    if expr[0] == '!MK_CLOSURE':
        nm_code = expr[1]
        default_arg = expr[3]
        if is_const_default_value(default_arg):
            default = get_default_value1(default_arg)
            default_args[nm_code] = default
            return nm_code
        Debug('*Not const default args  meth|attr', expr)        
    if expr[0] == '!LOAD_NAME':
        nm_prev = expr[1]

        if IsMethod(nmcl, nm_prev):
            nm_code = ValMethod(nmcl, nm_prev)
    if expr[0] == 'PY_TYPE' and expr[3][0] == '!LOAD_NAME':
        nm_prev = expr[3][1]
        if IsMethod(nmcl, nm_prev):
            nm_code = ValMethod(nmcl, nm_prev)
    if nm_code is None: 
        t = TypeExpr(expr)
        if t is not None and t[0] is types.FunctionType and t[1] is not None:
            nm_code = t[1]   
    v3 = []
    if nm_code is None and TCmp(expr, v3, ('!PyObject_Call', '?', ('!BUILD_TUPLE', (('!MK_FUNK', '?', '?'),)), ('NULL',))):     
        nm_code = v3[1]        
    return nm_code        

def one_store_clause(nmcl, nmslot, expr):
    v2 = []
    if nmslot in ('__doc__', '__module__'):
        return True
    if nmslot in ('__new__', '__del__'):
        nm_code = get_nmcode(nmcl, expr)
        if nm_code is None and expr[0] == '!MK_CLOSURE':
            nm_code = expr[1]
        if nm_code is not None:    
            no_compiled[nm_code] = True
        else:
            pp('Fatal(', expr, 'Is', 'NoCompiled', nm_code, ')')
    if expr is not None and is_simple_attr(expr):
        _3(nmcl, ('Attribute', nmslot), expr)
        return True
    nm_code = get_nmcode(nmcl, expr)
    if nm_code is not None:    
        def_method(nmcl, nmslot, nm_code, False, False)
        if nmslot == '__init__':
            parse_constructor(nmcl, nm_code)          
        return True
    if expr is not None and expr[0] == '!PyObject_Call':
        if TCmp(expr, v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'property'), '?', '?')):
            _3(nmcl, 'Property', nmslot)  
            return one_store_property_clause(nmcl, nmslot, v2[0], v2[1])
        if TCmp(expr, v2, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'staticmethod'),\
                        ('!BUILD_TUPLE', ('?',)), ('NULL',)) ):
            return one_store_modificator_clause(nmcl, nmslot, 'StaticMethod', v2[0])                
        if TCmp(expr, v2, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'classmethod'),\
                        ('!BUILD_TUPLE', ('?',)), ('NULL',)) ):
            return one_store_modificator_clause(nmcl, nmslot, 'ClassMethod', v2[0])   
    if expr is None:
        def_method(nmcl, nmslot, None, False, False)
        return False
    def_method(nmcl, nmslot, None, False, False)
    return False

def def_method(cl, slot, nmcode, isstaticmeth, isclassmeth, isderived = False):
    it = (cl, slot, nmcode, isstaticmeth, isclassmeth, isderived)
#    assert nmcode is not None
    for i, a in enumerate(all_meth):
        if a[:2] == it[:2]:
            all_meth[i] = it
            return
    all_meth.append(it)
    

def one_store_modificator_clause(nmcl, nmslot, Modificator, expr):
    nm_code = None
    if expr is not None:
        nm_code = get_nmcode(nmcl, expr)
    if nm_code is not None:    
        def_method(nmcl, nmslot, nm_code, Modificator == 'StaticMethod', Modificator == 'ClassMethod')
        return True
    def_method(nmcl, nmslot, None, Modificator == 'StaticMethod', Modificator == 'ClassMethod')
    Debug('*Not const default args %s meth|attr' % Modificator, expr)        
    return False

def one_store_property_clause(nmcl, nmslot, tupl, dic):
    getter, setter, deleter, doc = None, None, None, None
    if tupl[0] == '!BUILD_TUPLE':
        _tupl = list(tupl[1])
        while len(_tupl) < 4:
            _tupl.append(None)
        getter, setter, deleter, doc = _tupl
    elif tupl == ('CONST', ()):
        pass    
    else:
        Debug('*Undefined property positional arg', nmcl, nmslot, tupl, dic)       
    if dic == ('NULL',):
        pass
    elif dic[0] == '!BUILD_MAP':
        for (k,v) in dic[1]:
            if k == ('CONST', 'doc'):
                assert doc is None
                doc = v
            elif k == ('CONST', 'fget'):            
                assert getter is None
                getter = v      
            elif k == ('CONST', 'fset'):            
                assert setter is None
                setter = v      
            elif k == ('CONST', 'fdel'):            
                assert deleter is None
                deleter = v      
    else:        
        Debug('*Undefined property key arg', nmcl, nmslot, tupl, dic)   
        return False
    for k,v in (('Getter', getter), ('Setter', setter), ('Deleter', deleter)):
        if v is None or v == ('CONST', None):
            continue
        nm_code = get_nmcode(nmcl, v)
        if nm_code is not None:    
            _3(nmcl, (k, nmslot), nm_code)            
            continue
        Debug('*Access %s property class %s -> %s UNPARSE method %s ' % (k, nmcl, nmslot, nm_code))    
        return False
    return True                
     
def add_derived(nm):
    l0 = [] 
    for a1,b1 in all_derived:
        if a1 == nm:
            if b1[0] == '!CALC_CONST':
                li = [(nm,b,c,d,e,True) for a,b,c,d,e,f in all_meth if a == b1[1]]
                l0.extend(li)
    d = dict()
    for a1 in l0:
        d[a1] = True
    l0 = d.keys()
    d2 = {}
    for v in l0:
        if v[:2] in d2:
            continue
        d2[v[:2]] = 1
        all_meth.append(v)
                
     
def parse_class_def(nm, seq):
    i = -1
    while i < len(seq)-1:
        assert type(i) is int
        i += 1
        v = seq[i]
        if type(v) is tuple:     
            if v[0] == '.L':
                continue
            if v[0] == 'UNPUSH':
                Debug('*Ignored stmt in class def', v)
                continue
            v2 = []
            if len(v) > 0 and type(v[0]) is str and v[0] == 'STORE':
                if TCmp(v, v2, ('STORE', (('STORE_NAME', '?'),), ('?',))):
                    if not one_store_clause(nm, v2[0], v2[1]):
                        Debug('*Parse store clause illegal', v)
                    continue
                if TCmp(v, v2, ('STORE', (('STORE_GLOBAL', '?'),), ('?',))):
                    continue
                if TCmp(v, v2, ('STORE', (('PyObject_SetItem', ('!PyObject_Call', ('!LOAD_BUILTIN', 'locals'), ('CONST', ()), ('NULL',)), '?'),), ('?',))):
                    if v2[0][0] == 'CONST':
                        if not one_store_clause(nm, v2[0][1], v2[1]):
                            Debug('*Parse store clause illegal', v)
                    continue
                if TCmp(v, v2, ('STORE', (('PyObject_SetItem', '?', '?'),), ('?',))):
                    continue            
                if TCmp(v, v2, ('STORE', (('PyObject_SetAttr', '?', '?'),), ('?',))):
                    continue
                if TCmp(v, v2, ('STORE', (('SET_VARS', '?'),), (('!BUILD_LIST', '?'),))) and len(v2[0]) == len(v2[1]):
                    for j in range(len(v2[0])):
                        if v2[0][j][0] == 'STORE_NAME':
                            if not one_store_clause(nm, v2[0][j][1], v2[1][j]):
                                Debug('*Parse store clause illegal', v)
                    continue            
                if TCmp(v, v2, ('STORE', (('SET_VARS', '?'),), (('!BUILD_TUPLE', '?'),))) and len(v2[0]) == len(v2[1]):
                    for j in range(len(v2[0])):
                        if v2[0][j][0] == 'STORE_NAME':
                            if not one_store_clause(nm, v2[0][j][1], v2[1][j]):
                                Debug('*Parse store clause illegal', v)
                    continue            
                if TCmp(v, v2, ('STORE', (('SET_VARS', '?'),), ('?',))): # and v2[1][0] in ('PY_TYPE', '!PyObject_Call', '!LIST_COMPR', '!CALL_CALC_CONST', '!LOAD_NAME'):
                    for j in range(len(v2[0])):
                        if v2[0][j][0] == 'STORE_NAME':
                            if not one_store_clause(nm, v2[0][j][1], None):
                                Debug('*Parse store clause illegal', v)
                    continue            
    
            if len(v) == 3 and type(v[0]) is str and v[0] == 'SEQ_ASSIGN':
                for vv in v[1]:
                    if vv[0] == 'STORE_NAME':
                        if not one_store_clause(nm, vv, v[2]):
                            Debug('*Parse store clause illegal', v)    
                continue
            if len(v) > 0 and v[0] == 'PYAPI_CALL':
                continue

            if IsBeg(v[0]):
                oldi = i
                i = get_closed_pair(seq, i)
                if (i - oldi) == 4 and v[0] == '(IF':
                    parse_class_def(nm, seq[oldi+1])
                    parse_class_def(nm, seq[oldi+3])
                    continue
                if (i - oldi) == 2 and v[0] == '(IF':
                    parse_class_def(nm, seq[oldi+1])
                    continue    
                if (i - oldi) == 2 and v[0] == '(FOR':
                    parse_class_def(nm, seq[oldi+1])
                    continue    
                if (i - oldi) == 2 and v[0] == '(WHILE':
                    parse_class_def(nm, seq[oldi+1])
                    continue                                    
                if (i - oldi) == 2 and v[0] == '(WITH':
                    parse_class_def(nm, seq[oldi+1])
                    continue     
                if (i - oldi) == 2 and v[0] == '(TRY':
                    parse_class_def(nm, seq[oldi+1])
                    continue   
                if (i - oldi) == 4 and v[0] == '(TRY' and seq[oldi+2][0] == ')(EXCEPT':
                    parse_class_def(nm, seq[oldi+1])
                    if  seq[oldi+3] != [('PASS',)]:
                        parse_class_def(nm, seq[oldi+3])
                    continue   
                if (i - oldi) == 6 and v[0] == '(TRY' and seq[oldi+2][0] == ')(EXCEPT':
                    parse_class_def(nm, seq[oldi+1])
                    if  seq[oldi+3] != [('PASS',)]:
                        parse_class_def(nm, seq[oldi+3])
                    if  seq[oldi+5] != [('PASS',)]:
                        parse_class_def(nm, seq[oldi+5])                    
                    continue                             
                pprint(v)
                pp(v[0], i - oldi)
                Fatal('*Complicated meth|attr', seq[oldi:i+1])
                assert False
                continue
            if v[0] == 'EXEC_STMT_3':
                continue        
            if v[0] == 'CONTINUE':
                continue
            if v[0] == 'BREAK_LOOP':
                continue
            if v[0] == 'DELETE_NAME':
                continue
            if v[0] == 'DELETE_SUBSCR':
                continue        
            if v[0] == 'RAISE_VARARGS':
                continue        
            if v[0] == 'PRINT_ITEM_1':
                continue        
            if v[0] == 'PRINT_NEWLINE':
                continue 
            if v[0] == 'IMPORT_FROM_AS':
                continue        
            if v[0] == 'PASS':
                continue        
            if v[0] == 'SET_EXPRS_TO_VARS' and len(v[1]) == len(v[2]):
                for iii in range(len(v[1])):
                    parse_class_def(nm, [('STORE', (v[1][iii],), (v[2][iii],))])
                continue
       
        pprint(v)
        Fatal('*Parse class def error', v) 
        assert False

def parse_for_special_slot_class(nmcod, seq, nmcl):
    i = -1
    while i < len(seq)-1:
        assert type(i) is int
        i += 1
        v = seq[i]
        if type(v) is tuple:
            if v[0] == '.L':
                continue
            if v[0] == 'UNPUSH':
                continue
            v2 = []
            if len(v) > 0 and type(v[0]) is str and v[0] == 'STORE':
                if TCmp(v, v2, ('STORE', (('STORE_NAME', '?'),), ('?',))) and v2[0] in ('__new__', '__del__'):
                    v3 = []
                    if TCmp(v2[1], v3, ('!PyObject_Call',('!LOAD_BUILTIN', 'staticmethod'), \
                                        ('!BUILD_TUPLE', ('?',)), ('NULL',))):
                        v2[1] = v3[0]
                    elif TCmp(v2[1], v3, ('!PyObject_Call',('!LOAD_NAME', 'staticmethod'), \
                                        ('!BUILD_TUPLE', ('?',)), ('NULL',))):
                        v2[1] = v3[0]            
                    nm_code = get_nmcode(nmcl, v2[1])
                    if nm_code is None and v2[1][0] == '!MK_CLOSURE':
                        nm_code = v2[1][1]
                    if nm_code is not None:    
                        no_compiled[nm_code] = True
                    else:
                        pp('Fatal(Can\'t detect code for %s.%s method' % (nmcod, v2[0]), v, ')')
        continue
    
def parse_constructor(nmclass, nmcode):
    seq = N2C(nmcode).cmds[1]   
    for v in seq:
        v2 = []
        if type(v) is tuple and len(v) == 3 and type(v[0]) is str and v[0] == 'STORE' and\
          TCmp(v, v2, ('STORE', (('PyObject_SetAttr', ('?', 'self'), ('CONST', '?')),), ('?',))):
            SetAttrInstance(nmclass, v2[1])
        
def repl_in_if_store(ret, old, new, stor, dele):
    ret = list(ret)
    if not expr_in_expr(stor, ret[0]) and ret[0][0] == '(IF':
        ret[0] = replace_subexpr(ret[0], old, new)
    else:
        return ret    
    if len(ret) == 3 or len(ret) == 2:
        ret[1] = repl_in_list_if_store(ret[1], old, new, stor, dele)
    elif len(ret) == 5 or len(ret) == 4:   
        ret[1] = repl_in_list_if_store(ret[1], old, new, stor, dele)
        ret[3] = repl_in_list_if_store(ret[3], old, new, stor, dele)
    return ret    

def repl_in_list_if_store(ret, old, new, stor, dele):
    j = 0
    while j < len(ret):
        if IsBeg(ret[j][0]):
            j1 = get_closed_pair(ret, j)
            srepr = ret[j:j1]
            if expr_in_expr(stor, srepr) or expr_in_expr(dele, srepr):
                if ret[j][0] == '(IF':
                    ret[j:j1] = repl_in_if_store(ret[j:j1], old, new, stor, dele)
                    if is_not_caused_store(ret[j:j1], {stor:0, dele:0}):
                        j = j1 + 1
                        continue
                break
            ret[j:j1] = replace_subexpr(ret[j:j1], old, new)
            j = j1 + 1
        else:
            srepr = ret[j]
            if expr_in_expr(stor, srepr):
                if ret[j][0] == 'STORE' and len(ret[j][1]) == 1 and \
                    ret[j][1][0] == stor and len(ret[j][2]) == 1:
                    v2 = replace_subexpr(ret[j][2][0], old, new)
                    ret[j] = ('STORE', ret[j][1], (v2,))
                break
            elif expr_in_expr(dele, srepr):
                break
            ret[j] = replace_subexpr(ret[j], old, new)
            j = j + 1
    return ret

def apply_typ(ret, d):
    for old, t in d.items():    
        if t is None: 
            continue
        old_old = old
        if old_old[0] == 'PY_TYPE':
            if old_old[1] != t[0]:
                Fatal('def %s: change detected type' % g_co.c_name, old_old[1], t[0],ret)
                return ret
            old_old = old[3]
        assert old_old[0] != 'PY_TYPE'
        new = ('PY_TYPE', t[0], t[1], old_old, None) 
        t1 = TypeExpr(old_old)
        t2 = TypeExpr(new)
        if old != new and t1 != t2:  
            if IsTuple(t1) and IsTuple(t2) and type(t1[1]) is tuple and type(t2[1]) is tuple and len(t2[1]) > len(t1[1]):
                if type(t[1]) is int:
                    new = ('PY_TYPE', t2[0], t2[1], old_old, None)         
            ret2 = replace_subexpr(ret, old, new)
            ret = ret2
    return ret   

def SetRangeIntVar(d, v1, v2, v3, corrected, copyed): 
    var = ('FAST', v2)   
    for k in d.iterkeys():
        assert k[0] != 'PY_TYPE'
    trg = None
    if type(v1) is tuple:
        if v1[corrected] is None or (corrected == 0 and v1[corrected] < v3) or (corrected == 1 and v1[corrected] > v3):
            if corrected == 0:
                trg = Int(v3, v1[1])
            else:
                trg = Int(v1[0], v3)
        if trg is not None:
            if var not in d:
                d[var] = trg
            else:
                src = d[var]
                assert IsInt(src)
                if src[1] is None:
                    d[var] = trg
                elif corrected == 0 and src[1][0] < v3:
                    d[var] = Int(v3, v1[1])
                elif corrected == 1 and src[1][1] > v3:
                    d[var] = Int(v1[0], v3)
              
                else:
                    assert False
    elif v1 is None:
        if var not in d:
            if corrected == 0:
                trg = Int(v3, MInt)
            else:
                trg = Int((-MInt)-1, v3)            
            d[var] = trg
        else:
            src = d[var]
            assert IsInt(src)
            if src[1] is None:
                if trg is not None:
                    d[var] = trg
                elif corrected == 0:
                    d[var] = Int(v3, MInt)
                elif corrected == 1:
                    d[var] = Int((-MInt)-1, v3)                  
            elif corrected == 0 and src[1][0] < v3:
                d[var] = Int(v3, src[1][1])
            elif corrected == 1 and src[1][1] > v3:
                d[var] = Int(src[1][0], v3)
            else:
                assert False   

def SetRangeIntVar2(d, trg, var): 
  
    for k in d.iterkeys():
        assert k[0] != 'PY_TYPE'

    if var not in d:
        d[var] = trg
    else:
        src = d[var]
        assert IsInt(src)
        d[var] = intersect_int(trg,src)




def type_in_if(ret, d, prevtype = False):
    if type(ret) is str and ret == 'NULL':
        return ret
    assert type(d) is dict
    assert type(ret) is tuple
    ret0 = ret[0]
    assert type(ret0) is str
    curnewdef = None
    
    if ret0 == '!BOOLEAN':
        return ('!BOOLEAN', type_in_if(ret[1], d))
    if ret0 in ('!AND_JUMP', '!AND_BOOLEAN', '!AND_JUMPED_STACKED'):
        return (ret0,) + tuple([type_in_if(r, d) for r in ret[1:]])
    if ret0 in ('!OR_JUMP', '!OR_BOOLEAN', '!OR_JUMPED_STACKED'):
        return apply_typ((ret0,) + tuple([type_in_if(r, dict(d)) for r in ret[1:]]), d)
    if ret0 in '!COND_EXPR':
        return apply_typ((ret0, type_in_if(ret[1], d), type_in_if(ret[2], dict(d)), type_in_if(ret[3], dict(d))), d)   
    v = []
    old, nm, built = None, None, None
    ## if ret0 == '!PyObject_IsInstance':
        ## if TCmp(ret, v, ('!PyObject_IsInstance', '?', ('CALC_CONST', '?'))):
            ## old, nm = v
            ## built = False        
    if ret0 == '!_EQ_':
        if TCmp(ret, v, ('!_EQ_', ('!PyObject_Type', '?'), \
                                            ('!LOAD_BUILTIN', '?'))):
            old, nm = v
            built = True                                       
        elif TCmp(ret, v, ('!_EQ_', ('!LOAD_BUILTIN', '?'), \
                                                ('!PyObject_Type', '?'))):
            nm, old = v
            built = True
        elif TCmp(ret, v, ('!_EQ_', ('!PyObject_Type', '?'), '?')):
            t = TypeExpr(v[1])
            if t is not None and t[1] is not None:                
                if t[0] is type:
                    old, nm = v[0], t[1]
                    built = True
                elif t[0] in (T_NEW_CL_TYP, T_OLD_CL_TYP):
                    old, nm = v[0], t[1]
                    built = False
                else:
                    pp('type_in_if(', t, ret)

        ## elif TCmp(ret, v, ('!_EQ_', ('!PyObject_Type', '?'), \
                                            ## ('CALC_CONST', '?'))):
            ## old, nm = v
            ## built = False 

        elif TCmp(ret, v, ('!_EQ_', ('CALC_CONST', '?'), \
                                                ('!PyObject_Type', '?'))):
            nm, old = v
            built = False       
    elif ret0 == '!PyObject_RichCompare(':
        if TCmp(ret, v, ('!PyObject_RichCompare(', ('!LOAD_BUILTIN', '?'),  \
                    ('!PyObject_Type', '?'), 'Py_EQ')): 
            nm, old = v   
            built = True
        elif TCmp(ret, v, ('!PyObject_RichCompare(', ('!PyObject_Type', '?'), \
                            ('!LOAD_BUILTIN', '?'), 'Py_EQ')): 
            old, nm = v     
            built = True
    elif ret0 == '!BINARY_SUBSCR_Int' and added_pass_subscr:  
        if TCmp(ret,v, ('!BINARY_SUBSCR_Int', 
                        ('PY_TYPE', '?', '?', ('FAST', '?'), None), 
                        ('CONST', '?'))) and IsTuple(ret[1][1:3]) and type(v[3]) is int:
            var = ('FAST', v[2])
            if v[3] >= 0 and v[0] is tuple:
                if var not in d:
                    l0 = v[1]
                    if type(l0) is tuple:
                        l0 = len(l0)
                    if l0 > (v[3]+1):
                        nl = l0
                    else:
                        nl = v[3]+1
                    d[var] = curnewdef = (tuple, nl)
                else:
                    assert IsTuple(d[var])
                    if d[var][1] is None and v[1] is None:
                        d[var] = curnewdef = (tuple, v[3]+1)
                        return ('!BINARY_SUBSCR_Int', ('PY_TYPE', tuple, None, type_in_if(var, d, True), None), ('CONST', v[3]))
                    elif type(d[var][1]) is int and d[var][1] == v[1] and v[1] < v[3]+1:
                        d[var] = curnewdef = (tuple, v[3]+1)
                        return ('!BINARY_SUBSCR_Int', ('PY_TYPE', tuple, v[1], type_in_if(var, d, True), None), ('CONST', v[3]))

                    elif d[var][1] is None:
                        d[var] = curnewdef = (tuple, v[3]+1)
                    elif (type(d[var][1]) is int and d[var][1] <= v[3]+1):
                        d[var] = curnewdef = (tuple, v[3]+1)
                    elif (type(d[var][1]) is tuple and len(d[var][1]) <= v[3]+1):
                        tu = d[var][1]
                        while len(tu) <= v[3]+1:
                            tu += (None,)
                        d[var] = curnewdef = (tuple, tu)
                    elif type(d[var][1]) is int  and d[var][1] > v[3]+1:
                        return ('!BINARY_SUBSCR_Int', ('PY_TYPE', tuple, d[var][1], var, None), ('CONST', v[3]))
                    elif type(d[var][1]) is tuple  and len(d[var][1]) > v[3]+1:
                        return ('!BINARY_SUBSCR_Int', ('PY_TYPE', tuple, d[var][1], var, None), ('CONST', v[3]))
                    else:
                        pprint(ret)
                        pprint(v)
                        pp('---', d[var])
                        assert False
        del v[:]
        if TCmp(ret,v, ('!BINARY_SUBSCR_Int', 
                        ('FAST', '?'),
                        ('CONST', '?'))) and ('FAST', v[0]) in d and IsTuple(d[('FAST', v[0])]) and type(v[1]) is int:
            var = ('FAST', v[0])
            if v[1] >= 0:
                if var not in d:
                    d[var] = curnewdef = (tuple, v[1]+1)
                else:
                    old_type = d[var][1]
                    assert IsTuple(d[var])
                    assert old_type is None or type(old_type) is int
                    if old_type is None:
                        d[var] = (tuple, v[1]+1)
                        return ('!BINARY_SUBSCR_Int', ('PY_TYPE', tuple, None, var, None), ('CONST', v[1]))
                    if old_type <= v[1]+1:
                        d[var] = (tuple, v[1]+1)
                        return ('!BINARY_SUBSCR_Int', ('PY_TYPE', tuple, old_type, var, None), ('CONST', v[1]))
                    elif  old_type > v[1]+1:
                        return ('!BINARY_SUBSCR_Int', ('PY_TYPE', tuple, old_type, var, None), ('CONST', v[1]))
                    else:
                        pprint(ret)
                        pprint(v)
                        pp('---', d[var])
            del v[:]

    elif ret0.startswith('!c_Py_GE_Int'):
        if TCmp(ret,v, ('!c_Py_GE_Int', 
                        ('PY_TYPE', '?', '?', ('FAST', '?'), None), 
                        ('CONST', '?'))) and IsInt(tuple(ret[1][1:3])) and type(v[3]) is int:
            if v[3] >= v[1][0] and v[3] <= v[1][1]:
                SetRangeIntVar2(d, intersect_int(ret[1][1:3], Int(v[3], MInt)), ('FAST', v[2]))
                return ret
            if v[3] > v[1][1]:
                return ('CONST', False)
            if v[3] <= v[1][0]:
                return ('CONST', True)
            assert False
        del v[:]
        if TCmp(ret,v, ('!c_Py_GE_Int', 
                        ('FAST', '?'),
                        ('CONST', '?'))) and ('FAST', v[0]) in d and IsInt(d[('FAST', v[0])]) and type(v[1]) is int:
            SetRangeIntVar2(d, intersect_int(d[('FAST', v[0])], Int(v[1], MInt)), ('FAST', v[0]))

            return ('!c_Py_GE_Int', 
                        ('PY_TYPE', int, d[('FAST', v[0])][1], ('FAST', v[0]), None),
                        ('CONST', v[1]))
        del v[:]
    elif ret0.startswith('!c_Py_GT_Int'):
        if TCmp(ret,v, ('!c_Py_GT_Int', 
                        ('PY_TYPE', '?', '?', ('FAST', '?'), None), 
                        ('CONST', '?'))) and IsInt(ret[1][1:3]) and type(v[3]) is int:
            if v[3] >= v[1][0] and v[3] < v[1][1]:
                SetRangeIntVar2(d, intersect_int(ret[1][1:3], Int(v[3]+1, MInt)), ('FAST', v[2]))
                return ret
            if v[3] >= v[1][1]:
                return ('CONST', False)
            if v[3] < v[1][0]:
                return ('CONST', True)
            assert False
        del v[:]
        if TCmp(ret,v, ('!c_Py_GT_Int', 
                        ('FAST', '?'),
                        ('CONST', '?'))) and ('FAST', v[0]) in d and IsInt(d[('FAST', v[0])]) and type(v[1]) is int:
            SetRangeIntVar(d, d[('FAST', v[0])][1], v[0], v[1]+1, 0, 1)
            return ('!c_Py_GT_Int', 
                        ('PY_TYPE', int, d[('FAST', v[0])][1], ('FAST', v[0]), None),
                        ('CONST', v[1]))     
    elif ret0.startswith('!c_Py_LE_Int'):
        if TCmp(ret,v, ('!c_Py_LE_Int', 
                        ('PY_TYPE', '?', '?', ('FAST', '?'), None), 
                        ('CONST', '?'))) and IsInt(ret[1][1:3]) and type(v[3]) is int:
            if v[3] >= v[1][0] and v[3] <= v[1][1]:
                SetRangeIntVar2(d, intersect_int(ret[1][1:3], Int(-MInt-1, v[3])), ('FAST', v[2]))                
                return ret
            if v[3] >= v[1][1]:
                return ('CONST', True)
            if v[3] < v[1][0]:
                return ('CONST', False)
            assert False            
        del v[:]
        if TCmp(ret,v, ('!c_Py_LE_Int', 
                        ('FAST', '?'),
                        ('CONST', '?'))) and ('FAST', v[0]) in d and IsInt(d[('FAST', v[0])]) and type(v[1]) is int:                        
            SetRangeIntVar(d, d[('FAST', v[0])][1], v[0], v[1], 1, 0)
            return ('!c_Py_LE_Int', 
                        ('PY_TYPE', int, d[('FAST', v[0])][1], ('FAST', v[0]), None),
                        ('CONST', v[1]))     
    elif ret0.startswith('!c_Py_LT_Int'):
        if TCmp(ret,v, ('!c_Py_LT_Int', 
                        ('PY_TYPE', '?', '?', ('FAST', '?'), None), 
                        ('CONST', '?'))) and IsInt(ret[1][1:3]) and type(v[3]) is int:
            if v[3] > v[1][0] and v[3] <= v[1][1]:
                SetRangeIntVar2(d, intersect_int(ret[1][1:3], Int(-MInt-1, v[3]-1)), ('FAST', v[2]))  
                return ret
            if v[3] > v[1][1]:
                return ('CONST', True)
            if v[3] <= v[1][0]:
                return ('CONST', False)
            assert False            
                
        del v[:]
        if TCmp(ret,v, ('!c_Py_LT_Int', 
                        ('FAST', '?'),
                        ('CONST', '?'))) and ('FAST', v[0]) in d and IsInt(d[('FAST', v[0])]) and type(v[1]) is int:
            SetRangeIntVar(d, d[('FAST', v[0])][1], v[0], v[1]-1, 1, 0)
            return ('!c_Py_LT_Int', 
                        ('PY_TYPE', int, d[('FAST', v[0])][1], ('FAST', v[0]), None),
                        ('CONST', v[1]))         

    elif ret0.startswith('!SSIZE_T'):
        if TCmp(ret, v, ('!SSIZE_T>', ('!PyObject_Size', ('PY_TYPE', '?', None, ('FAST', '?'), None)), '?')):
            var = ('FAST', v[1])
            if type(v[2]) is int and v[2] >= 0 and v[0] is tuple:
                if var not in d:
                    d[var] = (tuple, v[2]+1)
                else:
                    assert IsTuple(d[var])
                    if d[var][1] is None or d[var][1] <= v[2]+1:
                        d[var] = (tuple, v[2]+1)
                    else:
                        pprint(ret)
                        pprint(v)
                        pp('---', d[var])
                return ret   
            del v[:]
        
        elif TCmp(ret, v, ('!SSIZE_T>', ('!PyObject_Size', '?'), '?')):
            if type(v[1]) is int and v[1] >= 0 and v[0] in d and IsTuple(d[v[0]]) and v[0][0] == 'FAST':
                ret = apply_typ(ret, d)
                if d[v[0]][1] is None:
                    d[v[0]] = (tuple, v[1]+1)
                return ret
            del v[:]
        elif TCmp(ret, v, ('!SSIZE_T==', ('!PyObject_Size', ('PY_TYPE', '?', None, ('FAST', '?'), None)), '?')):
            var = ('FAST', v[1])
            if type(v[2]) is int and v[2] >= 0 and v[0] is tuple:
                if var not in d:
                    d[var] = (tuple, v[2])
                else:
                    assert IsTuple(d[var])
                    if d[var][1] is None or d[var][1] <= v[2]:
                        d[var] = (tuple, v[2])
                    else:
                        pprint(ret)
                        pprint(v)
                        pp('---', d[var])
                return ret   
            del v[:]
        elif TCmp(ret, v, ('!SSIZE_T>=', ('!PyObject_Size', ('PY_TYPE', '?', None, ('FAST', '?'), None)), '?')):
            var = ('FAST', v[1])
            if type(v[2]) is int and v[2] >= 0 and v[0] is tuple:
                if var not in d:
                    d[var] = (tuple, v[2])
                else:
                    assert IsTuple(d[var])
                    if d[var][1] is None or d[var][1] <= v[2]:
                        d[var] = (tuple, v[2])
                    else:
                        pprint(ret)
                        pprint(v)
                        pp('---', d[var])
                return ret   
            del v[:]
            
        elif TCmp(ret, v, ('!SSIZE_T==', ('!PyObject_Size', '?'), '?')):
            if type(v[1]) is int and v[1] >= 0 and v[0] in d and IsTuple(d[v[0]]) and v[0][0] == 'FAST':
                ret = apply_typ(ret, d)
                if d[v[0]][1] is None:
                    d[v[0]] = (tuple, v[1])
                return ret    
            del v[:]
        elif TCmp(ret, v, ('!SSIZE_T>=', ('!PyObject_Size', '?'), '?')):
            if type(v[1]) is int and v[1] >= 0 and v[0] in d and IsTuple(d[v[0]]) and v[0][0] == 'FAST':
                ret = apply_typ(ret, d)
                if d[v[0]][1] is None:
                    d[v[0]] = (tuple, v[1])
                return ret    
            del v[:]

                 
    if added_pass_subscr and nm is None:
        darg = untyped(ret)
        if ret0 == 'PY_TYPE':
            if not (ret[3][0] != 'Py_TYPE'):
                pprint(ret)
            assert ret[3][0] != 'Py_TYPE'
            if darg not in d:
                curnewdef = ret[1:3]
                d[darg] = curnewdef
            elif d[darg] == ret[1:3]:
                curnewdef = ret[1:3]
            elif d[darg][0] is tuple and ret[1] is tuple and d[darg][1] is None and ret[2] is not None:
                curnewdef = ret[1:3]
                d[darg] = curnewdef
        if darg in d:
            if not prevtype and curnewdef is None and ret0 != 'PY_TYPE':
                return ('PY_TYPE', d[darg][0], d[darg][1], ret, None)
            elif ret0 == 'PY_TYPE' and curnewdef is None and not prevtype:
                return ('PY_TYPE', d[darg][0], d[darg][1], type_in_if(ret[3], d, True), None)
##                return ('PY_TYPE', ret[1], ret[2], type_in_if(ret[3], d, True), None)
            
        if ret0 == 'PY_TYPE' and darg in d:
            if ret[1:3] == d[darg]:
                return (ret0, ret[1], ret[2], type_in_if(ret[3], d, True), ret[4])
            else:
                t1, t2 = ret[1:3], d[darg]
                if t1[0] is tuple and t2[0] is tuple:
                    if type(t1[1]) is int and type(t2[1]) is int:
                        return (ret0, ret[1], max(t1[1], t2[1]), type_in_if(ret[3], d, True), ret[4])
                    elif t1[1] is None and type(t2[1]) is int:
                        return (ret0, ret[1], t2[1], type_in_if(ret[3], d, True), ret[4])                        
                    elif t2[1] is None and type(t1[1]) is int:
                        return (ret0, ret[1], t1[1], type_in_if(ret[3], d, True), ret[4])   
                    elif type(t1[1]) is tuple and type(t2[1]) is int and len(t1[1]) >= t2[1]:
                        d[darg] = t1
                        return ret
                ##pp('///', ret[1:3], d[darg])
        if ret0 == 'PY_TYPE':
            pp('jjj', ret)
        if ret0 not in ('FAST', 'CALC_CONST', '!LOAD_GLOBAL', '!LOAD_NAME', '!LOAD_DEREF'):
            if ret0 == '!PyNumber_Power' and ret[3] == 'Py_None':
                return (ret0, type_in_if(apply_typ(ret[1], d), d), type_in_if(apply_typ(ret[2], d), d), ret[3])                
            if ret0 in ('!PyObject_GetAttr3', '!_PyDict_Get'):
                return (ret0, type_in_if(apply_typ(ret[1], d), d), type_in_if(apply_typ(ret[2], d), d), type_in_if(apply_typ(ret[3], d), d))                
            if ret0 == '!PyList_GetSlice':
                return (ret0, type_in_if(apply_typ(ret[1], d), d), ret[2], ret[3])                
            if ret0 in ('!PySequence_Contains(', '!_EQ_', '!_NEQ_', '!PyNumber_Subtract', '!PyDict_Contains', \
                        '!PyNumber_Add', '!PySet_Contains', '!BINARY_SUBSCR_Int', \
                        '!from_ceval_BINARY_SUBSCR', '!PyNumber_Rshift', '!PyObject_HasAttr', '!PyNumber_And', '!PyNumber_Multiply', \
                        '!PyObject_GetAttr', '!_PyObject_GetAttrRaw', '!PyNumber_Remainder', '!PyObject_IsInstance', '!_PyString_StartSwith', \
                        '!_PyString_EndSwith', '!_PyString_Join', '!PyString_Format', '!PyNumber_Lshift', \
                        '!PyNumber_Rshift', '!PyNumber_Divide', '!PyNumber_Xor', '!PyNumber_Or', '!PyNumber_And', \
                        '!PyNumber_FloorDivide', '!PyObject_IsSubclass', '!_PyString_Find', \
                        '!PySequence_Repeat', '!_PyString_Index'):
                return (ret0, type_in_if(apply_typ(ret[1], d), d), type_in_if(apply_typ(ret[2], d), d))
            if ret0 == '!COND_METH_EXPR':
                meths = []
                for x,y in ret[3]:
                    meths.append((x, type_in_if(apply_typ(y, dict(d)), dict(d))))
                return (ret0, apply_typ(ret[1], d), type_in_if(apply_typ(ret[2], d), d), tuple(meths))
            if ret0 == '!MK_CLOSURE' and len(ret) == 4:
                return (ret0, ret[1], apply_typ(ret[2], d), apply_typ(ret[3], d))
            if ret0 == '!1NOT':
                return (ret0, apply_typ(ret[1], d))
            if ret0 == '!@PyInt_FromSsize_t':
                return (ret0, ret[1], apply_typ(ret[2], d))
            if ret0 in ('!PyObject_Type', '!PY_SSIZE_T', '!PyNumber_Int', '!PyObject_Repr',\
                        '!PyObject_Str', '!PyNumber_Absolute', '!PyObject_Size', '!PyList_GET_SIZE',
                        '!PyString_GET_SIZE', '!PySequence_Tuple', '!PyList_AsTuple', '!PyNumber_Negative',
                        '!PyInt_Type.tp_str', '!CHR_BUILTIN', '!PySequence_List', '!PySet_Size', '!PySet_New',
                        '!PyLong_FromVoidPtr', '!PyNumber_Long', '!GET_ITER', 
                        '!PyNumber_Invert', '!PyNumber_Float', '!PyObject_GetIter', '!PyDict_Keys', 
                        '!PyDict_Values', '!PyObject_Dir', '!_PyList_Pop', '!PyObject_Hash', '!PyDict_Size'):
                return (ret0, type_in_if(apply_typ(ret[1], d), d))
            if ret0 in ('!c_Py_EQ_String', '!c_Py_NE_String', '!c_Py_GE_Int','!c_Py_GT_Int',\
                        '!c_Py_LE_Int','!c_Py_LT_Int','!c_Py_EQ_Int', '!SSIZE_T!=', '!SSIZE_T==',\
                        '!SSIZE_T>=', '!SSIZE_T>', '!SSIZE_T<', '!SSIZE_T<=', '!c_Py_NE_Int'):
                return (ret0, type_in_if(apply_typ(ret[1], d), d), ret[2])
            if len(ret) == 4 and ret0 in ('!PyInt_Type.tp_new', '!PyFloat_Type.tp_new', '!PyLong_Type.tp_new', '!PyUnicode_Type.tp_new'):
                return (ret0, ret[1], type_in_if(apply_typ(ret[2], d), d), ret[3])
            if ret0 in ('!PyObject_RichCompare(', '!PyObject_Call'):
                return (ret0, type_in_if(apply_typ(ret[1], d), d), type_in_if(apply_typ(ret[2], d), d), ret[3])
            if ret0 == '!COND_EXPR':
                return (ret0, type_in_if(apply_typ(ret[1], d), d), type_in_if(apply_typ(ret[2], d), dict(d)), type_in_if(apply_typ(ret[3], d), dict(d)))
            if ret0 == '!PySequence_GetSlice':
                return (ret0, type_in_if(apply_typ(ret[1], d), d), type_in_if(apply_typ(ret[2], d), d) if type(ret[2]) is tuple else ret[2], type_in_if(ret[3], d) if type(ret[3]) is tuple else ret[3])
            if ret0 in ('!LOAD_BUILTIN', 'CONST'):
                return ret
            if ret0 in ('!MK_FUNK', '!CLASS_CALC_CONST_NEW', '!CLASS_CALC_CONST') and len(ret) == 3:
                return (ret0, ret[1], type_in_if(apply_typ(ret[2], d), d))
            if ret0 == '!STR_CONCAT' or ret0 == '!_PyString_Count':
                return (ret0,) + tuple([type_in_if(apply_typ(x, d), d) for x in ret[1:]])
            if ret0 == '!_PyEval_ApplySlice':
                return (ret0,) + tuple([type_in_if(apply_typ(x, d), d) if type(x) is tuple else x for x in ret[1:]])
            if ret0 == '!CALL_CALC_CONST' or ret0 == '!CALL_CALC_CONST_INDIRECT':
                return (ret0, ret[1], type_in_if(apply_typ(ret[2], d), d))
            if ret0 == '!PyTuple_GetSlice':
                return (ret0, type_in_if(apply_typ(ret[1], d), d), ret[2], ret[3])
            if ret0 == '!PyBool_Type.tp_new':
                return (ret0, ret[1], type_in_if(apply_typ(ret[2], d), d))
            if ret0 in ('!BUILD_TUPLE', '!BUILD_LIST', '!BUILD_SET'):
                return (ret0, tuple([type_in_if(apply_typ(x, d), d) for x in ret[1]]))
            if ret0 in ('!BUILD_MAP'):
                return (ret0, tuple([(type_in_if(x, d), type_in_if(y, d)) for x, y in ret[1]]))
            if ret0 in ('!NCMP'):
                return (ret0, tuple([type_in_if(x, d) if type(x) is tuple else x for x in ret[1]]))            
            if ret0 == '!_PyString_ctype':
                return (ret0, type_in_if(ret[1], d), ret[2])
            if ret0 == '!LIST_COMPR':
                if len(ret) == 3 and len(ret[2]) == 3 and ret[2][2] is not None and len(ret[2][2]) == 1:
                    ret = (ret0, ret[1], (ret[2][0], ret[2][1], (type_in_if(ret[2][2][0], {}),)))
                d.clear()
                return ret
            if ret0 == '!SET_COMPR':
                if len(ret) == 3 and len(ret[2]) == 3 and ret[2][2] is not None and len(ret[2][2]) == 1:
                    ret = (ret0, ret[1], (ret[2][0], ret[2][1], (type_in_if(ret[2][2][0], {}),)))
                d.clear()
                return ret
            if ret == ('!PyDict_New',):
                return ret
            if nm is None: #and 'BINARY_SUBSCR_Int' in repr(ret) :
                pp('++', ret0, ret)
    if nm in d_built and built:
        if old[0] == 'PY_TYPE' and d_built[nm] is old[1]:
            return ('CONST', True)
        if old[0] == 'PY_TYPE' and d_built[nm] is not old[1]:
            if old[1] == 'Sequence' and IsSequence((d_built[nm], None)):
                old = old[3]
            elif old[1] == 'IntOrLong' and d_built[nm] is int:
                old = old[3]
            elif old[1] == 'MayBe' and (d_built[nm], None) == old[2]:
                old = old[3]
            else:
                pp('//klo??')
                pp(old)
                pp(nm)
                pp(g_co.co_name)
                pp(ret)
                return ('CONST', False)
        assert old[0] != 'PY_TYPE'              
        ret = apply_typ(ret, d)
        if old not in d:
            if d_built[nm] is int:
                d[old] = Kl_Int
                d[untyped(old)] = Kl_Int
            else:
                d[old] = (d_built[nm], None)
                d[untyped(old)] = (d_built[nm], None)
        elif d[old] != (d_built[nm], None):
            pp('hfjfjhgjhg ???')
            pp(d[old])
            pp(old)
            pp(nm)
            pp(d)
            d[old] = None
        return ret
    elif nm not in d_built and built and type(nm) is tuple and len(nm) == 2:
        if old[0] == 'PY_TYPE' and nm[0] is old[1]:
            return ('CONST', True)
        if old[0] == 'PY_TYPE' and nm[0] is not old[1]:
            if old[1] == 'Sequence' and IsSequence((nm[0], None)):
                old = old[3]
            elif old[1] == 'IntOrLong' and nm[0] is int:
                old = old[3]
            elif old[1] == 'MayBe' and (nm[0], None) == old[2]:
                old = old[3]
            else:
                pp('//klo')
                pp(old)
                pp(nm)
                pp(g_co.co_name)
                pp(ret)
                return ('CONST', False)
        assert old[0] != 'PY_TYPE'              
        ret = apply_typ(ret, d)
        if old not in d:
            if nm[0] is int:
                d[old] = Kl_Int
                d[untyped(old)] = Kl_Int
            else:
                d[old] = (nm[0], None)
                d[untyped(old)] = (nm[0], None)
        elif d[old] != (nm[0], None):
            pp('hfjfjhgjhg ???')
            pp(d[old])
            pp(old)
            pp(nm)
            pp(d)
            d[old] = None
        return ret
    elif old is not None:
        isoldclass = IsOldClass(nm)
        isnewclass = IsNewClass(nm) 
        if old[0] == 'PY_TYPE':
            if built or old[1] != type:
                if (isoldclass or isnewclass) and IsAnyClass(old[2]):
                    if old[2] != nm:
                        return ('CONST', False)                    
                    if old[2] == nm:
                        return ('CONST', True) 
                

                if type(old[2]) is str and old[2] != nm:
                    pp(old)
                    pp(nm)
                    pp(ret)
                    pp(d)
                    pp(g_co.c_name)
                    assert old[2] == nm
        if old[0] == 'PY_TYPE':
            old = old[3]
        if isoldclass:  
            ret = apply_typ(ret, d)
            d[old] = (T_OLD_CL_INST, nm)
            for k in d.iterkeys():
                assert k[0] != 'PY_TYPE'              
                
            return ret
        elif isnewclass:  
            ret = apply_typ(ret, d)
            d[old] = (T_NEW_CL_INST, nm)
            for k in d.iterkeys():
                assert k[0] != 'PY_TYPE'              
                
            return ret  
                      
        ret = apply_typ(ret, d)
    if not prevtype or not added_pass_subscr:   
        return apply_typ(ret, d)
    return ret
        
def untyped(v):
    assert type(v) is tuple 
    if len(v) == 0:
        return v
    if v[0] == 'CONST':
        return v
    if v[0] == '!PyObject_GetAttr':
        if v[1][0] == 'PY_TYPE':
            return (v[0], ('PY_TYPE', v[1][1], v[1][2], untyped(v[1][3]), v[1][4]), untyped(v[2]))
        return (v[0], untyped(v[1]), untyped(v[2]))
    if v[0] == 'PY_TYPE':
        return untyped(v[3])
    return tuple([untyped(x) if type(x) is tuple else x for x in v])
        
def only_fast(d):
    d2 = []
    for k1,v in d.items():
        k = k1
        if k[0] == 'FAST':
            d2.append((k1,k,v))
            continue
        if added_pass_subscr:
            if k[0] == '!BINARY_SUBSCR_Int':
                if IsTuple(TypeExpr(k[1])):
                    k = k[1]
                else:
                    continue
            elif k[0] == 'PY_TYPE':
                if k[1] is tuple:
                    k = k[3]
                else:
                    continue
            elif k[0] == 'FAST':
                d2.append((k1,k,v))
                continue
            else:
                continue
            if k[0] == '!BINARY_SUBSCR_Int':
                if IsTuple(TypeExpr(k[1])):
                    k = k[1]
                else:
                    continue
            elif k[0] == 'PY_TYPE':
                if k[1] is tuple:
                    k = k[3]
                else:
                    continue
            elif k[0] == 'FAST':
                d2.append((k1,k,v))
                continue
            else:
                continue
            if k[0] == '!BINARY_SUBSCR_Int':
                if IsTuple(TypeExpr(k[1])):
                    k = k[1]
                else:
                    continue
            elif k[0] == 'PY_TYPE':
                if k[1] is tuple:
                    k = k[3]
                else:
                    continue
            elif k[0] == 'FAST':
                d2.append((k1,k,v))
                continue
            else:
                continue
            if k[0] == '!BINARY_SUBSCR_Int':
                if IsTuple(TypeExpr(k[1])):
                    k = k[1]
                else:
                    continue
            elif k[0] == 'PY_TYPE':
                if k[1] is tuple:
                    k = k[3]
                else:
                    continue
            elif k[0] == 'FAST':
                d2.append((k1,k,v))
            else:
                continue
    return d2
             
def list_typed_var_after_stmt(v, nmdef):             
    if type(v) is tuple and v[0] == 'STORE' and len(v[1]) == 1 and v[1][0][0] in ('STORE_FAST', 'STORE_NAME') and \
        len(v[2]) == 1:
        t = TypeExpr(v[2][0])
        if IsKlNone(t) and v[1][0][0] == 'STORE_NAME' and nmdef == 'Init_filename':
            return []
        elif t is None:
            return []
        stor = v[1][0]
        dele = v[1][0]
        dele = ('DELETE_' + dele[0][6:], dele[1])
        nm1 = v[1][0][1]
        if v[1][0][0] == 'STORE_FAST':
            nm2 = ('FAST', nm1)
        else:      
            nm2 = ('!LOAD_NAME', nm1)
        old = nm2
        if IsList(t):
            t = Kl_List
        assert nm2[0] != 'PY_TYPE'    
        new = ('PY_TYPE', t[0], t[1], nm2, None)             
        if (t in _Kl_Simples or IsInt(t)) and v[2][0][0] == 'CONST':
            new = v[2][0]
        if v[2][0][0] == '!CLASS_CALC_CONST':  
            assert v[2][0][1][0] != 'PY_TYPE'  
            new = ('PY_TYPE', t[0], v[2][0][1], nm2, None)
        elif v[2][0][0] == '!CLASS_CALC_CONST_NEW':    
            assert v[2][0][1][0] != 'PY_TYPE'  
            new = ('PY_TYPE', t[0], v[2][0][1], nm2, None)
        v2 = []    
        if TCmp(v[2][0], v2, ('!MK_FUNK', '?', ('CONST', ()))):
            new = v[2][0]

        return [(old, new, stor, dele)]    
    if type(v) is tuple and v[0] == 'STORE' and len(v[1]) == 1 and v[1][0][0] == 'SET_VARS' and len(v[2]) == 1:
        t = TypeExpr(v[2][0])
        if not IsTuple(t):
            return []
        if type(t[1]) is tuple and len(t[1]) == len(v[1][0][1]):
            t_prev = t
            lis = []
            for i,t  in enumerate(t_prev[1]):
                assign = v[1][0][1][i]
                if IsKlNone(t) and assign[0] == 'STORE_NAME' and nmdef == 'Init_filename':
                    continue
                if t is None:
                    continue
                if IsList(t):
                    t = Kl_List
                if assign[0] not in ('STORE_FAST', 'STORE_NAME'):
                    continue
                stor = assign
                dele = assign[:]
                dele = ('DELETE_' + dele[0][6:], dele[1])
                nm1 = assign[1]  
                if stor[0] == 'STORE_FAST':
                    nm2 = ('FAST', nm1)
                else:      
                    nm2 = ('!LOAD_NAME', nm1)
                old = nm2
                assert nm2[0] != 'PY_TYPE'  
                new = ('PY_TYPE', t[0], t[1], nm2, None)             
                lis.append((old, new, stor, dele))
            return lis   
    if type(v) is tuple and v[0] == 'SET_EXPRS_TO_VARS' and len(v[1]) == len(v[2]):
        _v = v
        lis = []
        for i in range(len(_v[1])):
            t = TypeExpr(v[2][i])
            if IsKlNone(t) and v[1][i][0] == 'STORE_NAME' and nmdef == 'Init_filename':
                return []
            elif t is None:
                return []
            if v[1][i][0] != 'STORE_FAST':
                continue
            stor = v[1][i]
            dele = v[1][i]
            dele = ('DELETE_' + dele[0][6:], dele[1])
            nm1 = v[1][i][1]
            nm2 = ('FAST', nm1)
            old = nm2
            if IsList(t):
                t = Kl_List
            assert nm2[0] != 'PY_TYPE'    
            new = ('PY_TYPE', t[0], t[1], nm2, None)             
            if (t in _Kl_Simples or IsInt(t)) and v[2][i][0] == 'CONST':
                new = v[2][i]
            if v[2][i][0] == '!CLASS_CALC_CONST':  
                assert v[2][i][1][0] != 'PY_TYPE'  
                new = ('PY_TYPE', t[0], v[2][i][1], nm2, None)
            elif v[2][i][0] == '!CLASS_CALC_CONST_NEW':    
                assert v[2][i][1][0] != 'PY_TYPE'  
                new = ('PY_TYPE', t[0], v[2][i][1], nm2, None)
            v2 = []    
            if TCmp(v[2][i], v2, ('!MK_FUNK', '?', ('CONST', ()))):
                new = v[2][i]
    
            lis.append((old, new, stor, dele))
        return lis
    return []
 
def recursive_type_detect(ret, nmdef):
    if type(ret) != list:
        return ret
    ret = ret[:]
    i = 0
    while i < len(ret):
        assert type(i) is int and i >= 0 and i <= (MInt / 10)
        v = ret[i]
        if type(v) is tuple and v[0] == '(FOR' and len(v[1]) == 1 and v[1][0][0] in ('STORE_FAST', 'STORE_NAME'):
            t = TypeExpr(v[2])
            if t == Kl_File or IsStr(t):
                assign = v[1][0] 
                stor = assign
                dele = assign[:]
                dele = ('DELETE_' + dele[0][6:], dele[1])
                nm1 = assign[1]  
                if stor[0] == 'STORE_FAST':
                    nm2 = ('FAST', nm1)
                else:      
                    nm2 = ('!LOAD_NAME', nm1)
                old = nm2
                assert nm2[0] != 'PY_TYPE'  
                if IsStr(t):
                    new = ('PY_TYPE', str, 1, nm2, None)   
                else:    
                    new = ('PY_TYPE', str, None, nm2, None)   
                j = i + 1          
                s_repr = ret[j]
                if IsChar(TypeExpr(new)) and IsChar(TypeExpr(old)):
                    pass
                elif not expr_in_expr(stor, s_repr) and not expr_in_expr(dele, s_repr):
                    ret[j] = replace_subexpr(ret[j], old, new)
                    i = i + 1
                    continue 
        v2 = []
        if type(v) is tuple and len(v) > 0 and type(v[0]) is str and v[0] == '(FOR':
            if len(v[1]) == 2 and len(v[1][0]) == 2 and v[1][0][0] == 'STORE_FAST' and 'enumerate' in repr(v[2]):
                v2 = [v[1][0][1]]
                v3 = []
                if TCmp(v[2], v3, \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'enumerate'), '?', \
                                ('NULL',))) :
                    stor = ('STORE_FAST', v2[0])
                    dele = ('DELETE_FAST', v2[0])
                    old = ('FAST', v2[0])
                    new = ('PY_TYPE', int, (0, MInt), old, None)   
                    j = i + 1          
                    s_repr = ret[j]
                    if not IsCardinal(TypeExpr(old)) and not expr_in_expr(stor, s_repr) and not expr_in_expr(dele, s_repr):
                        ret[j] = replace_subexpr(ret[j], old, new)
                        i = i + 1
                        continue 
        
                v2 = []
            
            if len(v[1]) == 1 and len(v[1][0]) == 2 and v[1][0][0] == 'STORE_FAST' and 'range' in repr(v[2]):

                v2 = [v[1][0][1]]
                v3 = []
                if TCmp(v[2], v3, \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), ('CONST', (int,)), \
                                ('NULL',))) or \
                TCmp(v[2], v3, \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('CONST', (int,)), \
                                ('NULL',))):
                    stor = ('STORE_FAST', v2[0])
                    dele = ('DELETE_FAST', v2[0])
                    old = ('FAST', v2[0])
                    if type(v3[0]) is int and v3[0] >= 0:
                        new = ('PY_TYPE', int, (0, v3[0]-1), old, None)  
                    else:
                        new = ('PY_TYPE', int, Kl_Int[1], old, None)   
                    j = i + 1          
                    s_repr = ret[j]
                    if not expr_in_expr(stor, s_repr) and not expr_in_expr(dele, s_repr):
                        ret[j] = replace_subexpr(ret[j], old, new)
                        i = i + 1
                        continue 
                    
                v2 = [v[1][0][1]]
                v3 = []
                if TCmp(v[2], v3, \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), ('CONST', (int, int)), \
                                ('NULL',))) or \
                TCmp(v[2], v3, \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('CONST', (int, int)), \
                                ('NULL',))):
                    stor = ('STORE_FAST', v2[0])
                    dele = ('DELETE_FAST', v2[0])
                    old = ('FAST', v2[0])
                    if type(v3[0]) is int and v3[0] >= 0 and type(v3[1]) is int and v3[1] >= 0:
                        new = ('PY_TYPE', int, (v3[0], v3[1]-1), old, None)  
                    else:
                        new = ('PY_TYPE', int, Kl_Int[1], old, None)   
                    j = i + 1          
                    s_repr = ret[j]
                    if not expr_in_expr(stor, s_repr) and not expr_in_expr(dele, s_repr):
                        ret[j] = replace_subexpr(ret[j], old, new)
                        i = i + 1
                        continue 

        
                v2 = []
                if ( TCmp(v, v2, ('(FOR', (('STORE_FAST', '?'),), \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), ('!BUILD_TUPLE', ('?',)), \
                                ('NULL',)))) or \
                    TCmp(v, v2, ('(FOR', (('STORE_FAST', '?'),), \
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('!BUILD_TUPLE', ('?',)), \
                                ('NULL',))))) and IsInt(TypeExpr(v2[1])):
                    stor = ('STORE_FAST', v2[0])
                    dele = ('DELETE_FAST', v2[0])
                    old = ('FAST', v2[0])
                    new = ('PY_TYPE', int, (0, MInt), old, None)   
                    j = i + 1 
                    s_repr = ret[j]         
                    if not IsCardinal(TypeExpr(old)) and not expr_in_expr(stor, s_repr) and not expr_in_expr(dele, s_repr):
                        ret[j] = replace_subexpr(ret[j], old, new)
                        i = i + 1
                        continue 
        if type(v) is tuple and v[0] == '(IF' and ret[i+2] == (')ENDIF',):
            cond = v[1]
            if cond[0] == '!1NOT' and cond[1][0] == '!BOOLEAN' and cond[1][1][0] == '!_EQ_':
                cond = ('!_NEQ_', cond[1][1][1], cond[1][1][2])
            if cond[0] == '!1NOT' and cond[1][0] == '!_EQ_':
                cond = ('!_NEQ_', cond[1][1], cond[1][2])
            if (len(ret[i+1]) == 1 or (len(ret[i+1]) == 2 and ret[i+1][0][0] == '.L')) and \
                    (ret[i+1][-1] in (('RAISE_VARARGS', 0, (('!LOAD_BUILTIN', 'AssertionError'),)), ('CONTINUE',), ('BREAK_LOOP',))  or \
                     ret[i+1][-1][0] in ('RETURN', 'RETURN_VALUE')):
                d = {}
                if  (cond[0] in ('!1NOT', '!_NEQ_') or 
                     (cond[0] == '!BOOLEAN' and cond[1][0] in ('!1NOT', '!_NEQ_') )):
                     
                    if cond[0] == '!1NOT':
                        ret[i] = ('(IF', ('!1NOT', type_in_if(cond[1], d)))
                    elif cond[0] == '!_NEQ_':
                        ret[i] = ('(IF', ('!1NOT', type_in_if(('!_EQ_', cond[1], cond[2]), d)))
                    else:
                        assert cond[0] == '!BOOLEAN'
                        if cond[1][0] == '!1NOT':
                            ret[i] = ('(IF', ('!1NOT', type_in_if(cond[1][1], d)))
                        elif cond[1][0] == '!_NEQ_':
                            ret[i] = ('(IF', ('!1NOT', type_in_if(('!_EQ_', cond[1][1], cond[1][2]), d)))    
                        else:
                            assert False
                    _d = only_fast(d)
                    prev = None
                    if i >= 1 and ret[i-1][0] == 'STORE':
                        prev = ret[i-1]
                    elif i >= 2 and ret[i-1][0] == '.L' and ret[i-2][0] == 'STORE':
                        prev = ret[i-2]
                    li = []
                    if prev is not None and len(prev[1]) == 1 and len(prev[2]) == 1 and prev[1][0][0] == 'STORE_FAST' and prev[2][0][0] == 'FAST':
                        fast1, fast2 = ('FAST', prev[1][0][1]), prev[2][0]
                    else:
                        fast1, fast2 = None, None
                    for k1, k2, v1 in _d:
                        if TypeExpr(('PY_TYPE', v1[0], v1[1], k1, None)) != TypeExpr(k1):
                            li.append((k1, ('PY_TYPE', v1[0], v1[1], k1, None), k2, ('STORE_FAST', k2[1]), ('DELETE_FAST', k2[1])))
                        if k1 == fast2 and k1 == k2:
                            k1, k2 = fast1, fast1
            
                            if TypeExpr(('PY_TYPE', v1[0], v1[1], k1, None)) != TypeExpr(k1):
                                li.append((k1, ('PY_TYPE', v1[0], v1[1], k1, None), k2, ('STORE_FAST', k2[1]), ('DELETE_FAST', k2[1])))
                        elif k1 == fast1 and k1 == k2:
                            k1, k2 = fast2, fast2
                            if TypeExpr(('PY_TYPE', v1[0], v1[1], k1, None)) != TypeExpr(k1):
                                li.append((k1, ('PY_TYPE', v1[0], v1[1], k1, None), k2, ('STORE_FAST', k2[1]), ('DELETE_FAST', k2[1])))
                    for old, new, dep, stor, dele in li:
                        replace_concretised_at_list_from_pos(ret, i+3, old, new, stor, dele) 
                    i += 3    
                    continue  
        if type(v) is tuple and v[0] == '(IF':
            d = {}
            ret[i] = ('(IF', type_in_if(v[1], d)) 
            _d = only_fast(d)
            li = []
            for k1, k2, v1 in _d:
                if v1 is not None and TypeExpr(('PY_TYPE', v1[0], v1[1], k1, None)) != TypeExpr(k1):
                    li.append((k1, ('PY_TYPE', v1[0], v1[1], k1, None), k2, ('STORE_FAST', k2[1]), ('DELETE_FAST', k2[1])))
 
            for old, new, dep, stor, dele in li:
                replace_concretised_at_list_from_pos(ret[i + 1], 0, old, new, stor, dele) 
            i += 1    
            continue      
        li = list_typed_var_after_stmt(v, nmdef) 
        for old, new, stor, dele in li:
            t1 = TypeExpr(old)
            t2 = TypeExpr(new)
            if t1 == t2:
                continue
            if new[0] == 'PY_TYPE' and IsStr(t2) and t1 == Kl_String and type(t2[1]) is str:
                new = ('CONST', t2[1])
            ## if new[0] != 'CONST' and t1 is not None and t2 is not None:

            if new[0] == '!MK_FUNK':
                if count_call_expr_in_expr(old, ret[i+1:]) != count_expr_in_expr(old, ret[i+1:]):
                    continue
            ## pp(old), new, TypeExpr(old), TypeExpr(new)
            ## TypeExpr(old) != TypeExpr(new)            
            replace_concretised_at_list_from_pos(ret, i + 1, old, new, stor, dele) 
        if type(ret[i]) is list:
            ret[i] = recursive_type_detect(ret[i], nmdef)    
        i += 1 

    return ret    

def replace_concretised_at_list_from_pos(ret, j, old, new, stor, dele):
    tnew = TypeExpr(new)
    assert type(j) is int and j >= 0

    while j < len(ret):
        assert type(j) is int and j >= 0
        if IsBeg(ret[j][0]):
            j1 = get_closed_pair(ret, j)
            if (new[0] == 'CONST' and type(new[1]) is int) : 
                v = []
                v2 = []
                if TCmp(ret[j], v, ('(WHILE', ('!BOOLEAN', \
                                             ('!c_Py_LT_Int', old, ('CONST', '?'))))):
                    if ( TCmp(ret[j+1][-1], v2, ('STORE', (stor,), \
                                       (('!PyNumber_Add', old, ('CONST', 1)),))) or \
                       TCmp(ret[j+1][-1], v2, ('STORE', (stor,), \
                                       (('!PyNumber_InPlaceAdd', old, ('CONST', 1)),))) ):
                        dic = {}
                        collect_store_and_delete_and_access(ret[j+1][:-1], dic)
                        if stor not in dic and dele not in dic and new[1] < v[0]:   
                            oold = ('PY_TYPE', int, _short_rng, old[:], None)
                            if IsShort(tnew) and IsShort(TypeExpr(('CONST', v[0]))):
                                ret[j] = replace_subexpr(ret[j], old, ('PY_TYPE', int, _short_rng, old[:], None))
                                ret[j+1][:-1] = replace_subexpr(ret[j+1][:-1], old, ('PY_TYPE', int, _short_rng, old[:], None))
                                ret[j+1][-1] = ('STORE', (stor[:],), \
                                            (('PY_TYPE', int, _short_rng, ('!PyNumber_Add', oold[:], ('CONST', 1)),None),))
                            else:    
                                ret[j] = replace_subexpr(ret[j], old, ('PY_TYPE', int, Kl_Int[1], old[:], None))              
                                ret[j+1][:-1] = replace_subexpr(ret[j+1][:-1], old, ('PY_TYPE', int, Kl_Int[1], old[:], None))
                                ret[j+1][-1] = ('STORE', (stor[:],), \
                                            (('PY_TYPE', int, Kl_Int[1], ('!PyNumber_Add', oold[:], ('CONST', 1)),None),))
                            ret[j+1:j+3] = [ret[j+1], ret[j+2], ('STORE', (stor[:],), (('CONST', v[0]),))]
                            continue
                    del v[:]    
                elif TCmp(ret[j], v, ('(WHILE', ('!BOOLEAN', \
                                             ('!c_Py_LE_Int', old, ('CONST', '?'))))):
                    if ( TCmp(ret[j+1][-1], v2, ('STORE', (stor,), \
                                       (('!PyNumber_Add', old, ('CONST', 1)),))) or \
                      TCmp(ret[j+1][-1], v2, ('STORE', (stor,), \
                                       (('!PyNumber_InPlaceAdd', old, ('CONST', 1)),))) ):
                        dic = {}
                        collect_store_and_delete_and_access(ret[j+1][:-1], dic)
                        if stor not in dic and dele not in dic and new[1] <= v[0]:   
                            oold = ('PY_TYPE', int, _short_rng, old[:], None)
                            if IsShort(tnew) and IsShort(TypeExpr(('CONST', v[0]))):
                                ret[j] = replace_subexpr(ret[j], old, ('PY_TYPE', int, _short_rng, old[:], None))
                                ret[j+1][:-1] = replace_subexpr(ret[j+1][:-1], old, ('PY_TYPE', int, _short_rng, old[:], None))
                                ret[j+1][-1] = ('STORE', (stor[:],), \
                                            (('PY_TYPE', int, _short_rng, ('!PyNumber_Add', oold[:], ('CONST', 1)),None),))
                            else:     
                                ret[j] = replace_subexpr(ret[j], old, ('PY_TYPE', int, Kl_Int[1], old[:], None))             
                                ret[j+1][:-1] = replace_subexpr(ret[j+1][:-1], old, ('PY_TYPE', int, Kl_Int[1], old[:], None))
                                ret[j+1][-1] = ('STORE', (stor[:],), \
                                            (('PY_TYPE', int, Kl_Int[1], ('!PyNumber_Add', oold[:], ('CONST', 1)),None),))
                            ret[j+1:j+3] = [ret[j+1], ret[j+2], ('STORE', (stor[:],), (('CONST', v[0] + 1),))]
                            continue
                    del v[:]
                elif ( TCmp(ret[j], v, \
                          ('(WHILE', ('!PyObject_RichCompare(', old, \
                                      '?', 'Py_LT'))) or\
                       TCmp(ret[j], v, \
                          ('(WHILE', ('!PyObject_RichCompare(', old, \
                                      '?', 'Py_LE'))) ):
                    if ( TCmp(ret[j+1][-1], v2, ('STORE', (stor,), \
                                       (('!PyNumber_Add', old, ('CONST', 1)),))) or\
                      TCmp(ret[j+1][-1], v2, ('STORE', (stor,), \
                                       (('!PyNumber_InPlaceAdd', old, ('CONST', 1)),))) ):
                        dic = {}
                        collect_store_and_delete_and_access(ret[j+1][:-1], dic)
                        if stor not in dic and dele not in dic and IsInt(TypeExpr(v[0])):
                            oold = ('PY_TYPE', int, _short_rng, old[:], None)
                            if IsShort(tnew):
                                subtype = _short_rng
                                if IsCardinal(tnew):
                                    subtype = (0, subtype[1])
                                    ('PY_TYPE', int, subtype, old[:], None)
                            else:
                                subtype = None                               
                            ret[j] = replace_subexpr(ret[j], old, ('PY_TYPE', int, subtype, old[:], None))                
                            ret[j+1][:-1] = replace_subexpr(ret[j+1][:-1], old, ('PY_TYPE', int, subtype, old[:], None))
                            ret[j+1][-1] = ('STORE', (stor[:],), \
                                        (('PY_TYPE', int, subtype, ('!PyNumber_Add', oold[:], ('CONST', 1)),None),))
                            continue   
                    del v[:]
            ret_j_j1 = ret[j:j1]
            dic = {}
            collect_store_and_delete_and_access(ret_j_j1, dic)
            if stor in dic and dele not in dic:
                if ret[j][0] == '(IF':
                    ret[j:j1] = repl_in_if_store(ret_j_j1, old, new, stor, dele)
                    if is_not_caused_store(ret_j_j1, {stor:0, dele:0}):
                        j = j1 + 1
                        continue
                break
            elif stor in dic or dele in dic:
                break
            ret[j:j1] = replace_subexpr(ret_j_j1, old, new)
            j = j1 + 1
            continue
        dic = {}
        collect_store_and_delete_and_access(ret[j], dic)
        if stor in dic:
            if ret[j][0] == 'STORE' and len(ret[j][1]) == 1 and \
                ret[j][1][0] == stor and len(ret[j][2]) == 1:
                v2 = replace_subexpr(ret[j][2][0], old, new)
                ret[j] = ('STORE', ret[j][1], (v2,))
            break
        elif dele in dic:
            break
        if new[0] == 'PY_TYPE' and new[1] is tuple and type(new[2]) is tuple and all([x is None for x in new[2]]):
            new = list(new)
            new[2] = len(new[2])
            new = tuple(new)
        ret[j] = replace_subexpr(ret[j], old, new)
        j = j + 1      

def is_not_caused_store(ret, ch_exprs):
    if ret[0][0] == '(IF':

        if len(ret) == 3 or len(ret) == 2:
            if ret[1][-1][0] in ('CONTINUE', 'BREAK_LOOP', 'BREAK', 'RETURN_VALUE', 'RETURN'):
                return True
            if is_not_caused_store2(ret[1], ch_exprs):
                return True
            return False
        if len(ret) == 5 or len(ret) == 4:
            is1 = False
            is2 = False
            if \
                ret[1][-1][0] in ('CONTINUE', 'BREAK_LOOP', 'BREAK', 'RETURN_VALUE', 'RETURN'):
                is1 = True
            else:
                if is_not_caused_store2(ret[1], ch_exprs):
                    is1 = True
            if is1:
                if ret[3][-1][0] in ('CONTINUE', 'BREAK_LOOP', 'BREAK', 'RETURN_VALUE', 'RETURN'):
                    is2 = True 
                else:
                    if is_not_caused_store2(ret[3], ch_exprs):
                        is2 = True
            return is1 and is2
        pp(len(ret))
        pprint(ret)   
        assert False
    return is_not_caused_store2(ret, ch_exprs)      

def is_not_caused_store2(ret, ch_exprs):
    j = 0
    assert type(ret) is list
    while j < len(ret):
        isbeg = IsBeg(ret[j][0])
        if isbeg:
            j1 = get_closed_pair(ret, j)
            item = ret[j:j1]
        else:
            j1 = j + 1
            item = ret[j]
        if isbeg and ret[j][0] == '(IF':
            if len(item) == 3 or len(item) == 2:
                if item[1][-1][0] in ('CONTINUE', 'BREAK_LOOP', 'BREAK', 'RETURN_VALUE', 'RETURN') or \
                    is_not_caused_store2(item[1], ch_exprs):
                    j += 3
                    continue
            elif len(item) == 5 or len(item) == 4:
                if \
                    ( item[1][-1][0] in ('CONTINUE', 'BREAK_LOOP', 'BREAK', 'RETURN_VALUE', 'RETURN') or \
                        is_not_caused_store2(item[1], ch_exprs) ) and \
                    ( item[3][-1][0] in ('CONTINUE', 'BREAK_LOOP', 'BREAK', 'RETURN_VALUE', 'RETURN') or \
                        is_not_caused_store2(item[3], ch_exprs) ):
                        j += 5
                        continue

            return False
        if exprs_in_expr(ch_exprs, item):
            return False       
        if isbeg:
            j = j1 + 1
        else:
            j += 1
    return True      

def collect_store_and_delete_and_fast(it, dic):
    if type(it) is list:
        for v in it:
            collect_store_and_delete_and_fast(v, dic)
        return
    if type(it) is tuple:
        if len(it) == 2:
            if it[0] == 'CONST':
                return
            if it[0] in ('STORE_FAST', 'DELETE_FAST', 'FAST'):
                dic[it] = True
        for v in it:
            if type(v) is tuple:
                collect_store_and_delete_and_fast(v, dic)
    return

def collect_store_and_delete_and_access(it, dic):
    if type(it) is list:
        for v in it:
            collect_store_and_delete_and_access(v, dic)
        return
    if type(it) is tuple:
        if len(it) == 2:
            if type(it[0]) is str and it[0] in ('STORE_FAST', 'DELETE_FAST', 'FAST', 'STORE_NAME', 'DELETE_NAME', '!LOAD_NAME'):
                dic[it] = True
        for v in it:
            if type(v) is tuple:
                collect_store_and_delete_and_access(v, dic)
    return

def replace_local_const_detect(ret, nmdef):
    if type(ret) != list:
        return ret
    ret = ret[:]
    i = 0
    while i < len(ret):
        assert type(i) is int
        v = ret[i]
        li1 = list_typed_var_after_stmt(v, nmdef)
        li = [(old, new, stor, dele) for old, new, stor, dele in li1 if old[0] == 'FAST' and new[0] != 'PY_TYPE']
        if len(li) > 0:
            dic = {}
            collect_store_and_delete_and_fast(ret[i+1:], dic)
            for old, new, stor, dele in li:
                if stor in dic or dele in dic:
                    continue
                if old not in dic:
                    if new[0] in ('CONST', '!MK_FUNK') and ret[i] == ('STORE', (stor,), (new,)):
                        del ret[i]
                else:    
                    ret[i+1:] = replace_subexpr(ret[i+1:], old, new)
        i += 1
    return ret                


def join_defined_calls(_calls, argcount, nm, is_varargs, che, dic):
    global g_co
    l = []
    co = N2C(nm)
    if is_varargs:
        argcount += 1  
    co.recursive = len([c for c, typs, called_from in _calls if called_from == nm]) > 0
    prev_g_co = g_co
    for c, typs, called_from in _calls:
        g_co = N2C(called_from)
        a = []
        if c[0] == 'CONST':
            for _a in c[1]:
                a.append(('CONST', _a))
        elif c[0] == '!BUILD_TUPLE':
            for i, _a in enumerate(c[1]):
                if _a[0] == 'CONST':
                    a.append(_a)
                elif _a[0] == 'CALC_CONST':
                    a.append(_a)
                elif _a[0] == 'PY_TYPE':
                    if _a[3][0] == 'FAST' and called_from == nm and i < len(co.co_varnames) and _a[3][1] == co.co_varnames[i] and ('STORE_FAST', _a[3][1]) not in dic:

                        a.append(('NIL', None))
                    else:
                        a.append((_a[1], _a[2])) 
                elif _a[0] == 'FAST' and called_from == nm and i < len(co.co_varnames) and _a[1] == co.co_varnames[i] and ('STORE_FAST', _a[1]) not in dic:

                    a.append(('NIL', None))
                else:
                    t = typs[i]
                    if t is not None:
                        assert len(t) == 2
                        a.append(t) 
                    else:
                        a.append((None, None))  
        elif c[0] == '!PyNumber_Add' and c[1][0] == '!BUILD_TUPLE' and IsTuple(TypeExpr(c[2])) and is_varargs and (argcount <= len(c[1][1]) + 1):
            for i, _a in enumerate(c[1][1] + (c[2],)):
                if _a[0] == 'CONST':
                    a.append(_a)
                elif _a[0] == 'CALC_CONST':
                    a.append(_a)
                elif _a[0] == 'PY_TYPE':
                    if _a[3][0] == 'FAST' and called_from == nm and i < len(co.co_varnames) and _a[3][1] == co.co_varnames[i]  and ('STORE_FAST', _a[3][1]) not in dic:

                        a.append(('NIL', None))
                    else:
                        a.append((_a[1], _a[2])) 
                elif _a[0] == 'FAST' and called_from == nm and i < len(co.co_varnames) and _a[1] == co.co_varnames[i]  and ('STORE_FAST', _a[1]) not in dic:

                    a.append(('NIL', None))
                else:
                    t = typs[i]
                    if t is not None:
                        assert len(t) == 2
                        a.append(t) 
                    else:
                        a.append((None, None))             
        else:
            pp('->>>>>>>>>>>>>>>>>>')
            pprint(c)
            pp('->>>>>>>>>>>>>>>>>>')
            pprint(_calls)
            pp(c[0] == '!PyNumber_Add')
            pp(c[1][0] == '!BUILD_TUPLE')
            pp(IsTuple(TypeExpr(c[2])))
            pp(is_varargs)
            pp(argcount, len(c[1][1])+1, c[1][1],  (argcount <= len(c[1][1]) + 1))
            pp(argcount, nm, is_varargs, che)
            pp(nm)
            Fatal('Can\'t join calls', c, _calls)
            assert False
        if argcount != len(a) and not is_varargs:
            if argcount > len(a):
                if nm in default_args:
                    cc = default_args[nm]
                    if cc[0] == 'CONST':
                        _refs2 = [('CONST', x) for x in cc[1]]
                    else:    
                        assert cc[0] == '!BUILD_TUPLE'
                        _refs2 = [x for x in cc[1]]
                        pos_default = 0
                        for i, x in enumerate(_refs2):
                            if x[0] != 'CONST':  
                                _refs2[i] = ('!BINARY_SUBSCR_Int', ('PY_TYPE', tuple, None, ('!LOAD_GLOBAL', co.default_args_nm()), None), ('CONST', pos_default))
                                pos_default += 1
                                add_fast_glob(co.default_args_nm())
                    add_args = argcount - len(a)
                    pos_args = len(_refs2) - add_args
                    a = a + _refs2[pos_args:]
        elif is_varargs:
            if argcount -1 > len(a):
                if nm in default_args:
                    cc = default_args[nm]
                    if cc[0] == 'CONST':
                        _refs2 = [('CONST', x) for x in cc[1]]
                    else:    
                        assert cc[0] == '!BUILD_TUPLE'
                        _refs2 = [x for x in cc[1]]
                        for i, x in enumerate(_refs2):
                            if x[0] != 'CONST':
                                _refs2[i] = ('!LOAD_GLOBAL', co.default_args_nm())    
                                add_fast_glob(co.default_args_nm())                                                    
                    add_args = ( argcount - 1 ) - len(a)
                    pos_args = len(_refs2) - add_args
                    a = a + _refs2[pos_args:]
            new_a = []
            for i in range(argcount-1):
                new_a.append(a[i])
            new_a.append((tuple, None))
            a = new_a  

        if len(a) != argcount: # or nm == 'HideDebug':
            Fatal('', _calls, a, argcount, nm, is_varargs)
            assert False
        assert len(a) == argcount  
        l.append(a)

    g_co = prev_g_co
    l2 = []     

    ## pprint(l)
    old_l = l
    for i in range(argcount):
        d = {}
        for ll in l:
            if ll[i][0] == 'CONST':
                d[(ll[i], type(ll[i][1]))] = True
            else:
                d[(ll[i], None)] = True
        if len(d) > 1:
            if (('NIL', None), None) in d:
                del d[(('NIL', None), None)]
        if len(d) > 1:
            d2 = {}
            for k,v in d.items():
                k = k[0]
                if type(k) is tuple and k[0] == 'CONST':
                    k = TypeExpr(k) 
                elif type(k) is tuple and k[0] == 'CALC_CONST':
                    k = TypeExpr(k)                     
                d2[k] = v
            d = d2  
        else:
            d2 = {}
            for k,v in d.items():
                k = k[0]
                d2[k] = v
            d = d2
        if len(d) > 1:
            if len(d) > 1 and None not in d and (None, None) not in d:
                ts = [(x[0], x[1]) for x in d.keys()]

                ts = uniq_list_type(ts)
                ## if len(ts) > 1:

                if len(ts) == 1:
                    d = {ts[0]:True}        
        if len(d) > 1:
            d = {None:True}
        
        l2.append(d.keys()[0])
    l = l2          
    return l, old_l

def dotted_name_to_first_name(nm):
    if '.' in nm:
        return nm.split('.')[0]
    return nm

def filter_founded_calc_const(p, k, do_del):
    v = []
    if TCmp(p, v, ('STORE', (('STORE_NAME', '?'),), \
                       (('!IMPORT_NAME', '?', ('CONST', -1), ('CONST', None)),))):
        if v[0] == k and not v[1].startswith(v[0] + '.'):
            set_all_calc_const(k, p[2][0])
            ImportedM[k] = dotted_name_to_first_name(v[1])
    elif TCmp(p, v, ('STORE', (('STORE_NAME', '?'),), \
                       (('!IMPORT_NAME', '?', ('CONST', 0), ('CONST', None)),))):
        if v[0] == k and not v[1].startswith(v[0] + '.'):
            set_all_calc_const(k, p[2][0])
            ImportedM[k] = dotted_name_to_first_name(v[1])
    elif p[0] == 'STORE' and len(p[1]) == len(p[2]) == 1:
        if p[2][0][0] in ('!LOAD_NAME', '!LOAD_GLOBAL') and  p[2][0][1] in calculated_const:
            if p[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL') and p[1][0][1] == k:
                ok = p[2][0][1]
                calculated_const[k] = calculated_const[ok]
                if ok in no_compiled:
                    no_compiled[k] = no_compiled[ok]
                if ok in default_args:
                    default_args[k] = default_args[ok]
                if ok in direct_code:
                    direct_code[k] = direct_code[ok]
                if ok in val_direct_code:
                    val_direct_code[k] = val_direct_code[ok]
                if ok in detected_return_type:
                    detected_return_type[k] = detected_return_type[ok]
                if ok in ImportedM:
                    ImportedM[k] = ImportedM[ok]                    
                for a,b,c in Iter3(ok, None, None):
                    _3(k, b,c)
        elif p[2][0][0] == 'CONST' or\
             TCmp(p[2][0], v, ('!PyObject_GetAttr', ('CONST', '?'), ('CONST', '?'))):
            if p[2][0][1] is not None:
                if p[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL') and p[1][0][1] == k:
                    set_mnemonic_const(k, p[2][0])
                elif p[1][0][0] == 'SET_VARS' and ('STORE_NAME', k) in p[1][0][1] and  p[2][0][0] == 'CONST' and type(p[2][0][1]) is tuple and  p[1][0][1].index(('STORE_NAME', k)) < len(p[2][0][1]):
                    pos_ = p[1][0][1].index(('STORE_NAME', k))
                    set_mnemonic_const(k, ('CONST', p[2][0][1][pos_]))
                elif p[1][0][0] == 'SET_VARS' and ('STORE_GLOBAL', k) in p[1][0][1] and  p[2][0][0] == 'CONST' and type(p[2][0][1]) is tuple and  p[1][0][1].index(('STORE_NAME', k)) < len(p[2][0][1]):
                    pos_ = p[1][0][1].index(('STORE_GLOBAL', k))
                    set_mnemonic_const(k, ('CONST', p[2][0][1][pos_]))
                else:
                    Fatal('--590--', p)
                    assert False
            return    
            
        
        elif p[2][0][0] == '!IMPORT_NAME':
            if p[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL') and p[1][0][1] == k and\
                p[2][0][2] == ('CONST', -1) and p[2][0][3] == ('CONST', None)  and not p[2][0][0].startswith(p[1][0][0] + '.'):
                set_all_calc_const(k, p[2][0])
                ImportedM[k] = dotted_name_to_first_name(p[2][0][1])
            else:
                Fatal('--597--', p)
                assert False
            return    
        else:
            if p[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL') and p[1][0][1] == k:
                set_all_calc_const(k, p[2][0])
            return
    elif p[0] == 'IMPORT_STAR':
        pp(p)
    elif p[0] == 'IMPORT_FROM_AS' and\
        TCmp(p, v, ('IMPORT_FROM_AS', '?', ('CONST', '?'), ('CONST', '?'), '?')):
        del v[1] ## Hack !!!!!!!!!!!!!!!!!!!!!!!!!!!
        imp, consts_, stores = v
        for i, reti in enumerate(stores):
            v = []
            if reti[0] in ('STORE_NAME', 'STORE_GLOBAL') and reti[1] == k:
                set_all_calc_const(k, None)
                v = IfConstImp(imp, consts_[i])
                if v is not None:
                    set_mnemonic_const(k, v)
                else:
                    ImportedM[k] = (imp, consts_[i])
                    if (imp, consts_[i], 'val') in t_imp:
                        t = t_imp[(imp, consts_[i], 'val')]
                        if IsNewType(t):
                            RegisterNewClass(k, None, None, False)
                        elif IsOldType(t):
                            RegisterOldClass(k, None, None, False)
                            
        return
    elif p[0] in (')(EXCEPT', '(FOR'):
        do_del.append(k)    
        return
    elif p[0] == 'SEQ_ASSIGN':
        if ('STORE_NAME', k) in p[1]:
            set_all_calc_const(k, p[2])
        else:
            for pi in p[1]:
                if pi[0] == 'SET_VARS':
                    if ('STORE_NAME', k) in pi[1]:
                        set_all_calc_const(k, p[2])
    elif p[0] == 'SEQ_ASSIGN' and ('STORE_NAME', k) in p[1]:
        set_all_calc_const(k, p[2])
    elif p[0] == 'SET_EXPRS_TO_VARS' and ('STORE_NAME', k) in p[1]:
        set_all_calc_const(k, p[2])  
    elif p[0] == 'UNPUSH':
        return
    elif p[0] == '!LIST_COMPR':
        return
    elif p[0] == '!SET_COMPR':
        return
    elif p[0] == 'PRINT_ITEM_1':
        return
    else:
        Fatal('can\'t handle CALC_CONST', p, k)
        assert False
 
list_ext = []
        
     
cc2 = None     
          
def compile_c(base, cname):
    global cc2
    global list_cname_exe, sys
    if True:
        global distutils
        global sys
        import distutils
        import distutils.core
        import sys
        try:
            global setuptools
            import setuptools
            import setuptools.dist
        except:
            pass
    optio = ['-O0']
    if len(opt_flag) > 0:
        optio = opt_flag
    preargs = optio + ['-Wall', '-g', '-fPIC'] #, '-Wno-unused-function'] #, '-pg']  
    cc = distutils.ccompiler.get_default_compiler(os.name, sys.platform)
    cc2 = new_compiler(os.name,cc, 1) 
    include_dirs = [sysconfig.get_python_inc()]   
    library_dirs = [sysconfig.get_python_lib()]   
    cc2.set_include_dirs([sysconfig.get_python_inc()])   
    cc2.set_library_dirs([sysconfig.get_python_lib()])   

    ## cl = 'clang-3.9'
    if True:
        cl = 'clang-6.0'
        cc2.compiler = [cl]
        cc2.compiler_so = [cl]
    cc2.compile([cname], output_dir=None, macros=None, debug=1, extra_preargs=preargs, extra_postargs=preargs, depends=None)
    link_exe(cname)
    return

def link_exe(cname):
    if sys.platform == 'win32':
        optio = []
    else:
        optio = ['-O0']
    if len(opt_flag) > 0:
        optio = opt_flag 
    if sys.platform == 'win32':
        pyver = '%d' % py_version
    else:
        pyver = sysconfig.get_config_var('VERSION')
        if pyver is None:
            pyver = '%d' % py_version
    
 
    libdir = sysconfig.get_python_lib()
    if sys.platform == 'win32':
        libs = [libdir, sysconfig.PREFIX + '\\bin', \
             sysconfig.PREFIX  + '\\lib',  sysconfig.PREFIX  + '\\libs']
    else:
        libs = [libdir,  sysconfig.PREFIX + '/bin', \
             sysconfig.PREFIX  + '/lib',  sysconfig.PREFIX  + '/config']
    if libdir.endswith('/site-packages'):
        libs.append(libdir[:-14])
        libs = [libdir[:-14]+'/config'] + libs
    if is_code_ext:
        basenm = 'pyhon'

    else:
        basenm = 'python'
    if hasattr(sys, 'gettotalrefcount') and sys.platform != 'win32' and pyver <= '2.7':
        libraries=[basenm+pyver + '_d']
    else:
        libraries=[basenm+pyver]
    if build_executable:
        link = cc2.link_executable
        newfile = cname[:-2]
        if sys.platform == 'win32':
            newfile = cname[:-2] + '.exe'        
    else:
        link = cc2.link_shared_object
        newfile = cname[:-2] + '.so'
        if sys.platform == 'win32':
            newfile = cname[:-2] + '.pyd'
    if sys.platform == 'win32':
        link([cname[:-2]+'.obj'], newfile, output_dir=None, libraries = [basenm+pyver], library_dirs=[sysconfig.get_python_lib()] + libs, runtime_library_dirs=[], debug=0, extra_preargs=[] + optio, extra_postargs=optio, target_lang=None) 
    else:
        libraries += ['m']
        link([cname[:-2]+'.o'], newfile, output_dir=None, libraries = libraries, library_dirs=[sysconfig.get_python_lib()] + libs, runtime_library_dirs=[], debug=1, extra_preargs=[ '-g'] + optio, extra_postargs=optio, target_lang=None) 

    return     
    

def unjumpable(cmd):
    cmd0 = cmd[0]
    if type(cmd0) is str:
        if len(cmd) == 1:
            if cmd0 in ('RETURN_VALUE', 'EXEC_STMT'):
                return False
            if cmd0[0:6] in ('BINARY', 'UNARY_'):
                return False
        if cmd0 in set_any:
            return False
        if cmd0 in _unjump_cmds:              
            return False
        if cmd0 == 'RAISE_VARARGS' and cmd[1] != 0:
            return False
        if cmd0 in ('STORE', 'SEQ_ASSIGN', 'SET_EXPRS_TO_VARS', 'UNPUSH'):
            return True
        if cmd0[0] in ('J', '(', ')')  :
            return False
        if cmd0 == 'LOAD_CONST':
            return False
    return not type(cmd) is list and \
            cmd0 is not None and cmd0[0] != '!' and cmd0 not in ('LOAD_FAST', 'LOAD_CLOSURE') and \
            (type(cmd0) is str and cmd0[0] not in ('J', '(', ')') and cmd0[0:2] != '.:')

def linear_to_seq(cmds):
    assert type(cmds) is list
    ret = []
    i = 0
    while i < len(cmds):
        assert type(i) is int
        cmd = cmds[i]
        if not unjumpable(cmd):
            ret.append(cmd)
            i = i + 1
            continue
        ret2 = []
        while unjumpable(cmd) or type(cmd) is list:
            if type(cmd) is list:
                ret2.extend(cmd[:])
            else:    
                ret2.append(cmd)
            i = i + 1
            if  i < len(cmds):
              cmd = cmds[i]
            else:
                break  
        if len(ret) > 0 and type(ret[-1]) is list:
            ret[-1] = ret[-1] + ret2
        else:    
            ret.append(ret2)
        continue
    cmds[:] = ret[:]    
        
def jump_to_continue_and_break(cmds): 
    assert type(cmds) is list       
    i = 0
    loops = [(i,pos_label(cmds, x[1])) for i,x in enumerate(cmds) if x[0] in ('J_SETUP_LOOP', 'J_SETUP_LOOP_FOR')]
    continues = {}
    ranges = {}
    for a,b in loops:
        assert type(a) is int
        assert type(b) is int
        j = a + 1
        while j < len(cmds) and j < b:
            if cmds[j][0] == '.:':
                continues[a] = cmds[j][1]
                break
            if type(cmds[j][0]) is str and (cmds[j][0].startswith('JUMP') or cmds[j][0].startswith('J_SETUP')):
                break
            j = j + 1 
        ranges[a] = set([i for i in range(a,b) if cmds[i][0][0] == 'J'])
    inter = [(a1,b1, a2,b2) for a1,b1 in loops for a2,b2 in loops if a2 > a1 and b2 < b1]
    for a1,b1,a2,b2 in inter:
        ranges[a1] = ranges[a1] - ranges[a2]
    for a,b in loops:
        for i in ranges[a]:
            cmd = cmds[i]
            if cmd[0] in jump and a in continues and cmd[1] == continues[a]:
                cmds[i] = ('JUMP_CONTINUE',) + cmd[1:]
            if cmd[0] == 'JUMP_IF_TRUE_POP' and a in continues and cmd[1] == continues[a]:
                cmds[i] = ('JUMP_IF_TRUE_POP_CONTINUE',) + cmd[1:]
            if cmd[0] == 'JUMP_IF_FALSE_POP' and a in continues and cmd[1] == continues[a]:
                cmds[i] = ('JUMP_IF_FALSE_POP_CONTINUE',) + cmd[1:]
            if cmd[0] == 'JUMP_IF2_TRUE_POP' and a in continues and cmd[1] == continues[a]:
                cmds[i] = ('JUMP_IF2_TRUE_POP_CONTINUE',) + cmd[1:]
            if cmd[0] == 'JUMP_IF2_FALSE_POP' and a in continues and cmd[1] == continues[a]:
                cmds[i] = ('JUMP_IF2_FALSE_POP_CONTINUE',) + cmd[1:]
           
def label(j,l):
    if type(l) is tuple and type(j) is tuple and len(j) > 1 and len(l) > 1:
        return bool(type(j[0]) is str and j[0][0] == 'J' and type(l[0]) is str and \
                    l[0] == '.:' and type(l[1]) is int and type(j[1]) is int and bool(l[1] == j[1]))
    return False

def endlabel(j,l):
    if type(l) is tuple and type(j) is tuple and len(j) > 1 and len(l) > 1:
        return bool(type(j[0]) is str and j[0][0] == 'J' and type(l[0]) is str and \
                (l[0] == '.:' or l[0] in jump) and type(l[1]) is int and type(j[1]) is int and bool(l[1] == j[1]))
    return False

def cmds_join(i,cmds):
    assert type(i) is int and i >= 0 and i <= (MInt / 10)
    assert type(cmds) is list
    if i >= len(cmds):
        return
    if i > 0 and type(cmds[i]) is list and type(cmds[i-1]) is list:
        cmds[i-1] = cmds[i-1] + cmds[i]
        del cmds[i]
        cmds_join(max(0,i-1),cmds)
        cmds_join(i,cmds)
        cmds_join(min(len(cmds)-1,i+1),cmds)
        return
    if i < len(cmds)-1 and type(cmds[i]) is list and type(cmds[i+1]) is list:
        cmds[i] = cmds[i] + cmds[i+1]
        del cmds[i+1]
        cmds_join(max(0,i-1),cmds)
        cmds_join(i,cmds)
        cmds_join(min(len(cmds)-1,i+1),cmds)
        return

    if i < len(cmds)-1 and i > 0 and \
        type(cmds[i-1]) is list and unjumpable(cmds[i]) and type(cmds[i+1]) is list:
        cmds[i] = cmds[i-1] + [cmds[i]] + cmds[i+1]
        del cmds[i-1]
        del cmds[i]
        cmds_join(max(0,i-1),cmds)
        cmds_join(i,cmds)
        cmds_join(min(len(cmds)-1,i+1),cmds)
        return
    if i > 0 and unjumpable(cmds[i]) and type(cmds[i-1]) is list:
        cmds[i-1] = cmds[i-1] + [cmds[i]]
        del cmds[i]
        cmds_join(max(0,i-1),cmds)
        cmds_join(i,cmds)
        cmds_join(min(len(cmds)-1,i+1),cmds)
        return
    if i < len(cmds)-1 and type(cmds[i]) is list and unjumpable(cmds[i+1]):
        cmds[i] = cmds[i] + [cmds[i+1]]
        del cmds[i+1]
        cmds_join(max(0,i-1),cmds)
        cmds_join(i,cmds)
        cmds_join(min(len(cmds)-1,i+1),cmds)
        return
    if i < len(cmds)-1 and type(cmds[i+1]) is list and unjumpable(cmds[i]):
        cmds[i] = [cmds[i]] + cmds[i+1]
        del cmds[i+1]
        cmds_join(max(0,i-1),cmds)
        cmds_join(i,cmds)
        cmds_join(min(len(cmds)-1,i+1),cmds)
        return
    if i > 0 and unjumpable(cmds[i]) and not type(cmds[i]) is list and\
       not type(cmds[i-1]) is list and cmds[i-1][0] == '.L':
        cmds[i-1] = [cmds[i-1],cmds[i]]
        del cmds[i]
        cmds_join(max(0,i-1),cmds)        
        return
    if unjumpable(cmds[i]) and not type(cmds[i]) is list :
        cmds[i] = [cmds[i]]
        return
    
def prin(a,b,c):
    pp_out(out, a)
    pp_out(out, b)
    
def print_pr(cmds):    
    if not print_pycmd:
        return
    assert type(cmds) is list
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l
    prin (1,pos__a, cmds)
    prin (2,pos__b, cmds)
    prin (3,pos__c, cmds)
    prin (4,pos__d, cmds)
    prin (5,pos__e, cmds)
    prin (6,pos__f, cmds)        
    prin (7,pos__g, cmds) 
    prin (8,pos__h, cmds)        
    prin (9,pos__i, cmds) 
    prin (10,pos__j, cmds) 
    prin (11,pos__k, cmds) 
    prin (12,pos__l, cmds)
    pp_out(out, '')  
                            
def half_recompile(cmds, co):
    global debug
    global restart
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l
    assert type(cmds) is list
    i = 0
    totemp = [(None,)] * 12
    oldi = -1
    first = True
    last = False
    added_pass = False
    only_matched = False
    ClearJumpCache()
    if debug:
        if print_pycmd:
            pp_out(out, 'Step 0')
            print_cmds(cmds)
        ClearJumpCache()    
    while i <= len(cmds):   
        assert type(i) is int and i >= 0
        if first and i == len(cmds):
            ClearJumpCache()
            if debug and print_pycmd:
                pp_out(out, 'Step 1')
                print_cmds(cmds)
            linear_to_seq(cmds)
            NoGoToGo(cmds)
            jump_to_continue_and_break(cmds)
            i = 0
            first = False
        elif not first and i == len(cmds) and not last and len(cmds) > 2:  
            ClearJumpCache()
            if debug and print_pycmd:
                pp_out(out, 'Step 2')
                print_cmds(cmds)
            added_pass = True
            NoGoToGo(cmds)
            NoGoToReturn(cmds)
            jump_to_continue_and_break(cmds)
            i = 0
            first = False
            last = True
            i = 0
            while i < len(cmds):
                assert type(i) is int
                if islineblock(cmds[i]):
                    del cmds[i]
                    continue
                i = i + 1
            i = 0      
        bingo = False    
        assert type(i) is int and i >= 0
        if oldi == i:
            bingo = True
            ClearJumpCache()
            if debug == True:
                tempor = cmds[i:i+12]
                while len(tempor) < 12:
                    tempor.append((None,))
                pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l = tempor
                if print_pycmd:
                    pp_out(out, '!!!!!!',i, '!!!!!!')
                    print_pr(cmds)
            _len = len(cmds)    
            cmds_join(i,cmds)
            i -= 12
            if len(cmds) < _len:
                i -= _len - len(cmds)
            if i < 0:
                i = 0 
        if i < 0:
            i = 0 
        assert type(i) is int
        assert i >= 0
        oldi = i
        assert type(cmds) is list
        tempor = cmds[i:i+12]
        if len(tempor) < 12:
            tempor = (tempor + totemp)[:12]
        assert type(tempor) is list
        pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l = tempor
        pos_a_0 = pos__a[0]
        if debug == True and print_pycmd and not only_matched:
            if bingo:
                pp_out(out, '*****',i, '*****')
            else:
                pp_out(out, '--',i, '--')
            print_pr(cmds)

        begin_cmp()

        if type(pos__a) is tuple and len(pos__a) >= 1:
            if type(pos_a_0) is str:
                if pos_a_0.startswith('JUMP') and\
                    pos_a_0 != 'JUMP_IF_NOT_EXCEPTION_POP':
                    changed_jump = process_jump(cmds,i,added_pass)
                    if changed_jump:
                        continue
                if pos_a_0 == 'J_FOR_ITER':
                    if pos__b[0] in set_any:
                        cmds[i:i+2] = [('J_LOOP_VARS', pos__a[1], (pos__b,))]
                        continue
                    if islineblock(pos__b) and pos__c[0] in set_any:
                        cmds[i:i+3] = [('J_LOOP_VARS', pos__a[1], (pos__c,))]
                        continue
                    if pos__b[0] == 'UNPACK_SEQ_AND_STORE' and pos__b[1] == 0:
                        b2 = pos__b[2]
                        if len(b2) == 1:
                            b2 += (None,)
                        cmds[i:i+2] = [('J_LOOP_VARS', pos__a[1], b2)]
                        continue
                if pos_a_0 == '.:' and pos__b[0] == 'J_LOOP_VARS':
                    if pos__e[0] == 'JUMP' and is_cmdmem(pos__c):
                        if SCmp(cmds, i, ((':', 4), 'J_LOOP_VARS', '>', \
                                        'LIST_APPEND', 'JUMP', '.:')) and \
                                        pos__a[1] != pos__b[1] and pos__f[0] != pos__b[1] and len(pos__d) == 2:  
                            rpl(cmds, [pos__a, ('J_BASE_LIST_COMPR', pos__b[1], (cmd2mem(pos__c),), (pos__b[2], None, ())),pos__f]                )
                            continue    
                        if SCmp(cmds, i, ((':', 4), 'J_LOOP_VARS', '>', \
                                        ('SET_ADD', 2), 'JUMP', '.:')) and \
                                        pos__a[1] != pos__b[1] and pos__f[0] != pos__b[1] :  
                            rpl(cmds, [pos__a, ('J_BASE_SET_COMPR', pos__b[1], (cmd2mem(pos__c),), (pos__b[2], None, ())),pos__f]                )
                            continue   
                        if SCmp(cmds, i, ((':', 4), 'J_LOOP_VARS', '>', \
                                        ('SET_ADD', 3), 'JUMP', '.:')) and \
                                        pos__a[1] != pos__b[1] and pos__f[0] != pos__b[1] :  
                            rpl(cmds, [pos__a, ('J_BASE_SET_COMPR', pos__b[1], (cmd2mem(pos__c),), (pos__b[2], None, ())),pos__f]                )
                            continue   
                    if pos__f[0] == 'JUMP' and is_cmdmem(pos__c) and is_cmdmem(pos__d):
                        if SCmp(cmds, i, ((':', 5), 'J_LOOP_VARS', '>', '>', \
                                        ('MAP_ADD', 2), 'JUMP', '.:')) and \
                                        pos__a[1] != pos__b[1] and pos__g[0] != pos__b[1] :  
                            rpl(cmds, [pos__a, ('J_BASE_MAP_COMPR', pos__b[1], (cmd2mem(pos__d),cmd2mem(pos__c),), (pos__b[2], None, ())),pos__g]   )
                            continue    
                    if pos__e[0] == 'LIST_APPEND':
                        if SCmp(cmds, i, ((':', 5), 'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP', '>', \
                                        'LIST_APPEND', 'JUMP', '.:')) and \
                                        pos__a[1] != pos__b[1] and pos__g[0] != pos__b[1] and len(pos__e) == 2:  
                            rpl(cmds, [pos__a, ('J_BASE_LIST_COMPR', pos__b[1], (cmd2mem(pos__d),), (pos__b[2], None, (Not(pos__c[2]),))),pos__g]                )
                            continue    
                        if SCmp(cmds, i, ((':', 5), 'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', '>', \
                                        'LIST_APPEND', 'JUMP', '.:')) and \
                                        pos__a[1] != pos__b[1] and pos__g[0] != pos__b[1] and len(pos__e) == 2:  
                            rpl(cmds, [pos__a, ('J_BASE_LIST_COMPR', pos__b[1], (cmd2mem(pos__d),), (pos__b[2], None, (pos__c[2],))),pos__g]                )
                            continue    
                    if pos__e[0] == 'SET_ADD':
                        if SCmp(cmds, i, ((':', 5), 'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP', '>', \
                                        'SET_ADD', 'JUMP', '.:')) and \
                                        pos__a[1] != pos__b[1] and pos__g[0] != pos__b[1] and len(pos__e) == 2:  
                            rpl(cmds, [pos__a, ('J_BASE_SET_COMPR', pos__b[1], (cmd2mem(pos__d),), (pos__b[2], None, (Not(pos__c[2]),))),pos__g]                )
                            continue    
                        if SCmp(cmds, i, ((':', 5), 'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', '>', \
                                        'SET_ADD', 'JUMP', '.:')) and \
                                        pos__a[1] != pos__b[1] and pos__g[0] != pos__b[1] and len(pos__e) == 2:  
                            rpl(cmds, [pos__a, ('J_BASE_SET_COMPR', pos__b[1], (cmd2mem(pos__d),), (pos__b[2], None, (pos__c[2],))),pos__g]                )
                            continue    

                    if pos__f[0] == 'MAP_ADD':
                        if SCmp(cmds, i, ((':', 5), 'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP', '>', '>', \
                                        ('MAP_ADD', 3), 'JUMP', '.:')) and \
                                        pos__a[1] != pos__b[1] and pos__g[0] != pos__b[1] and len(pos__f) == 2:  
                            rpl(cmds, [pos__a, ('J_BASE_MAP_COMPR', pos__b[1], (cmd2mem(pos__e),cmd2mem(pos__d),), (pos__b[2], None, (Not(pos__c[2]),))),pos__h]                )
                            continue    
                        if SCmp(cmds, i, ((':', 5), 'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', '>', '>', \
                                        ('MAP_ADD', 3), 'JUMP', '.:')) and \
                                        pos__a[1] != pos__b[1] and pos__g[0] != pos__b[1] and len(pos__f) == 2:  
                            rpl(cmds, [pos__a, ('J_BASE_MAP_COMPR', pos__b[1], (cmd2mem(pos__e),cmd2mem(pos__d),), (pos__b[2], None, (pos__c[2],))),pos__h]                )
                            continue               
                        if SCmp(cmds, i, ((':', 5), 'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', '>', '>', \
                                        ('MAP_ADD', 2), 'JUMP', '.:')) and \
                                        pos__a[1] != pos__b[1] and pos__g[0] != pos__b[1] and len(pos__f) == 2:  
                            rpl(cmds, [pos__a, ('J_BASE_MAP_COMPR', pos__b[1], (cmd2mem(pos__e),cmd2mem(pos__d),), (pos__b[2], None, (pos__c[2],))),pos__h]                )
                            continue                        
                  
                                 
                        
                    
                if pos_a_0 == '.L':
                    if pos__b[0] in jump and len(pos__b) == 2:
                        cmds[i:i+2] = [(pos__b[0], pos__b[1], pos__a[1])]
                        continue
                    if pos__b[0] == 'J_SETUP_LOOP' and len(pos__b) == 2:
                        cmds[i:i+2] = [('J_SETUP_LOOP', pos__b[1], pos__a[1])]
                        continue
                    if pos__b[0] == '.L':
                        cmds[i:i+2] = [pos__b]
                        continue
                    if pos__b[0] == 'DUP_TOP' and is_cmdmem(pos__c) and \
                        len(pos__d) == 2 and pos__d[0] == 'COMPARE_OP' and pos__d[1] == 'exception match':
                        cmds[i:i+4] = [('CHECK_EXCEPTION', cmd2mem(pos__c), pos__a[1])]
                        continue  
        
                if pos_a_0 == 'DELETE_FAST' and pos__a[1].startswith('_['):
                    cmds[i] = (')END_LIST_COMPR', ('FAST', pos__a[1]))
                    continue
                if pos_a_0 == 'DELETE_NAME' and pos__a[1].startswith('_['):
                    cmds[i] = (')END_LIST_COMPR', ('NAME', pos__a[1]))
                    continue
                if pos_a_0 == 'UNPACK_SEQUENCE' and len(pos__a) == 2 and pos__a[1] > 0 and pos__b[0] in set_any:
                    cmds[i] = ('UNPACK_SEQ_AND_STORE', pos__a[1], ())
                    continue
                if pos_a_0 == 'UNPACK_SEQUENCE' and len(pos__a) == 2 and pos__a[1] > 0 and pos__b[0] == 'UNPACK_SEQ_AND_STORE':
                    cmds[i] = ('UNPACK_SEQ_AND_STORE', pos__a[1], ())
                    continue
                if pos_a_0 == 'UNPACK_SEQ_AND_STORE':
                    if pos__a[1] == 0:
                        cmds[i] = ('SET_VARS', pos__a[2])
                        continue
                    if pos__a[1] > 0 and pos__b[0] == '.L' and pos__c[0] in set_any:
                        cmds[i:i+3] = [('UNPACK_SEQ_AND_STORE', pos__a[1]-1, pos__a[2] + (pos__c,))]
                        continue
                    if pos__a[1] > 0 and pos__b[0] in set_any:
                        cmds[i:i+2] = [('UNPACK_SEQ_AND_STORE', pos__a[1]-1, pos__a[2] + (pos__b,))]
                        continue
                    if pos__a[1] > 0 and pos__b[0] == 'UNPACK_SEQ_AND_STORE' and pos__b[1] == 0 :
                        cmds[i:i+2] = [('UNPACK_SEQ_AND_STORE', pos__a[1]-1, pos__a[2] + (pos__b,))]
                        continue
                if pos_a_0 == 'LOAD_CODEFUNC' and pos__b[0] == 'MAKE_FUNCTION':
                    cmds[i:i+2] = [('MK_FUNK', pos__a[1], pos__b[1], ())]
                    continue
                if pos_a_0 == 'MK_FUNK' and pos__a[2] == 0:
                    cmds[i:i+1] = [('!MK_FUNK', pos__a[1], TupleFromArgs(pos__a[3]))]
                    continue
                if pos_a_0 == 'MK_CLOSURE' and pos__a[2] == 0:
                    cmds[i:i+1] = [('!MK_CLOSURE', pos__a[1], pos__a[3], TupleFromArgs(pos__a[4]))]
                    continue
                if pos_a_0 == 'IMPORT_FROM' and pos__b[0] in set_any:
                    cmds[i:i+2] = [('IMPORT_AND_STORE_AS', (pos__a[1],), (pos__b,))] 
                    continue

                if pos_a_0 == 'IMPORT_AND_STORE_AS' and pos__b[0] == 'IMPORT_AND_STORE_AS':
                    cmds[i:i+2] = [('IMPORT_AND_STORE_AS', pos__a[1] + pos__b[1], pos__a[2] + pos__b[2])] 
                    continue
                if pos_a_0 == '!IMPORT_NAME' and pos__b[0] == 'IMPORT_AND_STORE_AS' and pos__c[0] == 'POP_TOP' and pos__a[3][1] == pos__b[1]:
                    cmds[i:i+3] = [('IMPORT_FROM_AS', pos__a[1], pos__a[2], pos__a[3], pos__b[2])]
                    continue    
                if pos_a_0 in ('LOAD_GLOBAL', 'LOAD_NAME'):
                    if pos__a[1] in ('True', 'False', 'None'):
                        if pos__a[1] == 'True':
                            cmds[i] = ('LOAD_CONST', True)
                        elif pos__a[1] == 'False':
                            cmds[i] = ('LOAD_CONST', False)
                        elif pos__a[1] == 'None':
                            cmds[i] = ('LOAD_CONST', None)
                        continue
                    if not redefined_all and pos__a[1] in d_built and \
                    (not pos__a[1].startswith('__') or pos__a[1] in ('__import__',) )and \
                        not  pos__a[1] in redefined_builtin:
                            cmds[i] = ('!LOAD_BUILTIN', pos__a[1])
                            continue
                    if pos_a_0 == 'LOAD_GLOBAL':
                        cmds[i] = ('!LOAD_GLOBAL', pos__a[1])
                        continue
                    if pos_a_0 == 'LOAD_NAME':
                        cmds[i] = ('!LOAD_NAME', pos__a[1])
                        continue
                if pos_a_0 == 'LOAD_DEREF':
                    cmds[i] = ('!LOAD_DEREF', pos__a[1])
                    continue
                if pos_a_0 == 'BUILD_LIST' and pos__a[1] == 0:
                    if len(pos__a) == 3:
                        cmds[i] = ('!BUILD_LIST', pos__a[2])
                    else:
                        cmds[i] = ('!BUILD_LIST', ())
                    continue
            if pos__a == ('!BUILD_LIST', ()) and (pos__b[0] == '!GET_ITER' or pos__b == ('LOAD_FAST', '.0')):
                changed_list_compr = process_list_compr_2(cmds,i,added_pass)
                if changed_list_compr:
                    continue
            if pos__a == ('!BUILD_SET', ()) and (pos__b[0] == '!GET_ITER' or pos__b == ('LOAD_FAST', '.0')):
                changed_list_compr = process_set_compr_2(cmds,i,added_pass)
                if changed_list_compr:
                    continue
                
            if pos_a_0 == 'BUILD_TUPLE' and pos__a[1] == 0:
                if len(pos__a) == 3:
                    cmds[i] = TupleFromArgs(pos__a[2])
                else:
                    cmds[i] = ('CONST', ())
                continue
            if pos_a_0 == 'BUILD_SET':
                if pos__a[1] == 0 and len(pos__a) == 3 :
                    cmds[i] = ('!BUILD_SET', pos__a[2])
                    continue            
                if pos__a[1] == 0 and len(pos__a) == 2:
                    cmds[i] = ('!BUILD_SET', ())
                    continue         

            if pos__a == ('!BUILD_SET', ()) and pos__b == ('LOAD_FAST', '.0') and \
               pos__c[0] == 'J_BASE_SET_COMPR' and pos__d == ('.:', pos__c[1]):
                if pos__c[3][1] is None:
                    if pos__c[3][2] == ():
                        cmds[i:i+4] = [('!SET_COMPR', pos__c[2], (pos__c[3][0], (cmd2mem(pos__b),), None))]
                        continue 
                    else:
                        cmds[i:i+4] = [('!SET_COMPR', pos__c[2], (pos__c[3][0], (cmd2mem(pos__b),), pos__c[3][2]))]
                        continue   
                    
            if pos__a == ('!PyDict_New',) and pos__b == ('LOAD_FAST', '.0') :
                if pos__c[0] == 'J_BASE_MAP_COMPR' and pos__d == ('.:', pos__c[1]):
                    if pos__c[3][1] is None:
                        if pos__c[3][2] == ():
                            cmds[i:i+4] = [('!MAP_COMPR', pos__c[2], (pos__c[3][0], (cmd2mem(pos__b),), None))]
                            continue 
                        else:
                            cmds[i:i+4] = [('!MAP_COMPR', pos__c[2], (pos__c[3][0], (cmd2mem(pos__b),), pos__c[3][2]))]
                            continue   
                if pos__c[0] == '.:' and pos__d[0] == 'J_LOOP_VARS' and is_cmdmem(pos__e) and pos__f[0] == 'J_BASE_MAP_COMPR' and pos__g == '.:' and \
                   pos__c[1] == pos__f[1] and pos__g[1] == pos__d[1] and pos__f[3][1] is None:
                        if pos__f[3][2] == ():
                            cmds[i:i+7] = [('!MAP_COMPR', pos__f[2], (pos__f[3][0], (cmd2mem(pos__b),), None))]
                            continue 
                        else:
                            cmds[i:i+7] = [('!MAP_COMPR', pos__f[2], (pos__f[3][0], (cmd2mem(pos__b),), pos__f[3][2]))]
                            continue          
                        
                if SCmp(cmds, i, ('!PyDict_New', '>', (':', 5, 1),\
                                    'J_LOOP_VARS', '!GET_ITER', 'J_BASE_MAP_COMPR', \
                                    ('::', 3))):
                    if pos__f[3][2] == ():                     
                        rpl(cmds, [('!MAP_COMPR', pos__f[2], (pos__d[2], (cmd2mem(pos__b),), None, pos__f[3][0], (pos__e[1],), None))])
                        continue  
                    else:
                        rpl(cmds, [('!MAP_COMPR', pos__f[2], (pos__d[2], (cmd2mem(pos__b),), None, pos__f[3][0], (pos__e[1],), pos__f[3][2]))])
                        continue   
                    
                if SCmp(cmds, i, ('!PyDict_New', '>', (':', 6, 1), \
                                    'J_LOOP_VARS', '!GET_ITER', (':', 10, 1), 'J_LOOP_VARS', '>', '>', 'MAP_ADD', 'JUMP', \
                                    ('::', 3))):
                         rpl(cmds, [('!MAP_COMPR', 
                                     (cmd2mem(pos__i),cmd2mem(pos__h)),  
                                     (pos__d[2], (cmd2mem(pos__b),), None, pos__g[2], (pos__e[1],), None )
                                    )])
                         continue  
                     
            if pos_a_0 == '!PyDict_New' and pos__b[0] == 'STORE_MAP':
                if len(pos__a) == 1:
                    cmds[i] = ('!BUILD_MAP', (pos__b[1:],))
                    del cmds[i+1]         
                    continue
            if pos_a_0 == '!BUILD_MAP' and pos__b[0] == 'STORE_MAP':
                cmds[i] = ('!BUILD_MAP', pos__a[1] + (pos__b[1:],))
                del cmds[i+1]         
                continue
            if pos_a_0 == 'BUILD_MAP':
                if pos__a[1] == 0 and len(pos__a) == 2:
                    cmds[i] = ('!PyDict_New',)
                    continue
                if pos__a[1] > 0 and len(pos__a) == 2:
                    cmds[i] = ('BUILD_MAP', pos__a[1], ())
                    continue
                if pos__a[1] > 0 and len(pos__a) == 3 and pos__b[0] == 'STORE_MAP':
                    cmds[i:i+2] = [('BUILD_MAP', pos__a[1]-1, pos__a[2] + ((pos__b[1], pos__b[2]),))]
                    continue
                if pos__a[1] == 0 and len(pos__a) == 3 :
                    cmds[i] = ('!BUILD_MAP', pos__a[2])
                    continue
                if pos__a[1] > 0 and len(pos__a) == 3 and pos__b[0] == '.L':
                    cmds[i:i+2] = [pos__a]
                    continue  
            if pos_a_0 == 'YIELD_VALUE' and len(pos__a) == 2 and pos__b[0] == 'POP_TOP':
                cmds[i:i+2] = [('YIELD_STMT', pos__a[1])]
                continue
            if pos_a_0 == 'LOAD_LOCALS' and pos__b[0] == 'RETURN_VALUE' and len(pos__b) == 1:
                cmds[i:i+2] = [(pos__b[0], ('f->f_locals',))]
                continue
            if pos_a_0 == 'RAISE_VARARGS' and pos__a[1] == 0 and pos__b[0] == 'POP_TOP':
                cmds[i:i+2] = [('RAISE_VARARGS_STMT',) + pos__a[1:]]
                continue            
            if pos_a_0 == '.:':
                if CountJumpCache(pos__a[1], cmds) == 0:
                    del cmds[i]
                    continue
                if pos__b[0] == 'J_LOOP_VARS' and pos__c[0] == 'JUMP_IF2_FALSE_POP_CONTINUE' and\
                        pos__c[1] == pos__a[1] and isretblock(pos__d) and pos__e[0] == '.:' and pos__b[1] == pos__e[1]:
                    cmds[i:i+5] = [pos__a,pos__b,[('(IF',) + pos__c[2:], pos__d, (')ENDIF',)],('JUMP_CONTINUE', pos__a[1]),pos__e]
                    continue
                if pos__b[0] == 'J_LOOP_VARS' and pos__c[0] == 'JUMP_IF2_FALSE_POP_CONTINUE' and\
                        pos__c[1] == pos__a[1] and isblock(pos__d) and pos__e[0] == '.:' and pos__b[1] == pos__e[1]:
                    cmds[i:i+5] = [pos__a,pos__b,[('(IF',) + pos__c[2:], pos__d, (')(ELSE',), [('CONTINUE',)],(')ENDIF',)],pos__e]
                    continue
                if pos__b[0] == '.:':
                    for iii in range(len(cmds)):
                        if cmds[iii][0][0] == 'J' and cmds[iii][1] == pos__a[1]:
                            li = list(cmds[iii])
                            li[1] = pos__b[1]
                            cmds[iii] = tuple(li)
                    del cmds[i]
                    continue        
    
            if pos_a_0 == 'DUP_TOP' and is_cmdmem(pos__b) and \
            len(pos__c) == 2 and pos__c[0] == 'COMPARE_OP' and pos__c[1] == 'exception match':
                cmds[i:i+3] = [('CHECK_EXCEPTION', cmd2mem(pos__b))]
                continue  
            if pos_a_0 == 'CHECK_EXCEPTION':
                if pos__b[0] == 'JUMP_IF_FALSE_POP' and\
                pos__c[0] == 'POP_TOP3' :
                    cmds[i:i+3] = [('JUMP_IF_NOT_EXCEPTION_POP', pos__b[1], pos__a[1:],())]
                    continue
                if pos__b[0] == 'JUMP_IF_FALSE_POP' and\
                pos__c[0] == 'POP_TOP' and pos__d[0] in set_any and\
                pos__e[0] == 'POP_TOP':
                    cmds[i:i+5] = [('JUMP_IF_NOT_EXCEPTION_POP', pos__b[1], pos__a[1:], (pos__d,))]
                    continue
                if pos__b[0] == 'JUMP_IF_FALSE_POP' and\
                pos__c[0] == 'POP_TOP' and pos__d[0] in ('UNPACK_SEQ_AND_STORE',) and pos__d[1] == 0 and\
                pos__e[0] == 'POP_TOP':
                    cmds[i:i+5] = [('JUMP_IF_NOT_EXCEPTION_POP', pos__b[1], pos__a[1:], pos__d[:])]
                    continue
            if pos_a_0 == 'POP_TOP' and pos__b[0] == 'POP_TOP' and pos__c[0] == 'POP_TOP':
                cmds[i:i+3] = [('POP_TOP3',)]
                continue    
            if pos_a_0 == '!GET_ITER':
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] in ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE') and\
                    pos__e[0] == 'PyList_Append' and \
                    pos__f[0] in ('JUMP', 'JUMP_CONTINUE') and\
                    pos__g[0] == '.:'and\
                    pos__h[0] == ')END_LIST_COMPR':
                        cmds[i:i+8] = [('BASE_LIST_COMPR', pos__e[2:], (pos__c[2], pos__a[1:], (pos__d[2],))),pos__g,pos__h] # vars in for, iter in fors, condidion 
                        continue
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] in ('JUMP_IF2_TRUE_POP', 'JUMP_IF2_TRUE_POP_CONTINUE') and\
                    pos__e[0] == 'PyList_Append' and \
                    pos__f[0] in ('JUMP', 'JUMP_CONTINUE') and\
                    pos__g[0] == '.:'and\
                    pos__h[0] == ')END_LIST_COMPR':
                        cmds[i:i+8] = [('BASE_LIST_COMPR', pos__e[2:], (pos__c[2], pos__a[1:], (Not(pos__d[2]),))),pos__g,pos__h] # vars in for, iter in fors, condidion 
                        continue
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] == 'PyList_Append' and \
                    pos__e[0] in ('JUMP', 'JUMP_CONTINUE') and\
                    pos__f[0] == '.:'and\
                    pos__g[0] == ')END_LIST_COMPR':
                        cmds[i:i+7] = [('BASE_LIST_COMPR', pos__d[2:], (pos__c[2], pos__a[1:], None)),pos__f,pos__g] # vars in for, iter in fors, condidion 
                        continue
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] in ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE') and\
                    pos__e[0] == 'BASE_LIST_COMPR' and\
                    pos__f[0] == '.:' and \
                    pos__g[0] == ')END_LIST_COMPR':
                        cmds[i:i+7] = [('BASE_LIST_COMPR', pos__e[1], (pos__c[2], pos__a[1:], (pos__d[2],)) +pos__e[2]),pos__f,pos__g]
                        continue
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] == 'JUMP_IF2_TRUE_POP' and\
                    pos__e[0] == 'BASE_LIST_COMPR' and\
                    pos__f[0] == '.:' and \
                    pos__g[0] == ')END_LIST_COMPR':
                        cmds[i:i+7] = [('BASE_LIST_COMPR', pos__e[1], (pos__c[2], pos__a[1:], (pos__d[2],)) +pos__e[2]),pos__f,pos__g]
                        continue
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] == 'BASE_LIST_COMPR' and\
                    pos__e[0] == '.:' and \
                    pos__f[0] == ')END_LIST_COMPR':
                        cmds[i:i+6] = [('BASE_LIST_COMPR', pos__d[1], (pos__c[2], pos__a[1:], None) +pos__d[2]),pos__e,pos__f]
                        continue
                if  pos__b[0] == '.:' and\
                    pos__c[0] == 'J_LOOP_VARS' and\
                    pos__d[0] == '.L' and\
                    pos__e[0] == 'BASE_LIST_COMPR' and\
                    pos__f[0] == '.:' and \
                    pos__g[0] == ')END_LIST_COMPR':
                        cmds[i:i+7] = [('BASE_LIST_COMPR', pos__e[1], (pos__c[2], pos__a[1:], None) +pos__e[2]),pos__f,pos__g]
                        continue
            if pos_a_0 == '(BEGIN_LIST_COMPR':
                if pos__b[0] == '.L' and pos__c[0] == 'BASE_LIST_COMPR' and pos__d[0] == ')END_LIST_COMPR':
                    cmds[i:i+4] = [('!LIST_COMPR', pos__c[1], pos__c[2])]
                    continue
                if pos__b[0] == 'BASE_LIST_COMPR' and pos__c[0] == ')END_LIST_COMPR':
                    cmds[i:i+3] = [('!LIST_COMPR', pos__b[1], pos__b[2])]
                    continue
            if pos_a_0 == 'RAISE_VARARGS' and pos__a[1] == 0 and pos__b[0] == 'POP_TOP':
                cmds[i:i+2] = [('RAISE_VARARGS_STMT',) + pos__a[1:]]
                continue
        if type(pos__a) is list and isblock(pos__a):
            if pos__b[0] == 'JUMP_IF2_TRUE_POP_CONTINUE' and islineblock(pos__c):
                if type(pos__c) is tuple:
                    cmds[i:i+3] = [pos__a+[('(IF',) + pos__b[2:], [pos__c,('CONTINUE',)], (')ENDIF',)]]
                    continue
                if type(pos__c) is list:
                    cmds[i:i+3] = [pos__a+[('(IF',) + pos__b[2:], pos__c+[('CONTINUE',)], (')ENDIF',)]]
                    continue
            if pos__b[0] == 'JUMP_IF2_FALSE_POP_CONTINUE' and isretblock(pos__c):
                    cmds[i:i+3] = [pos__a+[('(IF',) + pos__b[2:], pos__c, (')ENDIF',)], ('JUMP_CONTINUE', pos__b[1])]
                    continue
                
        if type(pos__a) is tuple and len(pos__a) >= 1:
            if pos_a_0 == '3CMP_BEG_3':
                if SCmp(cmds,i, ('3CMP_BEG_3', 'JUMP_IF_FALSE', 'POP_TOP', \
                                '>', 'COMPARE_OP', 'JUMP', (':', 1,1), \
                                'ROT_TWO', 'POP_TOP', ('::', 5))):
                    rpl(cmds, [New_3Cmp(('!3CMP',) + pos__a[1:] + (pos__e[1],) + (cmd2mem(pos__d),))])
                    continue
                if SCmp(cmds,i, ('3CMP_BEG_3', 'JUMP_IF_FALSE', \
                                'POP_TOP', '>', 'DUP_TOP', 'ROT_THREE', 'COMPARE_OP', \
                                'JUMP_IF_FALSE')) and pos__b[1] == pos__h[1]:
                    rpl(cmds, [('J_NCMP', pos__h[1]) + pos__a[1:] + (pos__g[1], cmd2mem(pos__d))])
                    continue
                if SCmp(cmds,i, ('3CMP_BEG_3', 'JUMP_IF_FALSE', 'POP_TOP', \
                                '>', 'COMPARE_OP', 'RETURN_VALUE', (':', 1,1), \
                                'ROT_TWO', 'POP_TOP', 'RETURN_VALUE')):
                    rpl(cmds, [('RETURN_VALUE',New_3Cmp(('!3CMP',) + pos__a[1:] + (pos__e[1],) + (cmd2mem(pos__d),)))])
                    continue
            if pos_a_0 == 'J_NCMP':
                if SCmp(cmds,i, ('J_NCMP', \
                                'POP_TOP', '>', 'DUP_TOP', 'ROT_THREE', 'COMPARE_OP', \
                                'JUMP_IF_FALSE')) and pos__a[1] == pos__g[1]:
                    rpl(cmds, [pos__a + (pos__f[1], cmd2mem(pos__c))])
                    continue
                if SCmp(cmds,i, ('J_NCMP', \
                                'POP_TOP', '.L', '>', 'DUP_TOP', 'ROT_THREE', 'COMPARE_OP', \
                                'JUMP_IF_FALSE')) and pos__a[1] == pos__h[1]:
                    rpl(cmds, [pos__a + (pos__g[1], cmd2mem(pos__d))])
                    continue
                if SCmp(cmds,i, ('J_NCMP', 'POP_TOP', \
                                '>', 'COMPARE_OP', 'JUMP', (':', 0,1), \
                                'ROT_TWO', 'POP_TOP', ('::', 4))):       #  1
                    rpl(cmds, [New_NCmp(pos__a[2:] + (pos__d[1], cmd2mem(pos__c)))])
                    continue
                if SCmp(cmds,i, ('J_NCMP', 'POP_TOP', \
                                '.L', '>', 'COMPARE_OP', 'JUMP', (':', 0,1), \
                                'ROT_TWO', 'POP_TOP', ('::', 5))):       #  1
                    rpl(cmds, [New_NCmp(pos__a[2:] + (pos__e[1], cmd2mem(pos__d)))])
                    continue
                if SCmp(cmds,i, ('J_NCMP', 'POP_TOP', \
                                '>', 'COMPARE_OP', 'RETURN_VALUE', (':', 0,1), \
                                'ROT_TWO', 'POP_TOP', 'RETURN_VALUE')):
                    rpl(cmds, [('RETURN_VALUE', New_NCmp(pos__a[2:] + (pos__d[1], cmd2mem(pos__c))))])
                    continue
                if SCmp(cmds,i, ('J_NCMP', 'POP_TOP', \
                                '.L', '>', 'COMPARE_OP', 'RETURN_VALUE', (':', 0,1), \
                                'ROT_TWO', 'POP_TOP', 'RETURN_VALUE')):
                    rpl(cmds, [('RETURN_VALUE', New_NCmp(pos__a[2:] + (pos__e[1], cmd2mem(pos__d))))])
                    continue
            if pos_a_0 == 'LOAD_CODEFUNC' and SCmp(cmds,i, ('LOAD_CODEFUNC', 'MAKE_FUNCTION', '!GET_ITER', 'CALL_FUNCTION_1')) and\
              pos__b[1] == 0 and pos__d[1] == 1: 
                cmds[i:i+4] = [('!GENERATOR_EXPR_NOCLOSURE',) + pos__a[1:] + (pos__c[1],)]
                continue
            if pos_a_0 == '!MK_CLOSURE':
                if pos__b[0] == 'GET_ITER' and\
                pos__c[0] == 'CALL_FUNCTION_1' and pos__c[1] == 1:
                    cmds[i:i+3] = [('!GENERATOR_EXPR',) + pos__a[1:] + (pos__b[1],)]
                    continue   
                if pos__b[0] == '.L':
                    cmds[i:i+2] = [pos__a]
                    continue  
            if pos_a_0 == 'MAKE_CLOSURE' and pos__b[0] == '.L':
                cmds[i:i+2] = [pos__a]
                continue   
    
            if pos_a_0 == 'LOAD_CONST':
                changed_load_const = process_load_const(cmds,i, added_pass)
                if changed_load_const:
                    continue
            if pos_a_0 == 'J_SETUP_FINALLY':
                changed_j_setup_fin = process_j_setup_finally(cmds,i, added_pass)
                if changed_j_setup_fin:
                    process_after_try_detect(cmds,i)
                    continue
            if pos_a_0 == 'J_BEGIN_WITH':
                changed_j_with = process_j_begin_with(cmds,i, added_pass)
                if changed_j_with:
                    continue
            if pos_a_0 == 'J_SETUP_LOOP':
                changed_loop = process_j_setup_loop(cmds,i, added_pass)
                if changed_loop:
                    continue
            if pos_a_0 == 'J_SETUP_LOOP_FOR':
                changed_loopfor = process_j_setup_loop_for(cmds,i)
                if changed_loopfor:
                    continue
            if pos_a_0 == '(BEGIN_TRY':
                changed_exc = process_begin_try(cmds,i)
                if changed_exc:
                    process_after_try_detect(cmds,i)
                    continue
            if pos_a_0 == 'J_SETUP_EXCEPT':
                changed_exc = process_setup_except(cmds,i)
                if changed_exc:
                    process_after_try_detect(cmds,i)
                    continue
            if pos_a_0 in ('JUMP_IF_NOT_EXCEPTION_POP', 'POP_TOP3'):
                changed_exc = process_except_clause(cmds,i)
                if changed_exc:
                    continue
            if is_cmdmem(pos__a):
                if is_cmdmem(pos__b):
                    changed_push = process_push2(cmds,i, added_pass)
                    if changed_push:
                        continue
                else:
                    changed_push = process_push(cmds,i, added_pass)
                    if changed_push:
                        continue
            if pos_a_0 == 'SEQ_ASSIGN_0':   
                if SCmp(cmds,i, ('SEQ_ASSIGN_0', '=')) and pos__a[1] > 0:          
                    rpl(cmds,[('SEQ_ASSIGN_0', pos__a[1]-1, pos__a[2] + (pos__b,), pos__a[3])])
                    continue    
                if SCmp(cmds,i, ('SEQ_ASSIGN_0', 'DUP_TOP')):          
                    rpl(cmds,[('SEQ_ASSIGN_0', pos__a[1]+1, pos__a[2], pos__a[3])])
                    continue    
                if pos__a[1] == 0:      
                    assert len(pos__a) == 4 
                    cmds[i] = ('SEQ_ASSIGN', pos__a[2], pos__a[3])
                    continue    
            if pos__c[0] == 'ROT_TWO':		  
                if pos_a_0 == 'LOAD_FAST' and SCmp(cmds,i, ('LOAD_FAST', '>', 'ROT_TWO')):
                    rpl(cmds,[pos__b[:], pos__a[:]])
                    continue
                if pos_a_0 == 'LOAD_NAME' and SCmp(cmds,i, ('LOAD_NAME', '>', 'ROT_TWO')):
                    rpl(cmds,[pos__b[:], pos__a[:]])
                    continue
            if pos__b[0] == 'J_LOOP_VARS' and pos_a_0 == '.:': 
                if SCmp(cmds,i, ((':', 3,0), 'J_LOOP_VARS', '*n', 'xJUMP_IF2_FALSE_POP_CONTINUE', '*')):
                    rpl(cmds,[pos__a,pos__b,pos__c+[('(IF', Not(pos__d[2])), [('CONTINUE',)], (')ENDIF',)]+pos__e])
                    continue
                if SCmp(cmds,i, ((':', 3,0), 'J_LOOP_VARS', '*n', 'xJUMP_IF2_FALSE_POP_CONTINUE', '*l')):
                    if type(pos__e) is tuple:
                        rpl(cmds,[pos__a,pos__b,pos__c+[('(IF', Not(pos__d[2])), [('CONTINUE',)], (')ENDIF',)],pos__e])
                    else:
                        rpl(cmds,[pos__a,pos__b,pos__c+[('(IF', Not(pos__d[2])), [('CONTINUE',)], (')ENDIF',)]+pos__e])
                    continue
                if SCmp(cmds,i, ((':', 3,0), 'J_LOOP_VARS', '*n', 'xJUMP_IF2_FALSE_POP_CONTINUE')):
                    rpl(cmds,[pos__a,pos__b,pos__c+[('(IF', Not(pos__d[2])), [('CONTINUE',)], (')ENDIF',)]])
                    continue
            if added_pass:   
                if pos_a_0 == 'JUMP' and type(pos__b) is tuple and \
                    pos__b[0] not in ('.:', 'POP_BLOCK', 'END_FINALLY', None, '^^'):
                    del cmds[i+1]
                    continue
                if pos_a_0 == 'RETURN_VALUE' and type(pos__b) is tuple and \
                    pos__b[0] not in ('.:', 'POP_BLOCK', 'END_FINALLY', None, '^^'):
                    del cmds[i+1]
                    continue
            if pos_a_0 == '(BEGIN_DEF':  
                if len(cmds) > 2 and SCmp(cmds,i, ('(BEGIN_DEF', '*r')):
                    del cmds[2:]
                    continue
            if pos_a_0 == 'J_COND_PUSH':  
                if SCmp(cmds,i, ('J_COND_PUSH', 'J_COND_PUSH')) and pos__a[1] == pos__b[1]:
                    rpl(cmds,[pos__a[:] + pos__b[2:]])
                    continue
                if SCmp(cmds,i, ('J_COND_PUSH', '>', ('::', 0))):
                    rpl(cmds,[('!COND_EXPR',) + pos__a[2:] + (cmd2mem(pos__b),)])
                    continue
        i = i + 1   
    if len(cmds) > 2:   
        pp(filename + ":Can't decompile " + cmds[0][1] + ' ' + str( co.co_firstlineno))
        pprint(cmds, 2, 166)
        N2C(cmds[0][1]).decompile_fail = True
        global fast_globals
        if fast_globals:
            fast_globals = False
            restart = True
            Debug('Options --no-fast-globals automate')
            
    else:
        N2C(cmds[0][1]).decompile_fail = False
    return cmds

def process_list_compr_2(cmds,i,added_pass):
    assert type(i) is int and i >= 0

    if SCmp(cmds, i, (('!BUILD_LIST', ()), 'LOAD_FAST', (':', 5, 1),\
                        'J_LOOP_VARS', '!GET_ITER', 'J_BASE_LIST_COMPR', \
                         ('::', 3))):
        if pos__f[3][2] == ():                     
            rpl(cmds, [('!LIST_COMPR', pos__f[2], (pos__d[2], (cmd2mem(pos__b),), None, pos__f[3][0], (pos__e[1],), None))])
            return True   
        else:
            rpl(cmds, [('!LIST_COMPR', pos__f[2], (pos__d[2], (cmd2mem(pos__b),), None, pos__f[3][0], (pos__e[1],), pos__f[3][2]))])
            return True   

    if SCmp(cmds, i, (('!BUILD_LIST', ()), '!GET_ITER', (':', 5, 1),\
                        'J_LOOP_VARS', '!GET_ITER', 'J_BASE_LIST_COMPR', \
                         ('::', 3))):
        if pos__f[3][2] == ():                     
            rpl(cmds, [('!LIST_COMPR', pos__f[2], (pos__d[2], (pos__b[1],), None, pos__f[3][0], (pos__e[1],), None))])
            return True   
        else:
            rpl(cmds, [('!LIST_COMPR', pos__f[2], (pos__d[2], (pos__b[1],), None, pos__f[3][0], (pos__e[1],), pos__f[3][2]))])
            return True   
        
    if SCmp(cmds, i, (('!BUILD_LIST', ()), \
                     '!GET_ITER', (':', 6, 1), 'J_LOOP_VARS', \
                     '!GET_ITER', (':', 8, 1), 'J_LOOP_VARS', \
                     '!GET_ITER', 'J_BASE_LIST_COMPR', ('::', 3))):
        if pos__i[3][2] == ():                     
            rpl(cmds, [('!LIST_COMPR', pos__i[2], (pos__d[2], (pos__b[1],), None,  pos__g[2], (pos__e[1],), None, pos__i[3][0], (pos__h[1],), None))])
            return True   
        else:
            rpl(cmds, [('!LIST_COMPR', pos__i[2], (pos__d[2], (pos__b[1],), None,  pos__g[2], (pos__e[1],), None, pos__i[3][0], (pos__h[1],), pos__i[3][2]))])
            return True   

    if SCmp(cmds, i, (('!BUILD_LIST', ()), \
                     '!GET_ITER', (':', 6, 1), 'J_LOOP_VARS', \
                     '!GET_ITER', (':', 9, 1), 'J_LOOP_VARS', \
                     '!GET_ITER', (':', 11, 1), 'J_LOOP_VARS', \
                     '!GET_ITER', 'J_BASE_LIST_COMPR', ('::', 3))):
        if pos__l[3][2] == ():                     
            rpl(cmds, [('!LIST_COMPR', pos__l[2], (pos__d[2], (pos__b[1],), None,  pos__g[2], (pos__e[1],), None, pos__j[2], (pos__h[1],), None, pos__l[3][0], (pos__k[1],), None))])
            return True   
        else:
            rpl(cmds, [('!LIST_COMPR', pos__l[2], (pos__d[2], (pos__b[1],), None,  pos__g[2], (pos__e[1],), None, pos__j[2], (pos__h[1],), None, pos__l[3][0], (pos__k[1],), pos__l[3][2]))])
            return True   
        

    if SCmp(cmds, i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4,6)),\
                        'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP','!GET_ITER', \
                        'J_BASE_LIST_COMPR', ('::', 3))):
        if pos__g[3][2] == ():                     
            rpl(cmds, [('!LIST_COMPR', pos__g[2], (pos__d[2], (pos__b[1],), (Not(pos__e[2]),), pos__g[3][0], (pos__f[1],), None))])
            return True   
        else:
            rpl(cmds, [('!LIST_COMPR', pos__g[2], (pos__d[2], (pos__b[1],), (Not(pos__e[2]),), pos__g[3][0], (pos__f[1],), pos__g[3][2]))])
            return True                                
                                                                                   
    if SCmp(cmds, i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4,6)),\
                        'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP','!GET_ITER', \
                        'J_BASE_LIST_COMPR', ('::', 3))):
        if pos__g[3][2] == ():                     
            rpl(cmds, [('!LIST_COMPR', pos__g[2], (pos__d[2], (pos__b[1],), (pos__e[2],), pos__g[3][0], (pos__f[1],), None))])
            return True   
        else:
            rpl(cmds, [('!LIST_COMPR', pos__g[2], (pos__d[2], (pos__b[1],), (pos__e[2],), pos__g[3][0], (pos__f[1],), pos__g[3][2]))])
            return True                                
                                                                                   
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', 'J_BASE_LIST_COMPR', ('::', 2))):
        if pos__c[3][1] is None:
            if pos__c[3][2] == ():
                rpl(cmds, [('!LIST_COMPR', pos__c[2], (pos__c[3][0], (pos__b[1],), None))])
                return True   
            else:
                rpl(cmds, [('!LIST_COMPR', pos__c[2], (pos__c[3][0], (pos__b[1],), pos__c[3][2]))])
                return True   

    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', 6,1), \
                    'J_LOOP_VARS', '>', ('LIST_APPEND', 2), 'JUMP', \
                    ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__e),), (pos__d[2], (pos__b[1],), None))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', 6,1), \
                    'J_LOOP_VARS', '>', ('LIST_APPEND', 2), 'JUMP_CONTINUE', \
                    ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__e),), (pos__d[2], (pos__b[1],), None))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', \
            '>', ('LIST_APPEND', 2), 'JUMP',\
            ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (pos__e[2],)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', \
            '>', ('LIST_APPEND', 2), 'JUMP_CONTINUE',\
            ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (pos__e[2],)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP_CONTINUE', \
            '>', ('LIST_APPEND', 2), 'JUMP_CONTINUE',\
            ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (pos__e[2],)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP', \
            '>', ('LIST_APPEND', 2), 'JUMP',\
            ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (Not(pos__e[2]),)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP', \
            '>', ('LIST_APPEND', 2), 'JUMP_CONTINUE',\
            ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (Not(pos__e[2]),)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_LIST', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP_CONTINUE', \
            '>', ('LIST_APPEND', 2), 'JUMP_CONTINUE',\
            ('::', 3))):
        rpl(cmds, [('!LIST_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (Not(pos__e[2]),)))]                )
        return True     
    return False

def process_set_compr_2(cmds,i,added_pass):
    assert type(i) is int and i >= 0
    if SCmp(cmds, i, (('!BUILD_SET', ()), 'LOAD_FAST', (':', 5, 1),\
                        'J_LOOP_VARS', '!GET_ITER', 'J_BASE_SET_COMPR', \
                         ('::', 3))):
        if pos__f[3][2] == ():                     
            rpl(cmds, [('!SET_COMPR', pos__f[2], (pos__d[2], (cmd2mem(pos__b),), None, pos__f[3][0], (pos__e[1],), None))])
            return True   
        else:
            rpl(cmds, [('!SET_COMPR', pos__f[2], (pos__d[2], (cmd2mem(pos__b),), None, pos__f[3][0], (pos__e[1],), pos__f[3][2]))])
            return True   

    if SCmp(cmds, i, (('!BUILD_SET', ()), '!GET_ITER', (':', 5, 1),\
                        'J_LOOP_VARS', '!GET_ITER', 'J_BASE_SET_COMPR', \
                         ('::', 3))):
        if pos__f[3][2] == ():                     
            rpl(cmds, [('!SET_COMPR', pos__f[2], (pos__d[2], (pos__b[1],), None, pos__f[3][0], (pos__e[1],), None))])
            return True   
        else:
            rpl(cmds, [('!SET_COMPR', pos__f[2], (pos__d[2], (pos__b[1],), None, pos__f[3][0], (pos__e[1],), pos__f[3][2]))])
            return True   
 
    if SCmp(cmds, i, (('!BUILD_SET', ()), \
                     '!GET_ITER', (':', 6, 1), 'J_LOOP_VARS', \
                     '!GET_ITER', (':', 8, 1), 'J_LOOP_VARS', \
                     '!GET_ITER', 'J_BASE_SET_COMPR', ('::', 3))):
        if pos__i[3][2] == ():                     
            rpl(cmds, [('!SET_COMPR', pos__i[2], (pos__d[2], (pos__b[1],), None,  pos__g[2], (pos__e[1],), None, pos__i[3][0], (pos__h[1],), None))])
            return True   
        else:
            rpl(cmds, [('!SET_COMPR', pos__i[2], (pos__d[2], (pos__b[1],), None,  pos__g[2], (pos__e[1],), None, pos__i[3][0], (pos__h[1],), pos__i[3][2]))])
            return True   

    if SCmp(cmds, i, (('!BUILD_SET', ()), \
                     '!GET_ITER', (':', 6, 1), 'J_LOOP_VARS', \
                     '!GET_ITER', (':', 9, 1), 'J_LOOP_VARS', \
                     '!GET_ITER', (':', 11, 1), 'J_LOOP_VARS', \
                     '!GET_ITER', 'J_BASE_SET_COMPR', ('::', 3))):
        if pos__l[3][2] == ():                     
            rpl(cmds, [('!SET_COMPR', pos__l[2], (pos__d[2], (pos__b[1],), None,  pos__g[2], (pos__e[1],), None, pos__j[2], (pos__h[1],), None, pos__l[3][0], (pos__k[1],), None))])
            return True   
        else:
            rpl(cmds, [('!SET_COMPR', pos__l[2], (pos__d[2], (pos__b[1],), None,  pos__g[2], (pos__e[1],), None, pos__j[2], (pos__h[1],), None, pos__l[3][0], (pos__k[1],), pos__l[3][2]))])
            return True   
    
    if SCmp(cmds, i, (('!BUILD_SET', ()), '!GET_ITER', (':', (4,6)),\
                        'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP','!GET_ITER', \
                        'J_BASE_SET_COMPR', ('::', 3))):
        if pos__g[3][2] == ():                     
            rpl(cmds, [('!SET_COMPR', pos__g[2], (pos__d[2], (pos__b[1],), (Not(pos__e[2]),), pos__g[3][0], (pos__f[1],), None))])
            return True   
        else:
            rpl(cmds, [('!SET_COMPR', pos__g[2], (pos__d[2], (pos__b[1],), (Not(pos__e[2]),), pos__g[3][0], (pos__f[1],), pos__g[3][2]))])
            return True                                
                                                                                   
    if SCmp(cmds, i, (('!BUILD_SET', ()), '!GET_ITER', (':', (4,6)),\
                        'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP','!GET_ITER', \
                        'J_BASE_SET_COMPR', ('::', 3))):
        if pos__g[3][2] == ():                     
            rpl(cmds, [('!SET_COMPR', pos__g[2], (pos__d[2], (pos__b[1],), (pos__e[2],), pos__g[3][0], (pos__f[1],), None))])
            return True   
        else:
            rpl(cmds, [('!SET_COMPR', pos__g[2], (pos__d[2], (pos__b[1],), (pos__e[2],), pos__g[3][0], (pos__f[1],), pos__g[3][2]))])
            return True                                
                                                                                   
    if SCmp(cmds,i, (('!BUILD_SET', ()), '!GET_ITER', 'J_BASE_SET_COMPR', ('::', 2))):
        if pos__c[3][1] is None:
            if pos__c[3][2] == ():
                rpl(cmds, [('!SET_COMPR', pos__c[2], (pos__c[3][0], (pos__b[1],), None))])
                return True   
            else:
                rpl(cmds, [('!SET_COMPR', pos__c[2], (pos__c[3][0], (pos__b[1],), pos__c[3][2]))])
                return True   
    
    if SCmp(cmds,i, (('!BUILD_SET', ()), 'LOAD_FAST', (':', 6,1), \
                    'J_LOOP_VARS', '>', ('SET_ADD', 2), 'JUMP', \
                    ('::', 3))):
        rpl(cmds, [('!SET_COMPR', (cmd2mem(pos__e),), (pos__d[2], (cmd2mem(pos__b),), None))]                )
        return True     

    if SCmp(cmds,i, (('!BUILD_SET', ()), '!GET_ITER', (':', 6,1), \
                    'J_LOOP_VARS', '>', ('SET_ADD', 2), 'JUMP', \
                    ('::', 3))):
        rpl(cmds, [('!SET_COMPR', (cmd2mem(pos__e),), (pos__d[2], (pos__b[1],), None))]                )
        return True     


    if SCmp(cmds,i, (('!BUILD_SET', ()), '!GET_ITER', (':', 6,1), \
                    'J_LOOP_VARS', '>', ('SET_ADD', 2), 'JUMP_CONTINUE', \
                    ('::', 3))):
        rpl(cmds, [('!SET_COMPR', (cmd2mem(pos__e),), (pos__d[2], (pos__b[1],), None))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_SET', ()), 'LOAD_FAST', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', \
            '>', ('SET_ADD', 2), 'JUMP',\
            ('::', 3))):
        rpl(cmds, [('!SET_COMPR', (cmd2mem(pos__f),), (pos__d[2], (cmd2mem(pos__b),), (pos__e[2],)))]                )
        return True     

    if SCmp(cmds,i, (('!BUILD_SET', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', \
            '>', ('SET_ADD', 2), 'JUMP',\
            ('::', 3))):
        rpl(cmds, [('!SET_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (pos__e[2],)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_SET', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', \
            '>', ('SET_ADD', 2), 'JUMP_CONTINUE',\
            ('::', 3))):
        rpl(cmds, [('!SET_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (pos__e[2],)))]                )
        return True     
    
    if SCmp(cmds,i, (('!BUILD_SET', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP_CONTINUE', \
            '>', ('SET_ADD', 2), 'JUMP_CONTINUE',\
            ('::', 3))):
        rpl(cmds, [('!SET_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (pos__e[2],)))]                )
        return True     

    if SCmp(cmds,i, (('!BUILD_SET', ()), 'LOAD_FAST', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP', \
            '>', ('SET_ADD', 2), 'JUMP',\
            ('::', 3))):
        rpl(cmds, [('!SET_COMPR', (cmd2mem(pos__f),), (pos__d[2], (cmd2mem(pos__b),), (Not(pos__e[2]),)))]                )
        return True     

    if SCmp(cmds,i, (('!BUILD_SET', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP', \
            '>', ('SET_ADD', 2), 'JUMP',\
            ('::', 3))):
        rpl(cmds, [('!SET_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (Not(pos__e[2]),)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_SET', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP', \
            '>', ('SET_ADD', 2), 'JUMP_CONTINUE',\
            ('::', 3))):
        rpl(cmds, [('!SET_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (Not(pos__e[2]),)))]                )
        return True     
    if SCmp(cmds,i, (('!BUILD_SET', ()), '!GET_ITER', (':', (4, 7)),\
            'J_LOOP_VARS', 'JUMP_IF2_TRUE_POP_CONTINUE', \
            '>', ('SET_ADD', 2), 'JUMP_CONTINUE',\
            ('::', 3))):
        rpl(cmds, [('!SET_COMPR', (cmd2mem(pos__f),), (pos__d[2], (pos__b[1],), (Not(pos__e[2]),)))]                )
        return True    
                    
    return False


def process_push(cmds,i,added_pass):
    assert type(i) is int and i >= 0
    aa = cmd2mem(pos__a)

    if pos__a[0] == 'LOAD_FAST':
        if SCmp(cmds,i, ('LOAD_FAST', (':', 4, 1), 'J_LOOP_VARS', '*', 'JUMP', (':', 2, 1))):
            rpl(cmds,[[('(FOR_DIRECT_ITER', aa, pos__c[2]), pos__d, (')FOR_DIRECT_ITER',)]])
            return True       

        if SCmp(cmds,i, ('LOAD_FAST', (':', 5, 1), 'J_LOOP_VARS', '!GET_ITER', (':', 7, 1), \
                         'J_LOOP_VARS', '*', 'JUMP', (':', 2, 1))):
            rpl(cmds,[[('(FOR_DIRECT_ITER2', aa, pos__c[2], pos__d[1]), pos__g, (')FOR_DIRECT_ITER2',)]])
            return True      

        if SCmp(cmds,i, ('LOAD_FAST', (':', 3, 2), 'J_LOOP_VARS', 'JUMP_IF2_FALSE_POP', '!GET_ITER', (':', 8, 1), \
                        'J_LOOP_VARS', '*', 'JUMP', ('::', 2))) and pos__d[1] == pos__g[1]:
            rpl(cmds,[[('(FOR_DIRECT_ITER', aa, pos__c[2]),\
                        [('(IF', pos__d[2]), \
                                [('(FOR', pos__g[2], pos__e[1]), pos__h, (')FOR',)], \
                        (')ENDIF',)], (')FOR_DIRECT_ITER',)]])
            return True   


    if SCmp(cmds,i, ('>', ('BUILD_LIST_FROM_ARG', 0), 'GET_ITER')):
        rpl(cmds,[ ('BUILD_LIST', 0), aa, pos__c])
        return True       

    if type(pos__b) is tuple and len(pos__b) > 0 and type(pos__b[0]) is str and pos__b[0].startswith('J'):
        if SCmp(cmds,i, ('>', 'J_SETUP_WITH', 'POP_TOP')):    
            rpl(cmds,[('J_BEGIN_WITH', pos__b[1], aa, ())])
            return True       
        if SCmp(cmds,i, ('>', 'J_SETUP_WITH', '=')):    
            rpl(cmds,[('J_BEGIN_WITH', pos__b[1], aa, (pos__c,))])
            return True       
        
        
        if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE_OR_POP', '>', (':', 1, 1))):
            rpl(cmds,[Or_j_s(pos__a, pos__c)])
            return True       
        if SCmp(cmds,i, ('>', 'JUMP_IF_FALSE_OR_POP', '>', (':', 1, 1))):
            rpl(cmds,[And_j_s(pos__a, pos__c)])
            return True       
    if pos__a[0] == '!BUILD_TUPLE' and pos__b[0] == 'POP_TOP':
        cmds[i:i+2] = [('UNPUSH', aa)]
        return True
    if pos__b is not None and pos__b[0] == 'DUP_TOP':
        if pos__a[0] == '!BUILD_LIST' and len(pos__a[1]) == 0 and\
            pos__c[0] == 'STORE_FAST' and pos__c[1].startswith('_['): # and pos__d[0] == 'GET_ITER':
            cmds[i:i+3] = [('(BEGIN_LIST_COMPR', ('FAST', pos__c[1]))] #, pos__d[1])]
            return True
        if pos__a[0] == '!BUILD_LIST' and len(pos__a[1]) == 0 and\
            pos__c[0] == 'STORE_NAME' and pos__c[1].startswith('_['):# and pos__d[0] == 'GET_ITER':
            cmds[i:i+3] = [('(BEGIN_LIST_COMPR', ('!NAME', pos__c[1]))] #, pos__d[1])]
            return True

        if SCmp(cmds,i, ('>', 'DUP_TOP', ('LOAD_ATTR_1', '__exit__'), \
                        'ROT_TWO', ('LOAD_ATTR_1', '__enter__'), ('CALL_FUNCTION_1', 0),\
                        'POP_TOP', 'J_SETUP_FINALLY')):
                cmds[i:i+8] = [('J_BEGIN_WITH', pos__h[1], aa,())] 
                return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', ('LOAD_ATTR_1', '__exit__'), 'STORE_FAST',\
                        ('LOAD_ATTR_1', '__enter__'), ('CALL_FUNCTION_1', 0), 'POP_TOP', 'J_SETUP_FINALLY')):
                cmds[i:i+8] = [('J_BEGIN_WITH', pos__h[1], aa,())] 
                return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', ('LOAD_ATTR_1', '__exit__'), \
                        'ROT_TWO', ('LOAD_ATTR_1', '__enter__'), \
                        ('CALL_FUNCTION_1', 0), 'STORE_FAST', \
                        'J_SETUP_FINALLY', 'LOAD_FAST', \
                        'DELETE_FAST', '=')) and pos__g[1] == pos__i[1] and pos__g[1] == pos__j[1]:
                cmds[i:i+11] = [('J_BEGIN_WITH', pos__h[1], aa, (pos__k))] 
                return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', ('LOAD_ATTR_1', '__exit__'), \
                        'ROT_TWO', ('LOAD_ATTR_1', '__enter__'), ('CALL_FUNCTION_1', 0),\
                            'STORE_FAST', 'J_SETUP_FINALLY', 'LOAD_FAST', \
                        ')END_LIST_COMPR', '=')) and pos__g[1] == pos__i[1] and pos__g[1] == pos__j[1][1]:
                cmds[i:i+11] = [('J_BEGIN_WITH', pos__h[1], aa, (pos__k))] 
                return True
            
        if (pos__a[0] == '!LOAD_DEREF' or pos__a[0] == '!LOAD_NAME' or pos__a[0] == '!LOAD_GLOBAL' or \
            pos__a[0] == '!PyDict_GetItem(glob,' or\
             pos__a[0] == 'LOAD_FAST' or pos__a[0] == '!PyObject_GetAttr'):
            cmds[i:i+2] = [pos__a[:], pos__a[:]]
            return True
                    
        if SCmp(cmds,i, ('>', 'DUP_TOP', '=', '=')):
                cmds[i:i+4] = [('SET_EXPRS_TO_VARS', (pos__d,pos__c), ('CLONE', aa))]
                return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', 'UNPACK_SEQ_AND_STORE', '=')) and pos__c[1] == 0:
                cmds[i:i+4] = [('SET_EXPRS_TO_VARS', (pos__d,pos__c), ('CLONE', aa))]
                return True           
        if SCmp(cmds,i, ('>', 'DUP_TOP', '>', 'ROT_TWO', \
                        'PRINT_ITEM_TO_0', 'PRINT_NEWLINE_TO_0')):        
            cmds[i:i+6] = [('PRINT_ITEM_AND_NEWLINE_TO_2', aa, cmd2mem(pos__c))]
            return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', '>', 'ROT_TWO', \
                        'PRINT_ITEM_TO_0', 
                        'DUP_TOP', '>', 'ROT_TWO', 'PRINT_ITEM_TO_0',
                        'PRINT_NEWLINE_TO_0')):        
            cmds[i:i+10] = [('PRINT_ITEM_AND_NEWLINE_TO_3', aa, cmd2mem(pos__c), cmd2mem(pos__g))]
            return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', '>', 'ROT_TWO',  'PRINT_ITEM_TO_0', 'POP_TOP')):        
            rpl(cmds,[('PRINT_ITEM_TO_2', aa, cmd2mem(pos__c))])
            return True 
        if pos__c[0] == 'LOAD_ATTR_1' and is_cmdmem(pos__d) and pos__e[0].startswith('INPLACE_') and pos__f[0] == 'ROT_TWO' and \
           pos__g[0] == 'STORE_ATTR_1'and pos__g[1] == pos__c[1]:   
           
                cmds [i:i+7] = [('STORE', (('PyObject_SetAttr', aa, ('CONST', pos__g[1])),), \
                        (('!' + recode_inplace['INPLACE_ADD'], ('!PyObject_GetAttr', aa, ('CONST', pos__c[1])), cmd2mem(pos__d)),))]
                return True   
        if SCmp(cmds,i, ('>', 'DUP_TOP', 'STORE_GLOBAL', 'STORE_FAST')):
            rpl(cmds,[pos__a, pos__d, ('LOAD_FAST', pos__d[1]), pos__c])
            return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', 'STORE_FAST', 'STORE_GLOBAL')):
            rpl(cmds,[pos__a, pos__c, ('LOAD_FAST', pos__c[1]), pos__d])
            return True
        if SCmp(cmds,i, ('>', 'DUP_TOP', '=')):
                rpl(cmds,[('SEQ_ASSIGN_0', 1, (pos__c,), aa)])
                return True    
        if SCmp(cmds,i, ('>', 'DUP_TOP', 'STORE_FAST')): 
                rpl(cmds,[pos__a, pos__c, ('LOAD_FAST', pos__c[1])])
                return True

    if SCmp(cmds,i, ('!PyObject_GetAttr', 'STORE', 'J_SETUP_FINALLY', \
                    'LOAD_FAST', ')END_LIST_COMPR', '=')) and\
                    pos__a[2][1] == '__exit__' and \
                    pos__b[1][0][1][:2] == '_[' and \
                    pos__d[1] == pos__b[1][0][1]:
            cmds[i:i+6] = [('J_BEGIN_WITH', pos__c[1], pos__a[1], (pos__f,))] 
            return True
    if SCmp(cmds,i, ('!PyObject_GetAttr', 'STORE', 'J_SETUP_FINALLY', '!LOAD_NAME', \
                    ')END_LIST_COMPR', '=')) and pos__a[2][1] == '__exit__' and pos__d[1] == pos__e[1][1]:
            rpl(cmds,[('J_BEGIN_WITH', pos__c[1], pos__a[1], (pos__f))])
            return True

    if isblock(pos__b) and len(pos__b) == 1 and type(pos__b[0]) is tuple:
        cmds[i+1:i+2] = pos__b
        return True

    if  is_cmdmem(pos__c) and pos__b[0] == '.L':
        del cmds[i+1]
        return True
    if pos__c[0] == 'MK_FUNK' and pos__c[2] > 0 and pos__b[0] == '.L':
        cmds[i:i+3] = [('MK_FUNK', pos__c[1], pos__c[2]-1, (aa,)+pos__c[3])]
        return True
    if pos__b[0] == 'MK_FUNK' and pos__b[2] > 0:
        cmds[i:i+2] = [('MK_FUNK', pos__b[1], pos__b[2]-1, (aa,)+pos__b[3])]
        return True
    if pos__b[0] == 'LOAD_CODEFUNC' and pos__c[0] == 'MAKE_CLOSURE':
        cmds[i:i+3] = [('MK_CLOSURE', pos__b[1], pos__c[1], aa, ())]
        return True
    if pos__b[0] == 'MK_CLOSURE' and pos__b[2] > 0:
        cmds[i:i+2] = [('MK_CLOSURE', pos__b[1], pos__b[2]-1, pos__b[3], (aa,)+pos__b[4])]
        return True       

    if SCmp(cmds,i, ('>', 'JUMP', '>', (':', 1, 1))):
        cmds[i:i+4] = [pos__a[:]]
        return True
    if SCmp(cmds,i, ('>', 'JUMP', '>', (':', 1, 2))):
        cmds[i:i+4] = [pos__a[:], pos__d[:]]
        return True

    if pos__b[0] == 'PRINT_ITEM_TO_2' and \
        pos__c[0] == 'DUP_TOP':
        cmds[i:i+3] = [pos__b[:], pos__a, pos__c]
        return True
    if pos__b[0] == 'PRINT_ITEM_TO_2' and \
        pos__c[0] == 'PRINT_NEWLINE_TO_0':
        cmds[i:i+3] = [pos__b[:], ('PRINT_NEWLINE_TO_1', aa)]
        return True
    if pos__b[0] == 'PRINT_NEWLINE_TO_0':
        cmds[i:i+2] = [('PRINT_NEWLINE_TO_1', aa)]
        return True

    if  is_cmdmem(pos__c) and pos__b[0] == '.L':
            cmds[i:i+3] = pos__b, pos__a, pos__c
            return True
    if pos__b[0] == 'STORE_ATTR_1':
        cmds[i:i+2] = [('PyObject_SetAttr', aa, ('CONST', pos__b[1]))]
        return True
    if  pos__b[0] in set_any:
        cmds[i:i+2] = [('STORE',(pos__b,), (aa,))]
        return True
    if pos__b[0] == 'PRINT_ITEM_0':
        cmds[i:i+2] = [('PRINT_ITEM_1',) + (aa,)]
        return True
    if ( pos__b[0] in ('JUMP_IF_FALSE_POP_BREAK','JUMP_IF_FALSE_POP_CONTINUE',\
                    'JUMP_IF_TRUE_POP_BREAK','JUMP_IF_TRUE_POP_CONTINUE',\
                    'JUMP_IF_FALSE_POP', 'JUMP_IF_TRUE_POP') and len(pos__b) == 2 ):
        bb = 'JUMP_IF2_' + pos__b[0][8:]     
        cmds[i:i+2] = [(bb, pos__b[1], aa)]
        return True
    if pos__b[0] == 'RETURN_VALUE' and len(pos__b) == 1:
        cmds[i:i+2] = [pos__b + (aa,)]
        return True
    if pos__b[0] == 'IMPORT_STAR' and len(pos__b) == 1 and pos__a[0] == '!IMPORT_NAME':
        cmds[i:i+2] = make_import_star(aa)
        return True
    if pos__b[0] == 'IMPORT_STAR' and len(pos__b) == 1:
        cmds[i:i+2] = [pos__b + (aa,)]
        return True
    if pos__b[0] == 'GET_ITER'  and len( pos__b) == 1 :
        cmds[i:i+2] = [('!GET_ITER',) + (aa,)]
        return True
    if pos__b[0] == 'BUILD_LIST' and pos__b[1] > 0:
        if len(pos__b) == 2:
            b_ = (pos__b[0], pos__b[1], ())
        else:
            b_ = pos__b    
        cmds[i:i+2] = [('BUILD_LIST', b_[1] - 1, (aa,) + b_[2])]
        return True
    if pos__b[0] == 'BUILD_TUPLE' and pos__b[1] > 0:
        if len(pos__b) == 2:
            b_ = (pos__b[0], pos__b[1], ())
        else:
            b_ = pos__b    
        cmds[i:i+2] = [('BUILD_TUPLE', b_[1] - 1, (aa,) + b_[2])]
        return True
    if pos__b[0] == 'BUILD_SET' and pos__b[1] > 0:
        if len(pos__b) == 2:
            b_ = (pos__b[0], pos__b[1], ())
        else:
            b_ = pos__b    
        cmds[i:i+2] = [('BUILD_SET', b_[1] - 1, (aa,) + b_[2])]
        return True
    if pos__b[0] == 'LOAD_ATTR_1':
        cmds[i:i+2] = [('!PyObject_GetAttr', aa, ('CONST', pos__b[1]))]
        return True
    if pos__b[0] == 'SLICE+0' and len(pos__b) == 1:
        cmds[i:i+2] = [('!PySequence_GetSlice', aa, 0, 'PY_SSIZE_T_MAX')]        
        return True
    if pos__b[0] == 'YIELD_VALUE' and len(pos__b) == 1 and pos__c[0] == 'POP_TOP':
        cmds[i:i+3] = [('YIELD_STMT', aa)]
        return True
    if pos__b[0] == 'YIELD_VALUE' and len(pos__b) == 1:
        cmds[i:i+2] = [('!YIELD_VALUE', aa)]
        return True
    if pos__b[0] == 'RAISE_VARARGS':
        if len(pos__b) == 2 and pos__b[1] == 1 and pos__c[0] == 'POP_TOP':
            cmds[i:i+3] = [('RAISE_VARARGS_STMT', 0, (aa,))]
            return True
        if len(pos__b) == 3 and pos__b[1] == 1 and pos__c[0] == 'POP_TOP':
            cmds[i:i+3] = [('RAISE_VARARGS_STMT', 0, (aa,)+ pos__b[2])]
            return True
        if len(pos__b) == 2 and pos__b[1] == 1:
            cmds[i:i+2] = [('RAISE_VARARGS', 0, (aa,))]
            return True
        if len(pos__b) == 2 and pos__b[1] >= 1:
            cmds[i:i+2] = [('RAISE_VARARGS', pos__b[1]-1, (aa,))]
            return True
        if len(pos__b) == 3 and pos__b[1] >= 1:
            cmds[i:i+2] = [('RAISE_VARARGS', pos__b[1]-1, (aa,) + pos__b[2])]
            return True
    if pos__b[0] in recode_unary:
        cmds[i:i+2] = [('!' +recode_unary[pos__b[0]], aa)]
        return True
    if type(pos__b[0]) is str:    
        if pos__b[0] == 'UNARY_NOT':
            cmds[i:i+2] = [Not(aa)]
            return True
        if pos__b[0].startswith('UNARY_'):
            cmds[i:i+2] = [('!1' + pos__b[0][6:], aa)]
            return True
        if pos__b[0] == 'DELETE_SLICE+0' and len(pos__b) == 1:
                    cmds[i:i+2] = [('DELETE_SLICE+0', aa)]
                    return True
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_1')) and pos__b[1] > 0:
        cmds[i:i+2] =  [(pos__b[0], pos__b[1]-1, (aa,) + pos__b[2], pos__b[3], pos__b[4])]
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_1')) and pos__b[1] == 0 and pos__b[3] == 0:
        if len(pos__b[4]) == 0:
# must be after type dectection             
            if pos__a[0] =='!LOAD_BUILTIN':
                cm = attempt_direct_builtin(pos__a[1],pos__b[2], TupleFromArgs(pos__b[2]))
                if cm is not None:
                    cmds[i:i+2] = [cm]
                    return True
            if len(pos__b[2]) == 0:
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('CONST',()), ('NULL',))]
                return True
            cmds[i:i+2] =  [('!PyObject_Call', aa, TupleFromArgs(pos__b[2]), ('NULL',))]
            return True
        else:
            if len(pos__b[2]) == 0:
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('CONST',()), DictFromArgs(pos__b[4]))]
                return True
            cmds[i:i+2] =  [('!PyObject_Call', aa, TupleFromArgs(pos__b[2]), DictFromArgs(pos__b[4]))]        
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_KW')):
        cmds[i:i+2] =  [('CALL_FUNCTION_KW_1',) + pos__b[1:] + (aa,)]
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_KW_1')) and pos__b[1] > 0:
        cmds[i:i+2] =  [(pos__b[0], pos__b[1]-1, (aa,) + pos__b[2], pos__b[3], pos__b[4], pos__b[5])]
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_KW_1')) and pos__b[1] == 0 and pos__b[3] == 0:
        if len(pos__b[4]) == 0:
            cmds[i:i+2] =  [('!PyObject_Call', aa, TupleFromArgs(pos__b[2]), pos__b[5])]
            return True        
        else:
            cmds[i:i+2] =  [('!PyObject_Call', aa, TupleFromArgs(pos__b[2]), ('!$PyDict_SymmetricUpdate', DictFromArgs(pos__b[4]), pos__b[5]))]
            return True        
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_VAR')):
        cmds[i:i+2] =  [('CALL_FUNCTION_VAR_1',) + pos__b[1:] + (aa,)]
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_VAR_1')) and pos__b[1] > 0:
        cmds[i:i+2] =  [(pos__b[0], pos__b[1]-1, (aa,) + pos__b[2], pos__b[3], pos__b[4], pos__b[5])]
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_VAR_1')) and pos__b[1] == 0 and pos__b[3] == 0:
        if len(pos__b[4]) == 0:
            t = TypeExpr(pos__b[5])
            if len(pos__b[2]) == 0:
                if IsTuple(t):
                    cmds[i:i+2] =  [('!PyObject_Call', aa, pos__b[5], ('NULL',))]
                elif IsList(t):
                    cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyList_AsTuple', pos__b[5]), ('NULL',))]
                else:
                    cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PySequence_Tuple', pos__b[5]), ('NULL',))]
                return True
            if IsTuple(t):
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyNumber_Add', TupleFromArgs(pos__b[2]), pos__b[5]), ('NULL',))]
            elif IsList(t):
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyNumber_Add', TupleFromArgs(pos__b[2]), ('!PyList_AsTuple', pos__b[5])), ('NULL',))]
            else:
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyNumber_Add', TupleFromArgs(pos__b[2]), ('!PySequence_Tuple', pos__b[5])), ('NULL',))]
            return True        
        else:
            t = TypeExpr(pos__b[5])
            if len(pos__b[2]) == 0:
                if IsTuple(t):
                    cmds[i:i+2] =  [('!PyObject_Call', aa, pos__b[5], DictFromArgs(pos__b[4]))]
                elif IsList(t):
                    cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyList_AsTuple', pos__b[5]), DictFromArgs(pos__b[4]))]
                else:
                    cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PySequence_Tuple', pos__b[5]), DictFromArgs(pos__b[4]))]
                return True

            if IsTuple(t):
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyNumber_Add', TupleFromArgs(pos__b[2]), pos__b[5]), DictFromArgs(pos__b[4]))]
            elif IsList(t):
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyNumber_Add', TupleFromArgs(pos__b[2]), ('!PyList_AsTuple', pos__b[5])), DictFromArgs(pos__b[4]))]
            else:
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyNumber_Add', TupleFromArgs(pos__b[2]), ('!PySequence_Tuple', pos__b[5])), DictFromArgs(pos__b[4]))]
            return True        
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_VAR_KW_1')) and pos__b[1] > 0:
        cmds[i:i+2] =  [(pos__b[0], pos__b[1]-1, (aa,) + pos__b[2], pos__b[3], pos__b[4], pos__b[5],pos__b[6])]
        return True       
    if SCmp(cmds,i, ('>', 'CALL_FUNCTION_VAR_KW_1')) and pos__b[1] == 0 and pos__b[3] == 0:
        t = TypeExpr(pos__b[5])
        if len(pos__b[4]) == 0 and len(pos__b[2]) == 0:
            if IsTuple(t):
                cmds[i:i+2] =  [('!PyObject_Call', aa, pos__b[5], pos__b[6])]
            elif IsList(t):
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PyList_AsTuple', pos__b[5]), pos__b[6])]
            else:
                cmds[i:i+2] =  [('!PyObject_Call', aa, ('!PySequence_Tuple', pos__b[5]), pos__b[6])]
            return True        
        if len(pos__b[2]) > 0: 
            if IsTuple(t):
                tup = ('!PyNumber_Add', TupleFromArgs(pos__b[2]), pos__b[5]) 
            elif IsList(t):
                tup = ('!PyNumber_Add', TupleFromArgs(pos__b[2]), ('!PyList_AsTuple',pos__b[5])) 
            else:
                tup = ('!PyNumber_Add', TupleFromArgs(pos__b[2]), ('!PySequence_Tuple',pos__b[5])) 
        else:
            tup = pos__b[5]
        if len(pos__b[4]) > 0: 
            dic = ('!$PyDict_SymmetricUpdate', DictFromArgs(pos__b[4]), pos__b[6])  
        else:
            dic = pos__b[6]            
        cmds[i:i+2] = [('!PyObject_Call', aa, tup, dic)]
        return True       
    if SCmp(cmds,i, ('>', '.L', 'CALL_FUNCTION_1')):
        rpl(cmds,[pos__a,pos__c])
        return True
    if SCmp(cmds,i, ('>', 'POP_TOP')):
        rpl(cmds,[('UNPUSH', aa)])
        return True       
    if SCmp(cmds,i, ('>', 'DELETE_ATTR_1')):
        rpl(cmds,[('DELETE_ATTR_2', aa, ('CONST', pos__b[1]))])
        return True
    if SCmp(cmds,i, ('>', 'STORE_SLICE+0')):
                rpl(cmds,[('STORE_SLICE_LV+0', aa)])
                return True
    if SCmp(cmds,i, ('>', 'BOXING_UNBOXING', 'UNPACK_SEQ_AND_STORE')) and pos__c[1] == 0:
        rpl(cmds,[pos__b,pos__a,pos__c])
        return True
    if SCmp(cmds,i, ('>', 'PRINT_ITEM_TO_2', 'POP_TOP')):        
        rpl(cmds,[('UNPUSH', aa), pos__b])
        return True
    if SCmp(cmds,i, ('>', 'SET_VARS')):
        rpl(cmds,[('SET_EXPRS_TO_VARS', pos__b[1], aa)])
        return True        
    if SCmp(cmds,i, ('>', 'SET_EXPRS_TO_VARS', '=')):
        rpl(cmds,[('SET_EXPRS_TO_VARS', (pos__c,) + pos__b[1], (aa,) + pos__b[2])])
        return True   
    if SCmp(cmds,i, ('LOAD_CONST', 'SET_EXPRS_TO_VARS', 'DUP_TOP')):
        rpl(cmds,[pos__b, pos__a, pos__a])
        return True       
    ('LOAD_CONST', (1, 2)),
    ('SET_EXPRS_TO_VARS', (('STORE_NAME', 'mma'), ('STORE_NAME', 'mmb')), (('CONST', 1), ('CONST', 2))),
    ('DUP_TOP',),         
    if SCmp(cmds,i, ('>', 'SET_EXPRS_TO_VARS', 'SET_VARS')):
        rpl(cmds,[('SET_EXPRS_TO_VARS', (pos__b[1],) + (pos__c[1],), (pos__b[2],) + (aa,))])
        return True        

    if SCmp(cmds,i, ('>', 'STORE', '=')):
        if len(pos__b[1]) == len(pos__b[2]) == 1:
            rpl(cmds,[('SET_EXPRS_TO_VARS', pos__b[1] + (pos__c,), pos__b[2] + (aa,))])
        else:
            assert False   
        return True       
    if SCmp(cmds,i, ('>', 'STORE', 'DUP_TOP')) and pos__b[2] == (aa,):
            rpl(cmds,[('SEQ_ASSIGN_0', 2, pos__b[1], aa)])
            return True    
    if SCmp(cmds,i, ('>', 'STORE', 'DUP_TOP')) and pos__b[2] == aa:
            rpl(cmds,[('SEQ_ASSIGN_0', 2, (pos__b[1],), aa)])
            return True    
    if SCmp(cmds,i, ('!PyDict_New', 'DUP_TOP', '>', 'ROT_TWO', '>', 'STORE_SUBSCR_0')):
        rpl(cmds, [('!BUILD_MAP', ((cmd2mem(pos__e), cmd2mem(pos__c)),))])
        return True
    if SCmp(cmds,i, ('!BUILD_MAP', 'DUP_TOP', '>', 'ROT_TWO', '>', 'STORE_SUBSCR_0')):
        rpl(cmds, [('!BUILD_MAP', pos__a[1] + ((cmd2mem(pos__e), cmd2mem(pos__c)),))])
        return True
    if pos__b is not None and pos__b[0] == 'JUMP_IF_FALSE':
        if pos__b[0] == 'JUMP_IF_FALSE' and pos__c[0] == 'POP_TOP' and is_cmdmem(pos__d): 
            if label(pos__b, pos__e):
                if OneJumpCache(pos__e[1], cmds):
                    cmds[i:i+5] = [And_j_s(aa, pos__d)]
                else:    
                    cmds[i:i+5] = [And_j_s(aa, pos__d), pos__e]
                return True
            if pos__e[0] == 'JUMP_IF_FALSE' and pos__b[1] == pos__e[1] and pos__f[0] == 'POP_TOP':
                cmds[i:i+6] = [And_j_s(aa, pos__d),pos__b,pos__c]
                return True
        if pos__b[0] == 'JUMP_IF_FALSE' and pos__c[0] == 'POP_TOP' and islineblock(pos__d) and\
            is_cmdmem(pos__e): 
                del cmds[i+3]
                return True

        if SCmp(cmds,i, ('>', 'JUMP_IF_FALSE', 'POP_TOP', '3CMP_BEG_3', \
                        'JUMP_IF_FALSE', 'POP_TOP', '>', 'COMPARE_OP', \
                        'RETURN_VALUE', (':', 4,1), 'ROT_TWO', 'POP_TOP',\
                        (':', 1,1), 'RETURN_VALUE')):
            rpl(cmds, [('RETURN_VALUE', And_j_s(pos__a, \
                                                New_3Cmp(('!3CMP', pos__d[1], pos__d[2], pos__d[3], pos__h[1], cmd2mem(pos__g)))))])
            return True

        if SCmp(cmds,i, ('>', 'JUMP_IF_FALSE', 'POP_TOP',\
                        'JUMP_IF2_TRUE_POP_CONTINUE', '>', (':', 1,1),\
                        'JUMP_IF_TRUE_POP_CONTINUE')) and pos__d[1] == pos__g[1]:
                rpl(cmds,[And_j_s(pos__a, Or_j_s(pos__d[2],pos__e)),pos__g])
                return True       
        if SCmp(cmds,i, ('>', 'JUMP_IF_FALSE', 'POP_TOP',\
                        'JUMP_IF2_TRUE_POP', '>', (':', 1,1),\
                        'JUMP_IF_TRUE_POP')) and pos__d[1] == pos__g[1]:
                rpl(cmds,[And_j_s(pos__a, Or_j_s(pos__d[2],pos__e)),pos__g])
                return True       
        if SCmp(cmds,i, ('>', 'JUMP_IF_FALSE', 'POP_TOP', 'JUMP_IF2_FALSE_POP', \
                        '>', (':', 1,1), 'JUMP_IF_TRUE', 'POP_TOP', (':', 3, 1),\
                        '>', ('::', 6))): 
                temp1 = And_j_s(pos__a, pos__d[2])         
                temp2 = And_j_s(temp1, pos__e)
                rpl(cmds,[Or_j_s(temp2, pos__j)])
                return True 
        if SCmp(cmds,i, ('>', 'JUMP_IF_FALSE', 'POP_TOP', '>', 'JUMP')) and pos__b[1] == pos__e[1]:
                rpl(cmds, [And_j_s(pos__a, pos__d), pos__e])
                return True
    if pos__b is not None and pos__b[0] == 'JUMP_IF_TRUE':
        if pos__b[0] == 'JUMP_IF_TRUE' and pos__c[0] == 'POP_TOP' and is_cmdmem(pos__d): 
            if label(pos__b, pos__e):
                if OneJumpCache(pos__e[1], cmds):
                    cmds[i:i+5] = [Or_j_s(aa, pos__d)]
                else:
                    cmds[i:i+5] = [Or_j_s(aa, pos__d), pos__e]
                return True
            if pos__e[0] == 'JUMP_IF_TRUE' and pos__b[1] == pos__e[1] and pos__f[0] == 'POP_TOP':
                cmds[i:i+6] = [Or_j_s(aa, pos__d),pos__b,pos__c]
                return True
        if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE', 'POP_TOP', '3CMP_BEG_3', \
                        'JUMP_IF_FALSE', 'POP_TOP', '>', 'COMPARE_OP', \
                        'RETURN_VALUE', (':', 4,1), 'ROT_TWO', 'POP_TOP',\
                        (':', 1,1), 'RETURN_VALUE')):
            rpl(cmds, [('RETURN_VALUE', Or_j_s(pos__a, \
                                                New_3Cmp(('!3CMP', pos__d[1], pos__d[2], pos__d[3], pos__h[1], cmd2mem(pos__g)))))])
            return True
        if type(pos__j) is tuple and len(pos__j) >= 2 and type(pos__j[1]) is int and SCmp(cmds,i, ('>', 'JUMP_IF_TRUE', 'POP_TOP', 'JUMP_IF2_FALSE_POP', \
                        '>', 'JUMP_IF_TRUE', 'POP_TOP', (':', 3, 1), \
                        '>', (':', 1, 2))) and pos__b[1] == pos__f[1] and CountJumpCache(pos__j[1],cmds) == 2:
                rpl(cmds,[Or_j_s(pos__a, Or_j_s(And_j_s(pos__d[2], pos__e), pos__i))])
                return True                                           
        if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE', 'POP_TOP', 'JUMP_IF2_FALSE_POP', \
                        '>', (':', 1,1), 'JUMP_IF_FALSE_POP')) and pos__d[1] == pos__g[1]:
            rpl(cmds,[Or_j_s(aa, And_j_s(pos__d[2],pos__e)),pos__g])
            return True
        if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE', 'POP_TOP', 'JUMP_IF2_FALSE_POP_CONTINUE', \
                    '>', (':', 1, 1), '=', 'ju')) and pos__d[1] == pos__h[1]:
# re.match_nl or (match_bol and re.nullable)
            rpl(cmds,[Or_j_s(pos__a, And_j_s(pos__d[2],pos__e)),pos__g,pos__h])
            return True       
        if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE', 'POP_TOP', '>', 'JUMP')) and pos__b[1] == pos__e[1]:
                rpl(cmds, [Or_j_s(pos__a, pos__d), pos__e])
                return True
        if SCmp(cmds,i, ('>', 'JUMP_IF_TRUE', 'POP_TOP', 'JUMP_IF2_TRUE_POP', \
                        'LOAD_CONST', (':', 1, 1), 'STORE_FAST', ('::', 3))) and\
                        pos__d[2][0] == 'FAST' and pos__d[2][1] == pos__g[1]:
                rpl(cmds, [Or_j_s(Or_j_s(pos__a, pos__d[2]), pos__e),pos__g])
                return True

    return False

def process_push2(cmds,i,added_pass):
    assert type(i) is int and i >= 0
    assert type(cmds) is list
    aa = cmd2mem(pos__a)
    bb = cmd2mem(pos__b)
    cc = pos__c

    assert type(aa) is tuple
    assert type(bb) is tuple
    if type(cc) is not tuple:
        return False
    cc0 = cc[0]
    cnt_push = 2
    if is_cmdmem(cc):
        cnt_push += 1
        cc = cmd2mem(cc)
        cc0 = cc[0]
        if type(pos__d) is tuple and is_cmdmem(pos__d):
            cnt_push += 1
            if type(pos__e) is tuple and is_cmdmem(pos__e):
                cnt_push += 1
                if type(pos__f) is tuple and is_cmdmem(pos__f):
                    cnt_push += 1
                    if type(pos__g) is tuple and is_cmdmem(pos__g):
                        cnt_push += 1
    if cnt_push == 3:
        if aa == bb:
            if SCmp(cmds,i, ('>', '>', '>', 'ROT_TWO', \
                        'PRINT_ITEM_TO_0', 'PRINT_NEWLINE_TO_0')):
                cmds[i:i+6] = [('PRINT_ITEM_AND_NEWLINE_TO_2', aa, cmd2mem(cc))]
                return True     
            if aa[0] in ('!LOAD_DEREF', '!LOAD_NAME'):
                if SCmp(cmds,i, ('>', '>', '>', 'ROT_TWO', \
                            'PRINT_ITEM_TO_0', 'DUP_TOP')):
                    cmds[i:i+6] = [cc, bb, pos__e, aa, aa ]
                    return True   
                if SCmp(cmds,i, ('>', '>', '>', 'ROT_TWO', \
                                'PRINT_ITEM_TO_0', 'POP_TOP')):
                    cmds[i:i+6] = [cc, bb, pos__e]
                    return True   
        if SCmp(cmds,i, ('>','>', '>', 'BUILD_CLASS')):
                rpl(cmds,[('!_PyEval_BuildClass', cmd2mem(cc), bb, aa)])
                return True
        cc = cmd2mem(cc)
        if pos__d[0] == 'STORE_SUBSCR_0':
                cmds[i:i+4] = [('STORE',(('PyObject_SetItem', bb, cc),), (aa,))]
                return True
        if pos__d[0] == 'SLICE+3' and len(pos__d) == 1:
                cmds[i:i+4] = [('!_PyEval_ApplySlice',) + (aa,) + (bb,) + (cc,)]
                return True
        if pos__d[0] == 'BUILD_SLICE' and len(pos__d) == 2 and pos__d[1] == 3:
                cmds[i:i+4] = [('!PySlice_New', aa, bb, cc)]
                return True
        if pos__d[0] == 'DELETE_SLICE+3':
            cmds[i:i+4] = [('DELETE_SLICE+3', aa, bb, cc)]
            return True
        if pos__d[0] == 'DUP_TOPX' and pos__d[1] == 3:
            cmds[i:i+4] = [aa,bb,cc,aa,bb,cc]
            return True
        if pos__d[0] == 'ROT_THREE' and pos__e[0] in ('STORE_SUBSCR_0', 'STORE_SLICE+2', 'STORE_SLICE+1'):
            cmds[i:i+4] = [cc,aa,bb]
            return True
        if SCmp(cmds,i, ('>','>', '>', '=', '=', '=')):
                    cmds[i:i+6] = [('SET_EXPRS_TO_VARS', (pos__f,pos__e,pos__d), (aa,bb,cc))]
                    return True
        if SCmp(cmds,i, ('>', '>', '>', 'ROT_THREE', 'ROT_TWO', '=', '=', '=')):
                    cmds[i:i+8] = [('SET_EXPRS_TO_VARS', (pos__f,pos__g,pos__h), (aa,bb,cc))]
                    return True
        if SCmp(cmds,i, ('>','>','>', 'EXEC_STMT')):
            rpl(cmds,[('EXEC_STMT_3', aa, bb, cc)])
            return True
        if SCmp(cmds,i, ('>', '>', '>', 'STORE_SLICE+3')):
                    rpl(cmds,[('STORE_SLICE_LV+3', aa, bb, cc)])
                    return True

    if cnt_push == 4:
        if SCmp(cmds,i, ('>', '>', '>', '>', 'ROT_FOUR')):
                rpl(cmds,[pos__d,aa,bb,cc])
                return True       
        if SCmp(cmds,i, ('>', '>','>', '>', '=', '=', '=', '=')):
                    cmds[i:i+8] = [('SET_EXPRS_TO_VARS', \
                                    (pos__h,pos__g,pos__f,pos__e), \
                                    (aa, bb, cc, cmd2mem(pos__d)))]
                    return True
    if cnt_push == 5:
        if SCmp(cmds,i, ('>', '>', '>','>', '>', '=', '=', '=', '=', '=')):
                    cmds[i:i+10] = [('SET_EXPRS_TO_VARS', \
                                     (pos__j,pos__i,pos__h,pos__g,pos__f), \
                                     (aa, bb, cc, cmd2mem(pos__d),cmd2mem(pos__e)))]
                    return True
    if cnt_push == 6:
        if SCmp(cmds,i, ('>', '>', '>', '>','>', '>', '=', '=', '=', '=', '=', '=')):
                    cmds[i:i+12] = [('SET_EXPRS_TO_VARS', \
                                     (pos__l,pos__k,pos__j,pos__i,pos__h,pos__g), \
                                     (aa, bb, cc, cmd2mem(pos__d), cmd2mem(pos__e),cmd2mem(pos__f)))]
                    return True
    if cnt_push == 2:
        if SCmp(cmds,i, ('>', '>', '=', '=')):
                    cmds[i:i+4] = [('SET_EXPRS_TO_VARS', (cc,pos__d), (bb,aa))]
                    return True
   

        if cc0 == 'BUILD_SLICE' and len(cc) == 2 and cc[1] == 2:
                cmds[i:i+3] = [('!PySlice_New', aa, bb, 'NULL')]
                return True
        if cc0 == 'STORE_MAP' and len(cc) == 1:
            cmds[i:i+3] = [('STORE_MAP', bb, aa)]
            return True
        if cc0 == 'ROT_TWO' and pos__d[0] == 'STORE_ATTR_1':
            cmds[i:i+4] = [('STORE', (('PyObject_SetAttr', aa, ('CONST', pos__d[1])),), (bb,))]
            return True
        if cc0 == 'ROT_TWO':
            if aa[0] in ('!LOAD_GLOBAL', 'CONST', 'FAST', '!PyObject_Repr', '!PyObject_GetAttr') or \
               bb[0] in ('!LOAD_GLOBAL', 'CONST', 'FAST', '!PyObject_Repr', '!PyObject_GetAttr'):     
                cmds[i:i+3] = [bb[:], aa[:]]
                return True
        
        if cc0 == 'DELETE_SLICE+1' and len(cc) == 1:
            cmds[i:i+3] = [('DELETE_SLICE+1', aa, bb)]
            return True
        if cc0 == 'IMPORT_NAME' and len(cc) == 2:
                cmds[i:i+3] = [('!IMPORT_NAME', cc[1], aa, bb)]
                return True
        if cc0 == 'COMPARE_OP':
            cmds[i:i+3] = process_compare_op(cc[1],aa,bb)
            return True
        if cc0 == 'LIST_APPEND' and len(cc) == 1:
                cmds[i:i+3] = [('PyList_Append', aa, bb)]
                return True
        if cc0 == 'SLICE+1' and len(cc) == 1:
                if isintconst(bb):
                    cmds[i:i+3] = [('!PySequence_GetSlice', aa, bb[1], 'PY_SSIZE_T_MAX')]
                else:    
                    cmds[i:i+3] = [('!_PyEval_ApplySlice', aa, bb, 'NULL')]
                return True
        if cc0 == 'SLICE+2' and len(cc) == 1:
                if isintconst(bb):
                    cmds[i:i+3] = [('!PySequence_GetSlice', aa, 0, bb[1])]
                else:    
                    cmds[i:i+3] = [('!_PyEval_ApplySlice', aa, 'NULL', bb)]
                return True
        if cc0 == 'BINARY_MODULO' and aa[0] == 'CONST' and \
            type(aa[1]) is str and bb[0] == '!BUILD_TUPLE':        
                cmds[i:i+3] = [('!PyString_Format', aa, bb)]
                return True
        if cc0 == 'BINARY_MULTIPLY' and (aa[0] == '!STR_CONCAT' or (aa[0] == 'CONST' and \
            (type(aa[1]) is str or type(aa[1]) is list or type(aa[1]) is tuple))):
                cmds[i:i+3] = [('!PySequence_Repeat', aa, bb)]
                return True
        if cc0 == 'BINARY_ADD':
            if aa[0] == '!STR_CONCAT' and bb[0] == '!STR_CONCAT':        
                cmds[i:i+3] = [aa + bb[1:]]
                return True
            if aa[0] == '!PyNumber_Add' and bb[0] == '!STR_CONCAT':        
                cmds[i:i+3] = [(bb[0], aa[1], aa[2]) + bb[1:]]
                return True
            if bb[0] == '!PyNumber_Add' and aa[0] == '!STR_CONCAT':        
                cmds[i:i+3] = [(aa[0], aa[1], aa[2]) + bb[1:]]
                return True
            if bb[0] == '!STR_CONCAT':        
                cmds[i:i+3] = [('!STR_CONCAT', aa) + bb[1:]]
                return True
            if aa[0] == '!STR_CONCAT':        
                cmds[i:i+3] = [aa + (bb,)]
                return True
            if bb[0] == 'CONST' and \
                    type(bb[1]) is str and aa[0] == '!PyNumber_Add':        
                cmds[i:i+3] = [('!STR_CONCAT', aa[1], aa[2], bb)]
                return True
            if bb[0] == 'CONST' and \
                    type(bb[1]) is str:        
                cmds[i:i+3] = [('!STR_CONCAT', aa, bb)]
                return True
            if aa[0] == 'CONST' and \
                    type(aa[1]) is str:        
                cmds[i:i+3] = [('!STR_CONCAT', aa, bb)]
                return True
        if cc0 == 'BINARY_SUBSCR' and bb[0] == 'CONST' and \
            type(bb[1]) is int: # and bb[1] >= 0:        
                cmds[i:i+3] = [('!BINARY_SUBSCR_Int', aa, bb)]
                return True
        if cc0 == 'BINARY_SUBSCR' :        
                cmds[i:i+3] = [('!from_ceval_BINARY_SUBSCR', aa, bb)]
                return True
        if cc0 == 'INPLACE_POWER':
                cmds[i:i+3] = [('!PyNumber_InPlacePower', aa, bb, 'Py_None')]
                return True
        if cc0 in recode_inplace:
                cmds[i:i+3] = [('!' +recode_inplace[cc0], aa, bb)]
                return True
        if cc0[:8] == 'INPLACE_':
                cmds[i:i+3] = [('!#=' + cc0[8:], aa, bb)]
                return True
        if cc0 == 'DELETE_SUBSCR' and len(cc) == 1:
                cmds[i:i+3] = [('DELETE_SUBSCR', aa, bb)]
                return True
        if cc0 == 'DUP_TOPX' and cc[1] == 2:
            cmds[i:i+3] = [aa,bb,aa,bb]
            return True
        if cc0 == 'CALL_FUNCTION_KW_1' and cc[3] > 0:
            cmds[i:i+3] =  [(cc0, cc[1], cc[2], cc[3]-1, cc[4] + ((aa, bb),), cc[5])]
            return True       
       
                    
        if cc0 == 'DELETE_SLICE+2' and SCmp(cmds,i, ('>', '>', 'DELETE_SLICE+2')) and len(cc) == 1:
            cmds[i:i+3] = [(cc0, aa, bb)]
            return True                
        if  cc0 == 'ROT_TWO' and SCmp(cmds,i, ('>', '>', 'ROT_TWO', '=', '=')):
                    cmds[i:i+5] = [('SET_EXPRS_TO_VARS', (pos__d,pos__e), (aa,bb))]
                    return True
        if  cc0 == 'CALL_FUNCTION_1' and SCmp(cmds,i, ('>', '>', 'CALL_FUNCTION_1')) and cc[3] > 0:
            cmds[i:i+3] =  [(cc0, cc[1], cc[2], cc[3]-1, cc[4] + ((aa, bb),))]
            return True       
        if  cc0 == 'CALL_FUNCTION_VAR_1' and SCmp(cmds,i, ('>', '>', 'CALL_FUNCTION_VAR_1')) and cc[3] > 0:
            rpl(cmds, [(cc0, cc[1], cc[2], cc[3]-1, cc[4] + ((aa, bb),), cc[5])])
            return True       
        if cc0 == 'CALL_FUNCTION_VAR_KW' and SCmp(cmds,i, ('>', '>', 'CALL_FUNCTION_VAR_KW')):
            cmds[i:i+3] =  [('CALL_FUNCTION_VAR_KW_1',) + cc[1:] + (aa,bb)]
            return True       
        if cc0 == 'CALL_FUNCTION_VAR_KW_1' and SCmp(cmds,i, ('>', '>', 'CALL_FUNCTION_VAR_KW_1')) and cc[3] > 0:
            cmds[i:i+3] =  [(cc0, cc[1], cc[2], cc[3]-1, cc[4] + ((aa, bb),), cc[5],cc[6])]
            return True       
        if cc0 == 'STORE_SLICE+2' and SCmp(cmds,i, ('>','>', 'STORE_SLICE+2')):
            rpl(cmds,[('STORE_SLICE_LV+2', aa, bb)])
            return True
        if cc0 == 'STORE_SLICE+1' and SCmp(cmds,i, ('>', '>', 'STORE_SLICE+1')):
                    rpl(cmds,[('STORE_SLICE_LV+1', aa, bb)])
                    return True
        if cc0 == 'DUP_TOP' and SCmp(cmds,i, ('>','>', 'DUP_TOP', 'ROT_THREE', 'COMPARE_OP')):
            rpl(cmds, [('3CMP_BEG_3', aa, pos__e[1], bb)])
            return True        
        if cc0 == 'DUP_TOP' and SCmp(cmds,i, ('>', '>', 'DUP_TOP', 'EXEC_STMT')):
                rpl(cmds,[('EXEC_STMT_3', aa, bb, bb)])
                return True       

        if cc0 == 'PRINT_ITEM_TO_0':
            cmds[i:i+3] = [('PRINT_ITEM_TO_2', bb,aa)]
            return True

        if cc0 == 'STORE_SUBSCR_0':
                cmds[i:i+3] = [('PyObject_SetItem',) + (aa,) + (bb,)]
                return True
        if cc0 == 'ROT_TWO' and pos__d[0] == 'STORE_SLICE+0':
            cmds[i:i+4] = [bb, aa, pos__d]
            return True


    if cc0 in recode_binary:
        if recode_binary[cc0] == 'PyNumber_Power+Py_None':
            cmds[i:i+3] = [('!PyNumber_Power', aa, bb, 'Py_None')]
        else:    
            pynum = recode_binary[cc0]
            if py_version < 30:
                if pynum in ('PyNumber_Rshift', 'PyNumber_Lshift') and bb[0] == 'CONST' and type(bb[1]) is long and bb[1] >= 0 and bb[1] <= 32:
                    bb = ('CONST', int(bb[1]))
            else:
                if pynum in ('PyNumber_Rshift', 'PyNumber_Lshift') and bb[0] == 'CONST' and type(bb[1]) is int and bb[1] >= 0 and bb[1] <= 32:
                    bb = ('CONST', int(bb[1]))
            cmds[i:i+3] = [('!' +recode_binary[cc0], aa, bb)]
        return True


    return False

imported_modules = {}

def module_dict_to_type_dict(pos__d):
    assert type(pos__d) is dict
    d2 = dict(pos__d)      
    for k in pos__d.keys():
        v = pos__d[k]
        t = type(v)
        if py_version < 30 and t is types.InstanceType:
            t2 = None
            try:
                t2 = (T_OLD_CL_INST, v.__class__.__name__)
            except:
                pass
            if t2 is not None:
                t = t2
        else:
            if type(t) != type:
                t = (T_NEW_CL_INST, v.__class__.__name__)
            else:  
                if t is int:
                    t = Kl_Int
                else:
                    t = (t, None)    
        d2[k] = t
    return d2

def CheckExistListImport(nm, fromlist=None,level=-1):
    global filename
    global need_accurate_frame
    global direct_call
    global restart

    if nm in ('org.python.core',):
        return
    this = None
    if nm + '.py' == filename:
        return    
    if automate_option:
        if 'weakref' in nm or 'thread' in nm or 'traceback' in nm or nm == 'gc':
            if need_accurate_frame != True or direct_call != False:
                need_accurate_frame = True
                direct_call = False
                restart = True
                print('Options --need-accurate-frame --no-direct-call automate (import module ' + nm + ')')
        
    if nm in list_import:
        return    
    if nm in imported_modules:
        this = imported_modules[nm]
    elif nm in sys.modules:
        this = sys.modules[nm]
        imported_modules[nm] = this
        list_import[nm] = module_dict_to_type_dict(this.__dict__)
        FillListImport(this)    
        return
    elif nm in ImportedM:
        v = ImportedM[nm]
        if type(v) is tuple and len(v) == 2:
            return CheckExistListImport(v[0] + '.' + v[1])
        elif type(v) is str and v != nm:
            return CheckExistListImport(v)
        if v != nm:
            Fatal(nm, v)
            assert False
    if this is None:
        try:
            if fromlist is None and level == -1 and nm != '' and attempt_import_info:
                this = _my_import(nm)
                imported_modules[nm] = this
            elif nm == '' and level != -1 and len(fromlist) == 1 and attempt_import_info:
                this = _my_import()
                imported_modules[fromlist[0]] = this
            else:    
                if attempt_import_info:
                    this = None
                    try:
                        this = _my_import(nm,{},{}, fromlist)
                    except RuntimeError:
                        pp(sys.exc_info())
                    if this is not None:
                        imported_modules[nm] = this
                else:
                    return
        except TypeError:
            if nm != '':
                Fatal('', nm, sys.exc_info())
                assert False
            Debug(sys.exc_info()[:2])
            if level == -1:
                Debug('Module %s import unsuccessful2' % nm, fromlist) 
            else:    
                Debug('Module %s relative import unsuccessful2' % nm)
            return     
        except ImportError:
            Debug(sys.exc_info()[:2])
            if level == -1:
                Debug('Module %s import unsuccessful2' % nm, fromlist) 
            else:    
                Debug('Module %s relative import unsuccessful2' % nm)
            return     
        except ValueError:
            Debug(sys.exc_info()[:2])
            if level == -1:
                Debug('Module %s import unsuccessful2' % nm, fromlist) 
            else:    
                Debug('Module %s relative import unsuccessful2' % nm)
            return     
        except RuntimeError:
            Debug(sys.exc_info()[:2])
            if level == -1:
                Debug('Module %s import unsuccessful2' % nm, fromlist) 
            else:    
                Debug('Module %s relative import unsuccessful2' % nm)
            return     
        except NameError:
            Debug(sys.exc_info()[:2])
            if level == -1:
                Debug('Module %s import unsuccessful2' % nm, fromlist) 
            else:    
                Debug('Module %s relative import unsuccessful2' % nm)
            return   
        except:
            pp(nm)
            pp(sys.exc_info())
            if nm != '' and nm[0] != '.':
                Fatal('',nm,sys.exc_info())
                assert False
            return 
        
    nms = nm.split('.')
    s = ''
    old_this = this

    if fromlist is not None and this is not None and this.__name__ == nm:
        assert this.__name__ == nm
        list_import[nm] = module_dict_to_type_dict(this.__dict__)
        imported_modules[nm] = this
    else:   
        pos__d2 = None 
        for v in nms:
            if s != '':
                s += '.'
                if pos__d2 is None or v not in pos__d2:
                    if fromlist is None:
                        Debug('Module %s %s (%s) import unsuccessful3' % (s, v, nm), fromlist) 
                    break
                this = pos__d2[v]
            if this is not None:
                pos__d2 = this.__dict__
                s += v    
                if type(this) is types.ModuleType:  
                    list_import[s] = module_dict_to_type_dict(pos__d2)
                    imported_modules[s] = this
    if old_this is not None:
        FillListImport(old_this)    

def FillListImport(module, nm = None, list_added = []):
    if nm is None:
        assert module is not None
        nm = module.__name__
    if nm not in imported_modules:
        imported_modules[nm] = module
    if nm not in list_import:
        list_import[nm] = module_dict_to_type_dict(module.__dict__)    
    if module in list_added:
        return    
    list_added.append(module)
    for k, v in module.__dict__.items():
        if type(v) is types.ModuleType:
            FillListImport(v, nm + '.' + k, list_added)  
                  

FillListImport(sys)
FillListImport(types)
##FillListImport(pprint)
FillListImport(glob)
## if flag_stat:
    ## FillListImport(traceback)
#FillListImport(gc)
FillListImport(os)
FillListImport(math)
FillListImport(operator)
FillListImport(csv)
##FillListImport(distutils)

def MyImport(nm):
    assert nm is not None
    if type(nm) is str and nm.startswith('__main__'):
        return None, {}
    CheckExistListImport(nm)
    if nm not in imported_modules:
        return None, {}
    this = imported_modules[nm]
    pos__d = this.__dict__
    
    if '.' in nm:
        nms = nm.split('.')
        pos__d = this.__dict__
        if hasattr(this, '__file__') and this.__file__.endswith(nms[-1] + '.pyc'):
            return this, pos__d
        if this.__name__ == nm:
            return this, pos__d
        for i in range(1, len(nms)):
            if nms[i] in this.__dict__ and type(this.__dict__[nms[i]]) is types.ModuleType:
                this = pos__d[nms[i]]
                pos__d = this.__dict__
            else:
                if nms[i] in pos__d:
                    this = pos__d[nms[i]]
                    pos__d = this.__dict__
                else:
                    Debug('Import Error', nm, this, i, nms) 
                    return None, {}
    return this, pos__d


def make_import_star(aa):
    if aa[1] in known_modules and aa[2] == ('CONST', -1):
        d = None
        this, d = MyImport(aa[1])
        if '__all__' in d:
            d2 = {}
            for k in d['__all__']:
                if k in d:
                    d2[k] = d[k]
            d = d2     
        r1 = []
        r2 = []
        for v in d:
            if v not in ('__name__', '__module__', '__file__') and \
                v in count_define_get:
                r1.append(v)
                r2.append(('STORE_NAME', v))
        r1 = ('CONST', tuple(r1))
        r2 = tuple(r2)
        return [('IMPORT_FROM_AS', aa[1], ('CONST', -1), r1, r2)]   
    else:
        Debug('Module %s star import unsuccessful - not in knows' % aa[1])     
    return [('IMPORT_STAR', aa)]

def val_imp(nm, k):
    assert nm is not None
    if nm == filename[:-3]:
        return None
    if nm in ImportedM:
        v = ImportedM[nm]
        if type(v) is tuple and len(v) == 2:
            if v[0] in list_import and v[1] in list_import[v[0]] and not IsModule(list_import[v[0]][v[1]]):
                return None
    this, d = MyImport(nm)
    if this is None:
        if nm in ImportedM:
            v = ImportedM[nm]
            if type(v) is tuple and len(v) == 2:
                return val_imp(v[0] + '.' + v[1], k)
            elif type(v) is str and v != nm:
                return val_imp(v, k)

    if k not in d:

        this, d = MyImport(nm + '.' + k)
        if this is not None and this.__name__ == (nm + '.' + k):
            return this
    if this is None:
        return None    
    return d[k]
    
def _process_compare_op_const(op, pos__a,pos__b):
    try:
        if op == '==':
            return('CONST', pos__a[1] == pos__b[1])              
        if op == '!=':
            return('CONST', pos__a[1] != pos__b[1])              
        if op == '>=':
            return('CONST', pos__a[1] >= pos__b[1])              
        if op == '<=':
            return('CONST', pos__a[1] <= pos__b[1])              
        if op == '<':
            return('CONST', pos__a[1] < pos__b[1])              
        if op == '>':
            return('CONST', pos__a[1] > pos__b[1])              
    except:
        pass    
    return None    

def _process_compare_op(op, a,b):
    flag1, v1 = is_calc_arg(a)
    flag2, v2 = is_calc_arg(b)
    if flag1 and flag2 and op not in('is', 'not is'):
        if op in op_2_c_op:
            ret_ret = calc_expr_2(op_2_c_op[op], v1, v2, ('!PyObject_RichCompare(', a,b, op))
        else:
            ret_ret = calc_expr_2(op, v1, v2, ('!PyObject_RichCompare(', a,b, op))
        if ret_ret is not None:
            return ret_ret     
    if a[0] in ('LOAD_CONST', 'CONST') and b[0] in ('LOAD_CONST', 'CONST'):
        const_r = _process_compare_op_const(op, a,b)
        if const_r is not None:
            return const_r
    if a[0] in ('LOAD_CONST', 'CONST') and type(a[1]) is int:
        if op in ('==', '!='):
            if op in op_2_c_op and op not in('is', 'is not'):
               return('!BOOLEAN', ('!c_' + op_2_c_op[op] + '_Int', cmd2mem(b), cmd2mem(a)))              

    if b[0] in ('LOAD_CONST', 'CONST'):
        if type(b[1]) is int:
            if a[0] == '!PY_SSIZE_T':
                if op in op_2_c_op and op not in('is', 'is not'):
                    return('!BOOLEAN', ('!SSIZE_T' + op, a[1], b[1])) 

            if int(b[1]) == b[1] and \
                op in op_2_c_op and op not in('is', 'is not'):
                return('!BOOLEAN', ('!c_' + op_2_c_op[op] + '_Int', cmd2mem(a), cmd2mem(b)))              
        if type(b[1]) is str:
            if op in ('==', '!='):
                return('!BOOLEAN', ('!c_' + op_2_c_op[op] + '_String', cmd2mem(a), cmd2mem(b)))
        if type(b[1]) is bool:
            if IsBool(TypeExpr(a)): 
                if b[1] and op == '==':
                    return a
                if not b[1] and op == '!=':
                    return a
                if not b[1] and op == '==':
                    return Not(a)
                if b[1] and op == '!=':
                    return Not(a)
# 11.06.2010 !!!
    if a[0] in ('LOAD_CONST', 'CONST') and type(a[1]) is str:
        if op in ('==', '!='):
            return('!BOOLEAN', ('!c_' + op_2_c_op[op] + '_String', cmd2mem(b), cmd2mem(a)))


    if op == 'not in':            
        return Not(('!BOOLEAN', ('!PySequence_Contains(', cmd2mem(b), cmd2mem(a))))
    if op == 'in':            
        return ('!BOOLEAN', ('!PySequence_Contains(', cmd2mem(b), cmd2mem(a)))
    if op == 'is':            
        return ('!BOOLEAN',('!_EQ_', cmd2mem(a), cmd2mem(b)))
    if op == 'is not':            
        return ('!BOOLEAN',('!_NEQ_', cmd2mem(a), cmd2mem(b)))
    return None

def process_compare_op(op, a,b):
    ret = _process_compare_op(op,a,b)
    if ret is not None:
        return [ret]
    if op in op_2_c_op:            
        return [('!PyObject_RichCompare(', cmd2mem(a), cmd2mem(b), op_2_c_op[op])]
    Fatal('Can\'t handle compare_op', op, a, b)
    assert False
    
def process_load_const_test1(cmds):
    try:
        if pos__a[1]:
            rpl(cmds,[pos__a, ('JUMP',) + pos__b[1:], pos__c])
        else:    
            rpl(cmds,[])
        return True
    except:
        pass
    return False

def process_load_const_test2(cmds):
    try:
        if not pos__a[1]:
            rpl(cmds,[pos__a, ('JUMP',) + pos__b[1:], pos__c])
        else:    
            rpl(cmds,[])
        return True
    except:
        pass
    return False

def process_load_const_test3(cmds):
    try:
        if pos__a[1]:
            rpl(cmds,[pos__a, ('JUMP',) + pos__b[1:]])
        else:    
            rpl(cmds,[pos__a])
        return True
    except:
        pass
    return False

def process_load_const_test4(cmds):
    try:
        if not pos__a[1]:
            rpl(cmds,[pos__a, ('JUMP',) + pos__b[1:]])
        else:    
            rpl(cmds,[pos__a])
        return True
    except:
        pass
    return False

def process_load_const(cmds,i,added_pass):
    assert type(i) is int and i >= 0
    if pos__a[0] == 'LOAD_CONST' and pos__b[0] == 'UNPACK_SEQUENCE' and pos__a[1] is not None and pos__b[1] == len(pos__a[1]):
        cmds[i:i+2] = [('LOAD_CONST', x) for x in reversed(pos__a[1])]
        return True
    if pos__a[0] == 'LOAD_CONST' and pos__b[0] == 'STORE':
        cmds[i:i+2] = [pos__b, pos__a]
        return True
    if pos__a[0] == 'LOAD_CONST' and pos__b[0] == 'DUP_TOP':
        cmds[i:i+2] = [pos__a, pos__a[:]]
        return True   
    if SCmp(cmds,i, ('LOAD_CONST', '-')):
        rpl(cmds,[pos__b,pos__a])
        return True     
    if SCmp(cmds,i,('LOAD_CONST', 'JUMP_IF_TRUE', 'POP_TOP')):
        if process_load_const_test1(cmds):
            return True
    if SCmp(cmds,i,('LOAD_CONST', 'JUMP_IF_FALSE', 'POP_TOP')):
        if process_load_const_test2(cmds):
            return True
    if SCmp(cmds,i,('LOAD_CONST', 'JUMP_IF_TRUE')):
        if process_load_const_test3(cmds):
            return True
    if SCmp(cmds,i,('LOAD_CONST', 'JUMP_IF_FALSE')):
        if process_load_const_test4(cmds):
            return True
    return False

def process_j_setup_finally(cmds,i,added_pass):
    assert type(i) is int and i >= 0
    if SCmp(cmds,i, ('J_SETUP_FINALLY', '*', 'POP_BLOCK', 'LOAD_CONST', \
                    (':',0,1), '*', 'END_FINALLY')) and pos__d[1] is None:                                    
            rpl(cmds,[[('(TRY',), pos__b, (')(FINALLY',), pos__f, (')ENDTRY',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', '*', 'POP_BLOCK', 'LOAD_CONST', \
                    (':',0,1), 'END_FINALLY')) and pos__d[1] is None:                                    
            rpl(cmds,[[('(TRY',), pos__b, (')(FINALLY',), [('PASS',)], (')ENDTRY',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', 'POP_BLOCK', 'LOAD_CONST', \
                    (':',0,1), 'END_FINALLY')) and pos__c[1] is None:                                    
            rpl(cmds,[[('(TRY',), [('PASS',)], (')(FINALLY',), [('PASS',)], (')ENDTRY',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', 'JUMP_CONTINUE', 'POP_BLOCK', \
                    'LOAD_CONST', (':', 0, 1), '**n', 'END_FINALLY', \
                    'JUMP_CONTINUE')) and pos__b[1] == pos__h[1]:
            rpl(cmds,[[('(TRY',), [('CONTINUE',)], (')(FINALLY',), pos__f, (')ENDTRY',)],pos__h])
            return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', '*n','JUMP_CONTINUE', 'POP_BLOCK', \
                    'LOAD_CONST', (':', 0, 1), '**n', 'END_FINALLY', \
                    'JUMP_CONTINUE')) and pos__c[1] == pos__i[1]:
            rpl(cmds,[[('(TRY',), pos__b + [('CONTINUE',)], (')(FINALLY',), pos__g, (')ENDTRY',)],pos__h])
            return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', 'POP_BLOCK', 'LOAD_CONST', \
                    (':',0,1), '*', 'END_FINALLY')) and pos__c[1] is None:                                    
            rpl(cmds,[[('(TRY',), [('PASS',)], (')(FINALLY',), pos__e, (')ENDTRY',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', '*r', (':',0,1), '*', 'END_FINALLY')):
        rpl(cmds,[[('(TRY',), pos__b, (')(FINALLY',), pos__d, (')ENDTRY',)]])
        return True
    if SCmp(cmds,i, ('J_SETUP_FINALLY', '*n', 'LOAD_CONST', (':',0,1), \
                    '*', 'END_FINALLY')) and pos__c[1] is None:
        rpl(cmds,[[('(TRY',), pos__b, (')(FINALLY',), pos__e, (')ENDTRY',)]])
        return True



    return False

def process_j_begin_with(cmds,i,added_pass):
    assert type(i) is int and i >= 0
    if SCmp(cmds,i, ('J_BEGIN_WITH', 'POP_BLOCK',('LOAD_CONST', None),\
                    (':', 0, 1), 'WITH_CLEANUP', 'END_FINALLY')):
            rpl(cmds,[[('(WITH',) + pos__a[2:],[('PASS',)], (')ENDWITH',)]])
            return True             
    if SCmp(cmds,i, ('J_BEGIN_WITH', '*', 'POP_BLOCK',('LOAD_CONST', None),\
                    (':', 0, 1), 'WITH_CLEANUP', 'END_FINALLY')):
            rpl(cmds,[[('(WITH',) + pos__a[2:], pos__b, (')ENDWITH',)]])
            return True             
    if SCmp(cmds,i, ('J_BEGIN_WITH', '*', 'JUMP_CONTINUE', 'POP_BLOCK',('LOAD_CONST', None),\
                    (':', 0, 1), 'WITH_CLEANUP', 'END_FINALLY')):
            rpl(cmds,[[('(WITH',) + pos__a[2:], pos__b + [('CONTINUE',)], (')ENDWITH',)]])
            return True             
    if SCmp(cmds,i, ('J_BEGIN_WITH', 'JUMP_CONTINUE', 'POP_BLOCK',('LOAD_CONST', None),\
                    (':', 0, 1), 'WITH_CLEANUP', 'END_FINALLY')):
            rpl(cmds,[[('(WITH',) + pos__a[2:], [('CONTINUE',)], (')ENDWITH',)]])
            return True             
    if SCmp(cmds,i, ('J_BEGIN_WITH', '*l', 'POP_BLOCK',('LOAD_CONST', None),\
                    (':', 0, 1), 'WITH_CLEANUP', 'END_FINALLY')):
            rpl(cmds,[[('(WITH',) + pos__a[2:], [('PASS',)], (')ENDWITH',)]])
            return True             
    if SCmp(cmds,i, ('J_BEGIN_WITH', '*r',\
                    (':', 0, 1), 'WITH_CLEANUP', 'END_FINALLY')):
            rpl(cmds,[[('(WITH',) + pos__a[2:], pos__b, (')ENDWITH',)]])
            return True             
    return False

def process_j_setup_loop(cmds,i,added_pass):
    assert type(i) is int and i >= 0
    if pos__a[0] == 'J_SETUP_LOOP':
        assert type(pos__a) is tuple
        assert type(pos__a[1]) is int
        if len(pos__a) == 2 and pos__b[0] == '!GET_ITER' and len(pos__b) == 2:
            cmds[i:i+2] = [('J_SETUP_LOOP_FOR', pos__a[1], pos__b[1])]
            return True
        if len(pos__a) == 3 and pos__b[0] == '!GET_ITER' and len(pos__b) == 2:
            cmds[i:i+2] = [('.L', pos__a[2]),('J_SETUP_LOOP_FOR', pos__a[1], pos__b[1])]
            return True
        if len(pos__a) == 2 and pos__b[0] == '.L' and pos__c[0] == '!GET_ITER' and len(pos__c) == 2:
            cmds[i:i+3] = [('J_SETUP_LOOP_FOR', pos__a[1], pos__c[1])]
            return True
        if len(pos__a) == 3 and pos__b[0] == '.L' and pos__c[0] == '!GET_ITER' and len(pos__c) == 2:
            cmds[i:i+3] = [('.L', pos__a[2]),('J_SETUP_LOOP_FOR', pos__a[1], pos__c[1])]
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'), 'POP_BLOCK', 'JUMP')) and\
            pos__a[0] != pos__d[1]:
            bod = pos__b[1][:-1]
            assert type(bod) is list
            if len(bod) == 0:
                bod = [('PASS',)]    
            cmds[i:i+4] = [[('(WHILE',) + pos__b[0][1:], bod, (')ENDWHILE',)],pos__d]
            return True
        if isblock(pos__b) and pos__c[0] == 'POP_BLOCK' and \
            pos__d[0] == '.:' and pos__d[1] == pos__a[1] and OneJumpCache(pos__d[1], cmds) and len(pos__b) == 3 and\
            pos__b[0][0] == '(IF' and pos__b[2][0] == ')ENDIF' and type(pos__b[1]) is list:
            cmds[i:i+4] = [[('(WHILE',) + pos__b[0][1:], pos__b[1], (')ENDWHILE',)]]
            return True
        if pos__b[0] == '.:' and pos__c[0] == 'JUMP_IF2_FALSE_POP' and\
            isblock(pos__d) and  pos__e[0] in jump and pos__e[1] == pos__b[1] and \
            pos__f[0] == '.:' and pos__f[1] == pos__c[1] and pos__g[0] == 'POP_BLOCK' and \
            pos__h[0] == '.:' and pos__h[1] == pos__a[1] and\
            OneJumpCache(pos__b[1], cmds) and\
            OneJumpCache(pos__f[1], cmds) and\
            OneJumpCache(pos__a[1], cmds):
            cmds[i:i+8] = [[('(WHILE',) + pos__c[2:], pos__d[:], (')ENDWHILE',)]]
            return True
        if pos__b[0] == '.:' and pos__c[0] == 'JUMP_IF2_FALSE_POP' and\
            isblock(pos__d) and  pos__e[0] in jump and pos__e[1] == pos__b[1] and \
            pos__f[0] == '.:' and pos__f[1] == pos__c[1] and pos__g[0] == 'POP_BLOCK' and \
            pos__h[0] == '.:' and pos__h[1] == pos__a[1] and\
            OneJumpCache(pos__b[1], cmds) and\
            OneJumpCache(pos__f[1], cmds) and\
            CountJumpCache(pos__a[1], cmds) > 1:
            cmds[i:i+8] = [[('(WHILE',) + pos__c[2:], pos__d[:], (')ENDWHILE',)],pos__h]
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', 'LOAD_FAST', (':', 5, 1),\
                        'J_LOOP_VARS', '*', 'JUMP_CONTINUE', (':',3,1),\
                        'POP_BLOCK', ('::', 0))) and pos__b[1][0] == '.':
            rpl(cmds,[[('(FOR_ITER',  pos__d[2], cmd2mem(pos__b)), pos__e, (')ENDFOR_ITER',)]])
            return True            
        if SCmp(cmds,i, ('J_SETUP_LOOP', 'JUMP_IF2_FALSE_POP_CONTINUE', '*r',
                        (':', 1, 1), 'POP_BLOCK', ('::',0))):
                rpl(cmds,[[('(WHILE',) + pos__b[2:] , pos__c, (')ENDWHILE',)]])
                return True   
        if SCmp(cmds,i, ('J_SETUP_LOOP', 'LOAD_FAST', (':', 5, 1), \
                        'J_FOR_ITER',\
                        '*', 'JUMP_CONTINUE', \
                        (':', 3, 1), 'POP_BLOCK', ('::', 0))) and\
            pos__e[0][0] == 'UNPACK_SEQ_AND_STORE' and pos__e[0][1] == 0 and pos__b[1][0] == '.':
                rpl(cmds,[[('(FOR_GENERATOR', pos__e[0][2]), pos__e[1:], (')ENDFOR_GENERATOR',)]])
                return True                   
        if SCmp(cmds,i, ('J_SETUP_LOOP', 'LOAD_FAST', (':', 5, 1), \
                        'J_FOR_ITER',\
                        '*', 'JUMP_CONTINUE', \
                        (':', 3, 1), 'POP_BLOCK', ('::', 0))) and\
            pos__e[0][0] == '.L' and pos__e[1][0] == 'UNPACK_SEQ_AND_STORE' and pos__e[1][1] == 0 and pos__b[1][0] == '.':
                rpl(cmds,[[('(FOR_GENERATOR', pos__e[1][2]), pos__e[2:], (')ENDFOR_GENERATOR',)]])
                return True    
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 3, 1), '*', 'JUMP_CONTINUE', ('::', 0))):
                rpl(cmds,[[('(WHILE', TRUE), pos__c, (')ENDWHILE',)]])
                return True     
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 4,1), 'JUMP_IF2_FALSE_POP', '*',\
                        'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', ('::', 0))) :
                rpl(cmds, [[('(WHILE',) + pos__c[2:], pos__d, (')ENDWHILE',)]])
                return True   
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 4, 1), 'JUMP_IF2_TRUE_POP', \
                        '*', 'JUMP_CONTINUE', (':',2, 1), 'POP_BLOCK', ('::',0))):
            rpl(cmds,[[('(WHILE', Not(pos__c[2])), pos__d, (')ENDWHILE',)]])
            return True
    # {'*' removed
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'), \
                        'POP_BLOCK', '*r', (':',0,1), '*r')):
                rpl(cmds,[[('(WHILE', pos__b[0][1]), pos__b[1], (')(ELSE',), pos__d, (')ENDWHILE',)],pos__f])
                return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*r', ')ENDIF'), \
                        'POP_BLOCK', '*r', (':',0,1), '*r')):
                rpl(cmds,[[('(WHILE', pos__b[0][1]), pos__b[1], (')(ELSE',), pos__d, (')ENDWHILE',)],pos__f])
                return True
    # }end '*' removed
##                return True


        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 3, 1), '*', 'JUMP_CONTINUE',\
                        'POP_BLOCK', '.L', 'RAISE_VARARGS', ('::',0),)):
                rpl(cmds,[[('(WHILE', TRUE), pos__c , (')(ELSE',), [pos__f, pos__g], (')ENDWHILE',)]])
                return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 3, 1), '*', 'JUMP_CONTINUE',\
                        'POP_BLOCK', '*', ('::',0),)):

                rpl(cmds,[[('(WHILE', TRUE), pos__c, (')(ELSE',), pos__f, (')ENDWHILE',)]])
                return True


            
        if SCmp(cmds,i, ('J_SETUP_LOOP',  (':', 3, 1), '*', 'JUMP_CONTINUE', 'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(WHILE', TRUE), pos__c, (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP',  (':', 2, 1), 'JUMP_CONTINUE', 'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(WHILE', TRUE), [('PASS',)]  , (')ENDWHILE',)]])
            return True        
        if SCmp(cmds,i, ('J_SETUP_LOOP',  (':', 3, 1), '*', 'JUMP_CONTINUE')):
            pp('-------+++++++(1')
            rpl(cmds,[[('(WHILE', TRUE), pos__c, (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', '*r', (':', 0,1), 'POP_BLOCK')):
            rpl(cmds,[[('(WHILE', TRUE), pos__b, (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', '*n', ('::', 0))):
            rpl(cmds,[[('(WHILE', TRUE), pos__b, (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', '*r', ('::', 0))):
            rpl(cmds,[[('(WHILE', TRUE), pos__b, (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', '*r', 'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(WHILE', TRUE), pos__b, (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\
                        'POP_BLOCK', '*n', ('::', 0))):
                rpl(cmds,[[('(WHILE',) + pos__b[0][1:], pos__b[1], (')(ELSE',),pos__d,(')ENDWHILE',)]])
                return True   
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 2, 1), 'JUMP_IF2_TRUE_POP_CONTINUE', \
                        'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(WHILE',) + pos__c[2:], [('PASS',)],(')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'), 'POP_BLOCK',\
                        'ju')) and pos__d[1] == pos__a[1]:
            bod = pos__b[1][:-1]
            assert type(bod) is list

            if len(bod) == 0:
                bod = [('PASS',)]    
            rpl(cmds,[[('(WHILE',) + pos__b[0][1:], bod,(')ENDWHILE',)],pos__d])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 4,1), 'JUMP_IF2_FALSE_POP', \
                        '*n', 'J_SETUP_LOOP', (':', 7, 1), '*n', 'JUMP', \
                        (':', 2,1), 'POP_BLOCK', ('::', 0))):
                rpl(cmds,[[('(WHILE',) + pos__c[2:], pos__d + [('(WHILE', TRUE), pos__g, (')ENDWHILE',)], (')ENDWHILE',)]])
                return True       
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\
                        'POP_BLOCK', '*n', 'jc')) and pos__a[1] == pos__e[1]:
                pp('-------+++++++(4')
                rpl(cmds,[[('(WHILE',) + pos__b[0][1:], pos__b[1], (')(ELSE',), pos__d, (')ENDWHILE',)]])
                return True       
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\
                        'POP_BLOCK', '*r', ('::',0))):
                rpl(cmds,[[('(WHILE',) + pos__b[0][1:], pos__b[1], (')(ELSE',), pos__d, (')ENDWHILE',)]])
                return True       
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*r', ')ENDIF'),\
                        'POP_BLOCK', '*n', ('::',0))):
                rpl(cmds,[[('(WHILE',) + pos__b[0][1:], pos__b[1], (')(ELSE',), pos__d, (')ENDWHILE',)]])
                return True    
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'), \
                        'POP_BLOCK', ('::', 0))):       #  4
                rpl(cmds,[[('(WHILE',) + pos__b[0][1:], pos__b[1], (')ENDWHILE',)]])
                return True       
        if SCmp(cmds,i, ('J_SETUP_LOOP', ('!', '.L', '(IF', '*c', ')ENDIF'), \
                        'POP_BLOCK', ('::', 0))):       #  4
                rpl(cmds,[[('(WHILE',) + pos__b[1][1:], pos__b[2], (')ENDWHILE',)]])
                return True       
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 2, 1), 'JUMP_CONTINUE', ('::', 0))):
            rpl(cmds,[[('(WHILE', TRUE), [('PASS',)], (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 2,1), 'JUMP_IF2_TRUE_POP_CONTINUE',\
                        'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(WHILE',) + pos__c[2:], [('PASS',)], (')ENDWHILE',)]])
            return True
        if SCmp(cmds,i, ('J_SETUP_LOOP', (':', 2,1), 'JUMP_IF2_FALSE_POP_CONTINUE',\
                        'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(WHILE', Not(pos__c[2])), [('PASS',)], (')ENDWHILE',)]])
            return True
    return False

def process_jump(cmds,i, added_pass):
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l

    jump = pos__a[0]
    assert type(jump) is str
    assert type(i) is int and i >= 0
    islist_b = type(pos__b) is list
    istuple_b = type(pos__b) is tuple
    iscmdmem_b = istuple_b and is_cmdmem(pos__b)
    if istuple_b and not iscmdmem_b:
        if jump == 'JUMP_IF_TRUE' and pos__b[0] == 'JUMP' and pos__c[0] == '.:' and \
        pos__a[1] == pos__c[1] and pos__b[1] != pos__a[1]:
            assert type(pos__a) is tuple
            if CountJumpCache(pos__a[1], cmds) == 1: 
                    cmds[i:i+3] = [('JUMP_IF_FALSE', pos__b[1])]
            else:      
                    cmds[i:i+3] = [('JUMP_IF_FALSE', pos__b[1]), pos__c]
            return True
        if jump == 'JUMP_IF_FALSE' and pos__b[0] == 'JUMP' and pos__c[0] == '.:' and \
        pos__a[1] == pos__c[1] and pos__b[1] != pos__a[1]:
            assert type(pos__a) is tuple
            if CountJumpCache(pos__a[1], cmds) == 1: 
                    cmds[i:i+3] = [('JUMP_IF_TRUE', pos__b[1])]
            else:      
                    cmds[i:i+3] = [('JUMP_IF_TRUE', pos__b[1]), pos__c]
            return True
            
        if len(pos__a) >= 3 and len(pos__b) >= 3 and pos__a[2] == pos__b[2]:
            if SCmp(cmds,i,('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP')) and pos__a[2] == pos__b[2]:
                rpl(cmds,[pos__a])
                return True
            if SCmp(cmds,i,('JUMP_IF2_TRUE_POP', 'JUMP_IF2_TRUE_POP')) and pos__a[2] == pos__b[2]:
                rpl(cmds,[pos__a])
                return True
        if len(pos__a) >= 2 and len(pos__b) >= 2 and pos__a[1] == pos__b[1]:
            if SCmp(cmds,i,('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP')) and pos__a[1] == pos__b[1]:
                rpl(cmds,[('JUMP_IF2_FALSE_POP', pos__a[1], And_j(pos__a[2], pos__b[2]))])
                return True
            if SCmp(cmds,i,('JUMP_IF2_TRUE_POP', 'JUMP_IF2_TRUE_POP')) and pos__a[1] == pos__b[1]:
                rpl(cmds,[('JUMP_IF2_TRUE_POP', pos__a[1], Or_j(pos__a[2], pos__b[2]))])
                return True
            if SCmp(cmds,i,('JUMP_IF2_TRUE_POP', 'JUMP_IF2_FALSE_POP')) and pos__a[1] == pos__b[1]:
                rpl(cmds,[('JUMP_IF2_TRUE_POP', pos__a[1], Or_j(pos__a[2], Not(pos__b[2])))])
                return True
            if SCmp(cmds,i,('JUMP_IF2_FALSE_POP_CONTINUE', 'JUMP_IF2_FALSE_POP_CONTINUE')) and pos__a[1] == pos__b[1]:
                rpl(cmds,[('JUMP_IF2_FALSE_POP_CONTINUE', pos__a[1], And_j(pos__a[2], pos__b[2]))])
                return True
            if SCmp(cmds,i,('JUMP_IF2_TRUE_POP_CONTINUE', 'JUMP_IF2_TRUE_POP_CONTINUE')) and pos__a[1] == pos__b[1]:
                rpl(cmds,[('JUMP_IF2_TRUE_POP_CONTINUE', pos__a[1], Or_j(pos__a[2], pos__b[2]))])
                return True
            if SCmp(cmds,i,('JUMP_IF2_TRUE_POP_CONTINUE', 'JUMP_IF2_FALSE_POP_CONTINUE')) and pos__a[1] == pos__b[1]:
                rpl(cmds,[('JUMP_IF2_TRUE_POP_CONTINUE', pos__a[1], Or_j(pos__a[2], Not(pos__b[2]) ))])
                return True
            if SCmp(cmds,i,('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP')) and pos__a[1] == pos__b[1]:
                rpl(cmds,[('JUMP_IF2_FALSE_POP', pos__a[1], And_j(pos__a[2], Not(pos__b[2])))])
                return True
            if SCmp(cmds,i,('JUMP_IF2_FALSE_POP_CONTINUE', 'JUMP_IF2_TRUE_POP_CONTINUE')) and pos__a[1] == pos__b[1]:
                rpl(cmds,[('JUMP_IF2_FALSE_POP_CONTINUE', pos__a[1], And_j(pos__a[2], Not(pos__b[2])))])
                return True

    if islist_b and type(pos__c) is tuple:
        if pos__c[0].startswith('J'):
            if SCmp(cmds,i,('xJUMP_IF2_FALSE_POP', '*', 'ju', (':', 0,1), '*', ('::',2))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), pos__e, (')ENDIF',)]])
                return True
        if pos__c[0].startswith('J') or pos__c[0].startswith('.:'):
            if SCmp(cmds,i,('xJUMP_IF2_FALSE_POP', ('!', '.L', '(IF', '*', ')ENDIF'), ('::',0))):
                rpl(cmds,[[('(IF', And_j(pos__a[2], pos__b[1][1])), pos__b[2], (')ENDIF',)]])
                return True
        
            if SCmp(cmds,i,('xJUMP_IF2_FALSE_POP', '*', ('::',0))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)]])
                return True
        
    if jump == 'JUMP_IF2_TRUE_POP':
        if istuple_b and not iscmdmem_b:
            if SCmp(cmds,i,('JUMP_IF2_TRUE_POP','JUMP_IF2_TRUE_POP', ('::', 0))):
                rpl(cmds,[(pos__b[0], pos__b[1], Or_j(pos__a[2], Not(pos__b[2])))])
                return True     
            if SCmp(cmds,i,('JUMP_IF2_TRUE_POP','JUMP_IF2_FALSE_POP', ('::', 0))):
                rpl(cmds,[(pos__b[0], pos__b[1], Or_j(pos__a[2], pos__b[2]))])
                return True     
            if SCmp(cmds,i,('JUMP_IF2_TRUE_POP','JUMP_IF2_FALSE_POP_CONTINUE', ('::', 0))):
                rpl(cmds,[(pos__b[0], pos__b[1], Or_j(pos__a[2], pos__b[2]))])
                return True 
            if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', ('::',0))):  
                rpl(cmds,[('UNPUSH', (pos__a[2]))])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE', (':',0,1), \
                        '*', ('::',1))):
                ifexpr = Or_j(pos__a[2], pos__b[2])
                rpl(cmds,[[('(IF', ifexpr), pos__d, (')ENDIF',), ('CONTINUE',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', 'JUMP_IF2_TRUE_POP', \
                            '*n', 'JUMP', (':', 1,1), '*r', (':', 0,1), '*n',\
                            ('::', 3))):
                rpl(cmds,[[('(IF', Not(pos__a[2])), \
                                    [('(IF',) + pos__b[2:], pos__f,\
                                    (')(ELSE',), pos__c, (')ENDIF',)],\
                                    (')(ELSE',), pos__h, (')ENDIF',)]])
                return True                    
            if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', 'JUMP_CONTINUE', ('::', 0))):
                    rpl(cmds,[('JUMP_IF2_FALSE_POP_CONTINUE', pos__b[1]) + pos__a[2:]])
                    return True             
        if islist_b:    
            if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*', ('::',0))):  
                rpl(cmds,[[('(IF', Not(pos__a[2])), pos__b, (')ENDIF',)]])
                return True        
            if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*', 'JUMP_CONTINUE', (':',0,1), '*', \
                        ('::',2))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__e, (')(ELSE',),pos__b, (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*', 'JUMP', (':',0,1), '*', ('::',2))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__e, (')(ELSE',), pos__b, (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*', 'JUMP_CONTINUE', ('::', 0))):
                rpl(cmds,[[('(IF', Not(pos__a[2])), pos__b + [('CONTINUE',)], (')ENDIF',)]])
                return True
            
            if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*r', '.:', '*r', '.:', '*ra', ('::', 0))): ## and pos__a[1] == pos__g[1]: #, ('::', 0))):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)], pos__c, pos__d, pos__e, pos__f])
                return True  
                        
        if iscmdmem_b:
            if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '>', 'JUMP_IF_FALSE', 'POP_TOP', ('::',0))):
                rpl(cmds,[Or_j_s(pos__a[2], pos__b), pos__c,pos__d])
                return True
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*l', ('::',0))):
            rpl(cmds,[('UNPUSH', pos__a[2])])
            return True            
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', '*l', '>', 'JUMP_IF_FALSE', 'POP_TOP', ('::',0))):
            rpl(cmds,[Or_j_s(pos__a[2], pos__c), pos__d,pos__e])
            return True
      
    elif jump == 'JUMP_IF2_FALSE_POP':
        if pos__b[0][0] == 'J':
            if pos__b[0] == 'J_SETUP_LOOP':
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\
                                'POP_BLOCK', 'JUMP', (':', 0,0))):       #  1
                    rpl(cmds,[pos__a,[('(WHILE',) + pos__c[0][1:], pos__c[1], (')ENDWHILE',)],pos__e,pos__f])
                    return True
                if type(pos__f) is tuple and len(pos__f) >= 2 and type(pos__f[1]) is int and SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\
                                'POP_BLOCK', '*n', (':', (0,1),0))) and CountJumpCache(pos__f[1],cmds) == 2:       #  1
                    rpl(cmds,[pos__a,[('(WHILE',) + pos__c[0][1:], pos__c[1], (')(ELSE',), pos__e, (')ENDWHILE',)],pos__f])
                    return True
                if type(pos__f) is tuple and len(pos__f) >= 2 and type(pos__f[1]) is int and SCmp(cmds,i, ('JUMP_IF2_TRUE_POP', 'J_SETUP_LOOP', ('!', '(IF', '*c', ')ENDIF'),\
                                'POP_BLOCK', '*n', (':', (0,1),0))) and CountJumpCache(pos__f[1],cmds) == 2:       #  1
                    rpl(cmds,[pos__a,[('(WHILE',) + pos__c[0][1:], pos__c[1], (')(ELSE',), pos__e, (')ENDWHILE',)],pos__f])
                    return True
            if SCmp(cmds,i,('JUMP_IF2_FALSE_POP','JUMP_IF2_FALSE_POP', ('::', 0))):
                rpl(cmds,[(pos__b[0], pos__b[1], Or_j(Not(pos__a[2]), pos__b[2]))])
                return True 
            
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP_CONTINUE', '*l', ('::',0))):
                rpl(cmds,[(pos__b[0], pos__b[1], And_j(pos__a[2], pos__b[2])),pos__c])
                return True     
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP_CONTINUE', ('::',0))):
                rpl(cmds,[(pos__b[0], pos__b[1], And_j(pos__a[2], pos__b[2]))])
                return True     
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', (':',0,1),\
                        'JUMP_IF2_FALSE_POP', (':', 1,1), '*', 'JUMP_CONTINUE', ('::',3))):
                tt = Or_j( And_j(pos__a[2], pos__b[2]),pos__d[2])
                rpl(cmds,[[('(IF', tt), pos__f + [('CONTINUE',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', (':',0,1),\
                        'JUMP_IF2_FALSE_POP', ('::', 1))):
                tt = Or_j( And_j(pos__a[2], pos__b[2]),pos__d[2])
                rpl(cmds,[('JUMP_IF2_FALSE_POP', pos__d[1], tt) + pos__a[2:]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_CONTINUE', ('::',0))):
                rpl(cmds,[[('(IF',) + pos__a[2:], [('CONTINUE',)], (')ENDIF',)]])
                return True    
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP', ('::',0))):
                rpl(cmds,[('JUMP_IF2_TRUE_POP', pos__b[1]) + pos__a[2:]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE', '*r',\
                        (':',0,1), 'JUMP_IF2_FALSE_POP_CONTINUE', '*r')) and pos__e[1] == pos__b[1]:
                rpl(cmds,[[('(IF',) + pos__a[2:],
                                [('(IF',) +pos__b[2:], pos__c, (')ENDIF',)], (')(ELSE',),\
                                [('(IF',) +pos__e[2:], pos__f, (')ENDIF',)], (')ENDIF',)], ('JUMP_CONTINUE', pos__b[1])])
                return True 
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE', \
                        (':', 0,1), '*n', ('::',1))):
                rpl(cmds,[[('(IF',) + pos__a[2:], [('(IF', Not(pos__b[2])), [('CONTINUE',)], (')ENDIF',)], (')(ELSE',), pos__d,(')ENDIF',)],pos__e])
                return True             
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', (':', 5,1),\
                            'J_LOOP_VARS', '*n', 'JUMP_CONTINUE', (':', 3,1), \
                            'POP_BLOCK', '*r', (':', 0, 1))):
                    rpl(cmds,[pos__a, [('(FOR', pos__d[2], pos__b[2]) , pos__e, (')(ELSE',),pos__i, (')ENDFOR',)],pos__j])
                    return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', (':', 5,1),\
                            'J_LOOP_VARS', '*n', 'JUMP_CONTINUE', (':', 3,1),\
                            'POP_BLOCK', 'JUMP', (':', 0,1))):
                    rpl(cmds,[pos__a, [('(FOR', pos__d[2], pos__b[2]) , pos__e, (')ENDFOR',)],pos__i,pos__j])
                    return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', ('::',0))):
                rpl(cmds,[('JUMP_IF2_TRUE_POP', pos__b[1], And_j(pos__a[2], pos__b[2]))])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP', '*n', 'JUMP',\
                            (':', 1,1), '*n', 'JUMP_CONTINUE', (':', (0,3), 2))):
                rpl(cmds,[pos__a,[('(IF',) + pos__b[2:], pos__c, (')(ELSE',),pos__f +[('CONTINUE',)], (')ENDIF',)],pos__h])
                return True
            if  SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', '*r', \
                                (':', 0,1), '*n', ('::', 1))):
                rpl(cmds,[[('(IF',) + pos__a[2:],[('(IF', Not(pos__b[2])), pos__c, (')ENDIF',)],
                                (')(ELSE',), pos__e, (')ENDIF',)  ]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE', ('::', 0))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], [('(IF', Not(pos__b[2])), [('CONTINUE',)], (')ENDIF',)],\
                                    (')ENDIF',)]])
                    return True  
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE', '*r', ('::', 0))):
                    rpl(cmds,[[('(IF',Not(pos__a[2])), [('(IF',) + pos__b[2:], [('CONTINUE',)], (')ENDIF',)] + pos__c,\
                                    (')ENDIF',)]])
                    return True  
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', \
                            '*n', 'JUMP', (':', 1,1), '*r', (':', 0,1), '*n',\
                            ('::', 3))):
                rpl(cmds,[[('(IF',) + pos__a[2:], \
                                    [('(IF',) + pos__b[2:], pos__f,\
                                    (')(ELSE',), pos__c, (')ENDIF',)],\
                                    (')(ELSE',), pos__h, (')ENDIF',)]])
                return True                    
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP_CONTINUE', \
                            '*n', 'JUMP', (':', 0,1), '*n', ('::', 3))):
                rpl(cmds,[[('(IF',) + pos__a[2:], \
                                [('(IF',) + pos__b[2:], pos__c, (')(ELSE',), [('CONTINUE',)],(')ENDIF',)],\
                                (')(ELSE',), pos__f, (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', \
                            '*r', (':', 1, 1), '*n', ('::', (0,2)))):
                    rpl(cmds,[[('(IF',) + pos__a[2:],\
                                        [('(IF',) + pos__b[2:],  \
                                        [('(IF', Not(pos__c[2])), pos__d, (')ENDIF',)],\
                                        (')(ELSE',), pos__f, (')ENDIF',)],\
                                    (')ENDIF',)]])
                    return True       
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', '*n', 'JUMP',\
                            (':', 0,1), '*n', (':', 3,2), ('::',1))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], \
                                        [('(IF',) + pos__b[2:], [('CONTINUE',)], (')ENDIF',)] + pos__c, \
                                    (')(ELSE',), pos__f, (')ENDIF',)], pos__g,pos__h])
                    return True       
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', 'JUMP_IF2_TRUE_POP', '*n', 'JUMP',\
                            (':', 0,1), '*n', (':', 3,1), ('::',1))) and pos__b[1] == pos__h[1]:
                    rpl(cmds,[[('(IF',) + pos__a[2:], \
                                        [('(IF',) + pos__b[2:], [('CONTINUE',)], (')ENDIF',)] + pos__c, \
                                    (')(ELSE',), pos__f, (')ENDIF',)], pos__h])
                    return True       
        elif islist_b:
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*r')):
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)], ('JUMP', pos__a[1])])
                return True                         
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*l', ('::',0))):
                if type(pos__b) is tuple:
                    rpl(cmds,[[pos__b, ('UNPUSH', pos__a[2])]])
                    return True
                if type(pos__b) is list:
                    rpl(cmds,[pos__b + [('UNPUSH', pos__a[2])]])
                    return True
            if type(pos__c) is tuple and pos__c[0].startswith('J'):
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_IF2_FALSE_POP', '*', ('::', (0,2)))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b+ [('(IF',) + pos__c[2:], pos__d, (')ENDIF',)], (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'ju', (':', 0,1), 'JUMP_IF2_FALSE_POP',\
                            '*', ('::', (2,4)))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), [('(IF',) + pos__e[2:], pos__f, (')ENDIF',)],(')ENDIF',)]])
                    return True 

                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'ju', (':', 0,1), 'JUMP_IF2_TRUE_POP',\
                            '*r')) and pos__c[1] == pos__e[1]:
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',), ('(IF',) + (('!1NOT', pos__e[2]),), pos__f, (')ENDIF',)], pos__c])
                    return True 
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'ju', (':', 0,1), 'JUMP_IF2_FALSE_POP',\
                            '*r')) and pos__c[1] == pos__e[1]:
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',), ('(IF',) + pos__e[2:], pos__f, (')ENDIF',)], pos__c])
                    return True 

                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_CONTINUE', ('::',0))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b+ [('CONTINUE',)], (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_CONTINUE', (':', 0, 1), \
                            '*', ('::',2))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), pos__e, (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_CONTINUE', (':', 0, 2), \
                            '*', ('::',2))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + [('CONTINUE',)], (')ENDIF',)],pos__d,pos__e])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP', (':',0,1), '*', ('::',2))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), pos__e, (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*l', 'J_SETUP_LOOP_FOR')):
                    rpl(cmds,[pos__a,pos__c])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_IF2_FALSE_POP_CONTINUE', '*r',\
                            ('::', 0))):
                    rpl(cmds,[[('(IF',) +pos__a[2:] ,pos__b+ [('(IF',) + pos__c[2:], pos__d, \
                                            (')ENDIF',), ('CONTINUE',)], (')ENDIF',)]])
                    return True 
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_IF2_FALSE_POP_CONTINUE', '*',\
                            ('::', 0))):
                    rpl(cmds,[[('(IF',) +pos__a[2:] ,pos__b+ [('(IF',) + pos__c[2:], pos__d, \
                                            (')(ELSE',), [('CONTINUE',)], \
                                            (')ENDIF',)], (')ENDIF',)]])
                    return True 
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*', 'JUMP_IF2_FALSE_POP_CONTINUE', '*l',\
                            ('::',0,))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), \
                                    [('(IF', Not(pos__c[2])), [('CONTINUE',)], (')ENDIF',)], \
                                    (')ENDIF',)]])
                    return True        
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'J_SETUP_LOOP_FOR', \
                                (':', 6,1), 'J_LOOP_VARS', '*n', 'ju', (':', 4,1),\
                                'POP_BLOCK', 'ju', (':', 0,1))) and pos__c[1] != pos__j[1]:
                        rpl(cmds,[pos__a, pos__b+[('(FOR', pos__e[2], pos__c[2]) , pos__f, (')ENDFOR',)],pos__j,pos__k])
                        return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0, 1),\
                                'JUMP_IF2_FALSE_POP_CONTINUE', '*n', ('::', 2))):       #  1
                    rpl(cmds,[[('(IF',) +pos__a[2:], pos__b, (')(ELSE',), [('(IF', Not(pos__e[2])), [('CONTINUE',)], (')ENDIF',)] + pos__f, (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_IF2_FALSE_POP_CONTINUE', ('::', 0))):
                        rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + [('(IF', Not(pos__c[2])), [('CONTINUE',)], (')ENDIF',)],\
                                        (')ENDIF',)]])
                        return True  
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_IF2_TRUE_POP', '*n',\
                                'JUMP_CONTINUE', ('::', (0,2)))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + [('(IF', Not(pos__c[2])), pos__d+[('CONTINUE',)], (')ENDIF',)],\
                                        (')ENDIF',)]])
                    return True              
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_IF2_TRUE_POP', '*r',\
                                (':', 0, 1), '*n', ('::', 2))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + [('(IF', Not(pos__c[2])), pos__d, (')ENDIF',)], (')(ELSE',), pos__f,(')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_IF2_FALSE_POP', '*r',\
                                (':', 0, 1), '*n', ('::', 2))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + [('(IF',) +pos__c[2:], pos__d, (')ENDIF',)], (')(ELSE',), pos__f, (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1),\
                                'JUMP_IF2_FALSE_POP', '*n', ('::', 2))) and islooplabel(pos__e[1],cmds):       #  1
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), \
                                    [('(IF',) + pos__e[2:], pos__f, (')(ELSE',), [('CONTINUE',)], (')ENDIF',)], (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'ju', (':', 0,1), ('::',2))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1), \
                                'JUMP_CONTINUE',  ('::', 2))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), [('CONTINUE',)], (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_IF2_FALSE_POP', 'jc', \
                                (':', 0,1), '*n', ('::', 2))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], \
                                    pos__b + [('(IF',) + pos__c[2:], [('CONTINUE',)], (')ENDIF',)],(')(ELSE',), pos__f, (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'ju', (':', 0,1), \
                                'JUMP_IF2_FALSE_POP_CONTINUE', '*n', ('::', 2))):
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), \
                                    [('(IF',) + pos__e[2:], pos__f, (')(ELSE',),[('CONTINUE',)], (')ENDIF',)]]])
                    return True
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_IF2_FALSE_POP', \
                                '*n', 'jc', (':', 0,1), '*n', ('::', 2))) and pos__e[1] not in (pos__f[1],pos__h[1]):
                        rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + \
                                            [('(IF',) + pos__c[2:], pos__d+ [('CONTINUE',)], (')ENDIF',)], \
                                        (')(ELSE',), pos__g, (')ENDIF',)]])
                        return True       
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', \
                                'JUMP_IF2_FALSE_POP', '*n', 'JUMP', \
                                (':', 2,1), '*n', 'JUMP_CONTINUE', \
                                (':', 0,1), '*n', ('::', 4))):
                        rpl(cmds,[[('(IF',) + pos__a[2:], pos__b +\
                                            [('(IF',) + pos__c[2:], pos__d, (')(ELSE',),
                                                    pos__g + [('CONTINUE',)], (')ENDIF',)],\
                                            (')(ELSE',), pos__j, (')ENDIF',)]])
                        return True 
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n','xJUMP_IF2_TRUE_POP', '*n', 'JUMP',\
                                (':', 0,1), '*n', (':', 4,2), ('::', 2))):
                        rpl(cmds,[[('(IF',) + pos__a[2:], pos__b +\
                                            [('(IF',) + pos__c[2:], [('CONTINUE',)], (')ENDIF',)] + pos__d, \
                                        (')(ELSE',), pos__g, (')ENDIF',)], pos__h,pos__i])
                        return True       
                if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'JUMP_CONTINUE', (':', 0, 1),\
                                '*n', 'JUMP_CONTINUE')) and pos__c[1] == pos__f[1]:
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b , (')(ELSE',), pos__e , (')ENDIF',)], pos__f])
                    return True  
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'jc', (':', 0,1), '*n',\
                            (':', None, 0), ('::',2))) and pos__c[1] != pos__f[1] and pos__a[1] != pos__f[1]:    
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')(ELSE',), pos__e, (')ENDIF',)], ('JUMP_CONTINUE', pos__c[1]), pos__f,('JUMP_CONTINUE', pos__c[1])])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', 'jc', ('::', 0))):     
                rpl(cmds,[[('(IF',) + pos__a[2:], pos__b + [('CONTINUE',)], (')ENDIF',)]])
                return True
            if type(pos__k) is tuple and len(pos__k) >= 2 and type(pos__k[1]) is int and SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n', \
                            'JUMP_IF2_FALSE_POP', '*n', \
                            'JUMP_IF2_FALSE_POP', '*n', \
                            'JUMP_IF2_TRUE_POP', '*r', \
                            (':', 2,1), '*r', \
                            (':', (0, 4, 6), 2), '*r')) and CountJumpCache(pos__k[1],cmds) == 3:
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b +\
                                        [('(IF',) + pos__c[2:], pos__d +\
                                                [('(IF',) + pos__e[2:], pos__f +\
                                                    [('(IF', Not(pos__g[2])), pos__h, (')ENDIF',)],\
                                                (')ENDIF',)],\
                                        (')(ELSE',), pos__j, \
                                        (')ENDIF',)],\
                                    (')ENDIF',)] +pos__l])            
                    return True    
            if type(pos__j) is tuple and len(pos__j) >= 2 and type(pos__j[1]) is int and SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '*n',\
                            'JUMP_IF2_TRUE_POP', \
                            'JUMP_IF2_FALSE_POP', '*n',\
                            'JUMP_IF2_FALSE_POP', 'JUMP_CONTINUE', \
                            (':', 3,1), '*n', \
                            (':', (0,2, 5)))) and CountJumpCache(pos__j[1],cmds) == 3:
                    rpl(cmds,[[('(IF',) + pos__a[2:], pos__b +\
                                        [('(IF',) + pos__c[2:], [('PASS',)], (')(ELSE',),\
                                                [('(IF',) + pos__d[2:], pos__e +\
                                                    [('(IF',) + pos__f[2:], [('CONTINUE',)], (')ENDIF',)],\
                                                (')(ELSE',), pos__i,
                                                (')ENDIF',)],\
                                        (')ENDIF',)],\
                                    (')ENDIF',)]])           
                    return True 

                      
        elif iscmdmem_b:
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '>', 'JUMP_IF_TRUE', 'POP_TOP',\
                        (':', 0,1), '>', ('::', 2))):
                rpl(cmds,[Or_j_s(And_j_s(pos__a[2], pos__b),pos__f)])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '>', 'JUMP', (':', 0, 1), '*l', '>', ('::', 2))):
                rpl(cmds,[('!COND_EXPR', pos__a[2], cmd2mem(pos__b),cmd2mem(pos__f))])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '>', 'JUMP', (':', 0, 1), '>', ('::', 2))):
                rpl(cmds,[('!COND_EXPR', pos__a[2], cmd2mem(pos__b),cmd2mem(pos__e))])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '>', 'JUMP_IF_TRUE', 'POP_TOP',\
                            (':', 0, 1), '*l', '>', ('::', 2))):
                rpl(cmds,[Or_j_s(And_j_s(pos__a[2], pos__b), pos__g)])
                return True
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', '>', 'JUMP_IF_TRUE', 'POP_TOP',\
                            (':', 0,1), 'JUMP_IF2_FALSE_POP', '>', \
                            'JUMP_IF_TRUE', 'POP_TOP', (':', 5,1), '>', \
                            ('::', (2,7)))):
                    rpl(cmds,[Or_j_s(And_j_s(pos__a[2],pos__b), Or_j_s(And_j_s(pos__f[2],pos__g),pos__k))])
                    return True 
        elif pos__b[0] == '.:':
            if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP', ('::',0))):  
                rpl(cmds,[('UNPUSH', (pos__a[2]))])
                return True
        else:
            pass    

    elif jump == 'JUMP_IF2_FALSE_POP_CONTINUE':
        if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP_CONTINUE', '*', ('::',0))):
            rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)]])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP_CONTINUE', '*c')):
            rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)]])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP_CONTINUE', '*n', ('::',0))):
            rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)]])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP_CONTINUE', '*r')):
            rpl(cmds,[[('(IF',) + pos__a[2:], pos__b , (')ENDIF',)], ('JUMP_CONTINUE', pos__a[1])])
            return True
    elif jump == 'JUMP_IF2_TRUE_POP_CONTINUE':
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP_CONTINUE', '*')):
            rpl(cmds,[[('(IF',) + pos__a[2:], [('CONTINUE',)], (')ENDIF',)]+pos__b])
            return True
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP_CONTINUE', 'JUMP_IF2_TRUE_POP', '*',\
                    'JUMP_CONTINUE', (':', 1, 2))) and pos__d[1] == pos__a[1]:
            rpl(cmds,[[('(IF',) + pos__a[2:], [('CONTINUE',)],\
                            (')(ELSE',), [('(IF', Not(pos__b[2])), pos__c + [('CONTINUE',)], (')ENDIF',)],(')ENDIF',)],pos__e])
            return True                             
    elif jump == 'JUMP_IF_TRUE':
        if SCmp(cmds,i, ('JUMP_IF_TRUE', 'POP_TOP', '.L', '>')):
            rpl(cmds,[pos__a,pos__b,pos__d])
            return True    
    elif jump == 'JUMP_IF_FALSE':
        if SCmp(cmds,i, ('JUMP_IF_FALSE', 'POP_TOP', '.L', '>')):
            rpl(cmds,[pos__a,pos__b,pos__d])
            return True   
    elif jump == 'JUMP':
        if SCmp(cmds,i, ('JUMP', '.:', 'JUMP_CONTINUE')) and pos__a[1] == pos__c[1] and pos__a[1] != pos__b[1]:
            rpl(cmds,[pos__b,pos__c])
            return True           
        if SCmp(cmds,i, ('JUMP', ('::',0))):
            rpl(cmds,[])
            return True    
        if SCmp(cmds,i, ('JUMP', '*', ('::',0))):
            rpl(cmds,[])
            return True    
        if SCmp(cmds,i, ('JUMP', '*', 'JUMP', ('::',0))):
            rpl(cmds,[])
            return True    
        if SCmp(cmds,i, ('JUMP', 'POP_BLOCK', 'JUMP', ('::',0))):
            rpl(cmds,[])
            return True      
        if SCmp(cmds,i, ('JUMP', (':', 4, 1), 'xJUMP_IF2_FALSE_POP', '*', 'JUMP')):
            rpl(cmds,[pos__a])
            return True
        if SCmp(cmds,i, ('JUMP','JUMP')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[pos__a])
            return True            
        if SCmp(cmds,i, ('JUMP', 'JUMP_CONTINUE')):
            rpl(cmds,[pos__a])
            return True
        if  SCmp(cmds,i, ('JUMP', '.:', 'JUMP')) and pos__a[1] == pos__c[1]:
            rpl(cmds,[pos__b,pos__c])
            return True
        if  SCmp(cmds,i, ('JUMP', '.:', 'JUMP_CONTINUE')) and pos__a[1] == pos__c[1]:
            rpl(cmds,[pos__b,pos__c])
            return True     
        if SCmp(cmds, i, ('JUMP', '.:', 'JUMP_IF2_FALSE_POP', '*',  (':', 0), 'JUMP')) and pos__f[1] == pos__c[1]:
            rpl(cmds,[pos__a,pos__b, [('(IF', pos__c[2]), pos__d, (')IF',)], pos__e, pos__f ])
            return True  
        if SCmp(cmds, i, ('JUMP', (':', 4, 1), 'J_LOOP_VARS', '*',  'JUMP', (':', 2), 'POP_BLOCK', '*', (':', 0), '*')) and \
                pos__j[0][0] == 'RETURN_VALUE':
            rpl(cmds, [pos__i, pos__j])
            return True
        if SCmp(cmds, i, ('JUMP', '.:', 'xJUMP_IF2_FALSE_POP', '*',  'JUMP_IF2_TRUE_POP', '*r', ('::', 2), '*r')) and pos__e[1] == pos__a[1]:
            rpl(cmds,[pos__a,pos__b, [('(IF', pos__c[2]), pos__d + [('(IF', Not(pos__e[2])), pos__f, (')IF',)], (')IF',)], pos__g, pos__h ])
            return True  
                 
    elif jump == 'JUMP_CONTINUE':
        if SCmp(cmds,i, ('JUMP_CONTINUE', '.:', 'JUMP_CONTINUE')) and pos__a[1] == pos__c[1] and pos__a[1] != pos__b[1]:
            rpl(cmds,[pos__b,pos__c])
            return True     
        if SCmp(cmds,i, ('JUMP_CONTINUE', 'JUMP_CONTINUE')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[pos__a])
            return True    
        if  SCmp(cmds,i, ('JUMP_CONTINUE', 'JUMP')):
            rpl(cmds,[pos__a])
            return True
        if  SCmp(cmds,i, ('JUMP_CONTINUE', '.:', 'JUMP')) and pos__a[1] == pos__c[1]:
            rpl(cmds,[pos__b,pos__a])
            return True

        if  SCmp(cmds,i, ('JUMP_CONTINUE', '.:', 'JUMP_CONTINUE')) and pos__a[1] == pos__c[1]:
            rpl(cmds,[pos__b,pos__c])
            return True
            
  
    if jump == 'JUMP_IF2_FALSE_POP_CONTINUE' or jump == 'JUMP_IF2_TRUE_POP_CONTINUE':
        if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP_CONTINUE', 'JUMP_CONTINUE')) and pos__a[1] == pos__b[1]:
            rpl(cmds,[('UNPUSH', pos__a[2]),pos__b])
            return True
        if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP_CONTINUE', 'xJUMP_IF2_FALSE_POP', \
                        'JUMP_CONTINUE')) and pos__a[1] == pos__c[1]:
            rpl(cmds,[[('(IF', Or_j(pos__a[2], pos__b[2])), [('CONTINUE',)], (')ENDIF',)], ('JUMP', pos__b[1])])
            return True   
        if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP_CONTINUE', '*')):
            rpl(cmds,[[('(IF', Not(pos__a[2])), [('CONTINUE',)], (')ENDIF',)]+pos__b])
            return True 

    if jump == 'JUMP_IF2_FALSE_POP' or jump == 'JUMP_IF2_TRUE_POP':
        if islist_b:
            if pos__c[0] == 'J_SETUP_LOOP':
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'J_SETUP_LOOP', \
                                (':', 5, 1), '*n', 'ju', ('::', 0))):
                    rpl(cmds,[[('(IF',) + pos__a[2:],pos__b + [('(WHILE', TRUE), pos__e, (')ENDWHILE',)], (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'J_SETUP_LOOP', \
                                ('!', '(IF', '*c', ')ENDIF'), 'POP_BLOCK', '*n', \
                                'JUMP_CONTINUE', (':', 0,0))) and pos__c[1] != pos__a[1] != pos__g[1]:
                    rpl(cmds,[pos__a, pos__b + [('(WHILE',) + pos__d[0][1:], pos__d[1][:-1], (')(ELSE',), pos__f, (')ENDWHILE',)],pos__g,pos__h])
                    return True
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'J_SETUP_LOOP', \
                                ('!', '(IF', '*r', ')ENDIF'), 'POP_BLOCK',  ('::', (0,2)))):
                    rpl(cmds,[pos__a, pos__b + [('(WHILE',) + pos__d[0][1:], pos__d[1][:-1], (')ENDWHILE',)],pos__f])
                    return True
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'J_SETUP_LOOP', \
                                ('!', '(IF', '*r', ')ENDIF'), 'POP_BLOCK', 'JUMP', (':', 0, 0))) and\
                                pos__a[1] != pos__c[1] and pos__a[1] != pos__f[1]:
                        rpl(cmds,[pos__a,pos__b+[('(WHILE',) + pos__d[0][1:], pos__d[1], (')ENDWHILE',)],pos__f,pos__g])
                        return True     
                    
            elif pos__c[0] == 'JUMP':
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1),\
                                '*n', 'JUMP_CONTINUE', ('::', 2))):            
                        rpl(cmds,[[('(IF',) + pos__a[2:], pos__b , (')(ELSE',), pos__e + [('CONTINUE',)], (')ENDIF',)]])
                        return True                
                if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', '*n', 'JUMP', (':', 0,1),\
                                '*n', 'JUMP_CONTINUE', ('::', 2))):
                    rpl(cmds,[[('(IF', Not(pos__a[2])), pos__b, (')(ELSE',), pos__e + [('CONTINUE',)], (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', '*n', 'JUMP', (':', 0,1),\
                                'JUMP_CONTINUE', ('::', 2))):
                    rpl(cmds,[[('(IF', Not(pos__a[2])), pos__b, (')(ELSE',), [('CONTINUE',)], (')ENDIF',)]])
                    return True
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0, 1),\
                                'xJUMP_IF2_TRUE_POP_CONTINUE', (':', 2,1), '*n', \
                                ('::', 4))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b, (')(ELSE',), [('(IF', pos__e[2]), [('CONTINUE',)], (')ENDIF',)]+pos__g, (')ENDIF',)]])
                    return True    
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0, 1),\
                                'xJUMP_IF2_TRUE_POP_CONTINUE', (':', 2,1), \
                                ('::', 4))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b, (')(ELSE',), [('(IF', pos__e[2]), [('CONTINUE',)], (')ENDIF',)], (')ENDIF',)]])
                    return True    
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1),\
                                '*n', 'JUMP_CONTINUE')) and pos__c[1] not in (pos__a[1], pos__d[1], pos__f[1]):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b, (')(ELSE',), pos__e + [('CONTINUE',)], (')ENDIF',)], pos__c])
                    return True   
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1),\
                                'JUMP_CONTINUE')) and pos__c[1] not in (pos__a[1], pos__d[1], pos__e[1]):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b, (')(ELSE',), [('CONTINUE',)], (')ENDIF',)], pos__c])
                    return True   
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1), '*r', \
                                '.:')) and pos__c[1] != pos__f[1]:
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b , (')(ELSE',), pos__e, (')ENDIF',)], pos__c,pos__f])
                    return True   
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP', (':', 0,1), '*n',\
                                'jc', ('::', 2))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b , (')(ELSE',), pos__e + [('CONTINUE',)], (')ENDIF',)]])
                    return True   
 
            elif is_cmdmem(pos__c):
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*l', '>', 'JUMP_IF_TRUE', 'POP_TOP',\
                                (':', 0,1), '>', ('::', 3))):
                    rpl(cmds,[Or_j_s(And_j_s(pos__a[2], pos__c), pos__g)])
                    return True
            elif pos__c[0] == '.:':
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*r', ('::',0))):
                        rpl(cmds,[[('(IF',) + pos__a[2:], pos__b, (')ENDIF',)]])
                        return True 
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*r', (':', None,0), 'END_FINALLY', ('::', 0))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b, (')ENDIF',)], pos__c,pos__d])
                    return True   
                if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', '*r', '.:', '*n', (':', 0, 0))):
                    rpl(cmds,[[('(IF', Not(pos__a[2])), pos__b, (')ENDIF',)], ('JUMP', pos__a[1]), pos__c,pos__d,pos__e])
                    return True   
            elif pos__c[0] == 'JUMP_CONTINUE':
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'JUMP_CONTINUE')):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b + [('CONTINUE',)], (')ENDIF',)], ('JUMP', pos__a[1])])
                    return True   
            elif pos__c[0] == 'J_SETUP_LOOP_FOR':  
                if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', '**n', 'J_SETUP_LOOP_FOR', (':', 6,1),\
                                'J_LOOP_VARS', '**n', 'JUMP_CONTINUE', (':', 4, 1),\
                                'POP_BLOCK', 'JUMP', (':', 0,1), '*n', (':', 2,1),\
                                'JUMP')):
                    cmds[i:i+9] = [pos__a,pos__b+[('(FOR', pos__e[2], pos__c[2]), pos__f[:], (')ENDFOR',)]]
                    return True
                if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', '*n', 'J_SETUP_LOOP_FOR', \
                                (':', 6, 1), 'J_LOOP_VARS', '*n', 'JUMP_CONTINUE', \
                                (':', 4, 1), 'POP_BLOCK', 'JUMP_CONTINUE', (':', 0, 0))) and \
                                pos__a[1] != pos__c[1] != pos__j[1]:
                    rpl(cmds,[pos__a, pos__b +[('(FOR', pos__e[2], pos__c[2]), pos__f[:], (')ENDFOR',)],pos__j, pos__k])
                    return True
            elif pos__e[0] == 'JUMP':    
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n','xJUMP_IF2_TRUE_POP', '*n', 'JUMP',\
                                (':', 0,1), '*n', (':', 4,1), ('::', 2))):
                        rpl(cmds,[[('(IF',) + pos__a[2:], pos__b +\
                                            [('(IF',) + pos__c[2:], [('CONTINUE',)], (')ENDIF',)] + pos__d, \
                                        (')(ELSE',), pos__g, (')ENDIF',)],pos__i])
                        return True       
            elif pos__d[0] == '.:':        
                if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', '*n',\
                                'xJUMP_IF2_TRUE_POP_CONTINUE', ('::', 0))):
                    rpl(cmds,[[('(IF', Not(pos__a[2])), pos__b + [('(IF', pos__c[2]), [('CONTINUE',)], (')ENDIF',)], (')ENDIF',)]])
                    return True
            elif pos__e[0] == '.:':        
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '*n', 'xJUMP_IF2_TRUE_POP', '*r',\
                                (':', 0,1), '*r', ('::', 2))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b + [('(IF', Not(pos__c[2])), pos__d, (')ENDIF',)], (')(ELSE',), pos__f , (')ENDIF',)]])
                    return True
            elif pos__f[0] == 'JUMP_CONTINUE':        
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '**n', 'xJUMP_IF2_FALSE_POP', '**n', \
                                'xJUMP_IF2_FALSE_POP', 'JUMP_CONTINUE', (':', 0, 1), \
                                '**n', ('::', (2, 4)))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b + [('(IF', pos__c[2]), \
                                                pos__d + [('(IF', pos__e[2]), [('CONTINUE',)], (')ENDIF',)], \
                                                (')ENDIF',)],\
                                (')(ELSE',), pos__h, (')ENDIF',)]])                
                    return True  
            elif pos__g[0] == 'JUMP_CONTINUE':        
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '**n', 'xJUMP_IF2_FALSE_POP', '**n', \
                                'xJUMP_IF2_FALSE_POP', '**n', 'JUMP_CONTINUE', (':', 0, 1), \
                                '**n', ('::', (2, 4)))):
                    rpl(cmds,[[('(IF', pos__a[2]), pos__b + [('(IF', pos__c[2]), \
                                                pos__d + [('(IF', pos__e[2]), pos__f + [('CONTINUE',)], (')ENDIF',)], \
                                                (')ENDIF',)],\
                                (')(ELSE',), pos__i, (')ENDIF',)]])                
                    return True  
        elif pos__b[0] == '(BEGIN_TRY':           
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '(BEGIN_TRY', '*n', ')END_BEGIN_TRY',\
                            'J_IF_NO_EXCEPT_IN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                            'END_FINALLY', (':', 4, 1), '*r', (':', 0, 1), '*r', ('::', 6))):
                        rpl(cmds,[[('(IF', pos__a[2]), concatenate_try_except(pos__c,pos__f, pos__j), (')(ELSE',), pos__l, (')ENDIF',)]])
                        return True 
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '(BEGIN_TRY', '*n', ')END_BEGIN_TRY',\
                            'J_IF_NO_EXCEPT_IN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                            'END_FINALLY', (':', 4, 1), '*r', (':', 0, 1), '*n', ('::', 6))):
                        rpl(cmds,[[('(IF', pos__a[2]), concatenate_try_except(pos__c,pos__f, pos__j), (')(ELSE',), pos__l, (')ENDIF',)]])
                        return True                     
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '(BEGIN_TRY', '*n', ')END_BEGIN_TRY',\
                            'J_IF_NO_EXCEPT_IN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                            'END_FINALLY', 'JUMP', (':', 0,None))) and pos__e[1] == pos__i[1]:
                rpl(cmds,[pos__a, concatenate_try_except(pos__c, pos__f),pos__j])
                return True                    
        elif pos__b[0] == 'J_SETUP_LOOP_FOR':           
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', 'J_LOOP_VARS', \
                            '*', (':', 2,1), 'POP_BLOCK', '*r', (':', 0,1), '*',(':', 1,1))):
                    rpl(cmds,[pos__a, [('(FOR', pos__c[2], pos__b[2]) , pos__d, (')(ELSE',),pos__g, (')ENDFOR',)],pos__h,pos__i,pos__j])
                    return True
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', 'J_LOOP_VARS', \
                            '*r', (':', 2, 1), 'POP_BLOCK', 'JUMP', (':', 0, 1))) and\
                            pos__g[1] not in (pos__a[1], pos__b[1], pos__c[1]):
                    rpl(cmds,[pos__a, [('(FOR', pos__c[2], pos__b[2]) , pos__d, (')ENDFOR',)],pos__g,pos__h])
                    return True
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', (':', 5, 1),\
                            'J_LOOP_VARS', '*n', 'JUMP_CONTINUE', (':', 3, 1),\
                            'POP_BLOCK', '*n', 'JUMP_CONTINUE', (':', 0, 1), '*n',\
                            (':', 1,1), ('::', 9))):
                rpl(cmds,[pos__a, [('(FOR', pos__d[2], pos__b[2]), pos__e[:], (')(ELSE',), pos__i,(')ENDFOR',)],pos__j,pos__k,pos__l,cmds[i+12]])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', 'J_SETUP_LOOP_FOR', (':', 5, 1),\
                            'J_LOOP_VARS', '*n', 'JUMP_CONTINUE', (':', 3, 1),\
                            'POP_BLOCK', 'JUMP_CONTINUE', (':', 0, 0))) and \
                            pos__i[1] not in (pos__a[1], pos__b[1], pos__d[1], pos__f[1]):
                rpl(cmds,[pos__a, [('(FOR', pos__d[2], pos__b[2]), pos__e[:], (')ENDFOR',)],pos__i,pos__j])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', (':', 5, 1),\
                            'J_LOOP_VARS', '*n', 'JUMP_CONTINUE', (':', 3, 1), \
                            'POP_BLOCK', '*n', 'JUMP', ('::', 0))) and pos__b[1] != pos__j[1] and \
                            pos__b[1] not in (pos__a[1],pos__c[1], pos__d[1]):       #  1
                rpl(cmds,[pos__a, [('(FOR', pos__d[2], pos__b[2]), pos__e[:], (')(ELSE',), pos__i,(')ENDFOR',)],pos__j,pos__k])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*r', (':', 2, 1),\
                             'POP_BLOCK', '*r', (':', 0, 1), '*r', ('::', 1))):
                rpl(cmds,[[('(IF', pos__a[2]), [('(FOR', pos__c[2], pos__b[2]), pos__d[:], (')(ELSE',), pos__g,(')ENDFOR',)], (')(ELSE',), pos__i, (')ENDIF',)]])
                return True        
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*r', (':', 2, 1),\
                             'POP_BLOCK', '*r', (':', 0, 1), '*', ('::', 1)), True):
                rpl(cmds,[[('(IF', pos__a[2]), [('(FOR', pos__c[2], pos__b[2]), pos__d[:], (')(ELSE',), pos__g,(')ENDFOR',)], (')(ELSE',), pos__i, (')ENDIF',)]])
                return True     
 
            
        elif pos__b[0] == 'J_SETUP_LOOP':           
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_SETUP_LOOP', \
                            (':', 4, 1), '*n', 'ju', ('::', 0))):
                rpl(cmds,[[('(IF',) + pos__a[2:],[('(WHILE', TRUE), pos__d, (')ENDWHILE',)], (')ENDIF',)]])
                return True
        elif pos__b[0] == 'JUMP':           
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'JUMP')) and pos__a[1] == pos__b[1]:
                rpl(cmds,[('UNPUSH', pos__a[2]),pos__b])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', 'JUMP', (':', 0,1),\
                            '*n', 'JUMP_CONTINUE', ('::', 1))):
                rpl(cmds,[[('(IF', pos__a[2]), pos__e + [('CONTINUE',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP', 'JUMP', (':', 0,1),\
                            'JUMP_CONTINUE', ('::', 1))):
                rpl(cmds,[[('(IF', pos__a[2]), [('CONTINUE',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'JUMP', (':', 0, 1),\
                            'xJUMP_IF2_TRUE_POP_CONTINUE', (':', 1,1), '*n', \
                            ('::', 3))):
                rpl(cmds,[[('(IF', Not(pos__a[2])),[('(IF', pos__d[2]), [('CONTINUE',)], (')ENDIF',)]+pos__f, (')ENDIF',)]])
                return True    
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'JUMP', (':', 0, 1),\
                            'xJUMP_IF2_TRUE_POP_CONTINUE', (':', 1,1), \
                            ('::', 3))):
                rpl(cmds,[[('(IF', Not(pos__a[2])),[('(IF', pos__d[2]), [('CONTINUE',)], (')ENDIF',)], (')ENDIF',)]])
                return True    
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'JUMP', (':', 0,1),\
                            '*n', 'JUMP_CONTINUE')) and pos__b[1] not in (pos__a[1], pos__c[1], pos__e[1]):
                rpl(cmds,[[('(IF', pos__a[2]), [('PASS',)], (')(ELSE',), pos__d + [('CONTINUE',)], (')ENDIF',)], pos__b])
                return True   
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'JUMP', (':', 0,1),\
                            'JUMP_CONTINUE')) and pos__b[1] not in (pos__a[1], pos__c[1], pos__d[1]):
                rpl(cmds,[[('(IF', pos__a[2]), [('PASS',)], (')(ELSE',), [('CONTINUE',)], (')ENDIF',)], pos__b])
                return True   
        elif pos__b[0][0] == 'J':           
            if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP',\
                            'xJUMP_IF2_TRUE_POP_CONTINUE', ('::', 0))):
                rpl(cmds,[[('(IF', Not(pos__a[2])), [('(IF', pos__b[2]), [('CONTINUE',)], (')ENDIF',)], (')ENDIF',)]])
                return True
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'xJUMP_IF2_TRUE_POP', '*r',\
                            (':', 0,1), '*r', ('::', 1))):
                rpl(cmds,[[('(IF', pos__a[2]), [('(IF', Not(pos__b[2])), pos__c, (')ENDIF',)], (')(ELSE',), pos__e , (')ENDIF',)]])
                return True    
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'xJUMP_IF2_FALSE_POP', '*n',\
                            'ju', (':', 0, 1), '*n', (':', 1, 1),\
                            '*n', ('::', 3))):
                rpl(cmds,[[('(IF', pos__a[2]),[('(IF', pos__b[2]), pos__c, (')(ELSE',), pos__h, (')ENDIF',)], (')(ELSE',), pos__f, (')ENDIF',)]])
                return True   
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'xJUMP_IF2_FALSE_POP', \
                            'ju', (':', 0, 1), '*n', (':', 1, 1),\
                            '*n', ('::', 2))):
                pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i = [('PASS',)],pos__c,pos__d,pos__e,pos__f,pos__g,pos__h                
                rpl(cmds,[[('(IF', pos__a[2]),[('(IF', pos__b[2]), pos__c, (')(ELSE',), pos__h, (')ENDIF',)], (')(ELSE',), pos__f, (')ENDIF',)]])
                return True   
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'xJUMP_IF2_FALSE_POP', '**n', \
                            'xJUMP_IF2_FALSE_POP', 'JUMP_CONTINUE', (':', 0, 1), \
                            '**n', ('::', (1, 3)))):
                rpl(cmds,[[('(IF', pos__a[2]), [('(IF', pos__b[2]), \
                                            pos__c + [('(IF', pos__d[2]), [('CONTINUE',)], (')ENDIF',)], \
                                            (')ENDIF',)],\
                            (')(ELSE',), pos__g, (')ENDIF',)]])                
                return True   
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'J_COND_PUSH', (':', 0, 1),\
                            '>', ('::', 1))):
                rpl(cmds,[('!COND_EXPR', pos__a[2], ('!COND_EXPR',) + pos__b[2:] + (cmd2mem(pos__d),), cmd2mem(pos__d))])
                return True
        elif pos__b[0] == 'RETURN_VALUE':           
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'RETURN_VALUE', ('::',0))) and len(pos__b) == 2:
                rpl(cmds,[[('(IF', pos__a[2]), [pos__b], (')ENDIF',)]])
                return True
        elif iscmdmem_b:           
            if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '>', 'JUMP', ('::', 0))) and pos__c[1] != pos__d[1]:
                rpl(cmds,[('J_COND_PUSH', pos__c[1], pos__a[2], cmd2mem(pos__b))])
                return True
            elif pos__b[0] == '!BUILD_LIST':
                if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', '!BUILD_LIST', '!GET_ITER', 'J_BASE_LIST_COMPR', (':', 0, 1), '>', ('::', 3))) and pos__d[3][1] is None:
                    compr = None
                    if pos__d[3][2] == ():
                        compr = ('!LIST_COMPR', pos__d[2], (pos__d[3][0], (pos__c[1],), None))
                    else:
                        compr = ('!LIST_COMPR', pos__d[2], (pos__d[3][0], (pos__c[1],), pos__d[3][2]))
                    rpl(cmds,[('!COND_EXPR', pos__a[2], compr, cmd2mem(pos__f))])
                    return True
        else:
            pass
    if jump == 'JUMP_IF_NOT_DEBUG' and islist_b:
        if SCmp(cmds,i, ('JUMP_IF_NOT_DEBUG', '*', (':', 0, 1))):
            rpl(cmds, [pos__b])
            return True
        if SCmp(cmds,i, ('JUMP_IF_NOT_DEBUG', '*', '.:')) and pos__a[1] == pos__c[1]:
            rpl(cmds, [pos__b, pos__c])
            return True        
        if SCmp(cmds,i, ('JUMP_IF_NOT_DEBUG', '*', 'JUMP_CONTINUE')) and pos__a[1] == pos__c[1]:
            rpl(cmds, [pos__b, pos__c])
            return True  
        if SCmp(cmds,i, ('JUMP_IF_NOT_DEBUG', '*', 'JUMP')) and pos__a[1] == pos__c[1]:
            rpl(cmds, [pos__b, pos__c])
            return True                
    if added_pass:
        if SCmp(cmds,i, ('xJUMP_IF2_TRUE_POP_CONTINUE',)):
            rpl(cmds,[[('(IF', pos__a[2]), [('CONTINUE',)], (')ENDIF',)]])
            return True   
        if SCmp(cmds,i, ('JUMP_IF2_TRUE_POP',)) and islooplabel(pos__a[1],cmds):
            rpl(cmds,[('JUMP_IF2_TRUE_POP_CONTINUE',) + pos__a[1:]])
            return True   
        if SCmp(cmds,i, ('JUMP_IF2_FALSE_POP',)) and islooplabel(pos__a[1],cmds):
            rpl(cmds,[('JUMP_IF2_FALSE_POP_CONTINUE',) + pos__a[1:]])
            return True   
        if SCmp(cmds,i, ('JUMP',)) and islooplabel(pos__a[1],cmds):
            rpl(cmds,[('JUMP_CONTINUE',) + pos__a[1:]])
            return True   
        if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'xJUMP_IF2_FALSE_POP', 'JUMP_CONTINUE', \
                    (':', 0,0), '*n', (':', 1,0))):
            rpl(cmds,[pos__a,[('(IF', pos__b[2]), [('CONTINUE',)], (')ENDIF',)],('JUMP', pos__b[1]), pos__d,pos__e,pos__f])
            return True           
        if SCmp(cmds,i, ('xJUMP_IF2_FALSE_POP', 'JUMP_CONTINUE', '.:')) and pos__a[1] != pos__b[1] != pos__c[1]: 
            rpl(cmds,[[('(IF', pos__a[2]), [('CONTINUE',)], (')ENDIF',)],('JUMP', pos__a[1]),pos__c])
            return True  
          
    return False

def process_j_setup_loop_for(cmds,i):
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l

    assert type(i) is int and i >= 0
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':',4,1), 'J_LOOP_VARS', '*', 'ju',
                        (':',2,1), 'POP_BLOCK', ('::',0))):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')ENDFOR',)]])
        return True 
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*', (':',1,1), 'POP_BLOCK',\
                    'JUMP')) and pos__a[1] == pos__f[1]:
        rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]), pos__c[:], (')ENDFOR',)],pos__f])
        return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':',4,1), 'J_LOOP_VARS', '*n',\
                    'ju', (':',2,1), 'POP_BLOCK', '*n', 'jc', ('::',0)))and\
                    pos__i[1] != pos__e[1]:
            rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',), pos__h + [('CONTINUE',)],(')ENDFOR',)]])
            return True 
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*', (':', 1, 1),\
                    'POP_BLOCK', ('::',0))):
        rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]), pos__c[:], (')ENDFOR',)]])
        return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3,0), 'J_LOOP_VARS',\
                    'xJUMP_IF2_FALSE_POP_CONTINUE', '*r')):
            rpl(cmds,[pos__a,pos__b,pos__c,[('(IF',) + pos__d[2:], pos__e, (')ENDIF',)], ('JUMP_CONTINUE',pos__d[1])])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3,0), 'J_LOOP_VARS',\
                    'xJUMP_IF2_FALSE_POP', '*r')):
            rpl(cmds,[pos__a,pos__b,pos__c,[('(IF',) + pos__d[2:], pos__e, (')ENDIF',)], ('JUMP',pos__d[1])])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*', (':',1,1), 'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]) , pos__c, (')ENDFOR',)]])
            return True 
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3, 2), 'J_LOOP_VARS', \
                    'xJUMP_IF2_TRUE_POP_CONTINUE', '*', 'JUMP_CONTINUE', \
                    (':', 2, 1), 'POP_BLOCK', ('::', 0))) and pos__d[1] == pos__f[1]:
            rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]) , [('(IF',) +pos__d[2:],\
                                                    [('CONTINUE',)],(')ENDIF',)]+ pos__e, (')ENDFOR',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3, 1), 'J_LOOP_VARS', \
                    'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', ('::', 0))):
            rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]) , [('PASS',)], (')ENDFOR',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*n', (':', 1,1),\
                    'POP_BLOCK', '*r', ('::', 0))):
            rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]) , pos__c, (')(ELSE',),pos__f, (')ENDFOR',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'xJUMP_IF2_FALSE_POP_CONTINUE', '*n', (':', 2, 1),\
                    'POP_BLOCK', ('::', 0))):       #  1
            rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]) , \
                            pos__d + [('(IF',) + pos__e[2:], pos__f, (')ENDIF',)], \
                            (')ENDFOR',)]])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,2), 'J_LOOP_VARS', '*n',\
                    'xJUMP_IF2_FALSE_POP_CONTINUE', '*n', 'JUMP_CONTINUE')):       
            rpl(cmds,[pos__a,pos__b,pos__c,pos__d + [('(IF',) +pos__e[2:], pos__f, (')ENDIF',)], pos__g])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3, 2), 'J_LOOP_VARS', \
                     'xJUMP_IF2_TRUE_POP')):
            if type(cmds[i+4]) is list:
                cmds[i:i+5] = [pos__a,pos__b,pos__c, [('(IF',) +pos__d[2:], [('CONTINUE',)], (')ENDIF',)]+cmds[i+4]]
            else:          
                cmds[i:i+4] = [pos__a,pos__b,pos__c, [('(IF',) +pos__d[2:], [('CONTINUE',)], (')ENDIF',)]]
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3,1), 'J_LOOP_VARS', \
                     'xJUMP_IF2_TRUE_POP')):
            if type(cmds[i+4]) is list:
                cmds[i:i+5] = [pos__a,pos__c, [('(IF',) +pos__d[2:], [('CONTINUE',)], (')ENDIF',)]+cmds[i+4]]
            else:                 
                cmds[i:i+4] = [pos__a,pos__c, [('(IF',) +pos__d[2:], [('CONTINUE',)], (')ENDIF',)]]
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,2), 'J_LOOP_VARS', '*n',\
                    'xJUMP_IF2_FALSE_POP_CONTINUE', '*n')):       
            rpl(cmds,[pos__a,pos__b,pos__c,pos__d+ [('(IF', Not(pos__e[2])), [('CONTINUE',)], (')ENDIF',)]+pos__f])
            return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,0), 'J_LOOP_VARS', '*n', 'JUMP')):
        rpl(cmds,[pos__a,pos__b,pos__c,pos__d,('JUMP_CONTINUE',) + pos__e[1:]])
        return True
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*r', (':', 1,1),\
                    'POP_BLOCK', '*n', ('::', 0))):
        rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]), pos__c[:], (')(ELSE',),pos__f,(')ENDFOR',)]])
        return True    
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2,1), 'POP_BLOCK', '*n', ('::', 0))):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',),pos__h,(')ENDFOR',)]])
        return True    
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'ju', (':', 2,1), 'POP_BLOCK', '*r', ('::', 0))):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',),pos__h,(')ENDFOR',)]])
        return True    
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4, 1), 'J_LOOP_VARS', '*n', 'ju',\
                    (':', 2,1), 'POP_BLOCK', '*n', 'ju')) and pos__a[1] == pos__i[1]:
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',),pos__h,(')ENDFOR',)],pos__i])
        return True    
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', 'JUMP')) and pos__h[1] == pos__a[1]:
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')ENDFOR',)],pos__h])
        return True  
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', 'JUMP_CONTINUE')) and pos__h[1] == pos__a[1]:
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')ENDFOR',)],pos__h])
        return True  
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2,1), 'POP_BLOCK', 'jc',\
                    ('::', 0))) and pos__h[1] not in (pos__b[1],pos__f[1],pos__i[1]):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',), [('CONTINUE',)],(')ENDFOR',)]])
        return True  
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2,1), 'POP_BLOCK', 'ju', \
                    '.:', 'END_FINALLY', ('::', 0))) and \
                    pos__h[1] not in (pos__a[1], pos__b[1],pos__c[1],pos__e[1],pos__f[1]) and\
                    pos__i[1] not in (pos__a[1], pos__b[1],pos__c[1],pos__e[1],pos__f[1]):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')ENDFOR',)],pos__h,pos__i,pos__j])
        return True  
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', '*r',\
                    '.:', 'END_FINALLY', ('::', 0))) and pos__i[1] not in [pos__b[1], pos__f[1],pos__k[1]]:
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',), pos__h,(')ENDFOR',)],pos__i,pos__j])
        return True         
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*r', (':', 1,1), \
                    'POP_BLOCK', '*r', ('::', 0))):
        rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]), pos__c[:], (')(ELSE',), pos__f,(')ENDFOR',)]])
        return True         
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*r', (':', 1,1),\
                    'POP_BLOCK', 'JUMP_CONTINUE')) and pos__a[1] == pos__f[1]:
        rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]), pos__c[:], (')ENDFOR',)],pos__f])
        return True        
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', 'J_LOOP_VARS', '*r', (':', 1,1),\
                    'POP_BLOCK', 'JUMP')) and pos__a[1] == pos__f[1]:
        rpl(cmds,[[('(FOR', pos__b[2], pos__a[2]), pos__c[:], (')ENDFOR',)],pos__f])
        return True   
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'JUMP_CONTINUE', (':', 2,1), 'POP_BLOCK', '*r', '.:')) \
                    and pos__i[1] != pos__a[1]:
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',), pos__h, (')ENDFOR',)],pos__i])
        return True   
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,2), 'J_LOOP_VARS', '*n',\
                    'xJUMP_IF2_TRUE_POP')):
        rpl(cmds,[pos__a,pos__b,pos__c,pos__d,('JUMP_IF2_TRUE_POP_CONTINUE',) + pos__e[1:]])
        return True   
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4,1), 'J_LOOP_VARS', '*n',\
                    'xJUMP_IF2_TRUE_POP')):
        rpl(cmds,[pos__a,pos__c,pos__d,('JUMP_IF2_TRUE_POP_CONTINUE',) + pos__e[1:]])
        return True       
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4, 1), 'J_LOOP_VARS', '*n', \
                    'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', '*r',\
                    'END_FINALLY', ('::', 0))):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',), pos__h, (')ENDFOR',)],pos__i])
        return True   
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 3, 1), 'J_LOOP_VARS', 'JUMP_CONTINUE', (':', 2, 1),
        'POP_BLOCK', '*n', (':', 0, 1))):
        rpl(cmds,[[('(FOR', pos__c[2], pos__a[2]), [('PASS',)], (')(ELSE',), pos__g, (')ENDFOR',)]])
        return True 
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4, 1), 'J_LOOP_VARS', \
                        '*', 'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', '*',\
                        'JUMP_CONTINUE')) and pos__e[1] != pos__i[1]:
        rpl(cmds, [[('(FOR', pos__c[2], pos__a[2]), pos__d[:] + [('CONTINUE',)], (')(ELSE',), pos__h + [('CONTINUE',)], (')ENDFOR',)]])
        return True    
    
       
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4, 1), 'J_LOOP_VARS', \
                        '*', 'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK',\
                        'JUMP')) and pos__e[1] != pos__h[1]:
        rpl(cmds, [[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')ENDFOR',)], pos__h])
        return True    

       
    if SCmp(cmds,i, ('J_SETUP_LOOP_FOR', (':', 4, 1), 'J_LOOP_VARS', \
                        '*', 'JUMP_CONTINUE', (':', 2, 1), 'POP_BLOCK', '*', \
                        'JUMP')) and pos__i[1] not in (pos__a[1], pos__b[1], pos__c[1]):
        rpl(cmds, [[('(FOR', pos__c[2], pos__a[2]), pos__d[:], (')(ELSE',), pos__h, (')ENDFOR',)], pos__i])
        return True   
       
    return False

def process_begin_try(cmds,i):
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l

    assert type(i) is int and i >= 0
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP_CONTINUE', (':', 4, 1),\
                    'END_FINALLY', (':', 3, 1), '*r')):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')(ELSE',),pos__k, (')ENDTRY',)],pos__g])
             return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP', (':', 4, 1),\
                    'END_FINALLY', (':', 3, 1), '*r')) and pos__g[1] not in (pos__d[1],pos__e[1]):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')(ELSE',),pos__k, (')ENDTRY',)],pos__g])
             return True      
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 4, 1), 'END_FINALLY',\
                    (':', 3, 1), '*r', ('::', 5))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('PASS',)], (')(ELSE',),pos__j, (')ENDTRY',)]])
             return True      
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    'JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP', (':', 4,1), 'END_FINALLY',\
                    (':', 3, 1), '*n', ('::', 6))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')(ELSE',),pos__k, (')ENDTRY',)]])
             return True      
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 4, 1), 'END_FINALLY',\
                    (':', 3, 1), '*n', ('::', 5))):
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('PASS',)], (')(ELSE',),pos__j, (')ENDTRY',)]])
                return True 
                  
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 4, 1),\
                    'END_FINALLY', ('::', (3,5)))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('PASS',)],(')ENDTRY',)]])
             return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 3, 1),\
                    'END_FINALLY', ('::', 4))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], [('PASS',)],(')ENDTRY',)]])
             return True     

    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP', (':', 4, 1),\
                    'END_FINALLY', ('::', (3,6)))):
            rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')ENDTRY',)]])
            return True               

    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*l', 'POP_TOP3', '*', 'JUMP', 'END_FINALLY', ('::', (3,7)))):
            rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), pos__g, (')ENDTRY',)]])
            return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*l', 'POP_TOP3', 'JUMP', 'END_FINALLY', ('::', (3,6)))):
            rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), [('PASS',)], (')ENDTRY',)]])
            return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'POP_TOP3', '*n', 'END_FINALLY', ('::', 3))):
            rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), pos__f, (')ENDTRY',)]])
            return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', \
                    '*', 'JUMP', (':', 3, 1), 'END_FINALLY', ('::', 5))):
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], pos__e, (')ENDTRY',)]])
                return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', \
                    '*', 'JUMP', (':', 3, 1), 'END_FINALLY', 'JUMP')) and pos__f[1] == pos__i[1]:
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], pos__e, (')ENDTRY',)],pos__i])
             return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', \
                    'JUMP', (':', 3,1), 'END_FINALLY', 'JUMP')) and pos__e[1] == pos__h[1]:
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], [('PASS',)], (')ENDTRY',)],pos__h])
             return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', \
                    '*r', (':', 3,1), 'END_FINALLY')):         
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], pos__e, (')ENDTRY',)]])
             return True     
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    'JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 4, 1), 'END_FINALLY',\
                    (':', 3,1), '*n', 'JUMP')) and pos__k[1] not in(pos__d[1],pos__e[1]):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')(ELSE',),pos__j, (')ENDTRY',)],pos__k])
             return True     
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    'JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 4, 1), 'END_FINALLY',\
                    ('::', 3))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')ENDTRY',)]])
             return True     
    if SCmp(cmds,i, ('(BEGIN_TRY', ('!', 'PASS'), ')END_BEGIN_TRY',\
                    'J_IF_NO_EXCEPT_IN_TRY', 'J_AFTER_EXCEPT_HANDLE', \
                    'END_FINALLY', (':', 3,1), '*n', ('::', 4))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), [('PASS',)],(')(ELSE',),pos__h, (')ENDTRY',)]])
             return True     
    if SCmp(cmds,i, ('(BEGIN_TRY', ('!', 'PASS'), ')END_BEGIN_TRY',\
                    'J_IF_NO_EXCEPT_IN_TRY', 'J_AFTER_EXCEPT_HANDLE', \
                    'END_FINALLY', ('::', (3,4)))):
             rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), [('PASS',)],(')ENDTRY',)]])
             return True     
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', \
                    (':', 4,1), 'END_FINALLY', (':', 3,1), '*n', 'JUMP_CONTINUE')) and pos__f[1] == pos__k[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('CONTINUE',)], (')(ELSE',),pos__j, (')ENDTRY',)],pos__k])
                return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', \
                    (':', 4,1), 'END_FINALLY', (':', 3,1), '*n', 'JUMP')) and pos__f[1] == pos__k[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('CONTINUE',)], (')(ELSE',),pos__j, (')ENDTRY',)],pos__k])
                return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', ('::', 3))):
            rpl(cmds,[concatenate_try_except(pos__b, pos__e)])
            return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP', (':', 4, 1),\
                    'END_FINALLY', 'JUMP')) and pos__d[1] == pos__g[1] and pos__d[1] == pos__j[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')ENDTRY',)],pos__g])
                return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP_CONTINUE', (':', 4, 1),\
                    'END_FINALLY', 'JUMP_CONTINUE')) and pos__d[1] == pos__g[1] and pos__d[1] == pos__j[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f, (')ENDTRY',)],pos__g])
                return True               
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', (':', 4, 1),\
                    'END_FINALLY', 'JUMP_CONTINUE')) and pos__d[1] == pos__f[1] and pos__d[1] == pos__i[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('PASS',)], (')ENDTRY',)],pos__f])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', \
                    'J_IF_NO_EXCEPT_IN_TRY', '*e',\
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY',\
                    'JUMP_CONTINUE')) and\
                    pos__d[1] == pos__f[1] and pos__d[1] == pos__h[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e), pos__h])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', \
                    'J_IF_NO_EXCEPT_IN_TRY', '*e',\
                    'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY',\
                    '.:', 'ju')) and\
                    pos__d[1] == pos__f[1] and pos__d[1] == pos__i[1] and pos__h[1] not in (pos__d[1], pos__f[1], pos__i[1]):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e), pos__h, pos__i])
                return True             
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', \
                    'J_IF_NO_EXCEPT_IN_TRY', '*e',\
                    'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY',\
                    'ju')) and\
                    pos__d[1] == pos__f[1] and pos__d[1] == pos__h[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e), pos__h])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', \
                    'J_IF_NO_EXCEPT_IN_TRY', '*e',\
                    'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY',\
                    ('::', (3,5)))):
           rpl(cmds,[concatenate_try_except(pos__b,pos__e)])
           return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', 'JUMP')) and pos__d[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e), pos__g])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', 'JUMP_CONTINUE')) and pos__d[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e), pos__g])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', \
                    (':', 4,1), 'END_FINALLY', ('::', 3))):
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], pos__f + [('CONTINUE',)], (')ENDTRY',)]])
                return True 
    if  SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3, 1),\
                    '*n', ('::', 5))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                    'END_FINALLY', ('::', 4))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__d)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 4,1), 'END_FINALLY', \
                    (':', 3, 1), '*n', ('::', 5))):
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__e[2:], [('PASS',)], (')(ELSE',),pos__j, (')ENDTRY',)]])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', \
                    '*n', (':', 3, 1), 'END_FINALLY')):            
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) + pos__d[2:], pos__e, (')ENDTRY',)]])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', 'JUMP_CONTINUE')) and\
                    pos__d[1] == pos__f[1] and pos__f[1] == pos__h[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__h])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY',\
                    (':', 3, 1), '*n', 'JUMP_CONTINUE')) and pos__f[1] == pos__j[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i),pos__j])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE_CONTINUE',\
                    'END_FINALLY', 'JUMP_CONTINUE')) and pos__e[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__d),pos__g])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE',\
                    'END_FINALLY', 'JUMP')) and pos__e[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__d),pos__g])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*l', 'POP_TOP3', 'JUMP', 'END_FINALLY', (':', 3,1),\
                    '*n', ('::', 6))):
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), [('PASS',)], (')(ELSE',),pos__j, (')ENDTRY',)]])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 4, 1), 'END_FINALLY',\
                    'JUMP')) and pos__d[1] == pos__f[1] and pos__f[1] ==pos__i[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) +pos__e[2:], [('PASS', )], (')ENDTRY',)],pos__i])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 4,1), 'END_FINALLY',\
                    'JUMP')) and pos__d[1] == pos__i[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) +pos__e[2:], pos__f, (')ENDTRY',)],pos__i])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                   'JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 4,1), 'END_FINALLY',\
                   'JUMP_CONTINUE')) and pos__d[1] == pos__i[1]:
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) +pos__e[2:], pos__f, (')ENDTRY',)],pos__i])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', (':', 4, 1),\
                    'END_FINALLY', ('::', 3))):       #  1
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',) +pos__e[2:], [('CONTINUE',)], (')ENDTRY',)]])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', ('::',3))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', '*e', \
                    'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', ('::', 4))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__d)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    ('!', '(EXCEPT1', '*n', ')ENDEXCEPT'), 'J_AFTER_EXCEPT_HANDLE_CONTINUE', \
                    'END_FINALLY', 'JUMP')) and\
                    pos__d[1] == pos__h[1] and pos__f[1] != pos__d[1]:
                tempor = pos__e[:-1]
                if len(tempor[-1][0]) > 0 and tempor[-1][0][0] == 'PASS':
                    tempor[-1] = [('CONTINUE',)]
                else:   
                    tempor[-1].append(('CONTINUE',))        
                tempor = tempor + [pos__e[-1]]                
                rpl(cmds,[concatenate_try_except(pos__b,tempor), pos__h])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    ('!', '(EXCEPT1', '*n', ')ENDEXCEPT'), 'J_AFTER_EXCEPT_HANDLE_CONTINUE', \
                    'END_FINALLY', ('::',3))) and pos__f[1] != pos__d[1]:
                tempor = pos__e[:-1]
                if len(tempor[-1][0]) > 0 and tempor[-1][0][0] == 'PASS':
                    tempor[-1] = [('CONTINUE',)]
                else:   
                    tempor[-1].append(('CONTINUE',))        
                tempor = tempor + [pos__e[-1]]
                rpl(cmds,[concatenate_try_except(pos__b,tempor)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3, 1),\
                    '*r', ('::', 5))):       #  1            
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*c', ')END_BEGIN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                    'END_FINALLY', ('::', 4))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__d)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3,1),\
                    '*n', 'JUMP')) and pos__f[1] == pos__j[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i),pos__j])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                     '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', ('::', (3,5)))):
        rpl(cmds,[concatenate_try_except(pos__b,pos__e)])
        return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', 'JUMP')) and pos__d[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__g])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', ('::', 3))):       #  2
                rpl(cmds,[concatenate_try_except(pos__b,pos__e)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', 'JUMP')) and\
                    pos__d[1] == pos__f[1] == pos__h[1]:            
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__h])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'END_FINALLY', 'ju')) and pos__d[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__g])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3,1), '*n',\
                    'JUMP_CONTINUE')) and pos__f[1] == pos__j[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i),pos__j])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    '*e', 'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY', 'JUMP_CONTINUE')) and\
                    pos__d[1] == pos__f[1] == pos__h[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__h])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY',\
                    ('!', '(EXCEPT1', ('!', 'PASS'), ')ENDEXCEPT'), \
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY', ('::', 3))):
                rpl(cmds,[[('(TRY',), pos__b, ('(EXCEPT',) + pos__e[0][1:], [('CONTINUE',)], (')ENDTRY',)]])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', \
                    'J_IF_NO_EXCEPT_IN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', \
                    '*n', 'JUMP_CONTINUE', (':', 4,1), 'END_FINALLY', ('::', 3))):
                rpl(cmds,[[('(TRY',), pos__b, ('(EXCEPT',) + pos__e[2:], pos__f+[('CONTINUE',)], (')ENDTRY',)]])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', '*e', \
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY',\
                    'JUMP_CONTINUE')) and pos__e[1] == pos__g[1]:
                rpl(cmds,[concatenate_try_except(pos__b,pos__d),pos__g])
                return True                        
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3,1),\
                    '*n', ('::', 5))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i)])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY',\
                    'J_IF_NO_EXCEPT_IN_TRY', '*e', \
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY',\
                    (':', 3, 1), '*r')):                   
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i),('JUMP_CONTINUE', pos__f[1])])
                return True
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    ('!', '.L', '(EXCEPT0', ('!', 'PASS'), ')ENDEXCEPT'),\
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY', ('::', 3))):       #  2             
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), [('CONTINUE',)], (')ENDTRY',)]])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    ('!', '(EXCEPT0', ('!', 'PASS'), ')ENDEXCEPT'),\
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY', ('::', 3))):       #  2             
                rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT',), [('CONTINUE',)], (')ENDTRY',)]])
                return True                     
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    ('!', '.L', '(EXCEPT1', ('!', 'PASS'), ')ENDEXCEPT'),\
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY', ('::', 3))):       #  2             
                rpl(cmds,[[('(TRY',pos__e[1][1]), pos__b, (')(EXCEPT',), [('CONTINUE',)], (')ENDTRY',)]])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    ('!', '(EXCEPT1', ('!', 'PASS'), ')ENDEXCEPT'),\
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY', ('::', 3))):       #  2             
                rpl(cmds,[[('(TRY',pos__e[0][1]), pos__b, (')(EXCEPT',), [('CONTINUE',)], (')ENDTRY',)]])
                return True    
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', 'JUMP_CONTINUE', \
                    ('::', 5))) and pos__d[1] == pos__h[1]:       #  1            
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,[('CONTINUE',)])])
                return True                                    
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3, 1),\
                    '*', '.:', 'END_FINALLY', ('::', 5))) and not islineblock(pos__i) and\
                    pos__j[1] not in (pos__d[1],pos__f[1]):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i), pos__j,pos__k])
                return True                                    
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY', '*e', 'END_FINALLY')):
                rpl(cmds,[concatenate_try_except(pos__b,pos__d)])
                return True      
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY',\
                    'J_IF_NO_EXCEPT_IN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                    'END_FINALLY', 'JUMP_CONTINUE', '.:', '*n', (':', (3,5), 1),\
                    'JUMP_CONTINUE')) and pos__h[1] == pos__l[1] and pos__i[1] not in (pos__d[1], pos__h[1]):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__h,pos__i,pos__j,pos__l])
                return True      
    if SCmp(cmds,i, ('(BEGIN_TRY', '*n', ')END_BEGIN_TRY',\
                    'J_IF_NO_EXCEPT_IN_TRY', '*e', 'J_AFTER_EXCEPT_HANDLE', \
                    'END_FINALLY', 'JUMP_CONTINUE', '.:', '*n', (':', (3,5), 2),\
                    'JUMP_CONTINUE')) and pos__h[1] == pos__l[1] and pos__i[1] not in (pos__d[1], pos__h[1]):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e),pos__h,pos__i,pos__j,pos__k,pos__l])
                return True              
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                    '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3, 1),\
                    '*r', ('::', 5))):
                rpl(cmds,[concatenate_try_except(pos__b,pos__e,pos__i)])
                return True              
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', '*l', 'POP_TOP3', '*r', 'END_FINALLY')):
                rpl(cmds, [[('(TRY',), pos__b, (')(EXCEPT',), pos__f, (')ENDTRY',)]])
                return True   

    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', 'JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP', (':', 4, 1), \
                     '*e', 'END_FINALLY', (':', 3, 1), '*', ('::', 6))):
                rpl(cmds,[concatenate_try_except(pos__b, concatenate_except(pos__e[2:], pos__f, pos__i), pos__l)])
                return True 

    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                     '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3, 1), '*', 'JUMP_CONTINUE', ('::', 5))):
                rpl(cmds,[concatenate_try_except(pos__b, pos__e, pos__i + [('CONTINUE',)])])
                return True 
    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                     '*e', 'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3, 1), '*r', '.:')) and pos__j[1] not in (pos__d[1], pos__f[1]):
                rpl(cmds,[concatenate_try_except(pos__b, pos__e, pos__i), pos__j])
                return True 

    if SCmp(cmds,i, ('(BEGIN_TRY', '*', ')END_BEGIN_TRY', 'J_IF_NO_EXCEPT_IN_TRY', \
                     'JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', (':', 4, 1), '*e', \
                     'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 3, 2))) and pos__i[1] == pos__d[1]:
                if pos__h[0][0] == '(EXCEPT1' and len(pos__h[0]) == 3:
                    rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT', pos__e[2], ()), [('CONTINUE',)],  (')(EXCEPT', ) + pos__h[0][1:], pos__h[1],  (')ENDTRY',)]])
                    return True
                if pos__h[0][0] == '(EXCEPT0' and len(pos__h[0]) == 1:
                    rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT', pos__e[2], ()), [('CONTINUE',)],  (')(EXCEPT', ) , pos__h[1],  (')ENDTRY',)], pos__k])
                    return True                
                if pos__h[0][0] == '.L' and pos__h[1][0] == '(EXCEPT0' and len(pos__h[1]) == 1:
                    rpl(cmds,[[('(TRY',), pos__b, (')(EXCEPT', pos__e[2], ()), [('CONTINUE',)],  (')(EXCEPT', ) , pos__h[2],  (')ENDTRY',)], pos__k])
                    return True                
                pprint(cmds[i:i+11])  
                assert False       
    if SCmp(cmds,i, ('(BEGIN_TRY', '*r', ')END_BEGIN_TRY', '*e', \
                      'END_FINALLY')) :
            rpl(cmds,[concatenate_try_except(pos__b,pos__d)])

            ## pprint(cmds[i:i+6])
            return True
                #assert False                 
    return False

def process_except_clause(cmds,i):
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l

    assert type(i) is int and i >= 0
    if SCmp(cmds,i, ('POP_TOP3', '*r', 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT0',), pos__b, (')ENDEXCEPT',)],pos__c])
        return True
    if SCmp(cmds,i, ('POP_TOP3', '*n', 'JUMP_CONTINUE', 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT0',), pos__b + [('CONTINUE',)], (')ENDEXCEPT',)],pos__d])
        return True
    if SCmp(cmds,i, ('POP_TOP3', 'JUMP_CONTINUE', 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT0',), [('CONTINUE',)], (')ENDEXCEPT',)],pos__c])
        return True
    if SCmp(cmds,i, ('POP_TOP3', 'JUMP', 'END_FINALLY')):
        if not islooplabel(pos__b[1],cmds):
           rpl(cmds,[[('(EXCEPT0',), [('PASS',)], (')ENDEXCEPT',)],('J_AFTER_EXCEPT_HANDLE', pos__b[1]),pos__c])
        else:   
           rpl(cmds,[[('(EXCEPT0',), [('CONTINUE',)], (')ENDEXCEPT',)],pos__c])
        return True
    if SCmp(cmds,i, ('POP_TOP3', '*n', 'JUMP', 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT0',), pos__b, (')ENDEXCEPT',)],('J_AFTER_EXCEPT_HANDLE', pos__c[1]),pos__d])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP', (':', 0,1), 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], pos__b, (')ENDEXCEPT',)],('J_AFTER_EXCEPT_HANDLE', pos__c[1]),pos__e])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', (':', 0,1), 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], pos__b + [('CONTINUE',)], (')ENDEXCEPT',)],pos__e])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 0,1), 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], pos__b, (')ENDEXCEPT',)],pos__d])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 0,1), 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], [('PASS',)], (')ENDEXCEPT',)],('J_AFTER_EXCEPT_HANDLE', pos__b[1]),pos__d])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', (':', 0,1), 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], [('CONTINUE',)], (')ENDEXCEPT',)],pos__d])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', (':', 0,1), 'END_FINALLY')):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], pos__b, (')ENDEXCEPT',)], pos__d])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'xJUMP_IF2_FALSE_POP', '*r',\
                    (':', 0, 1), 'END_FINALLY', '.:', '*n', ('::', 1))) and\
                    pos__a[1] != pos__f[1] != pos__b[1]:
        rpl(cmds,[pos__a, [('(IF', pos__b[2]), pos__c, (')ENDIF',)], pos__d,pos__e,pos__f,pos__g])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n',\
                    'xJUMP_IF2_FALSE_POP', '*n', \
                    'JUMP_CONTINUE', (':',0 ,1), \
                    'END_FINALLY', ('::', 2))):
        rpl(cmds,[[('(EXCEPT1',) +pos__a[2:], pos__b + \
                                 [('(IF',) + pos__c[2:], pos__d + [('CONTINUE',)], (')ENDIF',)],\
                         (')ENDEXCEPT',)], pos__g])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', (':', 0, 1), \
                    ('!', '(EXCEPT1', '*r', ')ENDEXCEPT'), 'END_FINALLY')):
        cmds[i:i+6] = [concatenate_except(pos__a[2:], pos__b + [('CONTINUE',)], pos__e),pos__f]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', (':', 0, 1), \
                    '*e', 'J_AFTER_EXCEPT_HANDLE')) and pos__c[1] == pos__f[1]:
        cmds[i:i+6] = [concatenate_except(pos__a[2:], pos__b + [('CONTINUE',)], pos__e),pos__f]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP', (':', 0, 1), \
                    '*e', 'J_AFTER_EXCEPT_HANDLE')) and pos__c[1] == pos__f[1]:
        cmds[i:i+6] = [concatenate_except(pos__a[2:], pos__b, pos__e),pos__f]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', (':', 0, 1), \
                    '*e', 'J_AFTER_EXCEPT_HANDLE_CONTINUE')) and pos__b[1] == pos__e[1]:
        cmds[i:i+5] = [concatenate_except(pos__a[2:], [('PASS',)], pos__d),pos__e]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', (':', 0, 1), \
                    '*e', 'END_FINALLY', 'JUMP_CONTINUE')) and pos__c[1] == pos__g[1]:
        cmds[i:i+7] = [concatenate_except(pos__a[2:], pos__b, pos__e),pos__f,pos__g]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', \
                    (':', 0, 1), '*e', 'J_AFTER_EXCEPT_HANDLE')) and pos__c[1] != pos__f[1]:
        rpl(cmds,[concatenate_except(pos__a[2:], pos__b + [('CONTINUE',)], pos__e),pos__f])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 0, 1), \
                    '*e', 'J_AFTER_EXCEPT_HANDLE')) and pos__b[1] == pos__e[1]:
        cmds[i:i+5] = [concatenate_except(pos__a[2:], [('PASS',)], pos__d),pos__e]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*', 'JUMP', (':', 0,1), '*e',
                    'END_FINALLY', ('::', 2))):
        rpl(cmds,[concatenate_except(pos__a[2:], pos__b, pos__e),pos__f])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 0, 1), '*e',\
                    'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 4, 2))):
        cmds[i:i+7] = [concatenate_except(pos__a[2:], pos__b, pos__d),pos__e,pos__f,pos__g]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 0, 1), '*e',\
                    'J_AFTER_EXCEPT_HANDLE', 'END_FINALLY', (':', 4, 1))):
        cmds[i:i+7] = [concatenate_except(pos__a[2:], pos__b, pos__d),pos__f]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 0, 1), '*e',\
                    'END_FINALLY')):
        cmds[i:i+5] = [concatenate_except(pos__a[2:], pos__b, pos__d),pos__e]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*r', (':', 0,1), '*e')):       
        cmds[i:i+4] = [concatenate_except(pos__a[2:], pos__b, pos__d)]
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*ra', 'JUMP', (':', 0,1), '*e')) and\
                    pos__c[1] != pos__a[1]:
        rpl(cmds,[concatenate_except(pos__a[2:], pos__b, pos__e)])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP', (':', 0, 1), '*e',\
                    'END_FINALLY', ('::', 1))):
        rpl(cmds,[concatenate_except(pos__a[2:], [('PASS',)], pos__d),pos__e])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', '*n', 'JUMP_CONTINUE', \
                    (':', 0, 1), '*e', 'END_FINALLY')):          
        rpl(cmds,[concatenate_except(pos__a[2:], pos__b + [('CONTINUE',)], pos__e),pos__f])
        return True
    if SCmp(cmds,i, ('JUMP_IF_NOT_EXCEPTION_POP', 'JUMP_CONTINUE', \
                    (':', 0, 1), '*e', 'END_FINALLY')):          
        rpl(cmds,[concatenate_except(pos__a[2:], [('CONTINUE',)], pos__d),pos__e])
        return True
    return False
    
def process_after_try_detect(cmds,_i):
    global count_define_set
    assert type(_i) is int and _i >= 0
    aa = cmds[_i]
    v0,v1,v2 = [], [], []
    if len(aa) == 5 and aa[0] == ('(TRY',) and \
       len(aa[1]) == 2 and aa[1][0][0] == '.L' and\
       TCmp(aa[1][1], v0, ('STORE', (('STORE_NAME', '?'),), \
                                 (('!IMPORT_NAME', '?', '?', '?'),))) and \
       TCmp(aa[2], v1, (')(EXCEPT', (('!LOAD_BUILTIN', 'ImportError'), '?'), ())) and\
       len(aa[3]) == 2 and aa[3][0][0] == '.L' and\
       TCmp(aa[3][1], v2, ('STORE', (('STORE_NAME', '?'),), (('CONST', None),))) and \
       aa[4] == (')ENDTRY',) and v0[0] == v0[1] and v0[0] == v2[0]:
            this, d = None, None
            this, d = MyImport(v0[1])
            cmds[_i] = aa[1]
            if v0[0] in count_define_set and count_define_set[v0[0]] > 1:
                count_define_set[v0[0]] -= 1
    
def process_setup_except(cmds,i):
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l
    
    assert type(i) is int and i >= 0

    if SCmp(cmds,i, ('J_SETUP_EXCEPT', 'xJUMP_IF2_TRUE_POP_CONTINUE', '*l', 'POP_BLOCK')):
        if type(pos__c) is tuple:
            rpl(cmds,[pos__a, [('(IF',) + pos__b[2:], [('CONTINUE',)], (')ENDIF',)]+[pos__c],pos__d])
        else:    
            rpl(cmds,[pos__a, [('(IF',) + pos__b[2:], [('CONTINUE',)], (')ENDIF',)]+pos__c,pos__d])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*', 'POP_BLOCK', 'JUMP', ('::', 0))) and pos__d[1] != pos__e[1]:
        rpl(cmds,[('(BEGIN_TRY',), pos__b, (')END_BEGIN_TRY',), ('J_IF_NO_EXCEPT_IN_TRY', pos__d[1])])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', 'POP_BLOCK', 'JUMP', ('::', 0))) and pos__d[1] != pos__c[1]:
        rpl(cmds,[('(BEGIN_TRY',), [('PASS',)], (')END_BEGIN_TRY',), ('J_IF_NO_EXCEPT_IN_TRY', pos__c[1])])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', 'JUMP_CONTINUE', 'POP_BLOCK', 'JUMP_CONTINUE', \
                    (':', 0, 1))) and pos__b[1] == pos__d[1]:
        rpl(cmds,[('(BEGIN_TRY',), [('CONTINUE',)], (')END_BEGIN_TRY',)])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', 'POP_BLOCK', 'JUMP_CONTINUE', \
                    (':', 0, 1))):
        rpl(cmds,[('(BEGIN_TRY',), [('CONTINUE',)], (')END_BEGIN_TRY',)])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*', 'JUMP_CONTINUE', \
                    'POP_BLOCK', 'JUMP', ('::', 0))) and pos__e[1] != pos__f[1]:
        rpl(cmds,[('(BEGIN_TRY',), pos__b + [('CONTINUE',)], (')END_BEGIN_TRY',), \
                       ('J_IF_NO_EXCEPT_IN_TRY', pos__e[1])])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*n', 'JUMP', ('::', 0))) and pos__c[1] != pos__d[1]:
        rpl(cmds,[('(BEGIN_TRY',), pos__b, (')END_BEGIN_TRY',), ('J_IF_NO_EXCEPT_IN_TRY', pos__c[1])])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*n', 'JUMP_CONTINUE', ('::', 0))) and pos__c[1] != pos__d[1]:
        rpl(cmds,[('(BEGIN_TRY',), pos__b +[('CONTINUE',)], (')END_BEGIN_TRY',)])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*n', 'JUMP_CONTINUE', 'POP_BLOCK',\
                    'JUMP_CONTINUE', (':', 0,1), '*e')):
        rpl(cmds,[('(BEGIN_TRY',), pos__b +[('CONTINUE',)], (')END_BEGIN_TRY',),pos__g])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*', 'POP_BLOCK', 'JUMP_CONTINUE', ('::', 0))) and pos__d[1] != pos__e[1]:
        rpl(cmds,[('(BEGIN_TRY',), pos__b, (')END_BEGIN_TRY',), ('J_IF_NO_EXCEPT_IN_TRY', pos__d[1])])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', '*r', ('::', 0))):
        rpl(cmds,[('(BEGIN_TRY',), pos__b, (')END_BEGIN_TRY',)])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', 'JUMP_CONTINUE', 'POP_BLOCK',\
                    'JUMP_CONTINUE', (':', 0,1), '*e', \
                    'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY',\
                    'JUMP_CONTINUE')) and pos__b[1] == pos__d[1] == pos__g[1] == pos__i[1]:
        rpl(cmds,[concatenate_try_except([('CONTINUE',)],pos__f), pos__i])
        return True
    if SCmp(cmds,i, ('J_SETUP_EXCEPT', 'POP_BLOCK', 'JUMP_CONTINUE', (':', 0, 1),\
                    '*e', 'J_AFTER_EXCEPT_HANDLE_CONTINUE', 'END_FINALLY',\
                    'JUMP_CONTINUE')) and pos__c[1] == pos__f[1] == pos__h[1]:
        rpl(cmds,[concatenate_try_except([('PASS',)],pos__e), pos__h])
        return True    
    return False
    
def concatenate_try_except(bl1, exc_tail, else_tail = None):
    out = []
    out.append(('(TRY',))
    out.append(bl1)
    if exc_tail is None:
       if else_tail is not None: 
          out.append((')(ELSE',))
          out.append(else_tail)
       out.append((')ENDTRY',) )
       return out
    tail = exc_tail[:]
    assert type(tail) is list
    while len(tail) > 0 and tail[0][0] == '.L':
        del tail[0]
    if tail[0][0] in ('(EXCEPT','(EXCEPT0','(EXCEPT1'):
        t1 = (')(EXCEPT',) + tail[0][1:]
        out.append(t1)
        return add_endtry(out, tail, bl1, exc_tail, else_tail)
    elif tail[0][0] == '(EXCEPT0':
        out.append((')(EXCEPT',))
        return add_endtry(out, tail, bl1, exc_tail, else_tail)
    Fatal('Error in exception sequence', bl1, exc_tail, else_tail)
    assert False
    return '~'

def add_endtry(out, tail, bl1, exc_tail, else_tail):
    assert type(tail) is list
    assert type(out) is list
    del tail[0]
    out.extend(tail[:-1])
    if tail[-1][0] != ')ENDEXCEPT':
        Fatal('Must be ENDEXCEPT', bl1, exc_tail, else_tail)
        assert False
        return '%%'
    if else_tail is not None: 
        out.append((')(ELSE',))
        out.append(else_tail)
    out.append((')ENDTRY',))
    return out
    
def concatenate_except(cond, bl1, exc_tail):
    out = []
    out.append(('(EXCEPT',) + cond)
    out.append(bl1)
    if exc_tail is None:
       out.append((')ENDEXCEPT',) )
       return out
    tail = exc_tail[:]
    assert type(tail) is list
    while len(tail) > 0 and tail[0][0] == '.L':
        del tail[0]
    if len(tail) == 0:
       out.append((')ENDEXCEPT',) )
       return out
    if tail[0][0] in ('(EXCEPT','(EXCEPT0','(EXCEPT1'):
        t1 = (')(EXCEPT',) + tail[0][1:]
        out.append(t1)
        del tail[0]
        out.extend(tail)
        return out
    elif tail[0][0] == '(EXCEPT0':
        t1 = (')(EXCEPT',)
        out.append(t1)
        del tail[0]
        out.extend(tail)
        return out
    Fatal('Error in concatenate except', filename)
    assert False
    return '~'

def attempt_convert_ncmp_to_boolean_and(t):
    assert t[0] == '!NCMP'
    t1 = t[1]
    assert len(t1) >= 3
    _v = []
    if TCmp (t,_v,  ('!NCMP', 
                        (
                            ('CONST', '?'), 
                            '<=', 
                            ('PY_TYPE', '?', '?', ('FAST', '?'), None), 
                            '<=', 
                            ('CONST', '?')
                        ) ) ):
        return ('!AND_BOOLEAN', 
                ('!c_Py_GE_Int', 
                        ('PY_TYPE', _v[1], _v[2], ('FAST', _v[3]), None), 
                        ('CONST', _v[0])),
                ('!c_Py_LE_Int', 
                        ('PY_TYPE', _v[1], _v[2], ('FAST', _v[3]), None), 
                        ('CONST', _v[4])))
    _v = []
    if TCmp (t,_v,  ('!NCMP', 
                        (
                            ('CONST', '?'), 
                            '<=', 
                            ('FAST', '?'), 
                            '<=', 
                            ('CONST', '?')
                        ) ) ) and type(_v[0]) is int and type(_v[2]) is int:

        return ('!AND_BOOLEAN', 
                ('!c_Py_GE_Int', 
                        ('FAST', _v[1]), 
                        ('CONST', _v[0])),
                ('!c_Py_LE_Int', 
                        ('FAST', _v[1]), 
                        ('CONST', _v[2])))
    _v = []
    if TCmp (t,_v,  ('!NCMP', 
                        (
                            ('CONST', '?'), 
                            '<', 
                            ('FAST', '?'), 
                            '<', 
                            ('CONST', '?')
                        ) ) ) and type(_v[0]) is int and type(_v[2]) is int:

        return ('!AND_BOOLEAN', 
                ('!c_Py_GT_Int', 
                        ('FAST', _v[1]), 
                        ('CONST', _v[0])),
                ('!c_Py_LT_Int', 
                        ('FAST', _v[1]), 
                        ('CONST', _v[2])))
    _v = []
    if TCmp (t,_v,  ('!NCMP', 
                        (
                            ('CONST', '?'), 
                            '<=', 
                            ('FAST', '?'), 
                            '<', 
                            ('CONST', '?')
                        ) ) ) and type(_v[0]) is int and type(_v[2]) is int:

        return ('!AND_BOOLEAN', 
                ('!c_Py_GE_Int', 
                        ('FAST', _v[1]), 
                        ('CONST', _v[0])),
                ('!c_Py_LT_Int', 
                        ('FAST', _v[1]), 
                        ('CONST', _v[2])))
                        
    _v = []
    if TCmp (t,_v,  ('!NCMP', 
                        (
                            ('CONST', '?'), 
                            '>', 
                            ('FAST', '?'), 
                            '>=', 
                            ('CONST', '?')
                        ) ) ) and type(_v[0]) is int and type(_v[2]) is int:

        return ('!AND_BOOLEAN', 
                ('!c_Py_LT_Int', 
                        ('FAST', _v[1]), 
                        ('CONST', _v[0])),
                ('!c_Py_GE_Int', 
                        ('FAST', _v[1]), 
                        ('CONST', _v[2])))   
    return t
    
def New_3Cmp(tupl):
    t = ('!NCMP', tuple(tupl[1:]))
    t = attempt_convert_ncmp_to_boolean_and(t)
    return ('!BOOLEAN', t)                 

def New_NCmp(tupl):
    t = ('!NCMP', tupl)
    t = attempt_convert_ncmp_to_boolean_and(t)
    return ('!BOOLEAN', t)                 

def isintconst(b):
    return type(b) is tuple and len(b) == 2 and b[0] == 'CONST' \
            and type(b[1]) is int

def rpl(cmds,new):
    global matched_tail_label

    if matched_tail_label is not None and (matched_tail_label[1] > 0 or matched_tail_label[3]):
        new = new + [matched_tail_label[2]]
    if type(new) is list:    
        if len(new) >= 2 and type(new[-1]) is tuple and type(new[-2]) is tuple and\
        len(new[-1]) == 2 and len(new[-2]) == 2 and new[-1][0] == '.:'  and new[-2][0] == '.:' and\
        new[-1][1] == new[-2][1]:
            Fatal("Dublicate label")
            assert False
    cmds[matched_i:matched_i+matched_len] = new
    return 

def begin_cmp():
    global matched_i
    global matched_p
    global matched_len
    global matched_tail_label
    matched_i = -1
    matched_p = None
    matched_len = -1
    matched_tail_label = None

stats__ = {}
scmp_debug = False

def SCmp(cmds,i0,pattern,recursive=False):
    global matched_i
    global matched_p
    global matched_len
    global stats__
    global matched_tail_label
    global used_cmpl, used_cmp, used_line, matched_cmpl, matched_cmp,matched_line,collect_stat##,p2l
    global pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l
    global scmp_debug
    
    ## if pattern not in stats__:
        ## stats__[pattern] = 0
    ## stats__[pattern] += 1
    if type(cmds) is tuple:
        return False
    assert type(cmds) is list
    assert type(i0) is int
    assert i0 >= 0
    assert i0 < MInt / 20
    assert type(pattern) is tuple
    if len(pattern) > len(cmds) - i0:
        return False
    tempor = None ##cmds[i0:i0+len(pattern)]
##    assert type(tempor) is None
    for i,p in enumerate(pattern):
        assert type(tempor) is list or tempor is None
        if type(tempor) is list and i >= len(tempor):
            return False
        if tempor is None:
            tempi = cmds[i0+i]
        else:
            tempi = tempor[i]
        if type(tempi) is tuple:
            if type(p) is str:
                tempi_0 = tempi[0]
                if type(tempi_0) is str:
                    if tempi_0 == p:
                        continue
                    if p.startswith('xJUMP_IF2'):
                        p1_ = p[1:]
                        if p1_ in anagr:
                            if tempi_0 == p1_:
                                continue
                            elif tempi_0 == anagr[p1_]:
                                assert len(tempi) >= 2
                                if tempor is None:
                                    tempor = cmds[i0:i0+len(pattern)]
                                tempi = tempor[i] = (p1_, tempi[1], Not(tempi[2])) #tuple(tempi)
                                continue
                        return False    
                if p == 'ju':
                    if tempi_0 not in ('JUMP', 'JUMP_CONTINUE'):
                        return False
                    continue
                elif p == 'jc':
                    if tempi_0 not in ('JUMP', 'JUMP_CONTINUE') or not islooplabel(tempi[1],cmds):
                        return False
                    continue
                elif p == '>':
                    if len(tempi) >= 1 and type(tempi_0) is str and \
                    (tempi_0 in ('CONST', 'FAST', 'LOAD_FAST', 'LOAD_CONST', 'LOAD_CLOSURE', 'PY_TYPE') or\
                        tempi_0[0] == '!'):
                            continue
                    return False   
                elif p == '=':
                    if tempi_0 in set_any:
                        continue
                    return False
                elif p in ('*', '*r', '*ra', '*c', '*e', '*n'):
                    return False
                elif p == '*l':
                    if type(tempi_0) is str and tempi_0 == '.L':    
                        continue
                    return False  
                elif p == '**n':
                    if tempor is None:
                        tempor = cmds[i0:i0+len(pattern)]
                    tempor[i:i+1] = [[('PASS',)], tempi]
                    tempor = tempor[0:len(pattern)]
                    continue
                elif p == '!GET_ITER' and tempi == ('LOAD_FAST', '.0'):
                    continue
            elif type(p) is tuple:
                if p[0] == ':' and len(tempi) >= 2 and type(tempi[1]) is int:
                    if len(p) == 3:
                        if type(p[1]) is tuple:
                            for p_p in p[1]:
                                assert type(p_p) is int and p_p >= 0
                                if tempor is None:
                                    tempor = cmds[i0:i0+len(pattern)]
                                if p_p >= len(tempor) or not label(tempor[p_p], tempi):
                                    return False
                        elif p[1] is not None:
                            if tempor is None:
                                tempor = cmds[i0:i0+len(pattern)]
                            if p[1] >= len(tempor) or not label(tempor[p[1]], tempi):
                                return False
                        is_one = OneJumpCache(tempi[1],cmds)        
                        if p[2] == 1 and not is_one:
                            return False
                        if p[2] == 2 and is_one:
                            return False
                elif p[0] == '::':
                    if len(p) == 2:
                        ltemp = 0
                        isjump = False
                        if tempi[0] == '.:': 
                            if type(p[1]) is tuple:
                                ltemp = len(p[1])
                                for p_p in p[1]:
                                    assert type(p_p) is int and p_p >= 0
                                    if not label(cmds[i0+p_p], tempi):
                                        return False
                            elif p[1] is not None:
                                ltemp = 1
                                if not label(cmds[i0+p[1]], tempi):
                                    return False
                            assert len(tempi) >= 2  
                            cnt_ju = CountJumpCache(tempi[1],cmds)        
                            if cnt_ju == 0:
                                return False
                        elif tempi[0] in jump: 
                            isjump = True
                            if type(p[1]) is tuple:
                                ltemp = len(p[1])
                                for p_p in p[1]:
                                    assert type(p_p) is int and p_p >= 0
                                    if not endlabel(cmds[i0+p_p], tempi):
                                        return False
                            elif p[1] is not None:
                                ltemp = 1
                                if not endlabel(cmds[i0+p[1]], tempi):
                                    return False
                            assert len(tempi) >= 2
                            cnt_ju = CountJumpCache(tempi[1],cmds)        
                            if cnt_ju == 0:
                                return False
                        else:
                            return False    
                        if i == len(pattern)-1:
                            if cnt_ju == -2:
                                assert len(tempi) >= 2
                                cnt_ju = CountJumpCache(tempi[1],cmds)        
                            matched_tail_label = (p, cnt_ju-ltemp, tempi, isjump)
                elif len(p) == 2:
                    if len(tempi) < 2 or not (p[0] == tempi[0] and p[1] == tempi[1]):
                        return False
                continue
            if type(tempi[0]) is str and type(p) is str and tempi[0] != p:
                return False
            if tempi[0] != p:
                return False
            
        elif type(tempi) is list:
            if type(p) is str:
                tempi_0 = tempi[0]
                assert type(tempi_0) is tuple
                if p == '*':
                    if (len(tempi) > 1 or tempi_0[0] != '.L'):
                        continue
                    return False
                elif p == '*r':
                    if tempi[-1][0] == 'RETURN_VALUE':
                        continue
                    return False
                elif p == '*ra':
                    if tempi[-1][0] == 'RAISE_VARARGS':
                        continue
                    return False
                elif p == '*c':
                    if tempi[-1][0] == 'CONTINUE':
                        continue
                    return False
                elif p == '*l':
                    if len(tempi) == 1 and tempi_0[0] == '.L':
                        continue
                    return False  
                elif p == '*e':
                    if not isexceptblock(tempi):
                        return False
                    continue
                elif p == '*n':
                    if (len(tempi) > 1 or tempi_0[0] != '.L'):
                        if tempi[-1][0] == 'RETURN_VALUE' or isexceptblock(tempi):
                            return False
                        continue
                    return False
                elif p == '**n':
                    if (len(tempi) > 1 or tempi_0[0] != '.L'):
                        if tempi[-1][0] == 'RETURN_VALUE' or isexceptblock(tempi):
                            return False
                    else:                
                        if tempor is None:
                            tempor = cmds[i0:i0+len(pattern)]
                        tempor[i:i+1] = [[('PASS',)], tempi]
                        tempor = tempor[0:len(pattern)]
                    continue
            elif type(p) is tuple:
                if p[0] == '!':
                    if len(tempi) == len(p)-1 and SCmp(tempi,0, p[1:],True):
                        continue
                    return False                
                elif p[0] == '::':
                    if len(p) == 2:
                        if tempi[0] in jump: 
                            if type(p[1]) is tuple:
                                for p_p in p[1]:
                                    assert type(p_p) is int and p_p >= 0
                                    if not endlabel(cmds[i0+p_p], tempi):
                                        return False
                            elif p[1] is not None:
                                if not endlabel(cmds[i0+p[1]], tempi):
                                    return False
                            assert False
                        else:
                            return False    
                        if i == len(pattern)-1:
                            if cnt_ju == -2:
                                assert False
                            matched_tail_label = (p, cnt_ju-ltemp, tempi, isjump)
                elif len(p) == 2:
                    if len(tempi) < 2 or not (p[0] == tempi[0] and p[1] == tempi[1]):
                        return False
                continue
            if tempi[0] != p:
                return False
            
    if not recursive:   
       matched_i = i0   
       matched_p = pattern
       matched_len = len(pattern)
       if tempor is None:
            tempor = cmds[i0:i0+len(pattern)]
           
       assert type(tempor) is list
       if len(tempor) > 12:
            tempor = tempor[:12]
       else:
            while len(tempor) < 12:
                tempor.append('^^') # ibo nefig
       pos__a,pos__b,pos__c,pos__d,pos__e,pos__f,pos__g,pos__h,pos__i,pos__j,pos__k,pos__l = tempor    
    return True    

def islineblock(a):
    if type(a) is list:
        if len(a) == 1 and a[0][0] == '.L':
            return True
    elif type(a) is tuple and a[0] == '.L':
        return True    
    return False  

def isblock(a):
    if type(a) is list:
        if len(a) > 1:
            return True
        if a[0][0] == '.L':
            return False
        else:
            return True
    else:
        return False 

def isretblock(a):
    return type(a) is list and a[-1][0] == 'RETURN_VALUE'

def islooplabel(label,cmds):
    if type(label) is int and type(cmds) is list:
        for i, v in enumerate(cmds):
            if type(v) is tuple and len(v) == 2 and type(v[1]) is int and v[1] == label and v[0] == '.:' and i > 0:
                jcmd = cmds[i-1][0]
                if type(jcmd) is str:
                    if jcmd == 'J_SETUP_LOOP_FOR' and cmds[i+1][0] == 'J_LOOP_VARS':
                        return True
                    if jcmd == 'J_SETUP_LOOP':
                        return True
                return False
    return False       

def isexceptblock(a):
    if type(a) is list:
        if a[-1][0] == ')ENDEXCEPT':
            if a[0][0] in ('(EXCEPT', '(EXCEPT0', '(EXCEPT1'):
                return True
            if a[0][0] == '.L' and a[1][0]  in ('(EXCEPT', '(EXCEPT0', '(EXCEPT1'):
                return True
    return False

def revert_conditional_jump_over_uncond_jump(cmds):
    i = 0
    while i < ( len(cmds) - 4):            
        a = cmds[i]
        if type(a[0]) is str and (a[0].startswith('JUMP_IF_') and a[0].endswith('_POP')):
            b,c, d = cmds[i+1], cmds[i+2], cmds[i+3]
            if b[0] == '.L' and c[0] in jump and d[0] == '.:' and a[1] == d[1]:
                if a[0] == 'JUMP_IF_FALSE_POP':
                    e = 'JUMP_IF_TRUE_POP'
                else:
                    e = 'JUMP_IF_FALSE_POP'
                oldlabel = a[1]    
                cmds[i:i+4] = [(e, c[1]),b,d] 
                del_if_unused_label(cmds, oldlabel)
                continue
            elif b[0] in jump and c[0] == '.:' and a[1] == c[1]:
                if a[0] == 'JUMP_IF_FALSE_POP':
                    e = 'JUMP_IF_TRUE_POP'
                else:
                    e = 'JUMP_IF_FALSE_POP'
                oldlabel = a[1]
                cmds[i:i+3] = [(e, b[1]),c] 
                del_if_unused_label(cmds, oldlabel)
                continue
        i = i + 1    
    
def del_dead_code(cmds):
    i = 0
    updated = False
    while i < (len(cmds) - 1):  
        assert type(i) is int and i >= 0        
        cmd = cmds[i]
        if cmd[0] in jump:
            cmd2 = cmds[i+1]
            if cmd2[0] not in ('END_FINALLY', 'POP_BLOCK') and (type(cmd2[0]) != str or cmd2[0][0] != '.'):
                del cmds[i+1]
                updated = True
                continue
            elif cmd2[0] == '.L':
                del cmds[i+1]
                updated = True
                continue
            elif cmd2[0] == '.:' and cmd2[1] == cmd[1]:
                oldlabel = cmd[1]
                del cmds[i]
                del_if_unused_label(cmds, oldlabel)
                i = max(0, i-3)
                updated = True
                continue
        i = i + 1        
    i = 0
    while i < (len(cmds) - 1):   
        assert type(i) is int and i >= 0     
        cmd = cmds[i]
        if cmd[0] == 'RETURN_VALUE' and \
        (type(cmds[i+1][0]) != str or cmds[i+1][0][0] != '.') and \
        cmds[i+1][0]  not in ('END_FINALLY', 'POP_BLOCK'):
            del cmds[i+1]
            updated = True
            continue
        elif cmd[0] == 'RETURN_VALUE' and cmds[i+1][0] == '.L':
            del cmds[i+1]
            updated = True
            continue
        i = i + 1 
    i = 0
    while i < (len(cmds) - 1):   
        assert type(i) is int and i >= 0     
        a,b = cmds[i], cmds[i+1]
        if type(a) is list and type(b) is list:
            cmds[i] = a+b
            del cmds[i+1]
            continue
        i = i + 1 

    return updated

def set_conditional_jump_popped(cmds):
    i = 0    
    updated = False
    while i < (len(cmds) - 1):         
        assert type(i) is int and i >= 0         
        cmd,b = cmds[i], cmds[i+1]
        if (( cmd[0] == 'JUMP_IF_FALSE' or cmd[0] == 'JUMP_IF_TRUE' ) and b[0] == 'POP_TOP'):

           ## assert type(cmd[1]) is int
           ## assert ('.:', cmd[1]) in cmds
           ttem = after_label(cmds, cmd[1], 3)

           to_label, pos_to_label = ttem ##after_label(cmds, cmd[1], 3)
           assert type(pos_to_label) is int and pos_to_label >= 0
           oldlabel = cmd[1]
           if to_label[1][0] == 'POP_TOP':
               if to_label[2][0] == '.:':
                    cmds[i:i+2] = [(cmd[0] + '_POP', to_label[2][1])]
                    del_if_unused_label(cmds, oldlabel)
                    i = max(0, i-3)
                    updated = True
                    continue
               elif pos_to_label > i+2:
                    new_label = gen_new_label(cmds)
                    cmds.insert(pos_to_label+2, ('.:', new_label))              
                    cmds[i:i+2] = [(cmd[0] + '_POP', new_label)]
                    del_if_unused_label(cmds, oldlabel)
                    i = max(0, i-3)
                    updated = True
                    continue
               elif pos_to_label < i:
                    new_label = gen_new_label(cmds)
                    cmds[i:i+2] = [(cmd[0] + '_POP', new_label)]
                    cmds.insert(pos_to_label+2, ('.:', new_label))              
                    del_if_unused_label(cmds, oldlabel)
                    i = max(0, pos_to_label-3) ### 27 08 2010 erlier pos_label (name of func)
                    updated = True
                    continue
               else:
                    Fatal('/3', 'Unhandled', to_label, '???', pos_to_label)   
                    assert False 
        i = i + 1        
    i3 = 0
    while i3 < (len(cmds) - 1):   
        assert type(i3) is int and i3 >= 0         
        cmd,b = cmds[i3], cmds[i3+1]
        if (( cmd[0] == 'JUMP_IF_FALSE' or cmd[0] == 'JUMP_IF_TRUE' ) and b[0] == 'POP_TOP'):
           to_label, pos_to_label = after_label(cmds, cmd[1], 3)
           assert type(pos_to_label) is int and pos_to_label >= 0
           oldlabel = cmd[1]
           if ( to_label[1][0] == 'JUMP_IF_FALSE_POP' and cmd[0] == 'JUMP_IF_FALSE') or\
              ( to_label[1][0] == 'JUMP_IF_TRUE_POP' and cmd[0] == 'JUMP_IF_TRUE'):
                cmds[i3:i3+2] = [(cmd[0] + '_POP', to_label[1][1])]
                del_if_unused_label(cmds, oldlabel)                
                i3 = max(0, i3-3)
                updated = True
                continue
        i3 = i3 + 1        

    i2 = 0
    while i2 < (len(cmds) - 1):           
        assert type(i2) is int and i2 >= 0         
        cmd,b = cmds[i2], cmds[i2+1]
        if (( cmd[0] == 'JUMP_IF_FALSE' or cmd[0] == 'JUMP_IF_TRUE' ) and b[0] == 'POP_TOP'):
           to_label, pos_to_label = after_label(cmds, cmd[1], 3)
           assert type(pos_to_label) is int and pos_to_label >= 0
           oldlabel = cmd[1]
           if len(to_label) >= 3 and to_label[2][0] == '.:' and \
             (( to_label[1][0] == 'JUMP_IF_FALSE_POP' and cmd[0] == 'JUMP_IF_TRUE') or\
              ( to_label[1][0] == 'JUMP_IF_TRUE_POP' and cmd[0] == 'JUMP_IF_FALSE')):
                cmds[i2:i2+2] = [(cmd[0] + '_POP', to_label[2][1])]
                del_if_unused_label(cmds, oldlabel)                
                i2 = max(0, i2-3)
                updated = True
                continue
        i2 = i2 + 1      
    i1 = 1
    while i1 < (len(cmds) - 1) and i1 > 0:         
        assert type(i1) is int and i1 >= 0           
        prev,cmd,b = cmds[i1-1],cmds[i1], cmds[i1+1]
        if (( cmd[0] == 'JUMP_IF_FALSE' or cmd[0] == 'JUMP_IF_TRUE' ) and b[0] == 'POP_TOP' and prev[0] == 'LOAD_FAST'):
           to_label, pos_to_label = after_label(cmds, cmd[1], 3)
           assert type(pos_to_label) is int and pos_to_label >= 0
           oldlabel = cmd[1]
           if ( to_label[1][0] == 'STORE_FAST' and \
               to_label[1][1] == prev[1]):
               if to_label[2][0] == '.:':
                    cmds[i1:i1+2] = [(cmd[0] + '_POP', to_label[2][1])]
                    del_if_unused_label(cmds, oldlabel)                    
                    i1 = max(0, i1-3)
                    updated = True
                    continue
               elif pos_to_label > i1+2:
                      new_label = gen_new_label(cmds)
                      cmds.insert(pos_to_label+2, ('.:', new_label))              
                      cmds[i1:i1+2] = [(cmd[0] + '_POP', new_label)]
                      del_if_unused_label(cmds, oldlabel)                      
                      i1 = max(0, i1-3)
                      updated = True
                      continue
               elif pos_to_label < i1:
                      new_label = gen_new_label(cmds)
                      cmds[i1:i1+2] = [(cmd[0] + '_POP', new_label)]
                      cmds.insert(pos_to_label+2, ('.:', new_label))              
                      del_if_unused_label(cmds, oldlabel)
                      
                      i1 = max(0, pos_to_label-3)  
                      updated = True
                      continue
        i1 = i1 + 1        
    return updated

def print_cmds(cmds):
    if not print_pycmd:
        return
    pp_out(out, 'co_const:')
    pprint_to_f(out, consts_from_cmds(cmds))
    pprint_to_f(out, cmds, 4, 120)
    return None

cache_jumps = {}

def ClearJumpCache():
    cache_jumps.clear()
    
def CountJumpCache(_label, cmds):
    assert type(_label) is int
    if _label in cache_jumps:
        v2 = cache_jumps[_label]
        assert type(v2) is int
        return v2
    if type(cmds) is list and type(_label) is int:
        label = _label
        v = len([x for x in cmds if type(x) is tuple and len(x) > 1 and type(x[1]) is int and x[1] == label and \
                 type(x[0]) is str and x[0].startswith('J')])
        cache_jumps[_label] = v
        return v

def OneJumpCache(label, cmds):
    if label in cache_jumps:
        v2 = cache_jumps[label]
        assert type(v2) is int
        return v2 == 1
    if type(cmds) is list and type(label) is int:
        v = len([x for x in cmds if type(x) is tuple and len(x) > 1 and type(x[1]) is int and x[1] == label and \
                 type(x[0]) is str and x[0].startswith('J')])
        cache_jumps[label] = v
        return v == 1
    else:
        pp(type(cmds))
        pp(type(label), label)
        pprint(cmds)        
        Fatal('CntJump of tuple', label, cmds)
        assert False
        return False

def TupleFromArgs(args):
    if len(args) > 0 and args[0] in ('!BUILD_TUPLE', 'CONST'):
        return args
    if len([x for x in args if x[0] != 'CONST']) == 0:
        return ('CONST', tuple([x[1] for x in args]))
    return ('!BUILD_TUPLE', args)

def DictFromArgs(args):
    return ('!BUILD_MAP', args)    

def cmd2mem(cmd):
    assert type(cmd) is tuple
    cm = cmd[0]
    if type(cm) is str:
        if cm == 'LOAD_CLOSURE':
            return ('LOAD_CLOSURE', cmd[1])
        if cm == 'LOAD_FAST':
            return ('FAST', cmd[1])
        if cm == 'LOAD_CONST':
            return ('CONST', cmd[1])
        if cm.startswith('!'):
            return cmd
        if cm in ('CONST', 'FAST', 'CALC_CONST'):
            return cmd
        if cm == 'PY_TYPE':
            return cmd
    Fatal('Illegal cms2mem', cmd)
    assert False
    return ()

def is_cmdmem(cmd):
    if type(cmd) is tuple and len(cmd) > 0:
        a = cmd[0]
        if type(a) is str:
            return a in ('CONST', 'FAST', 'LOAD_FAST', 'LOAD_CONST', 'LOAD_CLOSURE', 'PY_TYPE', 'CALC_CONST') \
                or (type(a) is str and a[0] == '!')
    return False

def del_if_unused_label(cmds, oldlabel):
    assert type(cmds) is list
    assert type(oldlabel) is int
    la = [x[1] for x in cmds if type(x) is tuple and len(x) > 1 and type(x[0]) is str and x[0][0] == 'J']
    if oldlabel not in la:
        i = 0
        while i < len(cmds):    
            assert type(i) is int        
            cmd = cmds[i]
            if type(cmd) is tuple and len(cmd) > 1:
                if cmd[0] == '.:' and cmd[1] == oldlabel:
                    if i > 0 and cmds[i-1][0] in jump and i < (len(cmds) - 1) and cmds[i+1][0] == 'POP_TOP':
                        del cmds[i]
                        del cmds[i]
                        continue
                    else:    
                        del cmds[i]
                    if i > 0 and cmds[i][0] == '.L' and cmds[i-1][0] == '.L':
                        del cmds[i]
                        continue
                    return
            i = i + 1 
            
def gen_new_label(cmds):
    return max( [x[1] for x in cmds if x[0] == '.:']) + 1

def after_label(cmds, label, n):
    for i in range(len(cmds)):            
        cmd = cmds[i]
        if type(cmd) is tuple and cmd[0] == '.:' and cmd[1] == label:
            return cmds[i:i+n], i
    assert ('.:', label) not in cmds
    assert False

         
def pos_label(cmds, label):
    i = 0
    while i < len(cmds):    
        assert type(i) is int        
        if cmds[i][0] == '.:' and cmds[i][1] == label:
            return i
        i = i + 1
        
def NoGoToGo(cmds):   
    while True:
        updated = False
        i = 0        
        while i < (len(cmds) - 3):  
            assert type(i) is int and i >= 0 and i <= (MInt / 10)
            cmdsi, cmdsi1, cmdsi2 = cmds[i:i+3]          
            if cmdsi[0] == 'JUMP_IF_TRUE' and cmdsi1[0] == 'JUMP' and cmdsi2[0] == '.:' and \
            cmdsi[1] == cmdsi2[1] and cmdsi[1] != cmdsi1[1]:
                oldlabel = cmdsi2[1]
                cmds[i:i+3] = [('JUMP_IF_FALSE', cmdsi1[1]), cmdsi2]
                del_if_unused_label(cmds, oldlabel)                
                i = max(0, i-3)
                updated = True
                continue
            if cmdsi[0] == 'JUMP_IF_FALSE' and cmdsi1[0] == 'JUMP' and cmdsi2[0] == '.:' and \
            cmdsi[1] == cmdsi2[1] and cmdsi[1] != cmdsi1[1]:
                oldlabel = cmdsi2[1]
                cmds[i:i+3] = [('JUMP_IF_TRUE', cmdsi1[1]), cmdsi2]
                del_if_unused_label(cmds, oldlabel)                
                i = max(0, i-3)
                updated = True
                continue
            i += 1        
        i = 0
        while i < len(cmds)-1:
                assert type(i) is int and i >= 0
                a,b = cmds[i], cmds[i+1]
                if type(a) is tuple and type(b) is tuple and len(b) > 1 and len(a) > 1:
                    if b[0] == '.:' and ((a[0] == 'JUMP_ABSOLUTE' or \
                                        a[0] in jump) and a[1] == b[1]):
                        oldlabel = a[1]
                        del cmds[i]
                        updated = True
                        del_if_unused_label(cmds, oldlabel)                        
                        continue
                i += 1  
                
        crossjump = {}
        for i in range(len(cmds) - 1):
            a,b = cmds[i], cmds[i+1]
            if type(a) is tuple and type(b) is tuple and len(b) > 1 and len(a) > 1:
                if a[0] == '.:' and ((b[0] == 'JUMP_ABSOLUTE' or \
                                    b[0] in jump) and a[1] != b[1]):
                    crossjump[a[1]] = b[1]
        loopes = {}
        for i in range(len(cmds)):
            a = cmds[i]
            if a[0] in ('J_SETUP_LOOP', 'J_SETUP_LOOP_FOR') and a[1] in crossjump:
                loopes[a[1]] = i
        i = 0

        while i < len(cmds):  
            assert type(i) is int       
            cmd = cmds[i]
            if cmd[0][0] == 'J' and cmd[1] in crossjump: 
                if cmd[1] not in loopes or (cmd[1] in loopes and loopes[cmd[1]] > i):
                    oldlabel = cmd[1]
                    cmds[i] = (cmd[0], crossjump[cmd[1]]) + cmd[2:]                    
                    del_if_unused_label(cmds, oldlabel)                    
                    updated = True
                    continue
            i = i + 1
        if not updated:            
            updated = set_conditional_jump_popped(cmds) 
        if not updated:            
            updated = del_dead_code(cmds)    
        if not updated:
            return    
 
def NoGoToReturn(cmds):
    return None 

def consts_from_cmds(cmds):
    return dict.fromkeys([x[1] for x in cmds if x[0] == 'LOAD_CONST']).keys()

def walk(co, match=None):
    if match is None or co.co_name == match:
        dis(co)
    for obj in co.co_consts:
        if type(obj) is types.CodeType:
            walk(obj, match)

def Pynm2Cnm(filename):
    global c_name
    pair = os.path.split(filename)
    nmmodule = nmvar_to_loc(pair[1][:-3])
    if c_name is not None:
        outnm = c_name + '.c'    
    elif not build_executable:
        outnm = nmmodule + '.c'
    else:
        outnm = nmmodule + '.c'    
    outnm = os.path.join(pair[0], outnm)
    return outnm, nmmodule
    

def _my_import(*args):
    global need_accurate_frame
    global direct_call
    global restart
    
    if len(args) > 0:
        nm = args[0]
        if automate_option:
            if 'weakref' in nm or 'thread' in nm or 'traceback' in nm or nm == 'gc':
                if need_accurate_frame != True or direct_call != False:
                    need_accurate_frame = True
                    direct_call = False
                    restart = True
                    pp('Options --need-accurate-frame --no-direct-call automate (import module ', nm, ')')
        
    if attempt_import_info or args == ('__builtin__',):
        return __import__(*args)
    return None

def get_options(options):
    global out
    global out3
    global debug
    global filename
    global TRUE
    global no_build
    global print_cline 
    global print_pyline
    ## global make_indent
    global direct_call
    global stat_func
    global Pass_Exit
    global flag_stat
    global opt_flag
    global start_sys_modules
    global hash_compile
    global hide_debug
    global dirty_iteritems
    global redefined_attribute
    global line_number
    global build_executable
    global fast_globals
    global no_generate_comment
    global c_name
    global calc_ref_total
    global recalc_refcnt
    global debug_tx
    global no_tx
    global no_cfunc
    global framed_cfunc
    global print_pycmd
    global inline_flag
    global print_tree_node
    global no_fastlocals
    global g_co
    global separate_global
    global added_pass_subscr
    global need_accurate_frame
    global automate_option
    global restart, is_code_ext
    global package
    global absfilename
    global attempt_import_info
    global compile_generators
    global codegen_notexist
    global codegen_notfound
    global codegen_found
    global codegen_type
    global count_bigpass
    global fast_slots
    global auto_slots
   
    TRUE = cmd2mem(('LOAD_CONST', True))
    c_name = None
    package = ""
    absfilename = ""
 
    automate_option = True
    need_accurate_frame = bool(options.need_accurate_frame)
    debug = bool(options.debug)
##    no_fastlocals = bool(options.no_fastlocals)
    print_pycmd = bool(options.print_pycmd)
    build_executable = bool(options.build_executable)
    fast_globals = bool(options.fast_globals)
    if build_executable:
        fast_globals = True
    if bool(options.no_fast_globals):
        fast_globals = False
    hide_debug = bool(options.hide_debug)
    added_pass_subscr = bool(options.added_pass_subscr)
    flag_stat = bool(options.flag_stat)
    assert options.generate_python_line_numbers in ['on', 'off']
    line_number = bool(options.generate_python_line_numbers == 'on') 
    no_generate_comment = bool(options.no_generate_comment)
    no_build = bool(options.no_build)
    ## make_indent = bool(options.make_indent)
    print_pyline = bool(options.print_pyline)
    print_cline = bool(options.print_cline)
    direct_call = bool(options.direct_call)
    debug_tx = bool(options.debug_tx)
    no_tx = bool(options.no_tx)
    no_cfunc = bool(options.no_cfunc) 
    separate_global = bool(options.separate_global)
    automate_option = bool(options.automate_option)
    package = options.package
    attempt_import_info = bool(options.attempt_import_info)
    compile_generators = bool(options.compile_generators)
    codegen_notexist = int(options.codegen_notexist)
    codegen_notfound = int(options.codegen_notfound)
    codegen_found = int(options.codegen_found)
    codegen_type = int(options.codegen_type)
    count_bigpass = int(options.count_bigpass)
    framed_cfunc = False ##bool(options.framed_cfunc)
    if no_cfunc:
        framed_cfunc = False
    opt_flag = options.opt_flag
    if opt_flag is None:
        opt_flag = ''
    if len(opt_flag) > 0:
        if ' ' in opt_flag:
            opt_flag = opt_flag.split()
        else:
            opt_flag = [opt_flag]
    else:
        opt_flag = []        
    inline_flag = bool(options.inline_flag)
    print_tree_node = bool(options.print_tree_node)
    c_name = options.c_name
    fast_slots = bool(options.fast_slots)
    auto_slots = bool(options.auto_slots)

    if not hasattr(sys, "gettotalrefcount"):
        if calc_ref_total:
            calc_ref_total = False
            Debug('Can\'t generate "calc_ref_total" code for not Py_REF_DEBUG python')
        if recalc_refcnt:
            recalc_refcnt = False
            Debug('Can\'t generate "recalc_refcnt" code for not Py_REF_DEBUG python')

absfilename = ''
    
def main():
    global out
    global out3
    global debug
    global filename
    global TRUE
    global no_build
    global print_cline 
    global print_pyline
    ## global make_indent
    global direct_call
    global stat_func
    global Pass_Exit
    global flag_stat
    global opt_flag
    global start_sys_modules
    global hash_compile
    global hide_debug
    global dirty_iteritems
    global redefined_attribute
    global line_number
    global build_executable
    global fast_globals
    global no_generate_comment
    global c_name
    global calc_ref_total
    global recalc_refcnt
    global debug_tx
    global no_tx
    global no_cfunc
    global framed_cfunc
    global print_pycmd
    global inline_flag
    global print_tree_node
    global no_fastlocals
    global g_co
    global separate_global
    global added_pass_subscr 
    global check_calcref 
    global restart
    global absfilename
    global fast_slots
    global auto_slots
    TRUE = cmd2mem(('LOAD_CONST', True))
    c_name = None
    is_refcntall = hasattr(sys, 'gettotalrefcount')
 
 
    parser = OptionParser()
    
    debug_group = OptionGroup(parser, "Internal options") 
    gen_group = OptionGroup(parser, "Codegeneration options") 
    genmatch_group = OptionGroup(parser, "Trace match table codegeneration options") 
    
    gen_group.add_option("-e", "--build-executable", action="store_true", dest="build_executable", default=False, help="build executable (not extension module)")
    gen_group.add_option("", "--fast-globals", action="store_true", dest="fast_globals", default=False, help="fast GLOBAL")
    gen_group.add_option("", "--no-fast-globals", action="store_true", dest="no_fast_globals", default=False, help="no fast GLOBAL")
    gen_group.add_option("", "--fast-slots", action="store_true", dest="fast_slots", default=False, help="fast __slots__ attribute")
    gen_group.add_option("", "--auto-slots", action="store_true", dest="auto_slots", default=False, help="automatic __slots__ attribute")
    debug_group.add_option("", "--show-debug", action="store_false", dest="hide_debug", default=True, help="show compiler debug messages")
    debug_group.add_option("-S", "--show-statistic", action="store_true", dest="flag_stat", default=False, help="show compiler internal statistic")
##    gen_group.add_option("", "--no-line-numbers", action="store_false", dest="line_number", default=True, help="supress line number code")
    gen_group.add_option("", "--python-line-numbers", dest="generate_python_line_numbers", metavar="on|off", type="choice", choices=['on', 'off'], default='on', help="on|off python line number at generated C code. By default on.")
    parser.add_option("", "--added-pass-subscr", action="store_true", dest="added_pass_subscr", default=False, help="add pass to evaluate type indexing")
    ## parser.add_option("", "--use-gcc-extension", action="store_true", dest="gcc_extension", default=False, help="use gcc extension")

    gen_group.add_option("", "--no-generate-comments", action="store_true", dest="no_generate_comment", default=False, help="supress internal tree comment")
    parser.add_option("-c", "--no-compile", action="store_true", dest="no_build", default=False, help="only generate C-code, no compile")
##    parser.add_option("-i", "--indent", action="store_true", dest="make_indent", default=False, help="run \'indent\' for generated C file")
    parser.add_option("-L", "--trace-py-line", action="store_true", dest="print_pyline", default=False, help="trace python line numbers")
    parser.add_option("-l", "--trace-c-line", action="store_true", dest="print_cline", default=False, help="trace C line numbers")
    gen_group.add_option("", "--no-direct-call", action="store_false", dest="direct_call", default=True, help="supress direct C call convenction")
    parser.add_option("", "--no-attempt-import-info", action="store_false", dest="attempt_import_info", default=True, help="no emulate attempt import info")
    parser.add_option("", "--need-accurate-frame", action="store_true", dest="need_accurate_frame", default=False, help="Only PyFrame call convenction")
    debug_group.add_option("-d", "--decompiler-debug", action="store_true", dest="debug", default=False, help="trace decompilation")
    debug_group.add_option("", "--decompiler-print", action="store_true", dest="print_pycmd", default=False, help="print decompilation psevdocode")
    debug_group.add_option("", "--optimiser-debug", action="store_true", dest="debug_tx", default=False, help="trace optimisation")
    debug_group.add_option("", "--no-optimiser", action="store_true", dest="no_tx", default=False, help="no text optimisation")
    parser.add_option("", "--inline-subst", action="store_true", dest="inline_flag", default=False, help="inline subst of small's def")
##    gen_group.add_option("", "--not-use-fastlocals-array", action="store_true", dest="no_fastlocals", default=False, help="no faslocals array")
    debug_group.add_option("", "--print-tree-node", action="store_true", dest="print_tree_node", default=False, help="print all passed tree node")
    gen_group.add_option("-f", "--compiler-flag", action="store", type="string", dest="opt_flag")
    parser.add_option("-n", "--c-named-as", action="store", type="string", dest="c_name")
    if True:
        parser.add_option("", "--use-cfunc", action="store_false", dest="no_cfunc", default=True, help="generate cfunc")
    gen_group.add_option("", "--separate-global", action="store_true", dest="separate_global", default=False, help="not fastglob[] array")
    parser.add_option("", "--no-automate-option", action="store_false", dest="automate_option", default=True, help="not use automate options")
    parser.add_option("", "--package", action="store", dest="package", default="", help="__package__ name")
    gen_group.add_option("", "--compile-generators", action="store_true", dest="compile_generators", default=False, help="attempt compile generators")
    
    genmatch_group.add_option("-N", "--codegen-op-not-exist", action="store", type="int", dest="codegen_notexist", default=0, help="trace not exist codegen op")
    genmatch_group.add_option("-E", "--codegen-op-not-found", action="store", type="int", dest="codegen_notfound", default=0, help="trace not match codegen op")
    genmatch_group.add_option("-M", "--codegen-op-match", action="store", type="int", dest="codegen_found", default=0, help="trace match codegen op")
    genmatch_group.add_option("-T", "--codegen-op-type", action="store", metavar='0-6', type="int", dest="codegen_type", default=0, help="trace type ret (0 - not, 1 - C type, 2 - C type or undefined size int|long type, 3 - C type or undefined size int|long type or str type, 4 - any defined type, 5 - any, 6 - undefined type") 

    parser.add_option("-B", "--count-bigpass", action="store", type="int", dest="count_bigpass", default=1, help="count big pass (default 1)")
    parser.add_option_group(gen_group)
    parser.add_option_group(debug_group)
    parser.add_option_group(genmatch_group)
    
    (options, argv) = parser.parse_args()

    get_options(options)
        
    if len(argv) == 0:
        exit(1)
    filenames = argv[0:]
    listf1 = []
    for filename in filenames:    
        listf = glob.glob(filename)
        listf1.extend(listf)
    listf = [x for x in listf1 if x.endswith('.py') or x.endswith('.PY')]

    if len(listf) == 0:
        pp('Files not found')
        exit(1)
    elif len(listf) > 1:
        if sys.argv[0].endswith('.py') or sys.argv[0].endswith('.pyc') or sys.argv[0].endswith('.pyo'):
            newsinglecmd = [ sys.executable, sys.argv[0]] + [x for x in sys.argv[1:] if not x.endswith('.py') and not x.endswith('.PY') and not '*' in x]
        else:
            newsinglecmd = [ sys.argv[0]] + [x for x in sys.argv[1:] if not x.endswith('.py') and not x.endswith('.PY') and not '*' in x]
        for filname in listf:
            ## pprint(sys.__dict__)
            retcode = subprocess.call(newsinglecmd + [filname])
            if retcode != 0:
                exit(retcode)
        exit(0)
        
    start_sys_modules = sys.modules.copy()  
    restart = False 
    if  is_refcntall:
        next_refcntall = sys.gettotalrefcount()

    for filename in listf:
        loc_filename = filename
        assert type(loc_filename) is str     
        get_options(options)     
        clear_one_file()
        compilable = True
        absfilename = os.path.abspath(loc_filename)
        if loc_filename.endswith('.py') or loc_filename.endswith('.PY'):
            restart = False
            pp('Compile ' + loc_filename)
            buf = open(loc_filename).read()
            assert type(buf) is str
            redefined_attribute =  ('__get__' in buf or \
                                    '__set__' in buf or '__delete__' in buf or \
                                    '__getattribute__' in buf or \
                                    '__delattr__' in buf or '__getattr__' in buf or \
                                    '__delattr__' in buf )\
                                        and loc_filename != '2c.py'
            if print_pycmd:                            
                outnm = loc_filename[:-3] + '.pycmd'
                out = open(outnm, 'w')
            else:
                out = None    
            outnm, nmmodule = Pynm2Cnm(loc_filename)
            out3 = open(outnm, 'w')
            is_compile = True
            hash_compile = hash(buf) 
            co = None
            try:
                co = compile(buf, loc_filename, "exec")
            except SyntaxError:
                assert type(buf) is str
                buf = buf.replace('\r\n', '\n')
                is_compile = False
            if not is_compile:    
                try:
                    co = compile(buf, loc_filename, "exec")
                except:
                    ## sy = sys.exc_info()[1]




                    pp(repr(sys.exc_info()[1]))
                    compilable = False
                    
            if compilable:   
                if co.co_flags & 0x10000 and 'print' not in d_built:
                    b = _my_import('__builtin__')
                    d_built['print'] = b.__dict__["print"]
                    b = None
                else:
                    if 'print' in d_built:
                        del d_built['print']   
                        
                SetPass('DisAssemble') 
                check_calcref = False
                walk(co)
                check_calcref = False
                SetPass('PostDisAssemble') 
                post_disassemble()
                if restart:
                    restart = False
                    clear_one_file()
                    pp('Restart compile ' + loc_filename)
                    buf = open(loc_filename).read()
                    if print_pycmd:                            
                        outnm = loc_filename[:-3] + '.pycmd'
                        out = open(outnm, 'w')
                    else:
                        out = None    
                    outnm, nmmodule = Pynm2Cnm(loc_filename)
                    out3 = open(outnm, 'w')
                    if co.co_flags & 0x10000 and 'print' not in d_built:
                        b = _my_import('__builtin__')
                        d_built['print'] = b.__dict__["print"]
                        b = None
                    else:
                        if 'print' in d_built:
                            del d_built['print']    
                    SetPass('DisAssemble') 
                    check_calcref = False
                    walk(co)
                    check_calcref = False
                    SetPass('PostDisAssemble') 
                    post_disassemble() 


                clear_one_file()
                co = None
                g_co = None
                if out is not None:
                    out.close()
                if out3 is not None:    
                    out3.close() 
        if  is_refcntall:
            prev_refcntall = next_refcntall
            next_refcntall = sys.gettotalrefcount()
            pp('refcntall(' + loc_filename + ') += ' + str(next_refcntall - prev_refcntall) + ' = ' + str(next_refcntall))
        
    if py_version < 30:
        co = compile('print 1\n', 'test.py', "exec")
    else:
        co = compile('print(1)\n', 'test.py', "exec")
    clear_after_all_files()
    co = None
    g_co = None  
        
def And_j_s(a,b):
    a,b = cmd2mem(a), cmd2mem(b)
    if a[0] == '!BOOLEAN' == b[0]:
        return ('!BOOLEAN', And_bool(a,b))
    if b[0] == '!AND_JUMPED_STACKED':
        return ('!AND_JUMPED_STACKED', a) + b[1:]
    if a[0] == '!AND_JUMPED_STACKED':
        return a + (b,)
    return ('!AND_JUMPED_STACKED', a,b)
        
def Or_j_s(a,b):
    a,b = cmd2mem(a), cmd2mem(b)
    if a[0] == '!BOOLEAN' == b[0]:
        return ('!BOOLEAN', Or_bool(a,b))
    if b[0] == '!OR_JUMPED_STACKED':
        return ('!OR_JUMPED_STACKED', a) + b[1:]
    if a[0] == '!OR_JUMPED_STACKED':
        return a + (b,)
    return ('!OR_JUMPED_STACKED', a,b)

def And_j(a,b):
    a,b = cmd2mem(a), cmd2mem(b)
    if a[0] == '!BOOLEAN' == b[0]:
        return ('!BOOLEAN', And_bool(a,b))
    if b[0] == '!AND_JUMP' == a[0]:
        return  a + b[1:]
    if b[0] == '!AND_JUMP':
        return ('!AND_JUMP', a) + b[1:]
    if a[0] == '!AND_JUMP':
        return a + (b,)
    return ('!AND_JUMP', a,b)

def And_bool(a,b):
    a,b = cmd2mem(a), cmd2mem(b)
    if b[1][0] == '!AND_BOOLEAN' == a[1][0]:
        return  a[1] + b[1][1:]
    if b[1][0] == '!AND_BOOLEAN':
        return ('!AND_BOOLEAN', a) + b[1][1:]
    if a[1][0] == '!AND_BOOLEAN':
        return a[1] + (b,)
    return ('!AND_BOOLEAN', a,b)

def Or_j(a,b):
    a,b = cmd2mem(a), cmd2mem(b)
    if a[0] == '!BOOLEAN' == b[0]:
        return ('!BOOLEAN', Or_bool(a,b))
    if b[0] == '!OR_JUMP' == a[0]:
        return  a + b[1:]
    if b[0] == '!OR_JUMP':
        return ('!OR_JUMP', a) + b[1:]
    if a[0] == '!OR_JUMP':
        return a + (b,)
    return ('!OR_JUMP', a,b)

def Or_bool(a,b):
    a,b = cmd2mem(a), cmd2mem(b)
    if b[1][0] == '!OR_BOOLEAN' == a[1][0]:
        return  a[1] + b[1][1:]
    if b[1][0] == '!OR_BOOLEAN':
        return ('!OR_BOOLEAN', a) + b[1][1:]
    if a[1][0] == '!OR_BOOLEAN':
        return a[1] + (b,)
    return ('!OR_BOOLEAN', a,b)
        
def Not(b):    
    if b[0] == '!1NOT':
        return b[1]
    return ('!1NOT', b)

def formire_call(t):
    if '(' in t[2] and ')' in t[2]:
        if t[2][-1] == ')':
            t = list(t)
            i = t[2].index('(')
            t[2] = t[2][0:-1]
            i = t[2].index('(')
            t[2:3] = [t[2][:i], '(', t[2][i+1:]]
            t = tuple(t) + (')',)   
    elif t[2][-1] != ')':        
        if t[2][-1] == '(':
            t = list(t)
            t[2] = t[2][0:-1]
            t = tuple(t)   
        t = list(t)      
        t[2:3] = [t[2], '(']
        i = 4
        while i < len(t)-1:
            assert type(i) is int
            if t[i+1] != ',':
                t[i:i+1] = [t[i], ',']
            i += 2
        t = tuple(t) + (')',)
    return t    


class Out(list):
    def print_to(self, s):
        self.append(s)
    def append_cline(self):
        if print_cline:
            if True:
                self.append('if (PyErr_Occurred()) {printf (\"ERROR %s\\n\",PyObject_REPR(PyErr_Occurred()));}')
            self.append('printf (\"cline %d\\n\", __LINE__);')
    def Cls(self, *vv):
        assert type(vv) is tuple
        for v in vv:
            if type(v) is tuple:
                if istempref(v):
                    clearref(self, v)
                    if len(self) >= 2 and self[-2] == ('Py_CLEAR(' + CVar(v) + ');'):
                        pprint(self)
                        assert False
                elif istemptyped(v):
                    clear_typed(v)
                else:
                    pass
    def ZeroTemp(self, g):
        if istempref(g):
            self.Raw(g, ' = 0;')
            if len(self) > 1 and self[-1] == self[-2]:
                del self[-1]

    def CLEAR(self, ref): 
        if type(ref) is tuple:
            assert istempref(ref)
        if type(ref) is str:
            assert ref.startswith('temp[') or ref.startswith('GETLOCAL(') or ref.startswith('GETFREEVAR(')    
        self.append('Py_CLEAR(' + CVar(ref) + ');')

    def INCREF(self, ref): 
        self.append('Py_INCREF(' + CVar(ref) + ');')
    def DECREF(self, ref): 
        self.append('Py_DECREF(' + CVar(ref) + ');')
    def XINCREF(self, ref): 
        self.append('Py_XINCREF(' + CVar(ref) + ');')
        
    def ClsFict(self, v):
        if istempref(v):
            clearref(self, v, True)
        elif istemptyped(v):
            clear_typed(v)
        else:
            pass
    def Comment(self, it):
        if no_generate_comment:
            return None
        lpp = PrettyPrinter(2, 144, [''])
        ls = ['']
        lpp._format(it, ls, 0, 0, 0)
        if ls[-1] == '':
            del ls[-1]
        self.append('')
        for s in ls:
            assert type(s) is str
            if '/*' in s:
                s = s.replace('/*', '/?*')
            assert type(s) is str
            if '*/' in s:
                s = s.replace('*/', '*?/')
            self.append('/* ' + s + ' */')
                
    def check_err(self, t0, eq):
        if eq == 'NULL':
            eq = '0'
        self.Raw('if (', t0, ' == ', eq, ') goto ', labl, ';')
        UseLabl()

    def PushInt(self, t, i):
        assert istempref(t)
        self.Raw(t, ' = PyInt_FromLong ( ', i, ' );')

    def PushFloat(self, t, i):
        assert istempref(t)
        self.Raw(t, ' = PyFloat_FromDouble ( ', i, ' );')

    def frame_back(self):
        if True:
            self.append('tstate->frame = f->f_back;')
        else:
            self.append('tstate->frame = PyObject_GetAttrString(f, "f_back");')
            
    def Raw(self, *t):
        self.append(''.join([CVar(x) for x in t]))
 

    def Stmt(self, *_t):
        t = tuple([x[3] if type(x) is tuple and len(x) == 5 and type(x[0]) is str and x[0] == 'PY_TYPE' else x for x in _t])
        if len(t) == 2 and t[0] == 'CLEARREF' and istempref(t[1]):
            self.append('CLEARTEMP('+str(t[1][1]) + ');')
            
            return
        elif len(t) == 3 and type(t[0]) is tuple and t[1] == '='and IsCalcConst(t[0]):
            self.append(do_str(t))
            self.append_cline()
            
            return            
        elif t[0] in CFuncVoid:
            if t[0] == 'SETLOCAL' and t[1] not in g_co.used_fastlocals:
                g_co.used_fastlocals[t[1]] = True
                if g_co.list_compr_in_progress == False:
                    self.Stmt('LETLOCAL', nmvar_to_loc(t[1]), t[2])
                    return
            Used(t[0])
            t2 = [t[0], '(']
            for v in t[1:]:
                t2.append(v)
                t2.append(',')
            if len(t) == 1:
                t2.append(')')  
            else:      
                t2[-1] = ')'
            self.append(do_str(tuple([CVar(x) for x in t2])))
            self.append_cline()
            
            return

        elif t[0] in CFuncIntCheck:
            Used(t[0])
            t2 = mk_t2(t)
            t2.append(') == -1) goto ' + CVar(labl))
            UseLabl()
            self.append(do_str(t2))
            self.append_cline()
            
            return
        elif t[0] in CFuncPyObjectRef:
            Used(t[0])
            t2 = mk_t2(t)
            assert labl is not None
            t2.append(') == 0) goto ' + CVar(labl))
            UseLabl()
            self.append(do_str(t2))
            self.append_cline()
            
            return
        elif len(t) >= 3 and t[1] == '=' and t[0] != 'f->f_lineno' and \
               (type(t[2]) != int and type(t[2]) != long and (type(t[2]) != tuple or t[2][0] != 'CONST')):
            if len(t) == 5 and t[3] in ('==', '!='):       
                self.append(do_str(t))
                self.append_cline()
                
                return
            if len(t) == 3 and t[2][0] == 'FAST' and t[0][0] == 'PY_TEMP':
                self.append(do_str(t))
                self.append_cline()
                
                return
            if len(t) == 4 and t[2][0] == '!' and t[0][0] == 'TYPED_TEMP' and t[3][0] == 'TYPED_TEMP':
                self.append(do_str(t))
                self.append_cline()
                
                return
            if istemptyped(t[2]) and istemptyped(t[0]):
                self.append(do_str(t))
                self.append_cline()
                
                return    
            if istempref(t[0]) and t[2] in ('Py_True', 'Py_False'):
                self.append(do_str(t))
                self.append_cline()
                
                return    
            if type(t[2]) is str and t[2].endswith('(glob,'):
                t = list(t)
                t[2:3] = [t[2][:-6], 'glob']
                t = tuple(t)
            t = formire_call(t)
            if t[2] in CFuncNoCheck:
                Used(t[2])
                assign_py = t[0][0] == 'PY_TEMP'                
                t = [CVar(x) for x in t]
                self.append(do_str(t))
                self.append_cline()
                if assign_py:
                    if t[2] not in ( 'PyIter_Next', 'Py_INCREF'):
                       Fatal(t, '???', t[2], 'Py_INCREF(' + t[0] + ');')
                       assert False
                elif t[2] not in CFuncIntNotCheck and t[2] not in CFuncFloatNotCheck \
                     and t[2] not in CFuncLongNotCheck:    
                    Fatal(t)
                    assert False
                
                return                   

            if t[2] in CFuncPyObjectRef:
                Used(t[2])
                t0 = t[0]
                assign_py = type(t0) is tuple and \
                    (t0[0] == 'PY_TEMP' or t0.startswith('GETLOCAL('))
                    
                t = [CVar(x) for x in t]
                self.append(do_str(t))
                self.append_cline()
                if assign_py:
                    last = self[-1]
                    assert type(last) is str
                    if last.startswith(ConC(t[0], ' = ')) and last.endswith(';'):
                        s0 = '(' + last[:-1] + ')'
                        del self[-1]
                        self.check_err(s0, 'NULL')
                    else:    
                        self.check_err(t[0], 'NULL')
                    if t[2] in CFuncNeedINCREF:
                        self.append('Py_INCREF(' + t[0] + ');')
                    elif not t[2] in CFuncNotNeedINCREF:
                        Debug('INCREF?', t)
                        self.append('Py_INCREF(' + t[0] + ');')
                    if checkmaxref != 0:
                        self.append('if ((' + t[0] + ')->ob_refcnt > ' + str(checkmaxref) + ') printf("line %5d, refcnt %6d \\n", __LINE__,(' + t[0] + ')->ob_refcnt);')
                else:    
                    Fatal(t)
                    assert False
                
                return                   
            if t[2] in set_IntCheck: #CFuncIntCheck or t[2] in CFuncLongCheck:
                Used(t[2])
                assign_temp = t[0][0] == 'TYPED_TEMP'   
                t = [CVar(x) for x in t]
                self.append(do_str(t))
                self.append_cline()
                if assign_temp:
                    last = self[-1]
                    assert type(last) is str                    
                    if last.startswith(ConC(t[0], ' = ')) and last.endswith(';'):
                        s0 = '(' + last[:-1] + ')'
                        del self[-1]
                        self.check_err(s0, '-1')
                    else:    
                        self.check_err(t[0], '-1')
                else:    
                    pp(t)
                    assert False
                
                return     
            elif type(t[2]) is str and t[2].startswith('_Direct_'):
                assign_py = type(t[0]) is tuple and \
                    (t[0][0] == 'PY_TEMP' or t[0].startswith('GETLOCAL('))
                t = [CVar(x) for x in t]
                self.append(do_str(t))
                self.append_cline()
                if assign_py:
                    last = self[-1]
                    assert type(last) is str                    
                    if last.startswith(ConC(t[0], ' = ')) and last.endswith(';'):
                        s0 = '(' + last[:-1] + ')'
                        del self[-1]
                        self.check_err(s0, 'NULL')
                    else:    
                        self.check_err(t[0], 'NULL')
                    if checkmaxref != 0:
                        self.append('if ((' + t[0] + ')->ob_refcnt > ' + str(checkmaxref) + ') printf("line %5d, refcnt %6d \\n", __LINE__,(' + t[0] + ')->ob_refcnt);')
                else:    
                    Fatal(t)
                    assert False
                
                return                   
            Fatal('Call undefined C-function', t[2], t)
            assert False
        elif t[0] in ( '}', '{', 'if'):
            pass
        elif maybe_call(t[0]):
            t = list(t)      
            t[0:1] = [t[0], '(']
            i = 2
            while i < len(t)-1:
                assert type(i) is int and i >= 0
                if t[i+1] != ',':
                   t[i:i+1] = [t[i], ',']
                i += 2
            t = tuple(t) + (')',)
            Used(t[0])
            if t[0] not in CFuncVoid:
                Fatal('Call undefined C-function', t[0],t)
                assert False
            
        self.append(do_str(t))
        

def TextMatch(s, p, v):
    assert type(p) is tuple
    assert type(s) is str
    for i, p2 in enumerate(p):
        assert type(p2) is str
        if p2 == '*':
            if i == len(p) - 1:
                v.append(s)
                return True
            else:
                assert type(s) is str
                pi1 = p[i+1]
                assert type(pi1) is str
                ind = s.find(pi1)  
                if ind == -1:
                    return False  
                v.append(s[:ind])
                s = s[ind:]
        else:
            assert type(s) is str
            assert type(p2) is str
            if s.startswith(p2):
                s = s[len(p2):]
            else:
                return False    
    if len(s) != 0:
        return False
    return True

Tx_compiled = {}
Tx_pre_compiled = {}
Tx_fast = {}
Tx_len_match = 0
Tx_pos_match = 0
Tx_pattern = None
Tx_cnt = {}

def TxCompile_PreCheck(tp2):
    li_ = []
    for tupl in tp2:
        if type(tupl) is not tuple:
            break
        assert len(tupl) > 0
        if len(tupl) == 1:
            if type(tupl[0]) is str:
                li_.append((tupl[0], ""))
            else:
                li_.append(("", ""))
        else:
            if type(tupl[0]) is str:
                if type(tupl[-1]) is str:
                    li_.append((tupl[0], tupl[-1]))
                else:
                    li_.append((tupl[0], ""))
            else:
                if type(tupl[-1]) is str:
                    li_.append(("", tupl[-1]))
                else:
                    li_.append(("", ""))   
    if len(li_) == 1 or len(tp2) > len(li_):
        return None
    return tuple(li_)

global Tx_cnt2
Tx_cnt2 = {}
global Tx_Lin
Tx_lin = {}

def TxMatch(o, pos, p2_, li, debug = False):
    global Tx_cnt
    if flag_stat:
        if p2_ in Tx_cnt:
            Tx_cnt[p2_] += 1
        else:
            Tx_lin[p2_] = inspect.stack()[1][2]
            Tx_cnt[p2_] = 1
        if p2_ not in Tx_cnt2:
            Tx_cnt2[p2_] = 0            
    assert type(pos) is int
    assert type(o) is Out
    assert type(li) is dict

    assert type(p2_) is str
    if p2_ in Tx_compiled:
        tp2 = Tx_compiled[p2_]
        li_ = Tx_fast[p2_]
    else:
        Tx_pre_compiled[p2_] = TxPreCompile(p2_)
        Tx_compiled[p2_] = tp2 = TxCompile(Tx_pre_compiled[p2_])
        Tx_fast[p2_] = li_ = TxCompile_PreCheck(tp2)


    assert type(tp2) is tuple
    if pos + len(tp2) > len(o):
        return False
    if li_ is not None and not Tx_PreCheck(pos, li_, o):
        return False
    if len(li) > 0:
        li.clear()
    pos_i = TxBaseMatchD(pos, tp2, o, li, debug)
    if pos_i > 0:
        global Tx_len_match, Tx_pattern, Tx_pos_match
        Tx_len_match = int(pos_i - pos)
        Tx_pattern = Tx_pre_compiled[p2_]
        Tx_pos_match = pos
        if flag_stat:
            if p2_ in Tx_cnt:
                Tx_cnt2[p2_] += 1
            else:
                Tx_cnt2[p2_] = 1        
        return True
    return False

def Tx_PreCheck(pos_i_, patt, o):
    assert type(o) is Out
    assert type(patt) is tuple
    assert type(pos_i_) is int
    assert pos_i_ >= 0 and pos_i_ < MInt / 10
    for i, p in enumerate(patt):
        pos_i = pos_i_ + i
        assert type(p) is tuple and len(p) == 2
        beg, end = p
        oi = o[pos_i]
        assert type(oi) is str
        assert type(beg) is str
        assert type(end) is str
        if oi.startswith(beg) and oi.endswith(end):
            continue
        if len(oi) == 0 or oi[0] == '/':
            return True
        return False
    return True
    
def TxBaseMatchD(pos_i_, patt, o, di, debug):
    assert type(di) is dict
    assert type(pos_i_) is int and pos_i_ >= 0 and pos_i_ < (MInt / 10)
    pos_i = pos_i_
    assert type(o) is Out and type(patt) is tuple and type(pos_i) is int and type(debug) is bool
    for i, p in enumerate(patt):
        assert type(pos_i) is int and pos_i >= 0 and pos_i < (MInt / 10)
        pos_i2 = -1
        for pos_i3 in range(pos_i, len(o)):
            o_pos_i = o[pos_i3]
            assert type(o_pos_i) is str
            if len(o_pos_i) == 0 or (o_pos_i[0] == '/' and o_pos_i.startswith('/*')):
                continue
            pos_i2 = pos_i3
            break
        pos_i = pos_i2
        if pos_i <0:
            return -1
        if type(p) is tuple:
            if debug:
                if TxMatch__D_debug(o[pos_i], p, di):
                    pp('/ %d success' % i, o[pos_i], p, di)
                    pos_i += 1
                    if i == len(patt) - 1:
                        return pos_i
                    elif pos_i >= len(o):
                        return -1
                    continue    
                pp('/ %d fail' % i, o[pos_i], p, di)
            else:
                if TxMatch__D(o[pos_i], p, di):
                    pos_i += 1
                    if i == len(patt) - 1:
                        return pos_i
                    elif pos_i >= len(o):
                        return -1
                    continue
            return -1 
        assert type(i) is int and i >= 0       
        assert type(pos_i) is int and pos_i >= 0 and pos_i < (MInt / 10)
        if type(p) is int:
            if 60 > p >= 30 and p not in di:
                i2 = pos_i
                success = False
                while i2 < len(o):
                    assert type(i2) is int and i2 >= 0
                    oi2 = o[i2]
                    assert type(oi2) is str
                    if oi2.startswith('/*') or\
                    oi2.startswith('PyLine = ') or\
                    oi2.startswith('PyAddr = ') or\
                    oi2.startswith('f->f_lineno = ') or\
                    oi2.startswith('f->f_lasti = '):
                        return -1
                    assert type(i) is int and i >= 0  
                    patt_i_1 = patt[i+1]
                    if type(patt_i_1) is tuple and type(patt_i_1[0]) is str and oi2.startswith(patt_i_1[0]) :
                        di2 = di.copy()
                        if TxMatch__D(oi2, patt_i_1, di2):
                            di.update(di2)
                            if debug:
                                pp('/ %d success' % i, o[pos_i:i2], p, di)
                            di[p] = o[pos_i:i2]
                            pos_i = i2
                            success = True
                            assert i < (MInt / 10)
                            break
                        if debug:
                            pp('/ %d fail' % i, o[pos_i:i2], oi2, patt_i_1, di)
                        return -1        
                    elif  '{' in oi2 or '}' in oi2:
                        if debug:
                            pprint(patt)
                            pprint(oi2)
                            pp(i+1)
                            pp('/ %d fail 93' % i, o[pos_i:i2], oi2, patt_i_1, di)
                        return -1
    
                    i2 += 1
                if success == False:                    
                    if debug:
                        pp('/ %d fail 0' % i, o[pos_i:i2], o[i2], patt[i+1], di)
                    return -1
                else:
                    continue
            elif 90 > p >= 60 and p not in di:
                i2 = pos_i
                success = False
                while i2 < len(o):
                    assert type(i2) is int and i2 >= 0
                    oi2 = o[i2]
                    assert type(oi2) is str                        
                    if oi2.startswith('/*') or\
                    oi2.startswith('PyLine = ') or\
                    oi2.startswith('PyAddr = ') or\
                    oi2.startswith('f->f_lineno = ') or\
                    oi2.startswith('f->f_lasti = '):
                        return -1
                    if i == len(patt) - 1:
                        s3 = oi2
                        if not (s3.startswith('CLEARTEMP(') or\
                                s3.startswith('Py_CLEAR(temp[') or\
                                ( s3.startswith('temp[') and \
                                s3.endswith('] = 0;'))):
                            if debug:
                                pp('/ %d success' % i, o[pos_i:i2], p, di)
                            di[p] = o[pos_i:i2]
                            pos_i = i2                         
                            success = True
                            break
                    else:
                        patt_i1 = patt[i+1]
                        if type(patt_i1) is tuple and \
                          (type(patt_i1[0]) is not str or (type(patt_i1[0]) is str and oi2.startswith(patt_i1[0]))) :
                            di2 = di.copy()
                            if TxMatch__D(oi2, patt_i1, di2):
                                di.update(di2)
                                if debug:
                                    pp('/ %d success' % i, o[pos_i:i2], p, di)
                                di[p] = o[pos_i:i2]
                                pos_i = i2
                                for s3 in o[pos_i:i2]:
                                    assert type(s3) is str
                                    if not (s3.startswith('CLEARTEMP(') or s3.startswith('Py_CLEAR(temp[') or ( s3.startswith('temp[') and s3.endswith('] = 0;'))):
                                        if debug:
                                            pp('/ %d fail 1 ' % i, o[pos_i:i2], oi2, patt_i1, di)
                                        return -1                               
                                success = True
                                break
                            if debug:
                                pp('/ %d fail' % i, o[pos_i:i2], oi2, patt_i1, di)
                            return -1  
                        elif  '{' in oi2 or '}' in oi2:
                            if debug:
                                pprint(patt)
                                pprint(oi2)
                                pp(i+1)
                                pp('/ %d fail 9' % i, o[pos_i:i2], oi2, patt_i1, di)
                            return -1
                    i2 += 1
                if success == False:                    
                    if debug:
                        pp('/ %d fail 5' % i, o[pos_i:i2], o[i2], patt[i+1], di)
                    return -1
                else:
                    continue
    
            elif 60 > p >= 30 and p not in di:
                if di[p] == o[pos_i:pos_i+len(di[p])]:
                    pos_i += len(di[p])
                    continue
            pp(p, i)
            pprint(patt)
            assert False

    return pos_i

                
debug_tx = False
def TxRepl(o, pos, p2, li, used = None):
    global debug_tx
    global Tx_pos_match
    pos = Tx_pos_match
    assert type(pos) is int and pos >= 0
    if p2 not in Tx_compiled:
        Tx_compiled[p2] = TxCompile(TxPreCompile(p2))
    new = []
    for p in Tx_compiled[p2]:
        if type(p) is int:
            new.extend(li[p])
        else:
            new.append(TxRepl__(p, li))
    print_patterns = True
    if debug_tx:
        pp('')
        pp('')
        pp(' === BEFORE ' + str(pos))
        for v in o[max(pos-2, 0):pos]:
            pp('  ', v)
        for v in o[pos:pos+Tx_len_match]:
            pp('>>', v)
        for v in o[pos+Tx_len_match:min(pos+Tx_len_match +2, len(o) - 1)]:
            pp('  ', v)
        if print_patterns:    
            pp('')
            pp('    === Apply:')
            for v in Tx_pattern:
                pp('??', #id(Tx_pattern), 
                   v)   
            pp('')
            pp('    === Replace:')
            if type(p2) is tuple:
                for v in p2:
                    pp('!!', #id(p2),
                        v)   
            elif type(p2) is str:
                for v in p2.split('\n'):
                    assert type(v) is str
                    v = v.strip()
                    if v != '':
                        pp('!!', #id(p2), 
                           v.strip())   
            pp(        '')   
            pp('    === Memo:' )
            pprint(li)
        print
        pp('    === After', pos )
    if o[pos:pos+Tx_len_match] == new :
        Fatal ('Cycle modification', new, )
        assert False
    o[pos:pos+Tx_len_match] = new
    if debug_tx:
        for v in o[max(pos-2, 0):pos]:
            pp('  ', v)
        for v in o[pos:pos+len(new)]:
            pp('<<', v)
        for v in o[pos+len(new):min(pos+len(new) +2, len(o) - 1)]:
            pp('  ', v)
    if used is not None:
        for x in used:
            Used(x)
            
def TxPreCompile(tupl):
    if type(tupl) is str:
        li = tupl.strip().splitlines()
        assert type(li) is list
        li2 = []
        for t in li:
            assert type(t) is str
            t = t.strip().replace('\r', '').replace('\n', '').strip()
            if t != '':
                li2.append(t)
            
        ## tupl = [t.strip() for t in tupl if t.strip() != '']
        ## tupl = [t.replace('\r', '') for t in tupl]
        ## tupl = [t.replace('\n', '') for t in tupl]
        ## tupl = [t.strip() for t in tupl if t.strip() != '']
        ## tupl = [t.strip() for t in tupl if t.strip() != '']
        tupl = tuple(li2)
    return tupl
        
def TxCompile(tupl):
    compiled = []
    for p in tupl:
        assert type(p) is str
        if len(p) > 0 and p[0] == '>' and len(p) >= 2 and len(p) <= 3:
            compiled.append(int(p[1:]) + 30)
        elif len(p) > 0 and p[0] == '<' and len(p) >= 2 and len(p) <= 3:
            compiled.append(int(p[1:]) + 60)
        else:
            p = p.replace('$', '`$').split('`')
            s3 = []
            if len(p[0]) == 0:
                p = p[1:]
            for _s in p:
                if _s[0] == '$': 
                    assert len(_s) >= 2
                    if _s[1] == '1' and len(_s) > 2 and _s[2] >= '0' and _s[2] <= '9':
                        s3.append(int(_s[1] + _s[2]))
                        if len(_s) > 3:
                            s3.append(_s[3:])
                    else:    
                        s3.append(int(_s[1]))
                        if len(_s) > 2:
                            s3.append(_s[2:])
                else:       
                    s3.append(_s)
            compiled.append(tuple(s3))
    return tuple(compiled)            

def TxMatch__D(s, p, li):
    if type(s) is str and type(li) is dict and type(p) is tuple:
        i = 0
        while i < len(p):
            assert type(i) is int
            assert i >= 0
            p2 = p[i]
            assert type(s) is str
            if type(p2) is int:
                if p2 not in li: #li[p2] == None:
                    if i == len(p) - 1:
                        li[p2] = s
                        return True
                    else:
                        p3 = p[i+1]
                        assert type(p3) is str
                        ind = s.find(p3)  
                        assert type(ind) is int
                        if ind == -1:
                            return False  
                        li[p2] = s[:ind]
                        s = s[ind+len(p3):]
                        i += 2
                        continue
                else:
                    p2 = li[p2]
                    
            assert type(s) is str
            assert type(p2) is str
            if s.startswith(p2):
                s = s[len(p2):]
                i += 1
                continue
            else:
                return False   
        if len(s) != 0:
            return False
        assert len(s) == 0
        return True
    else:
        Fatal('strange types')
        assert False
    return False

def TxMatch__D_debug(s, p, li):
    if type(s) is str and type(li) is dict and type(p) is tuple:
        for i, p2 in enumerate(p):
            assert type(s) is str
            if type(p2) is int:
                if p2 not in li: #li[p2] == None:
                    if i == len(p) - 1:
                        li[p2] = s
                        return True
                    else:
                        p3 = p[i+1]
                        if type(p3) is str:
                            ind = s.find(p3)  
                            assert type(ind) is int
                            if ind == -1:
                                pp(p3 , 'not found')
                                return False  
                            li[p2] = s[:ind]
                            s = s[ind:]
                        else:
                            Fatal('not str', p3)
                            assert False
                            return False
                else:
                    p2 = li[p2]
            assert type(s) is str
            if type(p2) is str:
                if s.startswith(p2):
                    assert type(s) is str
                    s = s[len(p2):]
                else:
                    pp('not started with2', p2, ':::', p)                      
                    return False   
        if len(s) != 0:
            return False
        assert len(s) == 0
        return True
    else:
        Fatal('strange types')
        assert False
    return False

def TxRepl__(p, li):
    s = ''
    for p2 in p:
        if type(p2) is int:
            s += li[p2]
        else:
            s += p2    
    return s

def repl_sk_typed_loc(s, beg, replbeg): 
    assert type(s) is str
    assert type(replbeg) is str
    assert type(beg) is str
    l1, l2 = s.split(beg, 1) 
    assert type(l1) is str
    assert type(l2) is str
    if ')' not in l2:
        return s 
    l2, l3 = l2.split(')', 1)
    assert type(l2) is str
    assert type(l3) is str
    if ''.join(l2.split('_')).isalnum():
        return l1 + replbeg + l2 + l3 
    return s 
  
no_tx = False
no_cfunc = True
framed_cfunc = True
def optimize(o):
    global g_co, debug_tx
    global no_tx
    if no_tx:
        return
    assert type(o) is Out
    i = 0
    check_Loc_ = have_ctype_local_variable()
    while i < len(o) - 1:
        assert type(i) is int and i >= 0
        min_i = i - 200
        if min_i < 0:
            min_i = 0
        assert type(min_i) is int and min_i >= 0
        for i in range(min_i, len(o)):    
            v2 = {}
            if i >= len(o):
                break
            assert type(i) is int
            assert i >= 0 and i <= (MInt / 10)
            oi = o[i]
            assert type(oi) is str
            oiold = oi
            if check_Loc_:
                oipos = oi.find('(Loc_')
                if oipos > 0: #'(Loc_' in oi:
                    oic = oi[oipos-1]
                    if oic == '(':
                        oi = repl_sk_typed_loc(oi, '((Loc_', '(Loc_') 
                    elif oic == ')':
                        oi = repl_sk_typed_loc(oi, ')(Loc_', ')Loc_') 
                    elif oic == '!':
                        oi = repl_sk_typed_loc(oi, '!(Loc_', '!Loc_') 
                    elif oic == ' ' and oipos > 1:
                        oic = oi[oipos-2]
                        if oic == '=':
                            oi = repl_sk_typed_loc(oi, '= (Loc_', '= Loc_') 
                        elif oic == '(':
                            oi = repl_sk_typed_loc(oi, '( (Loc_', '( Loc_') 
                    if oi is not oiold:
                        o[i] = oi
            assert type(oi) is str
            if i + 1 < len(o):
                oi1 = o[i+1]
                assert type(oi1) is str
                if (oi1.startswith('CLEARTEMP(') or \
                (oi1.startswith('temp[') and \
                 oi1.endswith('] = 0;') ) ):
                        if oi.endswith(';') and '{' not in oi and '}' not in oi and \
                           ':' not in oi and \
                           'Trace' not in oi and \
                           not oi.endswith(' ;') and \
                           not oi.startswith('Py_CLEAR') and \
                           not oi.startswith('Py_INCREF') and \
                           not oi.startswith('Py_DECREF') and \
                           not oi.startswith('CLEARTEMP(') and \
                           not oi.startswith('PyObject ') and \
                           not oi.startswith('long ') and \
                           not oi.startswith('int ') and \
                           not oi.startswith('temp = ') and \
                           not (oi.startswith('temp[') and oi.endswith('] = 0;') ):
                            if 'temp[' not in oi:
                                o[i], o[i+1] = oi1, oi
                                break
                            else:
                                if oi1.startswith('CLEARTEMP('):
                                    tempn = 'temp[' +oi1[10:-2] + ']'
                                else:
                                    tempn = oi1[:-5]
                                if '(' in tempn or ')' in tempn or not tempn.startswith('temp[') or not tempn.endswith(']'):
                                    Fatal('Unsiccess', o[i], o[i+1], tempn)
                                    assert False
                                if tempn not in oi:
                                    o[i], o[i+1] = oi1, oi
                                    break

                oi1 = o[i+1]
                assert type(oi1) is str
                if (oi1.startswith('CLEARTEMP(') or \
                (oi1.startswith('temp[') and \
                 oi1.endswith('] = 0;') ) ):
                        if '{' not in oi and '}' not in oi and \
                           ':' not in oi and \
                           'Trace' not in oi and \
                           ' ;' not in oi and \
                           not oi.startswith('Py_CLEAR') and \
                           not oi.startswith('Py_INCREF') and \
                           not oi.startswith('Py_DECREF') and \
                           not oi.startswith('CLEARTEMP(') and \
                           not oi.startswith('PyObject ') and \
                           not oi.startswith('long ') and \
                           not oi.startswith('int ') and \
                           not oi.startswith('temp = ') and \
                           not (oi.startswith('temp[') and oi.endswith('] = 0;') ) and \
                           ';' in oi:
                            if 'temp[' not in oi:
                                o[i], o[i+1] = o[i+1], o[i]
                                break
                            else:
                                if oi1.startswith('CLEARTEMP('):
                                    tempn = 'temp[' +oi1[10:-2] + ']'
                                else:
                                    tempn = oi1[:-5]
                                if '(' in tempn or ')' in tempn or not tempn.startswith('temp[') or not tempn.endswith(']'):
                                    Fatal('Unsiccess', o[i], o[i+1], tempn)
                                    assert False
                                if tempn not in oi:
                                    o[i], o[i+1] = oi1, oi
                                    break

            oi = o[i]
            assert type(oi) is str
            if len(oi) == 0:
                continue
            oic = oi[0]
            if oic == '/' and oi.startswith('/*'):
                continue
            if oic == 'P' and oi.startswith('Py') and (oi.startswith('PyLine = ') or oi.startswith('PyAddr = ')):
                continue
            if oic == 'f' and oi.startswith('f-') and (oi.startswith('f->f_lineno = ') or oi.startswith('f->f_lasti = ')):
                if oi.startswith('f->f_lineno = ') and \
                    TxMatch(o, i, """f->f_lineno = $0;
                        f->f_lasti = $1;
                        f->f_lineno = $2;
                        f->f_lasti = $3;""", v2):
                            TxRepl(o, i, """f->f_lineno = $2;
                                f->f_lasti = $3;""", v2)
                            break                 
                continue
            if not ( oic == 'i' and oi.startswith('if (')):
                if oic == '{' and oi == '{':
                    if TxMatch(o, i, """
                        {
                        char __s[1];
                        __s[0] = (unsigned char)$3;
                        if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto label_$10;
                        }
                        int_$11 = PyString_GET_SIZE ($12 );
                        temp[$1] = PyString_FromStringAndSize(NULL, 1 + int_$11);
                        charref_$7 = PyString_AS_STRING ( temp[$1] );
                        *charref_$7++ = *PyString_AS_STRING ( temp[$0] );
                        CLEARTEMP($0);
                        """, v2):
                            TxRepl(o, i, """
                                int_$11 = PyString_GET_SIZE ($12 );
                                temp[$1] = PyString_FromStringAndSize(NULL, 1 + int_$11);
                                charref_$7 = PyString_AS_STRING ( temp[$1] );
                                *charref_$7++ = (unsigned char)$3;
                                   """, v2)
                            break
                    if TxMatch(o, i, """                        
                        {
                        char __s[1];
                        __s[0] = (unsigned char)long_$2;
                        if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto label_$3;
                        }
                        int_$5 = *PyString_AS_STRING ( temp[$1] ) == *PyString_AS_STRING ( temp[$0] );
                        CLEARTEMP($1);
                        CLEARTEMP($0);                        
                        """, v2):
                            TxRepl(o, i, """
                                int_$5 = *PyString_AS_STRING ( temp[$1] ) == (unsigned char)long_$2;
                                CLEARTEMP($1);
                                   """, v2)
                            break
                    if TxMatch(o, i, """
                        {
                        char __s[1];
                        __s[0] = (unsigned char)long_$2;
                        if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto $3;
                        }
                        int_$5 = PyString_GET_SIZE ( $4 );
                        int_$6 = PyString_GET_SIZE ( temp[$0] );
                        temp[$1] = PyString_FromStringAndSize(NULL, int_$5 + int_$6);
                        charref_$8 = PyString_AS_STRING ( temp[$1] );
                        memcpy(charref_$8, PyString_AS_STRING ( $4 ), int_$5);
                        charref_$8 += int_$5;
                        memcpy(charref_$8, PyString_AS_STRING ( temp[$0] ), int_$6);
                        CLEARTEMP($0);
                        """, v2):
                            TxRepl(o, i, """
                                int_$5 = PyString_GET_SIZE ( $4 );
                                temp[$1] = PyString_FromStringAndSize(NULL, int_$5 + 1);
                                charref_$8 = PyString_AS_STRING ( temp[$1] );
                                memcpy(charref_$8, PyString_AS_STRING ( $4 ), int_$5);
                                charref_$8 += int_$5;
                                charref_$8[0] = (unsigned char)long_$2;
                                """, v2)
                            break  
                    if TxMatch(o, i, """
                        {
                        char __s[1];
                        __s[0] = (unsigned char)long_$11;
                        if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto $3;
                        }
                        if (PyString_CheckExact(temp[$1])) {
                        int_$4 = (PyString_GET_SIZE(temp[$1]) == PyString_GET_SIZE(temp[$0])) && (PyString_AS_STRING(temp[$1])[0] == PyString_AS_STRING(temp[$0])[0]) && (memcmp(PyString_AS_STRING(temp[$1]), PyString_AS_STRING(temp[$0]), PyString_GET_SIZE(temp[$1])) == 0);
                        } else {
                        if ((int_$4 = PyObject_RichCompareBool ( temp[$1] , temp[$0] , Py_EQ )) == -1) goto $3;
                        }
                        CLEARTEMP($1);
                        CLEARTEMP($0);                    
                        """, v2):
                            TxRepl(o, i, """
                                if (PyString_CheckExact(temp[$1])) {
                                int_$4 = (PyString_GET_SIZE(temp[$1]) == 1) && (PyString_AS_STRING(temp[$1])[0] == (unsigned char)long_$11);
                                } else {
                                char __s[1];
                                __s[0] = (unsigned char)long_$11;
                                if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto $3;
                                if ((int_$4 = PyObject_RichCompareBool ( temp[$1] , temp[$0] , Py_EQ )) == -1) goto $3;
                                CLEARTEMP($0);
                                }
                                CLEARTEMP($1);
                                """, v2)
                            break  
                    if TxMatch(o, i, """{
                        char __s[1];
                        __s[0] = (unsigned char)$6;
                        if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto $5;
                        }
                        $2 = *PyString_AS_STRING(temp[$0]);
                        Py_CLEAR(temp[$0]);
                        temp[$0] = 0;""", v2):
                            TxRepl(o, i, """$2 = (unsigned char)$6;""", v2)
                            break  
                    if TxMatch(o, i, """{
                        char __s[1];
                        __s[0] = (unsigned char)$6;
                        if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto $5;
                        }
                        $2 = *PyString_AS_STRING ( temp[$0] );
                        Py_CLEAR(temp[$0]);
                        temp[$0] = 0;""", v2):
                            TxRepl(o, i, """$2 = (unsigned char)$6;""", v2)
                            break                          
                elif oic == 't' and oi.startswith('temp['):
                    if tune_let_temp(o, i):
                        break
                    
                elif oic == 'P' and oi.startswith('Py_CLEAR(temp['):
                    if TxMatch(o, i, """Py_CLEAR(temp[$1]);
                        temp[$1] = 0;""", v2):
                            TxRepl(o, i, """CLEARTEMP($1);""", v2)
                            break
                    if TxMatch(o, i, """Py_CLEAR(temp[$0]);""", v2):
                            TxRepl(o, i, """CLEARTEMP($0);""", v2)
                            break      
                elif oic == 'P' and oi.startswith('Py_INCREF') and i+1 < len(o):    
                    if o[i+1].startswith('Py_INCREF'):

                        if TxMatch(o, i, """                
                            Py_INCREF($1);
                            Py_INCREF($2);
                            if ((temp[$3] = PyTuple_New ( 2 )) == 0) goto label_$4;
                            PyTuple_SET_ITEM ( temp[$3] , 0 , $1 );
                            PyTuple_SET_ITEM ( temp[$3] , 1 , $2 );
                            """, v2):
                                TxRepl(o, i, """                
                                    if ((temp[$3] = PyTuple_Pack ( 2 , $1 , $2 )) == 0) goto label_$4;
                                    """, v2)
                                break 
                    elif oi == 'Py_INCREF(Py_None);' and TxMatch(o, i, """
                        Py_INCREF(Py_None);
                        temp[$0] = Py_None;
                        CLEARTEMP($0);  
                        """, v2):
                            TxRepl(o, i, '', v2)
                            break                           
                    elif 'PyInt_CheckExact' in o[i+1]:           
                        if TxMatch(o, i, """Py_INCREF($1);
                            if (PyInt_CheckExact( $1 ) && ($6 = PyInt_AS_LONG ( $1 )) < (LONG_MAX-$2) ) {
                            temp[$0] = PyInt_FromLong ( $6 + $3 );
                            } else if (PyFloat_CheckExact( $1 )) {
                            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)$3));
                            } else {
                            if ((temp[$0] = PyNumber_Add ( $1 , $4 )) == 0) goto $5;
                            }
                            if (PyInt_CheckExact( temp[$0] )) {
                            $7 = PyInt_AS_LONG ( temp[$0] );
                            if ( $7 < 0) {
                            $7 += PyList_GET_SIZE($8);
                            }
                            if ( PyList_SetItem ( $8 , $7 , $1 ) == -1) goto $5;
                            } else {
                            if ( PyObject_SetItem ( $8 , temp[$0] , $1 ) == -1) goto $5;
                            Py_DECREF($1);
                            }
                            CLEARTEMP($0);""", v2) and v2[6] != v2[7]:
                                TxRepl(o, i, """if (PyInt_CheckExact( $1 ) && ($6 = PyInt_AS_LONG ( $1 )) < (LONG_MAX-$2) ) {
                                    $7 = $6 + $3;
                                    if ( $7 < 0) {
                                    $7 += PyList_GET_SIZE($8);
                                    }
                                    Py_INCREF($1);
                                    if ( PyList_SetItem ( $8 , $7 , $1 ) == -1) goto $5;
                                    } else {
                                    if ((temp[$0] = PyNumber_Add ( $1 , $4 )) == 0) goto $5;
                                    if ( PyObject_SetItem ( $8 , temp[$0] , $1 ) == -1) goto $5;
                                    CLEARTEMP($0);
                                    }""", v2)
                                break                
                        if TxMatch(o, i, """Py_INCREF($6);
                            if (PyInt_CheckExact( $5 ) && ($9 = PyInt_AS_LONG ( $5 )) > INT_MIN ) {
                            temp[$2] = PyInt_FromLong ( $9 - 1 );
                            } else if (PyFloat_CheckExact( $5 )) {
                            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($5) - ((double)1));
                            } else {
                            if ((temp[$2] = PyNumber_Subtract ( $5 , $18 )) == 0) goto $8;
                            }
                            if (PyInt_CheckExact( temp[$2] )) {
                            $10 = PyInt_AS_LONG ( temp[$2] );
                            if ( $10 < 0) {
                            $10 += PyList_GET_SIZE($7);
                            }
                            if ( PyList_SetItem ( $7 , $10 , $6 ) == -1) goto $8;
                            } else {
                            if ( PyObject_SetItem ( $7 , temp[$2] , $6 ) == -1) goto $8;
                            Py_DECREF($6);
                            }
                            CLEARTEMP($2);""", v2):
                                TxRepl(o, i, """if (PyInt_CheckExact( $5 ) && ($9 = PyInt_AS_LONG ( $5 )) > INT_MIN ) {
                                    $10 = $9 - 1;
                                    if ( $10 < 0) {
                                    $10 += PyList_GET_SIZE($7);
                                    }
                                    Py_INCREF($6);
                                    if ( PyList_SetItem ( $7 , $10 , $6 ) == -1) goto $8;
                                    } else {
                                    if ((temp[$2] = PyNumber_Subtract ( $5 , $18 )) == 0) goto $8;
                                    if ( PyObject_SetItem ( $7 , temp[$2] , $6 ) == -1) goto $8;
                                    CLEARTEMP($2);
                                    }""", v2)
                                break 
                    
                        if TxMatch(o, i, """Py_INCREF($6);
                            if (PyInt_CheckExact( $5 ) && ($9 = PyInt_AS_LONG ( $5 )) > INT_MIN ) {
                            temp[$2] = PyInt_FromLong ( $9 - 1 );
                            } else {
                            if ((temp[$2] = PyNumber_Subtract ( $5 , $18 )) == 0) goto $8;
                            }
                            if (PyInt_CheckExact( temp[$2] )) {
                            $10 = PyInt_AS_LONG ( temp[$2] );
                            if ( $10 < 0) {
                            $10 += PyList_GET_SIZE($7);
                            }
                            if ( PyList_SetItem ( $7 , $10 , $6 ) == -1) goto $8;
                            } else {
                            if ( PyObject_SetItem ( $7 , temp[$2] , $6 ) == -1) goto $8;
                            Py_DECREF($6);
                            }
                            CLEARTEMP($2);""", v2):
                                TxRepl(o, i, """if (PyInt_CheckExact( $5 ) && ($9 = PyInt_AS_LONG ( $5 )) > INT_MIN ) {
                                    $10 = $9 - 1;
                                    if ( $10 < 0) {
                                    $10 += PyList_GET_SIZE($7);
                                    }
                                    Py_INCREF($6);
                                    if ( PyList_SetItem ( $7 , $10 , $6 ) == -1) goto $8;
                                    } else {
                                    if ((temp[$2] = PyNumber_Subtract ( $5 , $18 )) == 0) goto $8;
                                    if ( PyObject_SetItem ( $7 , temp[$2] , $6 ) == -1) goto $8;
                                    CLEARTEMP($2);
                                    }""", v2)
                                break 
                            
                        if oi.startswith('Py_INCREF(temp['):
                            if TxMatch(o, i, """
                                Py_INCREF(temp[$0]);
                                if (PyInt_CheckExact$2) {
                                long_$13 = $3;
                                long_$12 = $4;
                                if ($5) goto label_$16 ;
                                temp[$1] = PyInt_FromLong ($6);
                                } else if (PyFloat_CheckExact$7) {
                                temp[$1] = PyFloat_FromDouble($8);
                                } else { label_$16 :;
                                if ((temp[$1] = PyNumber_$9) == 0) goto label_$10;
                                }
                                CLEARTEMP($0);                            
                                """, v2):
                                    TxRepl(o, i, """
                                        if (PyInt_CheckExact$2) {
                                        long_$13 = $3;
                                        long_$12 = $4;
                                        if ($5) goto label_$16 ;
                                        temp[$1] = PyInt_FromLong ($6);
                                        temp[$0] = 0;
                                        } else if (PyFloat_CheckExact$7) {
                                        temp[$1] = PyFloat_FromDouble($8);
                                        temp[$0] = 0;
                                        } else { label_$16 :;
                                        Py_INCREF(temp[$0]);
                                        if ((temp[$1] = PyNumber_$9) == 0) goto label_$10;
                                        CLEARTEMP($0);                            
                                        }
                                        """, v2)
                                    break 
                            
                            
                    elif o[i+1].startswith('SETLOCAL'):
                        if oi == 'Py_INCREF(Py_None);' and TxMatch(o, i, """
                            Py_INCREF(Py_None);
                            SETLOCAL ( $0 , Py_None );
                            """, v2):
                                TxRepl(o, i, """
                                    Py_XDECREF(GETLOCAL($0));   
                                    Py_INCREF(Py_None);
                                    GETLOCAL($0) = Py_None;
                                    """, v2)
                                break 
                   
                    if o[i+1].startswith('temp[') and oi.startswith('Py_INCREF(temp['):
                        if TxMatch(o, i, """
                            Py_INCREF(temp[$1]);
                            temp[$0] = 0;
                            if ((int_$3 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$4;
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    temp[$0] = 0;
                                    if ((int_$3 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$4;
                                    temp[$1] = 0;
                                    """, v2)
                                break 
                        if TxMatch(o, i, """
                            Py_INCREF(temp[$1]);
                            temp[$0] = 0;
                            if ((int_$3 = PyObject_Not ( temp[$1] )) == -1) goto label_$4;
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    temp[$0] = 0;
                                    if ((int_$3 = PyObject_Not ( temp[$1] )) == -1) goto label_$4;
                                    temp[$1] = 0;
                                    """, v2)
                                break 
                    if o[i+1].startswith('if ((int_') and oi.startswith('Py_INCREF(temp['):
                        if TxMatch(o, i, """
                            Py_INCREF(temp[$1]);
                            if ((int_$3 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$4;
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    if ((int_$3 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$4;
                                    temp[$1] = 0;
                                    """, v2)
                                break 
                        if TxMatch(o, i, """
                            Py_INCREF(temp[$1]);
                            if ((int_$3 = PyObject_Not ( temp[$1] )) == -1) goto label_$4;
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    if ((int_$3 = PyObject_Not ( temp[$1] )) == -1) goto label_$4;
                                    temp[$1] = 0;
                                    """, v2)
                                break 
                    if o[i+1].startswith('CLEARTEMP') and oi.startswith('Py_INCREF(temp['):
                        if TxMatch(o, i, """
                            Py_INCREF(temp[$1]);
                            CLEARTEMP($0);
                            int_$2 = temp[$1] $5= $3;
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    CLEARTEMP($0);
                                    int_$2 = temp[$1] $5= $3;
                                    temp[$1] = 0;
                                    """, v2)
                                break 
                        if TxMatch(o, i, """
                            Py_INCREF(temp[$1]);
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    temp[$1] = 0;
                                    """, v2)
                                break                             
                
                    if i+2 < len(o):
                        if 'PyList_GetItem' in o[i+1] and TxMatch(o, i, """ 
                            Py_INCREF($3);
                            if ((temp[$0] = PyList_GetItem ( $4 , $5 )) == 0) goto label_$2;
                            Py_INCREF(temp[$0]);
                            if ((temp[$1] = PyTuple_New ( 2 )) == 0) goto label_$2;
                            PyTuple_SET_ITEM ( temp[$1] , 0 , $3 );
                            PyTuple_SET_ITEM ( temp[$1] , 1 , temp[$0] );
                            temp[$0] = 0;""", v2):
                                TxRepl(o, i, """                
                                    if ((temp[$0] = PyList_GetItem ( $4 , $5 )) == 0) goto label_$2;
                                    if ((temp[$1] = PyTuple_Pack ( 2 , $3 , temp[$0] )) == 0) goto label_$2;
                                    temp[$0] = 0;
                                    """, v2)
                                break                
                        oi2 = o[i+2]
                        assert type(oi2) is str
                        if oi2.startswith('PyTuple_SET_ITEM') and TxMatch(o, i, """                
                            Py_INCREF($1);
                            if ((temp[$3] = PyTuple_New ( 1 )) == 0) goto label_$4;
                            PyTuple_SET_ITEM ( temp[$3] , 0 , $1 );
                            """, v2):
                                TxRepl(o, i, """                
                                    if ((temp[$3] = PyTuple_Pack ( 1 , $1 )) == 0) goto label_$4;
                                    """, v2)
                                break                
                        if oi.startswith('Py_INCREF(temp[') and oi2.startswith('CLEARTEMP('):
                            if TxMatch(o, i, """Py_INCREF(temp[$2]);
                                if ((temp[$1] = __c_BINARY_SUBSCR_Int ( temp[$2] , $3 )) == 0) goto $4;
                                CLEARTEMP($2);""", v2):
                                    TxRepl(o, i, """if ((temp[$1] = ___c_BINARY_SUBSCR_Int ( temp[$2] , $3 )) == 0) goto $4;
                                                    temp[$2] = 0;""", v2, ('___c_BINARY_SUBSCR_Int',))
                                    break
                                        
                                        
                            if TxMatch(o, i, """Py_INCREF(temp[$0]);
                                if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $3;
                                CLEARTEMP($0);""", v2):
                                    TxRepl(o, i, """if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $3;
                                        temp[$0] = 0;""", v2)
                                    break 
                            if TxMatch(o, i, """
                                Py_INCREF(temp[$0]);
                                $1 = temp[$0];
                                CLEARTEMP($0);""", v2):
                                    TxRepl(o, i, """
                                        $1 = temp[$0];
                                        temp[$0] = 0;""", v2)
                                    break
                            if TxMatch(o, i, """
                                Py_INCREF(temp[$1]);
                                long_$3 = PyInt_AS_LONG ( temp[$1] );
                                CLEARTEMP($1);
                                """, v2):
                                    TxRepl(o, i, """
                                        long_$3 = PyInt_AS_LONG ( temp[$1] );
                                        temp[$1] = 0;
                                        """, v2)
                                    break
                            if TxMatch(o, i, """
                                Py_INCREF(temp[$2]);
                                $3 = *PyString_AS_STRING ( temp[$2] );
                                CLEARTEMP($2);
                                """, v2):
                                    TxRepl(o, i, """
                                        $3 = *PyString_AS_STRING ( temp[$2] );
                                        temp[$2] = 0;
                                        """, v2)
                                    break

                                                    
                elif oic == '}' and oi == '} else if (1) {':
                    if TxMatch(o, i, """} else if (1) {
                               $1
                               } else {
                               $2
                               }""", v2):
                        if '{' not in v2[1] and '{' not in v2[2] and \
                        '}' not in v2[1] and '}' not in v2[2] and \
                        ':' not in v2[1] and ':' not in v2[2]:
                            TxRepl(o, i, ('} else {', '$1', '}'), v2)
                            break   
                    
                elif oic == '}' and oi.startswith('} else if (Py'):
                    if TxMatch(o, i, """
                        } else if (Py$1_CheckExact( $2 ) && Py$1_CheckExact( $2 )) {
                        """, v2): 
                        TxRepl(o, i, """
                            } else if (Py$1_CheckExact( $2 )) {
                            """, v2) 
                        break 
                    if TxMatch(o, i, """
                        } else if (Py$1_CheckExact( temp[$2] ) && Py$1_CheckExact( temp[$2] )) {
                        """, v2): 
                        TxRepl(o, i, """
                            } else if (Py$1_CheckExact( temp[$2] )) {
                            """, v2) 
                        break 
                    if oi.startswith('} else if (PyInt_CheckExact( '):
                        if TxMatch(o, i, """
                            } else if (PyInt_CheckExact( $9 )) {
                            long_$6 = PyInt_AS_LONG ( $9 );
                            long_$7 = PyInt_AS_LONG ( $9 );
                            if (long_$6 && long_$7 && (long_$6 * long_$7) / long_$7 == long_$6) {
                            temp[$0] = PyInt_FromLong ( long_$6 * long_$7 );
                            } else {                    
                            """, v2): 
                            TxRepl(o, i, """
                                } else if (PyInt_CheckExact( $9 )) {
                                long_$6 = PyInt_AS_LONG ( $9 );
                                if (long_$6 && (long_$6 * long_$6) / long_$6 == long_$6) {
                                temp[$0] = PyInt_FromLong ( long_$6 * long_$6 );
                                } else {                    
                                """, v2) 
                            break 
                    if oi.startswith('} else if (PyInt_CheckExact( temp['):
                        if TxMatch(o, i, """
                            } else if (PyInt_CheckExact( temp[$9] )) {
                            long_$6 = PyInt_AS_LONG ( temp[$9] );
                            long_$7 = PyInt_AS_LONG ( temp[$9] );
                            if (long_$6 && long_$7 && (long_$6 * long_$7) / long_$7 == long_$6) {
                            temp[$0] = PyInt_FromLong ( long_$6 * long_$7 );
                            } else {                    
                            """, v2): 
                            TxRepl(o, i, """
                                } else if (PyInt_CheckExact( temp[$9] )) {
                                long_$6 = PyInt_AS_LONG ( temp[$9] );
                                if (long_$6 && (long_$6 * long_$6) / long_$6 == long_$6) {
                                temp[$0] = PyInt_FromLong ( long_$6 * long_$6 );
                                } else {                    
                                """, v2) 
                            break    
                        if TxMatch(o, i, """
                            } else if (PyInt_CheckExact( temp[$12] )) {
                            long_$1 = PyInt_AS_LONG ( temp[$12] );
                            long_$2 = PyInt_AS_LONG ( temp[$12] );
                            if (!long_$1 || !long_$2 || (long_$1 * long_$2) / long_$2 == long_$1) {
                            temp[$3] = PyInt_FromLong ( long_$1 * long_$2 );
                            } else {
                            """, v2): 
                            TxRepl(o, i, """
                                } else if (PyInt_CheckExact( temp[$12] )) {
                                long_$1 = PyInt_AS_LONG ( temp[$12] );
                                if (!long_$1 || (long_$1 * long_$1) / long_$1 == long_$1) {
                                temp[$3] = PyInt_FromLong ( long_$1 * long_$1 );
                                } else { 
                                """, v2) 
                            break    
                        
                elif oic == 'i' and oi.startswith('int_'):
                    if 'int_' in oi[4:]:
                        if TxMatch(o, i, """int_$1 =  int_$1 ;""", v2):
                                TxRepl(o, i, (), v2)
                                break
            
                        if TxMatch(o, i, """int_$1 = int_$1;""", v2):
                                TxRepl(o, i, (), v2)
                                break
                    
                        if TxMatch(o, i, """int_$1 =  int_$1;""", v2):
                                TxRepl(o, i, (), v2)
                                break
                    if i+1 < len(o) and o[i+1].startswith('if ('):        
                        if TxMatch(o, i, """int_$1 = $12;
                            if (!( int_$1 )) {
                            int_$1 = $11;
                            }""", v2):
                                TxRepl(o, i, """int_$1 = ($12) || ($11);""", v2)
                                break  
                        if TxMatch(o, i, """int_$1 = $12;
                            if ( !(int_$1) ) {
                            int_$1 = $11;
                            }""", v2):
                                TxRepl(o, i, """int_$1 = ($12) || ($11);""", v2)
                                break  
                        if TxMatch(o, i, """int_$1 = $12;
                            if ( !int_$1 ) {
                            int_$1 = $11;
                            }""", v2):
                                TxRepl(o, i, """int_$1 = ($12) || ($11);""", v2)
                                break  
                        if TxMatch(o, i, """int_$1 = $12;
                            if ( int_$1 ) {
                            int_$1 = $11;
                            }""", v2):
                                TxRepl(o, i, """int_$1 = ($12) && ($11);""", v2)
                                break  
                    else:        
                        if TxMatch(o, i, """
                            int_$1 = $2temp[$3]$4;
                            CLEARTEMP($3);
                            Loc_int_$5 = int_$1;""", v2):    
                                TxRepl(o, i, """
                                    Loc_int_$5 = $2temp[$3]$4;
                                    CLEARTEMP($3);""", v2)
                                break  
                        if TxMatch(o, i, """
                            int_$1 = ( PyString_GET_SIZE($0) == 1 ) && (0 == memcmp(PyString_AS_STRING ( $0 ), "$3" , 1));
                            """, v2):
                                TxRepl(o, i, """
                                    int_$1 = ( PyString_GET_SIZE($0) == 1 ) && (*PyString_AS_STRING ( $0 ) == *"$3");
                                    """, v2)
                                break  
            
                elif oic == 'd' and oi.startswith('double'):
                    if TxMatch(o, i, """double_$4 = $3;
                        if ((temp[$0] = PyFloat_FromDouble ( double_$4 )) == 0) goto label_$0;
                        $5 = PyFloat_AsDouble(temp[$0]);
                        CLEARTEMP($0);""", v2):
                            TxRepl(o, i, """$5 = $3;""", v2)
                            break  
                    if TxMatch(o, i, """double_$5 = $0;
                        if ((temp[$6] = PyFloat_FromDouble ( double_$5 )) == 0) goto $10;""", v2):
                            TxRepl(o, i, """if ((temp[$6] = PyFloat_FromDouble ( $0 )) == 0) goto $10;""", v2)
                            break  

                    if TxMatch(o, i, """
                        double_$3 = PyFloat_AsDouble ( GETLOCAL($5) );
                        double_$4 = PyFloat_AsDouble ( GETLOCAL($5) );
                        if ((temp[$0] = PyFloat_FromDouble ( double_$3 $7 double_$4 )) == 0) goto label_$10;
                        """, v2) and ' ' not in v2[7]:
                            TxRepl(o, i, """
                                double_$3 = PyFloat_AsDouble ( GETLOCAL($5) );
                                if ((temp[$0] = PyFloat_FromDouble ( double_$3 $7 double_$3 )) == 0) goto label_$10;
                                """, v2)
                            break  
                    if TxMatch(o, i, """
                        double_$3 = PyFloat_AsDouble ( GETLOCAL($11) );
                        double_$4 = PyFloat_AsDouble ( GETLOCAL($11) );
                        double_$9 = double_$3 + double_$4;
                        """, v2):
                            TxRepl(o, i, """
                                    double_$9 = PyFloat_AsDouble ( GETLOCAL($11) ) * 2;
                                """, v2)
                            break   
                    if TxMatch(o, i, """
                        double_$3 = PyFloat_AsDouble ( GETLOCAL($11) );
                        double_$4 = PyFloat_AsDouble ( GETLOCAL($11) );
                        double_$9 = double_$3 $7 double_$4;
                        """, v2) and ' ' not in v2[7]:
                            TxRepl(o, i, """
                                    double_$3 = PyFloat_AsDouble ( GETLOCAL($11) );
                                    double_$9 = double_$3 $7 double_$3;
                                """, v2)
                            break   
                    if TxMatch(o, i, """
                        double_$3 = PyFloat_AsDouble ( GETLOCAL($5) );
                        double_$4 = PyFloat_AsDouble ( GETLOCAL($6) );
                        if ((temp[$0] = PyFloat_FromDouble ( double_$3 $7 double_$4 )) == 0) goto label_$10;
                        """, v2) and ' ' not in v2[7]:
                            TxRepl(o, i, """
                                   if ((temp[$0] = PyFloat_FromDouble ( PyFloat_AsDouble ( GETLOCAL($5) ) $7 PyFloat_AsDouble ( GETLOCAL($6) ) )) == 0) goto label_$10;
                                """, v2)
                            break              
                    if TxMatch(o, i, """
                        double_$3 = PyFloat_AsDouble ( GETLOCAL($11) );
                        double_$4 = PyFloat_AsDouble ( GETLOCAL($12) );
                        double_$9 = double_$3 $7 double_$4;
                        """, v2) and ' ' not in v2[7]:
                            TxRepl(o, i, """
                                   double_$9 = PyFloat_AsDouble ( GETLOCAL($11) ) $7 PyFloat_AsDouble ( GETLOCAL($12) );
                                """, v2)
                            break   
                    if TxMatch(o, i, """
                        double_$3 = $11;
                        double_$4 = Loc_double_$12;
                        double_$9 = double_$3 $7 double_$4;
                        """, v2) and ' ' not in v2[7] and ' ' in v2[11]:
                            TxRepl(o, i, """
                                   double_$9 = ($11) $7 Loc_double_$12;
                                """, v2)
                            break   
                    if TxMatch(o, i, """
                        double_$3 = (double)( Loc_long_$10 );
                        double_$4 = double_$3 $7 $11;
                        """, v2) and ' ' not in v2[7]:
                            TxRepl(o, i, """
                                   double_$4 = (double)( Loc_long_$10 ) $7 $11;
                                """, v2)
                            break  

                    if TxMatch(o, i, """
                        double_$13 = $3;
                        double_$12 = $14 $15 double_$13;                        
                        """, v2) and ' ' not in v2[14] and ' ' not in v2[15] and ' ' in v2[3]:
                            TxRepl(o, i, """
                                double_$12 = $14 $15 ( $3 );                        
                                """, v2)
                            break  

                    if TxMatch(o, i, """
                        double_$17 = PyFloat_AS_DOUBLE ( temp[$1] );
                        if ((temp[$2] = PyFloat_FromDouble ($18)) == 0) goto label_$0;
                        } else {
                        """, v2) and v2[18].count('(double_' + v2[17] + ')') == 1:
                            tupl = v2[18].rpartition('(double_' + v2[17] + ')')
                            v2[18] = tupl[0] + 'PyFloat_AS_DOUBLE ( temp[' + v2[1] + '] )' + tupl[2]
                            TxRepl(o, i, """
                                if ((temp[$2] = PyFloat_FromDouble ($18)) == 0) goto label_$0;
                                } else {
                                """, v2)
                            break  
                    if TxMatch(o, i, """
                        double_$17 = PyFloat_AS_DOUBLE ( GETLOCAL($1) );
                        if ((temp[$2] = PyFloat_FromDouble ($18)) == 0) goto label_$0;
                        } else {
                        """, v2) and v2[18].count('(double_' + v2[17] + ')') == 1:
                            tupl = v2[18].rpartition('(double_' + v2[17] + ')')
                            v2[18] = tupl[0] + 'PyFloat_AS_DOUBLE ( GETLOCAL(' + v2[1] + ') )' + tupl[2]
                            TxRepl(o, i, """
                                if ((temp[$2] = PyFloat_FromDouble ($18)) == 0) goto label_$0;
                                } else {
                                """, v2)
                            break  

                elif oic == 'l' and oi.startswith('long_'):
                    if TxMatch(o, i, """
                        long_$4 = ($6_GET_SIZE($7));
                        temp[$0] = PyInt_FromLong ( (long_$4 $5 $1) );
                        """, v2):    
                            TxRepl(o, i, """temp[$0] = PyInt_FromLong ( $6_GET_SIZE($7) $5 $1 );""", v2)
                            break     
                    if o[i+1].startswith('temp['):
                        if '] = PyInt_FromLong ( long_' in o[i+1] and 'temp['not in oi:
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                CLEARTEMP($9);
                                } else {
                                """, v2) and v2[9] != v2[14]:  
                                    TxRepl(o, i, """
                                            temp[$14] = PyInt_FromLong ( $5 );
                                            } else {
                                            """, v2)
                                    break   
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                } else {
                                """, v2):    
                                    TxRepl(o, i, """
                                            temp[$14] = PyInt_FromLong ( $5 );
                                            } else {
                                            """, v2)
                                    break     
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                } else { label_$15
                                """, v2):    
                                    TxRepl(o, i, """
                                            temp[$14] = PyInt_FromLong ( $5 );
                                            } else { label_$15
                                            """, v2)
                                    break     
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                if ((temp[$15] = _PyEval_ApplySlice ($16)) == 0) goto label_$18;
                                """, v2) and ('temp[' + v2[14] + ']') in v2[16]:    
                                    TxRepl(o, i, """
                                            temp[$14] = PyInt_FromLong ( $5 );
                                            if ((temp[$15] = _PyEval_ApplySlice ($16)) == 0) goto label_$18;
                                            """, v2)
                                    break    
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                if ((temp[$15] = FastCall($16)) == 0) goto label_$18;
                                """, v2) and ('temp[' + v2[14] + ']') in v2[16]:    
                                    TxRepl(o, i, """
                                            temp[$14] = PyInt_FromLong ( $5 );
                                            if ((temp[$15] = FastCall($16)) == 0) goto label_$18;
                                            """, v2)
                                    break     
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                if ((temp[$15] = _Call_CompiledWithFrame($16)) == 0) goto label_$18;
                                """, v2) and ('temp[' + v2[14] + ']') in v2[16]:    
                                    TxRepl(o, i, """
                                            temp[$14] = PyInt_FromLong ( $5 );
                                            if ((temp[$15] = _Call_CompiledWithFrame($16)) == 0) goto label_$18;
                                            """, v2)
                                    break                           
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                if ((temp[$15] = PyObject_RichCompare ($16)) == 0) goto label_$18;
                                """, v2) and ('temp[' + v2[14] + ']') in v2[16]:    
                                    TxRepl(o, i, """
                                            temp[$14] = PyInt_FromLong ( $5 );
                                            if ((temp[$15] = PyObject_RichCompare ($16)) == 0) goto label_$18;
                                            """, v2)
                                    break     
                
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                if (_Direct_$16) == -1) goto label_$18;
                                """, v2) and ('temp[' + v2[14] + ']') in v2[16]:    
                                    TxRepl(o, i, """
                                            temp[$14] = PyInt_FromLong ( $5 );
                                            if (_Direct_$16) == -1) goto label_$18;
                                            """, v2)
                                    break    
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                <1
                                LETLOCAL ( $16 , temp[$14] );
                                """, v2):    
                                    TxRepl(o, i, """
                                            temp[$14] = PyInt_FromLong ( $5 );
                                            <1
                                            LETLOCAL ( $16 , temp[$14] );
                                            """, v2)
                                    break                           
                            ## if TxMatch(o, i, """
                                ## long_$4 = $5;
                                ## temp[$14] = PyInt_FromLong ( long_$4 );
                                ## <1
                                ## SETLOCAL2 ( $16 , temp[$14] );
                                ## """, v2):    
                                    ## TxRepl(o, i, """
                                            ## temp[$14] = PyInt_FromLong ( $5 );
                                            ## <1
                                            ## SETLOCAL2 ( $16 , temp[$14] );
                                            ## """, v2)
                                    ## break       
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                <1
                                SETLOCAL ( $16 , temp[$14] );
                                """, v2) and 'temp[' not in v2[5]:
                                    TxRepl(o, i, """
                                            temp[$14] = PyInt_FromLong ( $5 );
                                            <1
                                            SETLOCAL ( $16 , temp[$14] );
                                            """, v2)
                                    break                                                                                        
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                if ((temp[$15] = PyTuple_New ($16)) == 0) goto label_$18;
                                """, v2):    
                                    TxRepl(o, i, """
                                            temp[$14] = PyInt_FromLong ( $5 );
                                            if ((temp[$15] = PyTuple_New ($16)) == 0) goto label_$18;
                                            """, v2)
                                    break      
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                <1
                                if ((temp[$15] = $16) == 0) goto label_$18;
                                CLEARTEMP($14);
                                """, v2):    
                                    TxRepl(o, i, """
                                            temp[$14] = PyInt_FromLong ( $5 );
                                            <1
                                            if ((temp[$15] = $16) == 0) goto label_$18;
                                            CLEARTEMP($14);
                                            """, v2)
                                    break                                                   
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                <1
                                long_$6 = PyInt_AS_LONG ( temp[$14] );
                                CLEARTEMP($14);
                                """, v2):    
                                    TxRepl(o, i, """
                                            <1
                                            long_$6 = $5;
                                            """, v2)
                                    break        
                
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                <1
                                temp[$15] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$14] ) $16 );
                                CLEARTEMP($14);
                                """, v2):    
                                    TxRepl(o, i, """
                                            <1
                                            temp[$15] = PyInt_FromLong ( ( $5 ) $16 );
                                            """, v2)
                                    break    
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                <1
                                temp[$15] = PyInt_FromLong ( $16 PyInt_AS_LONG ( temp[$14] ) );
                                CLEARTEMP($14);
                                """, v2):    
                                    TxRepl(o, i, """
                                            <1
                                            temp[$15] = PyInt_FromLong ( $16 ( $5 ) );
                                            """, v2)
                                    break   
                            if TxMatch(o, i, """
                                long_$4 = $5;
                                temp[$14] = PyInt_FromLong ( long_$4 );
                                long_$8 = PyInt_AS_LONG ( temp[$14] );
                                """, v2):    
                                    TxRepl(o, i, """
                                        temp[$14] = PyInt_FromLong ( $5 );
                                        long_$8 = PyInt_AS_LONG ( temp[$14] );
                                            """, v2)
                                    break  
                            if TxMatch(o, i, 
                                """long_$4 = $5;
                                temp[$0] = PyInt_FromLong ( long_$4 );
                                if (PyInt_CheckExact( $6 )) {
                                temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( $6 ) $7 PyInt_AS_LONG ( temp[$0] ) );
                                } else {
                                >1
                                }
                                CLEARTEMP($0);""", v2):    
                                    TxRepl(o, i, 
                                        """if (PyInt_CheckExact( $6 )) {
                                        temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( $6 ) $7 ($5) );
                                        } else {
                                        temp[$0] = PyInt_FromLong ( $5 );
                                        >1
                                        CLEARTEMP($0);
                                        }""", v2)
                                    break  
    
                        if TxMatch(o, i, """
                            long_$2 = PyInt_AS_LONG ( $3 );
                            temp[$1] = PyInt_FromLong ( ~long_$2 );
                            } else {
                            """, v2):    
    
                                TxRepl(o, i, """
                                    temp[$1] = PyInt_FromLong ( ~PyInt_AS_LONG ( $3 ) );
                                    } else {
                                        """, v2)
                                break                                
    
                        if TxMatch(o, i, """
                            long_$3 = (long)((unsigned char)*PyString_AS_STRING ( $5 ));
                            temp[$0] = PyInt_FromLong ( long_$3 );
                            } else {
                            """, v2):    
    
                                TxRepl(o, i, """
                                    temp[$0] = PyInt_FromLong ( ((unsigned char)*PyString_AS_STRING ( $5 )) );
                                    } else {
                                        """, v2)
                                break 
                        if TxMatch(o, i, """long_$4 = $2;
                            temp[$1] = PyInt_FromLong ( long_$4 );
                            long_$4 = PyInt_AS_LONG ( temp[$1] );
                            CLEARTEMP($1);""", v2):
                                v2[2] = v2[2].strip()
                                TxRepl(o, i, """long_$4 = $2;""", v2)
                                break
                        if TxMatch(o, i, """
                            long_$4 = $3;
                            temp[$1] = PyInt_FromLong ( long_$4 );
                            if ( _PyEval_AssignSlice ( $5 , temp[$1] , NULL , temp[$0] ) == -1) goto label_$6;
                            CLEARTEMP($0);
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    if ( PySequence_SetSlice ( $5 , $3 , PY_SSIZE_T_MAX , temp[$0] ) == -1) goto label_$6;
                                    CLEARTEMP($0);
                                    """, v2)
                                break    
                        if TxMatch(o, i, """
                            long_$3 = PyInt_AS_LONG ( $11 ) $12 $14;
                            temp[$0] = PyInt_FromLong ( long_$3 );
                            int_$2 = PyInt_AS_LONG ( temp[$0] ) $15 $16;
                            CLEARTEMP($0);    
                            """, v2):
                                TxRepl(o, i, """
                                    int_$2 = ( PyInt_AS_LONG ( $11 ) $12 $14 ) $15 $16;
                                    """, v2)
                                break  
                        if TxMatch(o, i, """
                            long_$3 = (long)((unsigned char)*($10));
                            temp[$1] = PyInt_FromLong ( long_$3 );
                            """, v2):
                                TxRepl(o, i, """
                                     temp[$1] = PyInt_FromLong ( (long)((unsigned char)*($10)) );
                                    """, v2)
                                break                               


                    if o[i+1].startswith('long_'):
                        if TxMatch(o, i, """
                            long_$2 = ($6_GET_SIZE($7));
                            long_$4 = long_$2 $3 $8;
                            """, v2) and ('long_' + v2[4]) not in o[i+2]:    
                                TxRepl(o, i, """long_$4 = ($6_GET_SIZE($7)) $3 $8;""", v2)
                                break  

                        if TxMatch(o, i, """long_$8 = $18;
                            long_$11 = Loc_long_$19;
                            long_$7 = long_$8 + long_$11;
                            if (( long_$7 ^ long_$8 ) < 0 && ( long_$7 ^ long_$11 ) < 0) goto label_$12 ;""", v2):
                                if ' ' not in v2[18]:
                                    TxRepl(o, i, """long_$8 = $18;
                                        long_$7 = long_$8 + Loc_long_$19;
                                        if (( long_$7 ^ long_$8 ) < 0 && ( long_$7 ^ Loc_long_$19 ) < 0) goto label_$12 ;""", v2)
                                    break
                            
                        if TxMatch(o, i, """long_$1 = (long)$3;
                            long_$2 = long_$1;
                            long_$1 = long_$2 + 1;""", v2):
                                TxRepl(o, i, """long_$1 = ((long)$3) + 1;""", v2)
                                break
                        if TxMatch(o, i, """long_$2 = $1;
                            long_$4 = $3;
                            int_$11 = long_$2 $5 long_$4;""", v2):
                                v2[1] = cond_add_sk(v2[1])
                                v2[3] = v2[3].strip()
                                TxRepl(o, i, """int_$11 = $1 $5 ($3);""", v2)
                                break  
                            
                        if TxMatch(o, i, """long_$2 = long_$1 + 1;
                            long_$1 = long_$2;""", v2):
                                TxRepl(o, i, """long_$1 = long_$1 + 1;""", v2)
                                break    
                    
                        if TxMatch(o, i, """long_$2 = $3;
                                long_$1 = long_$2;""", v2):
                                TxRepl(o, i, """long_$1 = $3;""", v2)
                                break  
                
                        if TxMatch(o, i, """long_$1 = $2;
                            long_$1 = long_$1 + 1;""", v2):
                                TxRepl(o, i, """long_$1 = ($2) + 1;""", v2)
                                break  
                
                        if TxMatch(o, i, """long_$0 = $3;
                            long_$1 = Glob_long_$4;
                            long_$2 = long_$0 - long_$1;
                            if (( long_$2 ^ long_$0 ) < 0 && ( long_$2 ^~ long_$1 ) < 0) goto $5 ;""", v2) and\
                            ' ' not in v2[4]:
                                TxRepl(o, i, """long_$0 = $3;
                                    long_$2 = long_$0 - Glob_long_$4;
                                    if (( long_$2 ^ long_$0 ) < 0 && ( long_$2 ^~ Glob_long_$4 ) < 0) goto $5 ;""", v2)
                                break 
                                
                        if TxMatch(o, i, """long_$0 = $3;
                            long_$1 = Loc_long_$4;
                            long_$2 = long_$0 - long_$1;
                            if (( long_$2 ^ long_$0 ) < 0 && ( long_$2 ^~ long_$1 ) < 0) goto $5 ;""", v2) and\
                            ' ' not in v2[4]:
                                TxRepl(o, i, """long_$0 = $3;
                                    long_$2 = long_$0 - Loc_long_$4;
                                    if (( long_$2 ^ long_$0 ) < 0 && ( long_$2 ^~ Loc_long_$4 ) < 0) goto $5 ;""", v2)
                                break  
                            
                        if TxMatch(o, i, """long_$2 = Loc_long_$6;
                            long_$4 = PyInt_AS_LONG ( $5 );
                            long_$1 = long_$2 + long_$4;
                            if (( long_$1 ^ long_$2 ) < 0 && ( long_$1 ^ long_$4 ) < 0) goto $9 ;""", v2):
                                TxRepl(o, i, """long_$4 = PyInt_AS_LONG ( $5 );
                                    long_$1 = Loc_long_$6 + long_$4;
                                    if (( long_$1 ^ Loc_long_$6 ) < 0 && ( long_$1 ^ long_$4 ) < 0) goto $9 ;""", v2)
                                break  
                                
                        if TxMatch(o, i, """
                            long_$3 = $10;
                            long_$4 = long_$3 * $5;
                            if (long_$4 / $5 == long_$3) {
                            temp[$2] = PyInt_FromLong (long_$4);
                            } else {
                            temp[$0] = $11;
                            temp[$2] = $12;
                            CLEARTEMP($0);
                            }
                            long_$15 = PyInt_AS_LONG ( temp[$2] );
                            """, v2):
                                TxRepl(o, i, """
                                    long_$3 = $10;
                                    temp[$2] = PyInt_FromLong (long_$3 * $5);
                                    long_$15 = PyInt_AS_LONG ( temp[$2] );
                                    """, v2)
                                break  
                            
                        if TxMatch(o, i, """
                            long_$5 =  $9 ;
                            long_$6 = long_$5 - 1;
                            temp[$0] = PyInt_FromLong ( long_$6 );
                            if ((temp[$1] = $11) == 0) goto label_$10;
                            CLEARTEMP($0);
                            """, v2) and ' ' not in v2[9]:
                                TxRepl(o, i, """
                                    temp[$0] = PyInt_FromLong ( $9 - 1 );
                                    if ((temp[$1] = $11) == 0) goto label_$10;
                                    CLEARTEMP($0);
                                    """, v2)
                                break  
                        if TxMatch(o, i, """
                            long_$5 =  $9 ;
                            long_$6 = long_$5 $2 $3;
                            temp[$0] = PyInt_FromLong ( long_$6 );
                            if ($15) goto label_$10;
                            CLEARTEMP($0);                           
                            """, v2) and ' ' not in v2[9] and v2[2] in '+-' and type(v2[3]) is str and v2[3].isdigit():
                                TxRepl(o, i, """
                                    temp[$0] = PyInt_FromLong ( $9 $2 $3 );
                                    if ($15) goto label_$10;
                                    CLEARTEMP($0);                           
                                    """, v2)
                                break  
                        if TxMatch(o, i, """
                            long_$4 =  $1 ;
                            long_$4 = long_$4 $2 $3;
                            """, v2) and ' ' not in v2[1] and v2[2] in '+-' and type(v2[3]) is str and v2[3].isdigit():
                                TxRepl(o, i, """
                                    long_$4 = $1 $2 $3;
                                    """, v2)
                                break     
                        if TxMatch(o, i, """
                            long_$6 = PyInt_AS_LONG ( $2 );
                            long_$5 = long_$6 + $7;
                            temp[$1] = PyInt_FromLong ( long_$5 );
                            if ( _PyEval_AssignSlice ( $4 , $2 , temp[$1] , temp[$0] ) == -1) goto label_$3;
                            CLEARTEMP($0);
                            CLEARTEMP($1);
                            """, v2):
                                TxRepl(o, i, """
                                    long_$6 = PyInt_AS_LONG ( $2 );
                                    if ( PySequence_SetSlice ( $4 , long_$6 , long_$6 + $7 , temp[$0] ) == -1) goto label_$3;
                                    CLEARTEMP($0);
                                    """, v2)
                                break    

                        if TxMatch(o, i, """
                            long_$6 = PyInt_AS_LONG ( GETLOCAL($1) );
                            long_$5 = long_$6 $12 $11;
                            temp[$0] = PyInt_FromLong ( long_$5 );
                            SETLOCAL ( $1 , temp[$0] );
                            temp[$0] = 0;
                            """, v2):
                                TxRepl(o, i, """
                                    long_$6 = PyInt_AS_LONG ( GETLOCAL($1) );
                                    Py_DECREF(GETLOCAL($1));
                                    GETLOCAL($1) = PyInt_FromLong ( long_$6 $12 $11 );                                   
                                    """, v2)
                                break    
                        if TxMatch(o, i, """
                            long_$6 = PyInt_AS_LONG ( GETLOCAL($1) );
                            long_$5 = long_$6 $12 $11;
                            temp[$0] = PyInt_FromLong ( long_$5 );
                            """, v2):
                                TxRepl(o, i, """
                                    temp[$0] = PyInt_FromLong ( PyInt_AS_LONG ( GETLOCAL($1) ) $12 $11 );
                                    """, v2)
                                break       
                        if TxMatch(o, i, """
                            long_$0 = $10;
                            long_$1 = PyInt_AS_LONG ( $9 );
                            long_$2 = long_$1 + long_$0;
                            if (( long_$2 ^ long_$1 ) < 0 && ( long_$2 ^ long_$0 ) < 0) goto label_$3 ;
                            temp[$5] = PyInt_FromLong ( long_$2 );
                            if (1) {
                            } else { label_$3 :;
                            temp[$6] = PyInt_FromLong ( long_$0 );
                            if ((temp[$5] = PyNumber_Add ( $9 , temp[$6] )) == 0) goto label_$4;
                            CLEARTEMP($6);
                            }
                            if (($7 = _PyEval_ApplySlice ( $8 , $9 , temp[$5] )) == 0) goto label_$4;
                            CLEARTEMP($5);
                            """, v2):
                                TxRepl(o, i, """
                                    long_$0 = $10;
                                    long_$1 = PyInt_AS_LONG ( $9 );
                                    long_$2 = long_$1 + long_$0;
                                    if (( long_$2 ^ long_$1 ) < 0 && ( long_$2 ^ long_$0 ) < 0) goto label_$3 ;
                                    if (($7 = PySequence_GetSlice ( $8 , long_$1 , long_$2 )) == 0) goto label_$4;
                                    if (0) { label_$3 :;
                                    temp[$6] = PyInt_FromLong ( long_$0 );
                                    if ((temp[$5] = PyNumber_Add ( $9 , temp[$6] )) == 0) goto label_$4;
                                    CLEARTEMP($6);
                                    if (($7 = _PyEval_ApplySlice ( $8 , $9 , temp[$5] )) == 0) goto label_$4;
                                    CLEARTEMP($5);
                                    }
                                    """, v2)
                                break  
                        if TxMatch(o, i, """    
                            long_$1 = $4;
                            long_$2 = PyInt_AS_LONG ( temp[$11] );
                            temp[$10] = PyInt_FromLong ( long_$1 );
                            long_$3 = long_$2 $5 long_$1;
                            if ($6) goto label_$7 ;
                            CLEARTEMP($11);
                            CLEARTEMP($10);
                            """, v2):
                                TxRepl(o, i, """
                                    long_$1 = $4;
                                    long_$2 = PyInt_AS_LONG ( temp[$11] );
                                    long_$3 = long_$2 $5 long_$1;
                                    if ($6) {
                                    temp[$10] = PyInt_FromLong ( long_$1 );
                                    goto label_$7 ;
                                    }
                                    CLEARTEMP($11);
                                    """, v2)
                                break   
                        if TxMatch(o, i, """    
                            long_$3 = ( Loc_long_$5 );
                            long_$13 = Py_ARITHMETIC_RIGHT_SHIFT(long, long_$3, $4);
                            """, v2):
                                TxRepl(o, i, """
                                    long_$13 = Py_ARITHMETIC_RIGHT_SHIFT(long, Loc_long_$5, $4);
                                    """, v2)
                                break  

                        if TxMatch(o, i, """   
                            long_$8 = PyList_GET_SIZE($11);
                            long_$9 = -1 + long_$8;
                            if ( PyList_SetSlice ( $11 , long_$9 , long_$9 + 1 , $12 ) == -1) goto label_$14;
                            """, v2):
                                TxRepl(o, i, """
                                    if ( PyList_SetSlice ( $11 , PyList_GET_SIZE($11) - 1 , PyList_GET_SIZE($11) , $12 ) == -1) goto label_$14;
                                    """, v2)
                                break       
                        if TxMatch(o, i, """   
                            long_$8 = PyList_GET_SIZE($11);
                            long_$9 = -1 + long_$8;
                            if ( PyList_SetSlice ( $11 , long_$9 , long_$8 , $12 ) == -1) goto label_$14;
                            """, v2):
                                TxRepl(o, i, """
                                    if ( PyList_SetSlice ( $11 , PyList_GET_SIZE($11) - 1 , PyList_GET_SIZE($11) , $12 ) == -1) goto label_$14;
                                    """, v2)
                                break       

                        if TxMatch(o, i, """   
                            long_$9 = PyInt_AS_LONG ( $14 );
                            long_$10 = PyInt_AS_LONG ( $15 );
                            if (((long_$2 = long_$9 + long_$10), !((long_$2^long_$9) < 0 && (long_$2^long_$10) < 0))) {
                            temp[$0] = PyInt_FromLong ( long_$2 );
                            } else {
                            if ((temp[$0] = PyNumber_Add ( $11 )) == 0) goto label_$12;
                            }
                            """, v2):
                                TxRepl(o, i, """
                                    if (((long_$2 = PyInt_AS_LONG ( $14 ) + PyInt_AS_LONG ( $15 )), !((long_$2^PyInt_AS_LONG ( $14 )) < 0 && (long_$2^PyInt_AS_LONG ( $15 )) < 0))) {
                                    temp[$0] = PyInt_FromLong ( long_$2 );
                                    } else {
                                    if ((temp[$0] = PyNumber_Add ( $11 )) == 0) goto label_$12;
                                    }
                                    """, v2)
                                break    
                            
                                                                                     
                            
    
                    if o[i+1].startswith('Py_ssize_t_'):  
                        if TxMatch(o, i, """long_$4 = $1;
                            Py_ssize_t_$2 = long_$4;""", v2):
                                TxRepl(o, i, """Py_ssize_t_$2 = $1;""", v2)
                                break                         


                    if o[i+1].startswith('Loc_long_'):
                        if TxMatch(o, i, """long_$4 = $1;
                            Loc_long_$2 = long_$4;""", v2):
                                TxRepl(o, i, """Loc_long_$2 = $1;""", v2)
                                break     

                                                                                
                    if o[i+1].startswith('if (') and o[i+1].endswith(') {'):
                        if TxMatch(o, i, """
                            long_$4 = ( Py$7_GET_SIZE($8) $9 $10 );
                            if ( !(($6 $5 long_$4)) ) {
                            """, v2):    
                                TxRepl(o, i, """if ( !($6 $5 ( Py$7_GET_SIZE($8) $9 $10 )) ) {""", v2)
                                break       
                        if TxMatch(o, i, """
                            long_$2 = PyInt_AS_LONG ( $5 );
                            if (PyInt_CheckExact( $6 )) {
                            int_$1 = long_$2 $7 PyInt_AS_LONG ( $6 );
                            } else {
                            if ((int_$1 = PyObject_RichCompareBool ( $5 , $6 , Py_$8 )) == -1) goto label_$0;
                            }
                            """, v2):
                                TxRepl(o, i, """
                                    if (PyInt_CheckExact( $6 )) {
                                    int_$1 = PyInt_AS_LONG ( $5 ) $7 PyInt_AS_LONG ( $6 );
                                    } else {
                                    if ((int_$1 = PyObject_RichCompareBool ( $5 , $6 , Py_$8 )) == -1) goto label_$0;
                                    }
                                    """, v2)
                                break     
                        if TxMatch(o, i, """
                            long_$11 = PyInt_AS_LONG ( $10 );
                            if (long_$11 < (LONG_BIT-1)) {
                            temp[$0] = PyInt_FromLong ( 0x1 << long_$11 );
                            } else {
                            if ((temp[$0] = PyNumber_Lshift($4, $10)) == 0) goto label_$2;
                            }
                            if (PyInt_CheckExact( temp[$0] )) {
                            long_$13 = PyInt_AS_LONG ( temp[$0] );
                            long_$12 = long_$13 $7 $5;
                            if ($18) goto label_$3 ;
                            temp[$1] = PyInt_FromLong ( long_$12 );
                            } else if (PyFloat_CheckExact( temp[$0] )) {
                            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $7 ((double)$5));
                            } else { label_$3 :;
                            if ((temp[$1] = PyNumber_$8 ( temp[$0] , $6 )) == 0) goto label_$2;
                            }
                            CLEARTEMP($0);
                            """, v2):
                                TxRepl(o, i, """
                                    long_$11 = PyInt_AS_LONG ( $10 );
                                    if (long_$11 < (LONG_BIT-1)) {
                                    long_$13 = 0x1 << long_$11;
                                    long_$12 = long_$13 $7 $5;
                                    if ($18) goto label_$3 ;
                                    temp[$1] = PyInt_FromLong ( long_$12 );
                                    } else { label_$3 :;
                                    if ((temp[$0] = PyNumber_Lshift($4, $10)) == 0) goto label_$2;
                                    if ((temp[$1] = PyNumber_$8 ( temp[$0] , $6 )) == 0) goto label_$2;
                                    CLEARTEMP($0);
                                    }
                                    """, v2)
                                break    
                        if TxMatch(o, i, """
                            long_$3 = PyInt_AS_LONG ( $7 );
                            if (((long_$4 = long_$3 + $5), !((long_$4^long_$3) < 0 && (long_$4^$5) < 0))) {
                            temp[$0] = PyInt_FromLong ( long_$4 );
                            } else {
                            temp[$1] = PyInt_FromLong ( $5 );
                            if ((temp[$0] = PyNumber_Add ( $7 , temp[$1] )) == 0) goto label_$8;
                            CLEARTEMP($1);
                            }
                            if ((temp[$1] = _PyEval_ApplySlice ( $6 , $7 , temp[$0] )) == 0) goto label_$8;
                            CLEARTEMP($0);
                            """, v2):
                                TxRepl(o, i, """
                                    long_$3 = PyInt_AS_LONG ( $7 );
                                    if (((long_$4 = long_$3 + $5), !((long_$4^long_$3) < 0 && (long_$4^$5) < 0))) {
                                    if ((temp[$1] = PySequence_GetSlice ( $6 , long_$3 , long_$4 )) == 0) goto label_$8;
                                    } else {
                                    temp[$1] = PyInt_FromLong ( $5 );
                                    if ((temp[$0] = PyNumber_Add ( $7 , temp[$1] )) == 0) goto label_$8;
                                    CLEARTEMP($1);
                                    if ((temp[$1] = _PyEval_ApplySlice ( $6 , $7 , temp[$0] )) == 0) goto label_$8;
                                    CLEARTEMP($0);
                                    }
                                    """, v2)
                                break  
    
                        if TxMatch(o, i, """                        
                            long_$5 = (long)((unsigned char)*($10));
                            if (long_$5 < (LONG_MAX >> $16) && long_$5 >= 0) {
                            temp[$0] = PyInt_FromLong ( (long_$5 << $16) );
                            } else {
                            temp[$1] = PyInt_FromLong ( long_$5 );
                            if ((temp[$0] = PyNumber_Lshift(temp[$1], $17)) == 0) goto label_$9;
                            CLEARTEMP($1);
                            }
                            """, v2) and  type(v2[16]) is str and v2[16].isdigit() and int(v2[16]) <= (32-8):
                                TxRepl(o, i, """
                                    temp[$0] = PyInt_FromLong ( ((long)((unsigned char)*($10)) << $16) );
                                    """, v2)
                                break   

                        if TxMatch(o, i, """    
                            long_$4 = Loc_long_$9;
                            if ( long_$4 < 0) {
                            long_$4 += PyList_GET_SIZE($5);
                            }
                            if ( PyList_SetItem ( $5 , long_$4 , $6 ) == -1) goto label_$0;
                            """, v2) and ' ' not in v2[9]:
                                TxRepl(o, i, """
                                    if ( Loc_long_$9 < 0) {
                                    if ( PyList_SetItem ( $5 , Loc_long_$9 + PyList_GET_SIZE($5) , $6 ) == -1) goto label_$0;
                                    } else {
                                    if ( PyList_SetItem ( $5 , Loc_long_$9 , $6 ) == -1) goto label_$0;
                                    }
                                    """, v2)
                                break
    
                        if TxMatch(o, i, """    
                            long_$4 =  long_$9 ;
                            if ( long_$4 < 0) {
                            long_$4 += PyList_GET_SIZE($5);
                            }
                            if ( PyList_SetItem ( $5 , long_$4 , $6 ) == -1) goto label_$0;
                            """, v2) and ' ' not in v2[9]:
                                TxRepl(o, i, """
                                    if ( long_$9 < 0) {
                                    if ( PyList_SetItem ( $5 , long_$9 + PyList_GET_SIZE($5) , $6 ) == -1) goto label_$0;
                                    } else {
                                    if ( PyList_SetItem ( $5 , long_$9 , $6 ) == -1) goto label_$0;
                                    }
                                    """, v2)
                                break
                        if TxMatch(o, i, """    
                            long_$4 = Loc_long_$9;
                            if ( long_$4 < 0) {
                            long_$5 = PyList_GET_SIZE($15);
                            long_$4 = long_$4 + long_$5;
                            }
                            if ( PyList_SetSlice ( $15 , long_$4 , long_$4 + $17 , temp[$0] ) == -1) goto label_$10;
                            CLEARTEMP($0);
                            """, v2) and ' ' not in v2[9]:
                                TxRepl(o, i, """
                                    if ( Loc_long_$9 < 0) {
                                    if ( PyList_SetSlice ( $15 , Loc_long_$9 + PyList_GET_SIZE($15) , Loc_long_$9 + PyList_GET_SIZE($15) + $17 , temp[$0] ) == -1) goto label_$10;
                                    } else {
                                    if ( PyList_SetSlice ( $15 , Loc_long_$9 , Loc_long_$9 + $17 , temp[$0] ) == -1) goto label_$10;
                                    }
                                    CLEARTEMP($0);
                                    """, v2)
                                break          
                                   
                        if TxMatch(o, i, """    
                            long_$4 = Glob_long_$9;
                            if ( long_$4 < 0) {
                            long_$4 += PyList_GET_SIZE($5);
                            }
                            if ( PyList_SetItem ( $5 , long_$4 , $6 ) == -1) goto label_$0;
                            """, v2) and ' ' not in v2[9]:
                                TxRepl(o, i, """
                                    if ( Glob_long_$9 < 0) {
                                    if ( PyList_SetItem ( $5 , Glob_long_$9 + PyList_GET_SIZE($5) , $6 ) == -1) goto label_$0;
                                    } else {
                                    if ( PyList_SetItem ( $5 , Glob_long_$9 , $6 ) == -1) goto label_$0;
                                    }
                                    """, v2)
                                break
                        if TxMatch(o, i, """   
                            long_$4 = ( Loc_long_$9 );
                            if ( long_$4 < 0) {
                            long_$4 += PyList_GET_SIZE($5);
                            }
                            if ((temp[$1] = PyList_GetItem ( $5 , long_$4 )) == 0) goto label_$0;                        
                            """, v2) and ' ' not in v2[9]:
                                TxRepl(o, i, """
                                    if ((temp[$1] = PyList_GetItem ( $5 , PyIF( Loc_long_$9 >= 0 , Loc_long_$9 , Loc_long_$9 + PyList_GET_SIZE($5) ) )) == 0) goto label_$0;   
                                    """, v2)
                                break
                        if TxMatch(o, i, """   
                            long_$4 = PyInt_AS_LONG ( $9 );
                            if ( long_$4 < 0) {
                            long_$4 += PyList_GET_SIZE($5);
                            }
                            if ((temp[$1] = PyList_GetItem ( $5 , long_$4 )) == 0) goto label_$0;                        
                            """, v2) and ' ' not in v2[9]:
                                TxRepl(o, i, """
                                    if ((temp[$1] = PyList_GetItem ( $5 , long_$4 = PyIF( PyInt_AS_LONG ( $9 ) >= 0 , PyInt_AS_LONG ( $9 ) , PyInt_AS_LONG ( $9 ) + PyList_GET_SIZE($5) ) )) == 0) goto label_$0;   
                                    """, v2)
                                break        
    
                        if TxMatch(o, i, """   
                            long_$4 = PyInt_AS_LONG ( $9 );
                            if ( long_$4 < 0) {
                            long_$4 += PyTuple_GET_SIZE($5);
                            }
                            if ((temp[$1] = PyTuple_GetItem ( $5 , long_$4 )) == 0) goto label_$0;                        
                            """, v2) and ' ' not in v2[9]:
                                TxRepl(o, i, """
                                    if ((temp[$1] = PyTuple_GetItem ( $5 , PyIF( PyInt_AS_LONG ( $9 ) >= 0 , PyInt_AS_LONG ( $9 ) , PyInt_AS_LONG ( $9 ) + PyTuple_GET_SIZE($5) ) )) == 0) goto label_$0;   
                                    """, v2)
                                break  
                            
                        if TxMatch(o, i, """   
                            long_$4 = PyInt_AS_LONG ( $9 );
                            if ( long_$4 < 0) {
                            long_$4 += PyList_GET_SIZE($5);
                            }
                            if ( PyList_SetItem ( $5 , long_$4 , $19 ) == -1) goto label_$0;                      
                            """, v2) and ' ' not in v2[9]:
                                TxRepl(o, i, """
                                    if ( PyList_SetItem ( $5 , PyIF( PyInt_AS_LONG ( $9 ) >= 0 , PyInt_AS_LONG ( $9 ) , PyInt_AS_LONG ( $9 ) + PyList_GET_SIZE($5) ) , $19 ) == -1) goto label_$0;    
                                    """, v2)
                                break    
                            
                        if TxMatch(o, i, """   
                            long_$4 = ( (Py_ssize_t_$9 + $19) );
                            if ( long_$4 < 0) {
                            long_$4 += PyList_GET_SIZE($5);
                            }
                            if ((temp[$1] = PyList_GetItem ( $5 , long_$4 )) == 0) goto label_$0;                        
                            """, v2) and ' ' not in v2[9] and type(v2[19]) is str and v2[19].isdigit():
                                TxRepl(o, i, """
                                    if ((temp[$1] = PyList_GetItem ( $5 , PyIF( Py_ssize_t_$9 >= -$19 , Py_ssize_t_$9 + $19 , Py_ssize_t_$9 + $19 + PyList_GET_SIZE($5) ) )) == 0) goto label_$0;   
                                    """, v2)
                                break                        
                        if TxMatch(o, i, """   
                            long_$4 = ( (Loc_long_$9 + $19) );
                            if ( long_$4 < 0) {
                            long_$4 += PyList_GET_SIZE($5);
                            }
                            if ((temp[$1] = PyList_GetItem ( $5 , long_$4 )) == 0) goto label_$0;                        
                            """, v2) and ' ' not in v2[9] and type(v2[19]) is str and v2[19].isdigit():
                                TxRepl(o, i, """
                                    if ((temp[$1] = PyList_GetItem ( $5 , PyIF( Loc_long_$9 >= -$19 , Loc_long_$9 + $19 , Loc_long_$9 + $19 + PyList_GET_SIZE($5) ) )) == 0) goto label_$0;   
                                    """, v2)
                                break            
                        if TxMatch(o, i, """   
                            long_$2 = PyInt_AS_LONG ( $3 );
                            if (((long_$7 = long_$2 + $4), !((long_$7^long_$2) < 0 && (long_$7^$4) < 0))) {
                            """, v2):
                                long_ = 'long_' + v2[2]
                                if long_ not in o[i+2] and long_ not in o[i+3] and long_ not in o[i+4]:
                                    TxRepl(o, i, """
                                        if (((long_$7 = PyInt_AS_LONG ( $3 ) + $4), !((long_$7^PyInt_AS_LONG ( $3 )) < 0 && (long_$7^$4) < 0))) {
                                        """, v2)
                                    break   
                        if TxMatch(o, i, """   
                            long_$7 = ( $6 );
                            if ( $9 $3 long_$7 ) {
                            """, v2) and ' ' not in v2[9] and v2[3] in ('==', '!=', '>', '<', '>=', '<='):
                                TxRepl(o, i, """
                                    if ( $9 $3 ( $6 ) ) {
                                    """, v2)
                                break                                                    
                                                                                       

                    if o[i+1].startswith('if (') and o[i+1].endswith(';'):
                        if TxMatch(o, i, """
                            long_$3 = 0;
                            if ((temp[$1] = PyList_GetItem ( $5 , long_$3 )) == 0) goto label_$0;
                            Py_INCREF(temp[$1]);
                            long_$4 = long_$3 + 1;
                            if ( PyList_SetSlice ( $5 , long_$3 , long_$4 , NULL ) == -1) goto label_$0;
                            """, v2):
                                TxRepl(o, i, """
                                    if ((temp[$1] = PyList_GetItem ( $5 , 0 )) == 0) goto label_$0;
                                    Py_INCREF(temp[$1]);
                                    if ( PyList_SetSlice ( $5 , 0 , 1 , NULL ) == -1) goto label_$0;
                                    """, v2)
                                break    
                        if TxMatch(o, i, """    
                            long_$6 = ( Loc_long_$7 );
                            if ((temp[$2] = PyList_GetItem ( $3 , long_$6 )) == 0) goto label_$0;
                            """, v2):
                                TxRepl(o, i, """
                                    if ((temp[$2] = PyList_GetItem ( $3 , Loc_long_$7 )) == 0) goto label_$0;
                                    """, v2)
                                break                         
                        if TxMatch(o, i, """    
                            long_$6 = ( Loc_long_$7 );
                            if ((temp[$2] = PyTuple_GetItem ( $3 , long_$6 )) == 0) goto label_$0;
                            """, v2):
                                TxRepl(o, i, """
                                    if ((temp[$2] = PyTuple_GetItem ( $3 , Loc_long_$7 )) == 0) goto label_$0;
                                    """, v2)
                                break
                            
                        if TxMatch(o, i, """    
                            long_$2 = PyList_GET_SIZE($3);
                            if ( PyList_SetSlice ( $4 , $5 , long_$2 , $9 ) == -1) goto label_$10;
                            """, v2) and ' ' not in v2[2]:
                                TxRepl(o, i, """
                                    if ( PyList_SetSlice ( $4 , $5 , PyList_GET_SIZE($3) , $9 ) == -1) goto label_$10;
                                    """, v2)
                                break    
                    
                        if TxMatch(o, i, """    
                            long_$7 = $6 + $11;
                            if ( PyList_SetSlice ( $12 , $6 , long_$7 , $8 ) == -1) goto label_$10;
                            """, v2) and ' ' not in v2[7]:
                                TxRepl(o, i, """
                                    if ( PyList_SetSlice ( $12 , $6 , $6 + $11 , $8 ) == -1) goto label_$10;
                                    """, v2)
                                break 
                            
                        if TxMatch(o, i, """   
                            long_$3 = Loc_long_$1;
                            if ( PyList_SetSlice ( $2 , long_$3 , long_$3 + $5 , $6 ) == -1) goto label_$0;
                            """, v2):
                                TxRepl(o, i, """
                                    if ( PyList_SetSlice ( $2 , Loc_long_$1 , Loc_long_$1 + $5 , $6 ) == -1) goto label_$0;
                                    """, v2)
                                break  
    
    
                        if TxMatch(o, i, """   
                            long_$3 = (Loc_long_$1 + $11);
                            if ( PyList_SetItem ( $2 , long_$3 , $6 ) == -1) goto label_$0;
                            """, v2):
                                TxRepl(o, i, """
                                    if ( PyList_SetItem ( $2 , (Loc_long_$1 + $11) , $6 ) == -1) goto label_$0;
                                    """, v2)
                                break  
    
                        if TxMatch(o, i, """   
                            long_$3 = Loc_long_$1;
                            if ( PyList_SetItem ( $2 , long_$3 , $6 ) == -1) goto label_$0;
                            """, v2):
                                TxRepl(o, i, """
                                    if ( PyList_SetItem ( $2 , Loc_long_$1 , $6 ) == -1) goto label_$0;
                                    """, v2)
                                break  
    
                        if TxMatch(o, i, """   
                            long_$3 = PyInt_AS_LONG ( GETLOCAL($1) );
                            if ((temp[$0] = PyList_GetItem ( $4 , long_$3 )) == 0) goto label_$10;
                            """, v2):
                                TxRepl(o, i, """
                                    if ((temp[$0] = PyList_GetItem ( $4 , PyInt_AS_LONG ( GETLOCAL($1) ) )) == 0) goto label_$10;
                                    """, v2)
                                break  
    
                        if TxMatch(o, i, """   
                            long_$3 = ( (PyInt_AS_LONG ( GETLOCAL($1) ) + $11) );
                            if ((temp[$0] = PyList_GetItem ( $4 , long_$3 )) == 0) goto label_$10;
                            """, v2):
                                TxRepl(o, i, """
                                    if ((temp[$0] = PyList_GetItem ( $4 , (PyInt_AS_LONG ( GETLOCAL($1) ) + $11) )) == 0) goto label_$10;
                                    """, v2)
                                break  

                        if TxMatch(o, i, """   
                            long_$3 = ( (PyInt_AS_LONG ( GETLOCAL($1) ) - $11) );
                            if ((temp[$0] = PyList_GetItem ( $4 , long_$3 )) == 0) goto label_$10;
                            """, v2):
                                TxRepl(o, i, """
                                    if ((temp[$0] = PyList_GetItem ( $4 , (PyInt_AS_LONG ( GETLOCAL($1) ) - $11) )) == 0) goto label_$10;
                                    """, v2)
                                break  
    
                        if TxMatch(o, i, """   
                            long_$3 = PyInt_AS_LONG ( GETLOCAL($1) );
                            if ((temp[$0] = PyTuple_GetItem ( $4 , long_$3 )) == 0) goto label_$10;
                            """, v2):
                                TxRepl(o, i, """
                                    if ((temp[$0] = PyTuple_GetItem ( $4 , PyInt_AS_LONG ( GETLOCAL($1) ) )) == 0) goto label_$10;
                                    """, v2)
                                break         
                            
                        if TxMatch(o, i, """   
                            long_$3 = ( (Loc_long_$1 + $11) );
                            if ((temp[$0] = PyList_GetItem ( $4 , long_$3 )) == 0) goto label_$10;
                            """, v2):
                                TxRepl(o, i, """
                                    if ((temp[$0] = PyList_GetItem ( $4 , (Loc_long_$1 + $11) )) == 0) goto label_$10;
                                    """, v2)
                                break  
                            
                        if TxMatch(o, i, """   
                            long_$3 = ( (Loc_long_$1 - $11) );
                            if ((temp[$0] = PyList_GetItem ( $4 , long_$3 )) == 0) goto label_$10;
                            """, v2):
                                TxRepl(o, i, """
                                    if ((temp[$0] = PyList_GetItem ( $4 , (Loc_long_$1 - $11) )) == 0) goto label_$10;
                                    """, v2)
                                break  

        
                    if TxMatch(o, i, "long_$2 = ( long_$5 );", v2) and ' ' not in v2[5]:
                            TxRepl(o, i, "long_$2 = long_$5;", v2)
                            break  
        

                    if TxMatch(o, i, """$2 = PyInt_AS_LONG ( $1 );
                        $3 = 0 - $2;
                        temp[$4] = PyInt_FromLong ( $3 );""", v2):
                            TxRepl(o, i, ('temp[$4] = PyInt_FromLong ( - PyInt_AS_LONG ( $1 ) );',), v2)
                            break     
                                   

                    if TxMatch(o, i, 'long_$1 = long_$1;', v2):
                            TxRepl(o, i, (), v2)
                            break

                    if TxMatch(o, i, """    
                        long_$4 =  long_$4 ;
                        """, v2) and ' ' not in v2[4]:
                            TxRepl(o, i, """
                                """, v2)
                            break
                        

                                                                 
                elif oic == 'P' and oi.startswith('Py_ssize_t_'):
                    if TxMatch(o, i, """
                        Py_ssize_t_$6 = Loc_long_$8;
                        for (Py_ssize_t_$7 = 0; Py_ssize_t_$7 < Py_ssize_t_$6; Py_ssize_t_$7 ++) {
                        """, v2):   
                        TxRepl(o, i, """
                            for (Py_ssize_t_$7 = 0; Py_ssize_t_$7 < Loc_long_$8; Py_ssize_t_$7 ++) {
                            """, v2)   
                        break                  
            
                elif oic == 'C' and oi.startswith('CLEARTEMP'):
                    if i+1 < len(o):
                        if oi == o[i+1]:
                            del o[i+1]
                            break         
                        if o[i+1].startswith('temp[') and TxMatch(o, i, """CLEARTEMP($0);
                                                                  temp[$0] = 0;""", v2):
                            del o[i+1]
                            break 
                    if i+3 < len(o) and o[i+3].endswith('] = 0;') and TxMatch(o, i, """CLEARTEMP($0);
                        temp[$1] = PyInt_FromLong ( $9 );
                        temp[$0] = temp[$1];
                        temp[$1] = 0;""", v2):
                            TxRepl(o, i, """CLEARTEMP($0);
                                temp[$0] = PyInt_FromLong ( $9 );""", v2)
                            break   
                    if i+2 < len(o) and TxMatch(o, i, """
                        CLEARTEMP($0);
                        Py_INCREF(temp[$1]);
                        CLEARTEMP($0);""", v2) and v2[1] != v2[0]:
                            TxRepl(o, i, """
                                CLEARTEMP($0);
                                Py_INCREF(temp[$1]);""", v2)
                            break                  
                if  i < (len(o) - 1) and ' = ' in oi and o[i+1].startswith("temp["):
                    pass
                elif oic == '}' and i < (len(o) - 1) and oi == '} else' and o[i+1] == '{':
                        o[i] = '} else {'
                        del o[i+1]
                        break 
                                       
                elif oic == 'f' and oi == 'for (;;) {' and TxMatch(o, i, """for (;;) {
                    int_$0 = $1;
                    if (!( int_$0 )) break;'""", v2):
                       TxRepl(o, i, """while ($1) {'""", v2)
                       v2 = {}
                       if TxMatch(o, i, """while (((GETLOCAL($1) == Py_None))) {""", v2): 
                           TxRepl(o, i, """while (GETLOCAL($1) == Py_None) {""", v2)   
                       elif TxMatch(o, i, """while (((Loc_long_$1 == $2))) {""", v2) and type(v2[2]) is str and v2[2].isdigit() and ' ' not in v2[1] and ' ' not in v2[2]: 
                           TxRepl(o, len(o)-6, """while (Loc_long_$1 == $2) {""", v2)                                                    
                       break  

                if 'PyInt_AsSsize_t' in oi:
                    pass
            else:
                if oi.endswith(';'):
                    if tune_if_dotcomma(o, i):
                        break
                elif oi.endswith('{'): 
                    if tune_if_sk(o, i):
                        break
        
                    if oi == 'if (1) {' and o[i+2] == '} else {' and o[i+4] == '}' and \
                       '{' not in o[i+1] and '{' not in o[i+3] and \
                       '}' not in o[i+1] and '}' not in o[i+3] and \
                       ':' not in o[i+1] and ':' not in o[i+3]:
                            o[i:i+5] = [o[i+1]] 
                            break      
                if '= long_' in oi:
                    pass

            if len(o) > i + 1 and \
                       (oi.startswith('goto ') or oi.startswith('return ') or \
                        oi.startswith('break;') or oi.startswith('continue;')):
                    i2 = len(o) + 1
                    for i2 in range(i+1, len(o) + 1):
                        if i2 < len(o) and (o[i2].startswith('/*') or o[i2] == ''):
                            continue
                        break
                    if i2 < len(o):
                        o_i2 = o[i2]
                        assert type(o_i2) is str
                        if o_i2.startswith('PyErr_Restore'):
                            del o[i2]
                            break
                        if o_i2.startswith('_PyEval_reset_exc_info'):
                            del o[i2]
                            break
                        if o_i2.startswith('Py_INCREF(') and TxMatch(o, i2, """
                            Py_INCREF($1);""", v2):
                                TxRepl(o, i2, '', v2)
                                break  
                        if o_i2.startswith('Py_CLEAR(') and TxMatch(o, i2, """
                            Py_CLEAR($1);""", v2):
                                TxRepl(o, i2, '', v2)
                                break  
                        if o_i2.startswith('CLEARTEMP(') and TxMatch(o, i2, """
                            CLEARTEMP($1);""", v2):
                                TxRepl(o, i2, '', v2)
                                break  
                        if o_i2.startswith('if (ping_threading () == -1) goto ') and TxMatch(o, i2, """
                            if (ping_threading () == -1) goto label_$1;""", v2):
                                TxRepl(o, i2, '', v2)
                                break  
                        if o_i2.startswith('return ') and TxMatch(o, i2, """
                            return $1;""", v2):
                                TxRepl(o, i2, '', v2)
                                break  
                        if o[i2] == 'continue;' and TxMatch(o, i2, """
                            continue;""", v2):
                                TxRepl(o, i2, '', v2)
                                break  
                        if o_i2.startswith('if (tstate->frame->f_exc_type != NULL) {') and TxMatch(o, i2, """                    
                            if (tstate->frame->f_exc_type != NULL) {
                                _PyEval_reset_exc_info ( f->f_tstate );
                            }""", v2): 
                                TxRepl(o, i2, '', v2)
                                break   
                        if o_i2.startswith('Py_LeaveRecursiveCall();') and TxMatch(o, i2, """Py_LeaveRecursiveCall();""", v2): 
                                TxRepl(o, i2, '', v2)
                                break 
                        if o_i2.startswith('tstate->frame = f->f_back;') and TxMatch(o, i2, """tstate->frame = f->f_back;""", v2): 
                                TxRepl(o, i2, '', v2)
                                break 
                        if o_i2.startswith('if ((temp') and TxMatch(o, i2, """if ((temp[$1] = $2) == 0) goto label_$3;""", v2):
                                TxRepl(o, i2, '', v2)
                                break 
                        if o_i2.startswith('if (calculated_const_') and TxMatch(o, i2, """if (calculated_const_$2 == 0) goto label_$3;""", v2):
                                TxRepl(o, i2, '', v2)
                                break 
                        if o_i2.startswith('if (') and TxMatch(o, i2, """if ($2 == -1) goto label_$3;""", v2):
                                TxRepl(o, i2, '', v2)
                                break 
                        if o_i2.startswith('temp[') and TxMatch(o, i2, """temp[$1] = $2;""", v2):
                                TxRepl(o, i2, '', v2)
                                break 
                        if o_i2.startswith('int_') and TxMatch(o, i2, """int_$1 = $2;""", v2):
                                TxRepl(o, i2, '', v2)
                                break 
    if True:
        for i in range(len(o)):
            oi = o[i]
            assert type(oi) is str
            ## if oi.startswith('SETLOCAL ( '):
                ## v2 = {}
                ## if 'temp[' in oi and oi.endswith('] );'):
                    ## if TxMatch(o, i, """SETLOCAL ( $0 , temp[$1] );""", v2):
                        ## TxRepl(o, i, """SETLOCAL2 ( $0 , temp[$1] );""", v2) 
                        ## continue
                ## if 'PyTuple_GET_ITEM' in oi:
                    ## if TxMatch(o, i, """SETLOCAL ( $0 , PyTuple_GET_ITEM ( $1) );""", v2):
                        ## TxRepl(o, i, """SETLOCAL2 ( $0 , PyTuple_GET_ITEM ( $1) );""", v2) 
                        ## continue
                ## if 'PyList_GET_ITEM' in oi:
                    ## if TxMatch(o, i, """SETLOCAL ( $0 , PyList_GET_ITEM ( $1) );""", v2):
                        ## TxRepl(o, i, """SETLOCAL2 ( $0 , PyList_GET_ITEM ( $1) );""", v2) 
                        ## continue
            if oi.startswith('SETSTATIC ( '):
                v2 = {}
                if 'temp[' in oi and oi.endswith('] );'):
                    if TxMatch(o, i, """SETSTATIC ( $0 , temp[$1] );""", v2):
                        TxRepl(o, i, """SETSTATIC2 ( $0 , temp[$1] );""", v2) 
                elif 'PyTuple_GET_ITEM' in oi:
                    if TxMatch(o, i, """SETSTATIC ( $0 , PyTuple_GET_ITEM ( $1) );""", v2):
                        TxRepl(o, i, """SETSTATIC2 ( $0 , PyTuple_GET_ITEM ( $1) );""", v2)             
    for i in range(len(o)-2):
        beg = None
        oi = o[i]
        assert type(oi) is str
        ## if i < (len(o) - 3) and (' = PyTuple_GET_ITEM' in oi or ' = PyTuple_GET_ITEM' in oi) and \
          ## 'INCREF' in o[i+1] and not ('PyObject_GetIter' in o[i+2]) and not o[i+2].startswith('}') and \
          ## 'INCREF' not in o[i+2] and not o[i+2].startswith('Py_CLEAR(GETLOCAL(') and \
          ## 'PyTuple_New' not in o[i+2]  and 'PyList_New' not in o[i+2]:
            ## pprint(o[i:i+10])
        if not oi.startswith('/*'):
            v2 = {}
            if 'PyInt_From' in oi and not oi.startswith('GETLOCAL(') and 'AS_LONG ( te' in o[i+1]:
                beg = max(i-5, 0)
            elif 'PyInt_From' in oi and not oi.startswith('GETLOCAL(') and o[i+1].startswith('CLEARTEMP(') and 'AS_LONG ( te' in o[i+2]:
                beg = max(i-5, 0)
            elif 'PyInt_From' in oi and not oi.startswith('GETLOCAL(') and o[i+2].startswith('CLEARTEMP(') and 'AS_LONG ( te' in o[i+1]:
                beg = max(i-5, 0)  
                v2 = {}
            elif 'PyFloat_From' in oi and not oi.startswith('GETLOCAL(') and 'AS_DOUBLE ( te' in o[i+1]:
                beg = max(i-5, 0)
            elif 'PyFloat_From' in oi and not oi.startswith('GETLOCAL(') and o[i+1].startswith('CLEARTEMP(') and 'AS_DOUBLE ( te' in o[i+2]:
                beg = max(i-5, 0)
            elif 'PyFloat_From' in oi and not oi.startswith('GETLOCAL(') and o[i+2].startswith('CLEARTEMP(') and 'AS_DOUBLE ( te' in o[i+1]:
                beg = max(i-5, 0)  
                v2 = {}
            elif 'PyFloat_From' in oi and not oi.startswith('GETLOCAL(') and 'AsDouble ( te' in o[i+1]:
                beg = max(i-5, 0)
            elif 'PyFloat_From' in oi and not oi.startswith('GETLOCAL(') and o[i+1].startswith('CLEARTEMP(') and 'AsDouble ( te' in o[i+2]:
                beg = max(i-5, 0)
            elif 'PyFloat_From' in oi and not oi.startswith('GETLOCAL(') and o[i+2].startswith('CLEARTEMP(') and 'AsDouble ( te' in o[i+1]:
                beg = max(i-5, 0)  
                v2 = {}
            elif beg is None and oi.startswith('if (') and oi.endswith(') {') and TxMatch(o, i, """
                                       if ($1) {
                                       >1
                                       temp[$2] = $3
                                       <2
                                       } else {
                                       >3
                                       }
                                       <9
                                       if ($11) {
                                       """, v2) and ('temp[' + v2[2] + ']') in v2[11]:
                beg = i
            elif beg is None and oi.startswith('if (') and oi.endswith(') {') and TxMatch(o, i, """
                                       if ($1) {
                                       >1
                                       temp[$2] = $3
                                       <2
                                       } else if ($9) {
                                       >3
                                       } else {
                                       >5
                                       }
                                       <9
                                       if ($11) {
                                       """, v2) and ('temp[' + v2[2] + ']') in v2[11]:
                beg = i
   
            elif oi.startswith('long_') and TxMatch(o, i, """
                long_$4 = $5;
                temp[$14] = PyInt_FromLong ( long_$4 );
                """, v2):    
                    pprint(o[i-5:i+5])
                    pp(436346546)
                    beg = i
    

def tune_let_temp(o, i):
    assert type(i) is int and i >= 0
    v2 = {}
    oi = o[i]
    assert type(oi) is str
    if oi.endswith('];') and oi[+5:-2].isdigit():
        del o[i]
        return True
    if '*_PyObject_GetDictPtr' in oi:
        pass        
    if 'PyDict_GetItem' in oi:
        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem(_$3_dict, $1);
            Py_INCREF(temp[$0]);
            if (_$4_dict) {
            if (PyDict_SetItem(_$4_dict, $2, temp[$0]) == -1) goto label_$10;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL($4) , $2 , temp[$0] ) == -1) goto label_$10;
            }
            CLEARTEMP($0);        
            """ , v2):
                TxRepl(o, i, """
                    if (_$4_dict) {
                    if (PyDict_SetItem(_$4_dict, $2, PyDict_GetItem(_$3_dict, $1)) == -1) goto label_$10;
                    } else {
                    temp[$0] = PyDict_GetItem(_$3_dict, $1);
                    Py_INCREF(temp[$0]);
                    if ( PyObject_SetAttr ( GETLOCAL($4) , $2 , temp[$0] ) == -1) goto label_$10;
                    CLEARTEMP($0);        
                    }
                       """, v2)
                return True
        
        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem$15($11,$12);
            if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$10;
            temp[$0] = 0;        
            """ , v2):
                TxRepl(o, i, """
                    if ((int_$1 = PyObject_IsTrue ( PyDict_GetItem$15($11,$12) )) == -1) goto label_$10;
                       """, v2)
                return True

        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem$15($11,$12);
            if ((int_$1 = PyObject_Not ( temp[$0] )) == -1) goto label_$10;
            temp[$0] = 0;        
            """ , v2):
                TxRepl(o, i, """
                    if ((int_$1 = PyObject_Not ( PyDict_GetItem$15($11,$12) )) == -1) goto label_$10;
                       """, v2)
                return True
        
        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem($3, $4);
            Py_INCREF(temp[$0]);
            Py_ssize_t_$2 = PyInt_AsSsize_t ( temp[$0] );
            CLEARTEMP($0);
            """ , v2):
                TxRepl(o, i, """
                    Py_ssize_t_$2 = PyInt_AsSsize_t ( PyDict_GetItem($3, $4) );
                       """, v2)
                return True
        
        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem($3, $4);
            Py_INCREF(temp[$0]);
            if ((temp[$1] = PyList_GetItem ( temp[$0] , $5 )) == 0) goto label_$2;
            Py_INCREF(temp[$1]);
            CLEARTEMP($0);
            """ , v2) and ('temp[%s]' % v2[0]) not in v2[5]:
                TxRepl(o, i, """
                    if ((temp[$1] = PyList_GetItem ( PyDict_GetItem($3, $4) , $5 )) == 0) goto label_$2;
                    Py_INCREF(temp[$1]);
                       """, v2)
                return True
        
        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem($9, $4);
            Py_INCREF(temp[$0]);
            temp[$1] = PyDict_GetItem($11, $5);
            Py_INCREF(temp[$1]);
            if ((temp[$2] = _Direct_$7 ( temp[$0] , temp[$1] )) == 0) goto label_$10;
            CLEARTEMP($0);
            CLEARTEMP($1);
            if (PyDict_SetItem($12, $6, temp[$2]) == -1) goto label_$10;
            CLEARTEMP($2);        
            """ , v2):
                TxRepl(o, i, """
                    if ((temp[$2] = _Direct_$7 ( PyDict_GetItem($9, $4) , PyDict_GetItem($11, $5) )) == 0) goto label_$10;
                    if (PyDict_SetItem($12, $6, temp[$2]) == -1) goto label_$10;
                    CLEARTEMP($2);        
                       """, v2)
                return True
        if TxMatch(o, i, """
            temp[$0] = PyDict_GetItem($1, $2);
            temp[$0] = PyDict_GetItem($1, $2);        
            """ , v2):
                TxRepl(o, i, """
                    temp[$0] = PyDict_GetItem($1, $2);        
                       """, v2)
                return True
        
    if 'PyInt_FromLong' in oi:
        if let_temp_PyInt_FromLong(o, i):
            return True

    if 'PyFloat_FromDouble' in oi:
        if TxMatch(o, i, """temp[$1] = PyFloat_FromDouble ($3);
            if (PyFloat_CheckExact( temp[$0] )) {
            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $5 PyFloat_AS_DOUBLE(temp[$1]));
            } else {
            if ((temp[$2] = PyNumber_$6 ( temp[$0] , temp[$1] )) == 0) goto $4;
            }
            CLEARTEMP($0);
            CLEARTEMP($1);""", v2):
                TxRepl(o, i, """if (PyFloat_CheckExact( temp[$0] )) {
                    temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $5 $3);
                    } else {
                    temp[$1] = PyFloat_FromDouble ($3);
                    if ((temp[$2] = PyNumber_$6 ( temp[$0] , temp[$1] )) == 0) goto $4;
                    CLEARTEMP($1);
                    }
                    CLEARTEMP($0);""", v2)
                return True 
        if TxMatch(o, i, """            
            temp[$0] = PyFloat_FromDouble ($5);
            if (PyFloat_CheckExact( $6 )) {
            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($6) $7 PyFloat_AS_DOUBLE(temp[$0]));
            } else {
            >0
            }
            CLEARTEMP($0);            
            """, v2) and not 'temp[' in v2[7]:
                TxRepl(o, i, """
                    if (PyFloat_CheckExact( $6 )) {
                    temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($6) $7 ($5));
                    } else {
                    temp[$0] = PyFloat_FromDouble ($5);
                    >0
                    CLEARTEMP($0);
                    }
                       """, v2)
                return True 
                        
    if 'PyBool_FromLong' in oi:
      
        if TxMatch(o, i, """
            temp[$0] = PyBool_FromLong($11);
            if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$10;
            if ( int_$1 ) {
            """, v2):
                TxRepl(o, i, """
                    temp[$0] = PyBool_FromLong($11);
                    int_$1 = $11;
                    if ( int_$1 ) {
                                """, v2)        
                return True    
        if TxMatch(o, i, """
            temp[$0] = PyBool_FromLong($11);
            if ((int_$1 = PyObject_Not ( temp[$0] )) == -1) goto label_$10;
            if ( int_$1 ) {
            """, v2):
                TxRepl(o, i, """
                    temp[$0] = PyBool_FromLong($11);
                    int_$1 = !$11;
                    if ( int_$1 ) {
                                """, v2)        
                return True              

            
        if TxMatch(o, i, """temp[$0] = PyBool_FromLong($2);
            if (($1 = PyObject_Not ( temp[$0] )) == -1) goto $4;
            CLEARTEMP($0);""", v2):
                v2[2] = v2[2].strip()
                TxRepl(o, i, """$1 = ! $2;""", v2)
                return True
        if TxMatch(o, i, """temp[$0] = PyBool_FromLong(int_$1);
            int_$1 = PyObject_IsTrue ( temp[$0] );
            CLEARTEMP($0);""", v2):
                TxRepl(o, i, "", v2)
                return True
        if TxMatch(o, i, """temp[$0] = PyBool_FromLong($1);
            $2 = PyObject_IsTrue(temp[$0]);
            CLEARTEMP($0);""", v2):
                v2[1] = v2[1].strip()
                TxRepl(o, i, """$2 = $1;""", v2)                
                return True  
            
        if TxMatch(o, i, """temp[$0] = PyBool_FromLong(int_$1);
                    CLEARTEMP($0);""", v2):
                TxRepl(o, i, "", v2)                
                return True  
        
    if 'PyString_FromStringAndSize' in oi:    
        if TxMatch(o, i, """
            temp[$0] = PyString_FromStringAndSize ( PyString_AS_STRING ( $2 ) + int_$3 , 1 );
            $4 = *PyString_AS_STRING ( temp[$0] );
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, "$4 = PyString_AS_STRING ( $2 )[int_$3];" , v2)
                return True
        if TxMatch(o, i, """temp[$0] = PyString_FromStringAndSize($2, 1);
            $9 = *PyString_AS_STRING ( temp[$0] );
            CLEARTEMP($0);""", v2):
                TxRepl(o, i, """$9 = *($2);""", v2)
                return True   
                        
        if TxMatch(o, i, """
            temp[$0] = PyString_FromStringAndSize((char *)&$1, 1);
            long_$2 = (long)((unsigned char)*PyString_AS_STRING ( temp[$0] ));
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    long_$2 = (long)$1;
                    """, v2)
                return True   
        
        if TxMatch(o, i, """            
            temp[$0] = PyString_FromStringAndSize((char *)&$2, 1);
            int_$5 = $3*PyString_AS_STRING ( temp[$0] )$4;
            CLEARTEMP($0);""", v2):
                TxRepl(o, i, """
                    int_$5 = $3($2)$4;
                    """, v2)
                return True  
        if TxMatch(o, i, """              
            temp[$0] = PyString_FromStringAndSize($5, 1);
            long_$4 = (long)((unsigned char)*PyString_AS_STRING ( temp[$0] ));
            CLEARTEMP($0);            
            """, v2):
                TxRepl(o, i, """
                    long_$4 = (long)((unsigned char)*($5));
                    """, v2)
                return True 
        if TxMatch(o, i, """              
            temp[$0] = PyString_FromStringAndSize($5, 1);
            long_$4 = (long)((unsigned char)*PyString_AS_STRING ( temp[$0] ));
            CLEARTEMP($0);            
            """, v2):
                TxRepl(o, i, """
                    long_$4 = (long)((unsigned char)*($5));
                    """, v2)
                return True 
    if '] = GETATTR(' in oi:
        if TxMatch(o, i, """
            temp[$0] = GETATTR($5);
            Py_INCREF(temp[$0]);
            if ( PyInt_CheckExact(temp[$0]) ) {
            int_$1 = PyInt_AS_LONG(temp[$0]) == $3;
            } else {
            if ((int_$1 = PyObject_RichCompareBool ( temp[$0] , $4 , Py_EQ )) == -1) goto label_$0;
            }
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    if ( PyInt_CheckExact(GETATTR($5)) ) {
                    int_$1 = PyInt_AS_LONG(GETATTR($5)) == $3;
                    } else {
                    if ((int_$1 = PyObject_RichCompareBool ( GETATTR($5) , $4 , Py_EQ )) == -1) goto label_$0;
                    }
                    """, v2)
                return True   
        if TxMatch(o, i, """
            temp[$0] = GETATTR($3);
            Py_INCREF(temp[$0]);
            temp[$1] = GETATTR($5);
            Py_INCREF(temp[$1]);
            if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , $11 )) == -1) goto label_$10;
            CLEARTEMP($0);
            CLEARTEMP($1);            
            """, v2):
                TxRepl(o, i, """
                    if ((int_$6 = PyObject_RichCompareBool ( GETATTR($3) , GETATTR($5) , $11 )) == -1) goto label_$10;
                    """, v2)
                return True   
            
        if TxMatch(o, i, """
            temp[$1] = GETATTR($6);
            Py_INCREF(temp[$1]);
            if ((int_$3 = PyObject_Not( temp[$1] )) == -1) goto label_$0;
            CLEARTEMP($1);
            """, v2):
                TxRepl(o, i, """
                    if ((int_$3 = PyObject_Not( GETATTR($6) )) == -1) goto label_$0;
                    """, v2)
                return True   
        if TxMatch(o, i, """
            temp[$1] = GETATTR($6);
            Py_INCREF(temp[$1]);
            int_$3 = (temp[$1] == $12);
            CLEARTEMP($1);
            """, v2):
                TxRepl(o, i, """
                    int_$3 = (GETATTR($6) == $12);
                    """, v2)
                return True   
        if TxMatch(o, i, """
            temp[$1] = GETATTR($6);
            Py_INCREF(temp[$1]);
            SETATTR($11,$12,$15,temp[$0]);
            CLEARTEMP($1);
            """, v2):
                TxRepl(o, i, """
                    SETATTR($11,$12,$15,GETATTR($6));
                    """, v2)
                return True      
        if TxMatch(o, i, """
            temp[$0] = GETATTR($3);
            Py_INCREF(temp[$0]);
            LETLOCAL ( $5 , temp[$0] );
            temp[$0] = 0;                            
            """, v2):
                TxRepl(o, i, """
                    GETLOCAL($5) = GETATTR($3);
                    Py_INCREF(GETLOCAL($5));
                    """, v2)
                return True      
        if TxMatch(o, i, """
            temp[$0] = GETATTR($16, calculated_const_$18, $17);
            Py_INCREF(temp[$0]);
            if (PyInt_CheckExact(temp[$0]) && PyInt_AS_LONG(temp[$0]) <= $11) {
            temp[$1] = PyInt_FromLong ( PyInt_AS_LONG(temp[$0]) $12 );
            } else {
            if ((temp[$1] = PyNumber_$14( temp[$0] , $15 )) == 0) goto label_$10;
            }
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    temp[$0] = GETATTR($16, calculated_const_$18, $17);
                    if (PyInt_CheckExact(temp[$0]) && PyInt_AS_LONG(temp[$0]) <= $11) {
                    temp[$1] = PyInt_FromLong ( PyInt_AS_LONG(temp[$0]) $12 );
                    temp[$0] = 0;
                    } else {
                    Py_INCREF(temp[$0]);
                    if ((temp[$1] = PyNumber_$14( temp[$0] , $15 )) == 0) goto label_$10;
                    CLEARTEMP($0);
                    }
                    """, v2)                        
                return True 
        if TxMatch(o, i, """
            temp[$0] = GETATTR($6);
            Py_INCREF(temp[$0]);
            if ((int_$1 = PyObject_IsTrue( temp[$0] )) == -1) goto label_$10;
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    if ((int_$1 = PyObject_IsTrue( GETATTR($6) )) == -1) goto label_$10;
                    """, v2)                        
                return True 
        if TxMatch(o, i, """
            temp[$0] = GETATTR($6);
            Py_INCREF(temp[$0]);
            if ((int_$1 = PyDict_Contains ( temp[$0] , $2 )) == -1) goto label_$10;
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    if ((int_$1 = PyDict_Contains ( GETATTR($6) , $2 )) == -1) goto label_$10;
                    """, v2)                        
                return True 
        if TxMatch(o, i, """
            temp[$0] = GETATTR($6);
            Py_INCREF(temp[$0]);
            if ((int_$1 = PyDict_Contains ( $2 , temp[$0] )) == -1) goto label_$10;
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    if ((int_$1 = PyDict_Contains ( $2 , GETATTR($6) )) == -1) goto label_$10;
                    """, v2)                        
                return True 
        if TxMatch(o, i, """            
            temp[$0] = GETATTR($6);
            Py_INCREF(temp[$0]);
            if ((temp[$1] = PyDict_GetItem ( temp[$0] , $2 )) == 0) goto label_$10;
            Py_INCREF(temp[$1]);
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    if ((temp[$1] = PyDict_GetItem ( GETATTR($6) , $2 )) == 0) goto label_$10;
                    Py_INCREF(temp[$1]);
                    """, v2)                        
                return True 
        if TxMatch(o, i, """            
            temp[$0] = GETATTR($6);
            Py_INCREF(temp[$0]);
            if ((temp[$1] = PyDict_GetItem ( $2 , temp[$0] )) == 0) goto label_$10;
            Py_INCREF(temp[$1]);
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    if ((temp[$1] = PyDict_GetItem ( $2 , GETATTR($6) )) == 0) goto label_$10;
                    Py_INCREF(temp[$1]);
                    """, v2)                        
                return True 
        if TxMatch(o, i, """            
            temp[$0] = GETATTR($6);
            Py_INCREF(temp[$0]);
            int_$1 = (PyDict_Size( temp[$0] ) $3);
            CLEARTEMP($0);                
            """, v2) and 'temp[' not in v2[3]:
                TxRepl(o, i, """
                    int_$1 = (PyDict_Size( GETATTR($6) ) $3);
                    """, v2)                        
                return True 
        if TxMatch(o, i, """            
            temp[$0] = GETATTR($6);
            Py_INCREF(temp[$0]);
            int_$1 = (PyTuple_GET_SIZE( temp[$0] ) $3);
            CLEARTEMP($0); 
            """, v2) and 'temp[' not in v2[3]:
                TxRepl(o, i, """
                    int_$1 = (PyTuple_GET_SIZE( GETATTR($6) ) $3);
                    """, v2)                        
                return True  
        if TxMatch(o, i, """            
            temp[$0] = GETATTR($6);
            Py_INCREF(temp[$0]);
            int_$1 = (temp[$0] $3);
            CLEARTEMP($0);
            """, v2) and 'temp[' not in v2[3]:
                TxRepl(o, i, """
                    int_$1 = (GETATTR($6) $3);
                    """, v2)                        
                return True  
        if TxMatch(o, i, """            
            temp[$0] = GETATTR($6);
            Py_INCREF(temp[$0]);
            temp[$2] = PyList_GET_ITEM ( temp[$1], $8 );
            Py_INCREF(temp[$2]);
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    temp[$2] = PyList_GET_ITEM ( GETATTR($6), $8 );
                    Py_INCREF(temp[$2]);
                    """, v2)                        
                return True                          
    if oi.endswith('] = 0;'):                     
        if TxMatch(o, i, """
            temp[$0] = 0;
            f->f_lineno = $2;
            f->f_lasti = $3;
            if ((temp[$0] = $1""", v2) and ('temp[' + v2[0] + ']') not in v2[1]:
                TxRepl(o, i, """
                        f->f_lineno = $2;
                        f->f_lasti = $3;
                        if ((temp[$0] = $1""", v2)
                return True           
        if TxMatch(o, i, """
            temp[$0] = 0;
            PyLine = $2;
            PyAddr = $3;
            if ((temp[$0] = $1""", v2) and ('temp[' + v2[0] + ']') not in v2[1]:
                TxRepl(o, i, """
                        PyLine = $2;
                        PyAddr = $3;
                        if ((temp[$0] = $1""", v2)
                return True           
        if TxMatch(o, i, """
            temp[$0] = 0;
            if ((temp[$0] = $1""", v2) and ('temp[' + v2[0] + ']') not in v2[1]:
                TxRepl(o, i, """
                        if ((temp[$0] = $1""", v2)
                return True           

        if TxMatch(o, i, """
            temp[$0] = 0;
            f->f_lineno = $2;
            f->f_lasti = $3;            
            temp[$0] = $1;""", v2) and ('temp[' + v2[0] + ']') not in v2[1]:
                TxRepl(o, i, """
                        f->f_lineno = $2;
                        f->f_lasti = $3;                       
                        temp[$0] = $1;""", v2)
                return True 
        if TxMatch(o, i, """
            temp[$0] = 0;
            PyLine = $2;
            PyAddr = $3;            
            temp[$0] = $1;""", v2) and ('temp[' + v2[0] + ']') not in v2[1]:
                TxRepl(o, i, """
                        PyLine = $2;
                        PyAddr = $3;
                        temp[$0] = $1;""", v2)
                return True             
        if TxMatch(o, i, """
            temp[$0] = 0;
            temp[$0] = $1;""", v2) and ('temp[' + v2[0] + ']') not in v2[1]:
                TxRepl(o, i, """temp[$0] = $1;""", v2)
                return True 
          
    if ( i < len(o) - 2 ) and 'PyList_GET_ITEM' in oi:
        ooi2 = o[i+2]
        assert type(ooi2) is str        
        ## if ooi2.startswith('SETLOCAL ( '):
            ## if TxMatch(o, i, """
                ## temp[$4] = PyList_GET_ITEM ( $3, $1 );
                ## Py_INCREF(temp[$4]);
                ## SETLOCAL ( $5 , temp[$4] );
                ## temp[$4] = 0;
                ## """, v2):
                    ## TxRepl(o, i, """
                        ## SETLOCAL ( $5 , PyList_GET_ITEM ( $3 , $1 ) );
                        ## Py_INCREF(GETLOCAL($5));
                        ## """, v2)
                    ## return False  
        ## elif ooi2.startswith('LETLOCAL ( '):
            ## if TxMatch(o, i, """
                ## temp[$4] = PyList_GET_ITEM ( $3 );
                ## Py_INCREF(temp[$4]);
                ## LETLOCAL ( $5 , temp[$4] );
                ## temp[$4] = 0;
                ## """, v2):
                    ## TxRepl(o, i, """
                        ## LETLOCAL ( $5 , PyList_GET_ITEM ( $3 ) );
                        ## Py_INCREF(GETLOCAL($5));
                        ## """, v2)
                    ## return False  
            ## if TxMatch(o, i, """
                ## temp[$4] = PyList_GET_ITEM ( $3 );
                ## Py_INCREF(temp[$4]);
                ## LETLOCAL ( $5 , temp[$4] );
                ## temp[$4] = Py$9;
                ## """, v2):
                    ## TxRepl(o, i, """
                        ## LETLOCAL ( $5 , PyList_GET_ITEM ( $3 ) );
                        ## Py_INCREF(GETLOCAL($5));
                        ## temp[$4] = Py$9;
                        ## """, v2)
                    ## return False          
                              
        ## elif ooi2.startswith('SETSTATIC ( '):
            ## if TxMatch(o, i, """
                ## temp[$4] = PyList_GET_ITEM ( $3 );
                ## Py_INCREF(temp[$4]);
                ## SETSTATIC ( $5 , temp[$4] );
                ## temp[$4] = 0;
                ## """, v2):
                    ## TxRepl(o, i, """
                        ## SETSTATIC ( $5 , PyList_GET_ITEM ( $3 ) );
                        ## Py_INCREF(GETSTATIC($5));
                        ## """, v2)
                    ## return False  
                
        if ooi2.startswith('temp['):
            if TxMatch(o, i, """
                temp[$0] = PyList_GET_ITEM ( $12 );
                Py_INCREF(temp[$0]);
                temp[$1] = PyList_GET_ITEM ( temp[$0], $3 );
                Py_INCREF(temp[$1]);
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        temp[$1] = PyList_GET_ITEM ( PyList_GET_ITEM ( $12 ), $3 );
                        Py_INCREF(temp[$1]);
                        """, v2)
                    return False  
            if TxMatch(o, i, """
                temp[$0] = PyList_GET_ITEM ( $12 );
                Py_INCREF(temp[$0]);
                temp[$1] = PyTuple_GET_ITEM ( temp[$0], $3 );
                Py_INCREF(temp[$1]);
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        temp[$1] = PyTuple_GET_ITEM ( PyList_GET_ITEM ( $12 ), $3 );
                        Py_INCREF(temp[$1]);
                        """, v2)
                    return False  
            if TxMatch(o, i, """
                 temp[$0] = PyList_GET_ITEM ( $6 );
                 Py_INCREF(temp[$0]);
                 temp[$1] = PyList_GET_ITEM ( $7 );
                 Py_INCREF(temp[$1]);
                 int_$5 = (temp[$0] $8 temp[$1]);
                 CLEARTEMP($0);
                 CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                         int_$5 = (PyList_GET_ITEM ( $6 ) $8 PyList_GET_ITEM ( $7 ));
                        """, v2)
                    return False                
        elif ooi2.startswith('int_'):
            if TxMatch(o, i, """
                temp[$0] = PyList_GET_ITEM ( $12 );
                Py_INCREF(temp[$0]);
                int_$1 = (PyList_GET_SIZE( temp[$0] ) $3 $2);
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        int_$1 = (PyList_GET_SIZE( PyList_GET_ITEM ( $12 ) ) $3 $2);
                        """, v2)
                    return False 
            if TxMatch(o, i, """
                temp[$0] = PyList_GET_ITEM ( $12 );
                Py_INCREF(temp[$0]);
                int_$1 = Py$14_CheckExact(temp[$0]);
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        int_$1 = Py$14_CheckExact(PyList_GET_ITEM ( $12 ));
                        """, v2)
                    return False 

        elif ooi2.startswith('if ((int_'):
            if TxMatch(o, i, """                
                temp[$1] = PyList_GET_ITEM ( $12 );
                Py_INCREF(temp[$1]);
                if ((int_$11 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$3 )) == -1) goto label_$15;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((int_$11 = PyObject_RichCompareBool ( temp[$0] , PyList_GET_ITEM ( $12 ) , Py_$3 )) == -1) goto label_$15;
                        CLEARTEMP($0);
                        """, v2)
                    return False 
            if TxMatch(o, i, """                
                temp[$0] = PyList_GET_ITEM ( $12 );
                Py_INCREF(temp[$0]);
                if ((int_$1 = PyObject_RichCompareBool ( temp[$0] , $3 , Py_$4 )) == -1) goto label_$5;
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        if ((int_$1 = PyObject_RichCompareBool ( PyList_GET_ITEM ( $12 ) , $3 , Py_$4 )) == -1) goto label_$5;
                        """, v2)
                    return False 
            if TxMatch(o, i, """
                temp[$2] = PyList_GET_ITEM ( $12 );
                Py_INCREF(temp[$2]);
                if ((int_$1 = PyDict_Contains ( $5 , temp[$2] )) == -1) goto label_$0;
                CLEARTEMP($2);                    
                """, v2):
                    TxRepl(o, i, """
                        if ((int_$1 = PyDict_Contains ( $5 , PyList_GET_ITEM ( $12 ) )) == -1) goto label_$0;
                        """, v2)
                    return True 

        elif ooi2.startswith('if ((temp['):
            if TxMatch(o, i, """
                temp[$0] = PyList_GET_ITEM ( $12 );
                Py_INCREF(temp[$0]);
                if ((temp[$1] = _c_BINARY_SUBSCR_Int ( temp[$0] ,$3)) == 0) goto label_$10;
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$1] = _c_BINARY_SUBSCR_Int ( PyList_GET_ITEM ( $12 ) ,$3)) == 0) goto label_$10;
                        """, v2)
                    return False 
            if TxMatch(o, i, """
                temp[$0] = PyList_GET_ITEM ( $12 );
                Py_INCREF(temp[$0]);
                if ((temp[$1] = PyDict_GetItem ($3, temp[$0] )) == 0) goto label_$10;
                Py_INCREF(temp[$1]);
                CLEARTEMP($0);                
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$1] = PyDict_GetItem ($3, PyList_GET_ITEM ( $12 ) )) == 0) goto label_$10;
                        Py_INCREF(temp[$1]);
                        """, v2)
                    return False 
        elif ooi2.startswith('if ( PyInt_CheckExact('):
            if TxMatch(o, i, """
                temp[$0] = PyList_GET_ITEM ( $12 );
                Py_INCREF(temp[$0]);
                if ( PyInt_CheckExact(temp[$0]) ) {
                int_$1 = PyInt_AS_LONG(temp[$0]) $6 $7;
                } else {
                if ((int_$1 = PyObject_RichCompareBool ( temp[$0] , $8 , Py_$9 )) == -1) goto label_$10;
                }
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        if ( PyInt_CheckExact(PyList_GET_ITEM ( $12 )) ) {
                        int_$1 = PyInt_AS_LONG(PyList_GET_ITEM ( $12 )) $6 $7;
                        } else {
                        if ((int_$1 = PyObject_RichCompareBool ( PyList_GET_ITEM ( $12 ) , $8 , Py_$9 )) == -1) goto label_$10;
                        }
                        """, v2)
                    return False 
        elif ooi2.startswith('if ((long_'):
            if TxMatch(o, i, """
                temp[$0] = PyList_GET_ITEM ( $12 );
                Py_INCREF(temp[$0]);
                if ((long_$2 = PyObject_Size( temp[$0] )) == -1) goto label_$10;
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        if ((long_$2 = PyObject_Size( PyList_GET_ITEM ( $12 ) )) == -1) goto label_$10;
                        """, v2)
                    return False 
        elif ooi2.startswith('if (PyList_CheckExact(temp['):
            if TxMatch(o, i, """
                temp[$0] = PyList_GET_ITEM ($1);
                Py_INCREF(temp[$0]);
                if (PyList_CheckExact(temp[$0]) && PyList_GET_SIZE(temp[$0]) > $2) {
                Py_INCREF($5);
                SETLISTITEM(temp[$0], $4, $5);
                } else {
                if ( PyObject_SetItem ( temp[$0] , $6 , $7 ) == -1) goto label_$10;
                }
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        if (PyList_CheckExact(PyList_GET_ITEM ($1)) && PyList_GET_SIZE(PyList_GET_ITEM ($1)) > $2) {
                        Py_INCREF($5);
                        SETLISTITEM(PyList_GET_ITEM ($1), $4, $5);
                        } else {
                        temp[$0] = PyList_GET_ITEM ($1);
                        Py_INCREF(temp[$0]);
                        if ( PyObject_SetItem ( temp[$0] , $6 , $7 ) == -1) goto label_$10;
                        CLEARTEMP($0);
                        }
                        """, v2)
                    return False 
            if TxMatch(o, i, """
                temp[$1] = PyList_GET_ITEM ( $2 );
                Py_INCREF(temp[$1]);
                if (PyList_CheckExact(temp[$1]) && PyList_GET_SIZE(temp[$1]) > $3) {
                SETLISTITEM(temp[$1], $4, temp[$0]);
                } else {
                if ( PyObject_SetItem ( temp[$1] , $5 , temp[$0] ) == -1) goto label_$10;
                Py_DECREF(temp[$0]);
                }
                CLEARTEMP($1);
                temp[$0] = 0;
                """, v2):
                    TxRepl(o, i, """
                        if (PyList_CheckExact(PyList_GET_ITEM ( $2 )) && PyList_GET_SIZE(PyList_GET_ITEM ( $2 )) > $3) {
                        SETLISTITEM(PyList_GET_ITEM ( $2 ), $4, temp[$0]);
                        } else {
                        temp[$1] = PyList_GET_ITEM ( $2 );
                        Py_INCREF(temp[$1]);
                        if ( PyObject_SetItem ( temp[$1] , $5 , temp[$0] ) == -1) goto label_$10;
                        Py_DECREF(temp[$0]);
                        CLEARTEMP($1);
                        }
                        temp[$0] = 0;
                        """, v2)
                    return False
                 
    if ( i < len(o) - 2 ) and 'PyTuple_GET_ITEM' in oi:
        ooi2 = o[i+2]
        assert type(ooi2) is str
        if ooi2.startswith('SETLOCAL ( '):
            if TxMatch(o, i, """
                temp[$4] = PyTuple_GET_ITEM ( $3 );
                Py_INCREF(temp[$4]);
                SETLOCAL ( $5 , temp[$4] );
                temp[$4] = 0;
                """, v2):
                    TxRepl(o, i, """
                        SETLOCAL ( $5 , PyTuple_GET_ITEM ( $3 ) );
                        Py_INCREF(GETLOCAL($5));
                        """, v2)
                    return False  
        elif ooi2.startswith('LETLOCAL ( '):
            if TxMatch(o, i, """
                temp[$4] = PyTuple_GET_ITEM ( $3 );
                Py_INCREF(temp[$4]);
                LETLOCAL ( $5 , temp[$4] );
                temp[$4] = 0;
                """, v2):
                    TxRepl(o, i, """
                        LETLOCAL ( $5 , PyTuple_GET_ITEM ( $3 ) );
                        Py_INCREF(GETLOCAL($5));
                        """, v2)
                    return False  
            if TxMatch(o, i, """
                temp[$4] = PyTuple_GET_ITEM ( $3 );
                Py_INCREF(temp[$4]);
                LETLOCAL ( $5 , temp[$4] );
                temp[$4] = Py$9;
                """, v2):
                    TxRepl(o, i, """
                        LETLOCAL ( $5 , PyTuple_GET_ITEM ( $3 ) );
                        Py_INCREF(GETLOCAL($5));
                        temp[$4] = Py$9;
                        """, v2)
                    return False          
                              
        elif ooi2.startswith('SETSTATIC ( '):
            if TxMatch(o, i, """
                temp[$4] = PyTuple_GET_ITEM ( $3 );
                Py_INCREF(temp[$4]);
                SETSTATIC ( $5 , temp[$4] );
                temp[$4] = 0;
                """, v2):
                    TxRepl(o, i, """
                        SETSTATIC ( $5 , PyTuple_GET_ITEM ( $3 ) );
                        Py_INCREF(GETSTATIC($5));
                        """, v2)
                    return False  
        elif ooi2.endswith('] = 0;'):
            if TxMatch(o, i, """
                temp[$0] = PyTuple_GET_ITEM ( $10 );
                if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$11;
                temp[$0] = 0;
                """, v2):
                    TxRepl(o, i, """if ((int_$1 = PyObject_IsTrue ( PyTuple_GET_ITEM ( $10 ) )) == -1) goto label_$11;""", v2)
                    return True   
        elif o[i+1].startswith('Py_INCREF(temp['):
            if ooi2.startswith('int_'):
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $11 );
                    Py_INCREF(temp[$0]);
                    int_$3 = $12;
                    CLEARTEMP($0);
                    """, v2):
                        v2[15] = v2[12].replace('temp[' + v2[0] + ']', 'PyTuple_GET_ITEM ( ' + v2[11] +' )')
                        TxRepl(o, i, """
                            int_$3 = $15;
                            """, v2)
                        return True
            if ooi2.startswith('Py_ssize_t_'):
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $11 );
                    Py_INCREF(temp[$0]);
                    Py_ssize_t_$3 = $12;
                    CLEARTEMP($0);
                    """, v2):
                        v2[15] = v2[12].replace('temp[' + v2[0] + ']', 'PyTuple_GET_ITEM ( ' + v2[11] +' )')
                        TxRepl(o, i, """
                            Py_ssize_t_$3 = $15;
                            """, v2)
                        return True
            if ooi2.startswith('if ((int_'):
                if TxMatch(o, i, """
                    temp[$2] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$2]);
                    if ((int_$1 = PyDict_Contains ( $5 , temp[$2] )) == -1) goto label_$0;
                    CLEARTEMP($2);                    
                    """, v2):
                        TxRepl(o, i, """
                            if ((int_$1 = PyDict_Contains ( $5 , PyTuple_GET_ITEM ( $12 ) )) == -1) goto label_$0;
                            """, v2)
                        return True 
                if TxMatch(o, i, """
                    temp[$1] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$1]);
                    if ((int_$11 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$9 )) == -1) goto label_$6;
                    CLEARTEMP($0);
                    CLEARTEMP($1);                      
                    """, v2):
                        TxRepl(o, i, """
                            if ((int_$11 = PyObject_RichCompareBool ( temp[$0] , PyTuple_GET_ITEM ( $12 ) , Py_$9 )) == -1) goto label_$6;
                            CLEARTEMP($0);
                            """, v2)
                        return True 
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    if ((int_$1 = PyObject_RichCompareBool ( temp[$0] , $14 , Py_$15 )) == -1) goto label_$16;
                    CLEARTEMP($0);
                    """, v2):
                        TxRepl(o, i, """
                            if ((int_$1 = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( $12 ) , $14 , Py_$15 )) == -1) goto label_$16;
                            """, v2)
                        return True 
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    if ((int_$1 = PyObject_IsTrue( temp[$0] )) == -1) goto label_$0;
                    CLEARTEMP($0);
                    """, v2):
                        TxRepl(o, i, """
                            if ((int_$1 = PyObject_IsTrue( PyTuple_GET_ITEM ( $12 ) )) == -1) goto label_$0;
                            """, v2)
                        return True 
                     
            if ooi2.startswith('if ((long_'):
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    if ((long_$19 = PyObject_Size( temp[$0] )) == -1) goto label_$10;
                    CLEARTEMP($0);                    
                    """, v2):
                        TxRepl(o, i, """
                            if ((long_$19 = PyObject_Size( PyTuple_GET_ITEM ( $12 ) )) == -1) goto label_$10;
                            """, v2)
                        return True 
            elif ooi2.startswith('if ( PyInt_CheckExact(temp['):
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    if ( PyInt_CheckExact(temp[$0]) ) {
                    int_$15 = PyInt_AS_LONG(temp[$0]) $11 $10;
                    } else {
                    if ((int_$15 = PyObject_RichCompareBool ( temp[$0] , $16 , Py_$17 )) == -1) goto label_$18;
                    }
                    CLEARTEMP($0);                    
                    """, v2):
                        TxRepl(o, i, """
                            if ( PyInt_CheckExact(PyTuple_GET_ITEM ( $12 )) ) {
                            int_$15 = PyInt_AS_LONG(PyTuple_GET_ITEM ( $12 )) $11 $10;
                            } else {
                            if ((int_$15 = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( $12 ) , $16 , Py_$17 )) == -1) goto label_$18;
                            }
                            """, v2)
                        return True   

            elif ooi2.startswith('if ((temp['):
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $10 );
                    Py_INCREF(temp[$0]);
                    if ((temp[$2] = $11) == 0) goto label_$12;
                    if ((temp[$1] = PyNumber_Add ( temp[$0] , temp[$2] )) == 0) goto label_$12;
                    CLEARTEMP($0);
                    CLEARTEMP($2);
                    """, v2):
                        TxRepl(o, i, """
                            if ((temp[$2] = $11) == 0) goto label_$12;
                            if ((temp[$1] = PyNumber_Add ( PyTuple_GET_ITEM ( $10 ) , temp[$2] )) == 0) goto label_$12;
                            CLEARTEMP($2);
                            """, v2)
                        return True   
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    if ((temp[$3] = PyTuple_GetItem ( $14 )) == 0) goto label_$10;
                    Py_INCREF(temp[$3]);
                    if ((int_$1 = PyObject_RichCompareBool ( temp[$0] , temp[$3] , Py_$11 )) == -1) goto label_$10;
                    CLEARTEMP($0);
                    CLEARTEMP($3);
                    """, v2):
                        TxRepl(o, i, """
                            if ((temp[$3] = PyTuple_GetItem ( $14 )) == 0) goto label_$10;
                            if ((int_$1 = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( $12 ) , temp[$3] , Py_$11 )) == -1) goto label_$10;
                            temp[$3] = 0;
                            """, v2)
                        return True                                                                                                   
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $10 );
                    Py_INCREF(temp[$0]);
                    if ((temp[$1] = PyTuple_GetItem ( temp[$0] , $15 )) == 0) goto label_$16;
                    CLEARTEMP($0);
                    """, v2):
                        TxRepl(o, i, """
                            if ((temp[$1] = PyTuple_GetItem ( PyTuple_GET_ITEM ( $10 ) , $15 )) == 0) goto label_$16;
                            """, v2)
                        return True    
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $10 );
                    Py_INCREF(temp[$0]);
                    if ((temp[$1] = PyTuple_GetItem ( temp[$0] , $11 )) == 0) goto label_$12;
                    Py_INCREF(temp[$1]);
                    CLEARTEMP($0);
                    """, v2):
                        TxRepl(o, i, """
                            if ((temp[$1] = PyTuple_GetItem ( PyTuple_GET_ITEM ( $10 ) , $11 )) == 0) goto label_$12;
                            Py_INCREF(temp[$1]);
                            """, v2)
                        return True    
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    if ((temp[$1] = PyObject_Type ( temp[$0] )) == 0) goto label_$10;
                    CLEARTEMP($0);
                    """, v2):
                        TxRepl(o, i, """
                            if ((temp[$1] = PyObject_Type ( PyTuple_GET_ITEM ( $12 ) )) == 0) goto label_$10;
                            """, v2)
                        return True   
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    if ((temp[$1] = _c_BINARY_SUBSCR_Int ( temp[$0] , $3 , $4 )) == 0) goto label_$2;
                    CLEARTEMP($0);                    
                    """, v2):
                        TxRepl(o, i, """
                            if ((temp[$1] = _c_BINARY_SUBSCR_Int ( PyTuple_GET_ITEM ( $12 ) , $3 , $4 )) == 0) goto label_$2;
                            """, v2)
                        return True   
                if TxMatch(o, i, """
                    temp[$2] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$2]);
                    if ((int_$1 = PyDict_Contains ( $5 , temp[$2] )) == -1) goto label_$0;
                    CLEARTEMP($2);                    
                    """, v2):
                        TxRepl(o, i, """
                            if ((int_$1 = PyDict_Contains ( $5 , PyTuple_GET_ITEM ( $12 ) )) == -1) goto label_$0;
                            """, v2)
                        return True  
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    if ((temp[$1] = _c_BINARY_SUBSCR_Int ( temp[$0] , $16 )) == 0) goto label_$14;
                    if (Py$11_CheckExact(temp[$1])) {
                    int_$15 = $17;
                    } else {
                    if ((int_$15 = $18) == -1) goto label_$14;
                    }
                    CLEARTEMP($0);
                    CLEARTEMP(1);                     
                    """, v2):
                        assert str(('temp[' + v2[0] + ']')) not in str(v2[18])
                        assert str('temp[' + v2[0] + ']') not in str(v2[17])
                        TxRepl(o, i, """
                            if ((temp[$1] = _c_BINARY_SUBSCR_Int ( PyTuple_GET_ITEM ( $12 ) , $16 )) == 0) goto label_$14;
                            if (Py$11_CheckExact(temp[$1])) {
                            int_$15 = $17;
                            } else {
                            if ((int_$15 = $18) == -1) goto label_$14;
                            }
                            CLEARTEMP(1); 
                            """, v2)
                        return True  
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    if ((temp[$1] = PyDict_GetItem ( $3 , temp[$0] )) == 0) goto label_$4;
                    Py_INCREF(temp[$1]);
                    CLEARTEMP($0);                    
                    """, v2):
                        TxRepl(o, i, """
                            if ((temp[$1] = PyDict_GetItem ( $3 , PyTuple_GET_ITEM ( $12 ) )) == 0) goto label_$4;
                            Py_INCREF(temp[$1]);
                            """, v2)
                        return True  
                    
            if ooi2.startswith('temp['):
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    temp[$1] = PyTuple_GET_ITEM ( $13 );
                    Py_INCREF(temp[$1]);
                    if ((int$11 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$16 )) == -1) goto label_$17;
                    CLEARTEMP($0);
                    CLEARTEMP($1);
                    """, v2):
                        TxRepl(o, i, """
                            if ((int$11 = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( $12 ) , PyTuple_GET_ITEM ( $13 ) , Py_$16 )) == -1) goto label_$17;
                            """, v2)
                        return True 
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    temp[$1] = PyTuple_GET_ITEM ( temp[$0], $3 );
                    Py_INCREF(temp[$1]);
                    CLEARTEMP($0);
                    """, v2):
                        TxRepl(o, i, """
                            temp[$1] = PyTuple_GET_ITEM ( PyTuple_GET_ITEM ( $12 ), $3 );
                            Py_INCREF(temp[$1]);
                            """, v2)
                        return True 
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    temp[$1] = PyTuple_GET_ITEM ( $11 );
                    Py_INCREF(temp[$1]);
                    int_$5 = (temp[$0] == temp[$1]);
                    CLEARTEMP($0);
                    CLEARTEMP($1);
                    """, v2):
                        TxRepl(o, i, """
                            int_$5 = (PyTuple_GET_ITEM ( $12 ) == PyTuple_GET_ITEM ( $11 ));
                            """, v2)
                        return True 
                if TxMatch(o, i, """
                    temp[$1] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$1]);
                    temp[$2] = PyTuple_GET_ITEM ( $11 );
                    Py_INCREF(temp[$2]);
                    if ((temp[$0] = PyObject_RichCompare ( temp[$1] , temp[$2] , Py_$5 )) == 0) goto label_$10;
                    CLEARTEMP($2);
                    CLEARTEMP($1);                 
                    """, v2):
                        TxRepl(o, i, """
                            if ((temp[$0] = PyObject_RichCompare ( PyTuple_GET_ITEM ( $12 ) , PyTuple_GET_ITEM ( $11 ) , Py_$5 )) == 0) goto label_$10;
                            """, v2)
                        return True  

            elif ooi2.startswith('if ((int_'):
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $10 );
                    Py_INCREF(temp[$0]);
                    if ((int_$14 = Py$19_Contains ( $15 , temp[$0] )) == -1) goto label_$16;
                    CLEARTEMP($0);
                    """, v2):
                        TxRepl(o, i, """
                            if ((int_$14 = Py$19_Contains ( $15 , PyTuple_GET_ITEM ( $10 ) )) == -1) goto label_$16;
                            """, v2)
                        return True   
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $2 );
                    Py_INCREF(temp[$0]);
                    if ((int_$1 = PyObject_RichCompareBool ( temp[$0] , $4 , Py_$5 )) == -1) goto label_$6;
                    CLEARTEMP($0);
                    """, v2):
                        TxRepl(o, i, """
                            if ((int_$1 = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( $2 ) , $4 , Py_$5 )) == -1) goto label_$6;
                            """, v2)
                        return True   
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    if ((int_$5 = Py$4_Contains ( $3 , temp[$0] )) == -1) goto label_$6;
                    CLEARTEMP($0);
                    """, v2):
                        TxRepl(o, i, """
                            if ((int_$5 = Py$4_Contains ( $3 , PyTuple_GET_ITEM ( $12 ) )) == -1) goto label_$6;
                            """, v2)
                        return True   
                                                                          
            if TxMatch(o, i, """
                temp[$0] = PyTuple_GET_ITEM ( $10 );
                Py_INCREF(temp[$0]);
                $14 = PyInt_AsLong(temp[$0]);
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        $14 = PyInt_AsLong(PyTuple_GET_ITEM ( $10 ));
                        """, v2)
                    return True         
            if ooi2.startswith('if (_Direct_'):
                pass
            elif ooi2.startswith('Loc_int_'):
                if TxMatch(o, i, """
                    temp[$1] = PyTuple_GET_ITEM ( $10 );
                    Py_INCREF(temp[$1]);
                    Loc_int_$11 = PyObject_IsTrue(temp[$1]);
                    CLEARTEMP($1);
                    """, v2):
                        TxRepl(o, i, """
                            Loc_int_$11 = PyObject_IsTrue(PyTuple_GET_ITEM ( $10 ));
                            """, v2)
                        return True  
            elif ooi2.startswith('if (PyString_CheckExact('):
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    if (PyString_CheckExact(temp[$0])) {
                    int_$1 = (PyString_GET_SIZE(temp[$0]) == $5 && 0 == memcmp( PyString_AS_STRING(temp[$0]), $6, $5));
                    } else {
                    if ((int_$1 = PyObject_RichCompareBool ( temp[$0] , $7 , Py_EQ )) == -1) goto label_$14;
                    }
                    CLEARTEMP($0);
                    """, v2):
                        TxRepl(o, i, """
                            if (PyString_CheckExact(PyTuple_GET_ITEM ( $12 ))) {
                            int_$1 = (PyString_GET_SIZE(PyTuple_GET_ITEM ( $12 )) == $5 && 0 == memcmp( PyString_AS_STRING(PyTuple_GET_ITEM ( $12 )), $6, $5));
                            } else {
                            if ((int_$1 = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( $12 ) , $7 , Py_EQ )) == -1) goto label_$14;
                            }
                            """, v2)
                        return True  
                if TxMatch(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $12 );
                    Py_INCREF(temp[$0]);
                    if (PyString_CheckExact(temp[$0])) {
                    int_$11 = (PyString_GET_SIZE(temp[$0]) != $7 || 0 != memcmp( PyString_AS_STRING(temp[$0]), $8, $7));
                    } else {
                    if ((int_$11 = PyObject_RichCompareBool ( temp[$0] , $9 , Py_NE )) == -1) goto label_$10;
                    }
                    CLEARTEMP($0);
                    """, v2):
                        TxRepl(o, i, """
                            if (PyString_CheckExact(PyTuple_GET_ITEM ( $12 ))) {
                            int_$11 = (PyString_GET_SIZE(PyTuple_GET_ITEM ( $12 )) != $7 || 0 != memcmp( PyString_AS_STRING(PyTuple_GET_ITEM ( $12 )), $8, $7));
                            } else {
                            if ((int_$11 = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( $12 ) , $9 , Py_NE )) == -1) goto label_$10;
                            }
                            """, v2)
                        return True  
                    
            if TxMatch(o, i, """
                temp[$0] = PyTuple_GET_ITEM ( $11 );
                Py_INCREF(temp[$0]);
                if ($2) {
                if ((int_$1 = _Direct_$3) == -1) goto label_$12;
                } else {
                >1
                }
                CLEARTEMP($0);
                """, v2):
                    te = 'temp[' + v2[0] + ']'
                    if not te in v2[2] and not te in v2[3]:
                        TxRepl(o, i, """
                            if ($2) {
                            if ((int_$1 = _Direct_$3) == -1) goto label_$12;
                            } else {
                            temp[$0] = PyTuple_GET_ITEM ( $11 );
                            Py_INCREF(temp[$0]);
                            >1
                            CLEARTEMP($0);
                            }
                            """, v2)                        
                        return True       
            if TxMatch(o, i, """
                temp[$1] = PyTuple_GET_ITEM ( $16 );
                Py_INCREF(temp[$1]);
                if (PyInt_CheckExact( temp[$1] )) {
                int_$12 = $14 PyInt_AS_LONG ( temp[$1] );
                } else {
                if ((int_$12 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$11 )) == -1) goto label_$10;
                }
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( PyTuple_GET_ITEM ( $16 ) )) {
                        int_$12 = $14 PyInt_AS_LONG ( PyTuple_GET_ITEM ( $16 ) );
                        } else {
                        if ((int_$12 = PyObject_RichCompareBool ( temp[$0] , PyTuple_GET_ITEM ( $16 ) , Py_$11 )) == -1) goto label_$10;
                        }
                        CLEARTEMP($0);
                        """, v2)                        
                    return True                                 
        else:
            pass
                        
    return False
    
def let_temp_PyInt_FromLong(o, i):
    assert type(i) is int and i >= 0
    v2 = {}
    if TxMatch(o, i, """    
        temp[$1] = PyInt_FromLong($11);
        Loc_$12 = PyInt_AsLong(temp[$1]);
        CLEARTEMP($1);
        """, v2) :
            TxRepl(o, i, """
                Loc_$12 = $11;
                    """, v2)
            return True    
    if TxMatch(o, i, """    
        temp[$2] = PyInt_FromLong ( $1 );
        if (PyInt_CheckExact( $3 )) {
        >0
        } else {
        >1
        }
        CLEARTEMP($2);
        """, v2) and ('temp[%s]' % v2[2]) not in v2[3]:
            TxRepl(o, i, """
                if (PyInt_CheckExact( $3 )) {
                temp[$2] = PyInt_FromLong ( $1 );
                >0
                CLEARTEMP($2);
                } else {
                temp[$2] = PyInt_FromLong ( $1 );
                >1
                CLEARTEMP($2);
                }
                    """, v2)
            return True    
    if TxMatch(o, i, """
        temp[$0] = PyInt_FromLong ( $3 );
        $1 = $11;
        long_$2 = PyInt_AS_LONG ( temp[$0] );
        """, v2) and ('temp[%s]' % v2[0]) not in v2[1] and ('temp[%s]' % v2[0]) not in v2[11] and v2[1] not in v2[3]:
            TxRepl(o, i, """
                long_$2 = $3;
                $1 = $11;
                temp[$0] = PyInt_FromLong ( long_$2 );
                """, v2)
            return True        

    if TxMatch(o, i, """
        temp[$0] = PyInt_FromLong ( $2 );
        if ($3) {
        temp[$1] = PyInt_FromLong ( $4 );
        } else {
        temp[$1] = $5temp[$0]$6;
        }
        CLEARTEMP($0);
        """, v2) and ('temp[%s]' % v2[0]) not in v2[3] and ('temp[%s]' % v2[0]) not in v2[4]:
            TxRepl(o, i, """
                if ($3) {
                temp[$1] = PyInt_FromLong ( $4 );
                } else {
                temp[$0] = PyInt_FromLong ( $2 );
                temp[$1] = $5temp[$0]$6;
                CLEARTEMP($0);
                }
                """, v2)
            return True        

    
    if TxMatch(o, i, """temp[$0] = PyInt_FromLong ($1);
        long_$4 = PyInt_AS_LONG ( temp[$0] );
        if ( long_$4 < 0) {
        long_$4 += $5;
        }
        CLEARTEMP($0);""", v2):
            TxRepl(o, i, """long_$4 = $1;
                if ( long_$4 < 0) {
                long_$4 += $5;
                }""", v2)
            return True
    if TxMatch(o, i, """temp[$0] = PyInt_FromLong ($1);
        $2 = PyInt_AS_LONG ( temp[$0] ) $3;
        CLEARTEMP($0);""", v2):
            v2[1] = cond_add_sk(v2[1])
            TxRepl(o, i, """$2 = $1 $3;""", v2)
            return True 
            

    if TxMatch(o, i, """temp[$0] = PyInt_FromLong ( $1 );
        if (($3 = PyObject_Not ( temp[$0] )) == -1) goto $2;
        CLEARTEMP($0);""", v2):
            TxRepl(o, i, """$3 = ! $1;""", v2)
            return True
            
    if TxMatch(o, i, """temp[$0] = PyInt_FromLong ($3);
        if ((temp[$1] = PyInt_Type.tp_str ( temp[$0] )) == 0) goto $4;
        CLEARTEMP($0);
        temp[$0] = PyInt_FromLong ($3);
        if ((temp[$2] = PyInt_Type.tp_str ( temp[$0] )) == 0) goto $4;
        CLEARTEMP($0);""", v2):
            v2[3] = v2[3].strip()
            TxRepl(o, i, """temp[$0] = PyInt_FromLong ($3);
                if ((temp[$1] = PyInt_Type.tp_str ( temp[$0] )) == 0) goto $4;
                CLEARTEMP($0);
                temp[$2] = temp[$1];
                Py_INCREF(temp[$2]);""", v2)
            return True 
                        
                        
                        
    if TxMatch(o, i, """temp[$4] = PyInt_FromLong ($1);
        if ((temp[$5] = PyObject_GetItem ( $2 , temp[$4] )) == 0) goto $0;
        CLEARTEMP($4);""", v2):
            v2[1] = v2[1].strip()
            TxRepl(o, i, """if ((temp[$5] = __c_BINARY_SUBSCR_Int ( $2, $1 )) == 0) goto $0;""", v2, ('__c_BINARY_SUBSCR_Int',))
            return True   
    

    if TxMatch(o, i, """
        temp[$1] = PyInt_FromLong ( $4 );
        if ( _PyEval_AssignSlice ( $3 , temp[$1] , NULL , temp[$0] ) == -1) goto label_$2;
        CLEARTEMP($0);
        CLEARTEMP($1);
        """, v2):
            TxRepl(o, i, """
                if ( PySequence_SetSlice ( $3 , $4 , PY_SSIZE_T_MAX , temp[$0] ) == -1) goto label_$2;
                CLEARTEMP($0);
                """, v2)
            return True  

                        
    if TxMatch(o, i, """temp[$2] = PyInt_FromLong ($0);
        $3 = PyInt_AS_LONG ( temp[$2] );
        if ( $3 < 0) {
        $3 += PyList_GET_SIZE($1);
        }
        if ((temp[$11] = PyList_GetItem ( $1 , $3 )) == 0) goto $10;
        Py_INCREF(temp[$11]);
        CLEARTEMP($2);""", v2):
            TxRepl(o, i, """$3 = $0;
                if ( $3 < 0) {
                $3 += PyList_GET_SIZE($1);
                }
                if ((temp[$11] = PyList_GetItem ( $1 , $3 )) == 0) goto $10;
                Py_INCREF(temp[$11]);""", v2)
            return True 
                        

    v2 = []
    if TextMatch(o[i], ('temp[', '*', '] = PyInt_FromLong (', '*', ');'), v2):
        patt = 'PyInt_AsLong(temp[' + v2[0] + '])'
        if i < (len(o) - 2) and patt in o[i+1] and\
        TextMatch(o[i+2], ('CLEARTEMP(', v2[0],');'), []):            
            o[i+1] = o[i+1].replace(patt, '(' + v2[1] + ')')
            del o[i+2]
            del o[i]
            return True
    if TextMatch(o[i], ('temp[', '*', '] = PyInt_FromLong (', '*', ');'), v2):
        patt = 'PyInt_AsLong ( temp[' + v2[0] + '] )'
        if i < (len(o) - 2) and patt in o[i+1] and\
        TextMatch(o[i+2], ('CLEARTEMP(', v2[0],');'), []):            
            o[i+1] = o[i+1].replace(patt, '(' + v2[1] + ')')
            del o[i+2]
            del o[i]
            return True
    v2 = []
    if TextMatch(o[i], ('temp[', '*', '] = PyInt_FromLong (', '*', ');'), v2):
        patt = 'PyInt_AS_LONG ( temp[' + v2[0] + '] )'
        if i < (len(o) - 2) and patt in o[i+1] and\
        TextMatch(o[i+2], ('CLEARTEMP(', v2[0],');'), []):            
            o[i+1] = o[i+1].replace(patt, '(' + v2[1] + ')')
            del o[i+2]
            del o[i]
            return True
    v2 = {}
    
    if TxMatch(o, i, """                        
temp[$0] = PyInt_FromLong ( $10 );
long_$3 = PyInt_AS_LONG ( temp[$0] );
long_$4 = long_$3 * $2;
if (long_$4 / $2 == long_$3) {
temp[$1] = PyInt_FromLong ( long_$4 );
} else {
temp[$1] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], $11);
}
CLEARTEMP($0);    
""", v2):                       
        TxRepl(o, i, """                        
long_$3 = $10;
long_$4 = long_$3 * $2;
if (long_$4 / $2 == long_$3) {
temp[$1] = PyInt_FromLong ( long_$4 );
} else {
temp[$0] = PyInt_FromLong ( $10 );
temp[$1] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], $11);
CLEARTEMP($0);    
}
""", v2)
        
        
    if '^' in o[i+1] and TxMatch(o, i, """
        temp[$0] = PyInt_FromLong ( $10 );
        if (((long_$11 = $10 + $14), !((long_$11^$10) < 0 && (long_$11^$14) < 0))) {
        temp[$1] = PyInt_FromLong ( long_$11 );
        } else {
        temp[$2] = PyInt_FromLong ( $10 );
        temp[$3] = PyInt_FromLong ( $14 );
        if ((temp[$1] = PyNumber_Add ( temp[$2] , temp[$3] )) == 0) goto label_$13;
        CLEARTEMP($2);
        CLEARTEMP($3);
        }
        if (($16 = _PyEval_ApplySlice ( $15 , temp[$0] , temp[$1] )) == 0) goto label_$13;
        CLEARTEMP($0);
        CLEARTEMP($1);               
               """, v2):
            TxRepl(o, i, """
                if (($16 = PySequence_GetSlice ( $15 , $10 , $10 + $14 )) == 0) goto label_$13;
                 """, v2)
            return True         
        
    
        
    if TxMatch(o, i, """temp[$1] = PyInt_FromLong ($2);
        if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $3 , $4 , temp[$1] )) == 0) goto $5;
        CLEARTEMP($1);""", v2):
            v2[2] = v2[2].strip()
            TxRepl(o, i, """if ((temp[$0] = __c_BINARY_SUBSCR_Int ( $3 , $4 )) == 0) goto $5;""", v2, ('__c_BINARY_SUBSCR_Int',))
            return True
    
                    
    if TxMatch(o, i, """temp[$0] = PyInt_FromLong ( $2 );
        CLEARTEMP($1);
        $6 = PyInt_AsLong ( temp[$0] );
        CLEARTEMP($0);""", v2):
            TxRepl(o, i, """$6 = $2;
                CLEARTEMP($1);""", v2)
            return True    
                        
    
    
    
    if TxMatch(o, i, """temp[$1] = PyInt_FromLong ( $4 );
        $2 = PyInt_AsSsize_t ( temp[$1] );
        CLEARTEMP($1);""", v2):
            TxRepl(o, i, """$2 = $4;""", v2)
            return True  
                                        
    
    if TxMatch(o, i, """
        temp[$0] = PyInt_FromLong ( $5 );
        long_$3 = PyInt_AS_LONG ( temp[$0] );
        long_$2 = $4;
        temp[$1] = PyInt_FromLong ( long_$2 );
        CLEARTEMP($0);
        """, v2): 
                TxRepl(o, i, """
                    long_$3 = $5;
                    long_$2 = $4;
                    temp[$1] = PyInt_FromLong ( long_$2 );
                    """, v2) 
                return True
        
    if TxMatch(o, i, """
        temp[$1] = PyInt_FromLong ( $10 );
        long_$5 = PyInt_AS_LONG ( temp[$1] );
        long_$6 = $7;
        if ($8) {
        temp[$2] = PyInt_FromLong ( long_$6 );
        } else {
        temp[$2] = PyInt_Type.tp_as_number->nb$9;
        }
        CLEARTEMP($1);
        """, v2): 
                TxRepl(o, i, """
                    long_$5 = $10;
                    long_$6 = $7;
                    if ($8) {
                    temp[$2] = PyInt_FromLong ( long_$6 );
                    } else {
                    temp[$1] = PyInt_FromLong ( $10 );
                    temp[$2] = PyInt_Type.tp_as_number->nb$9;
                    CLEARTEMP($1);
                    }
                    """, v2) 
                return True
    


    if TxMatch(o, i, """
        temp[$0] = PyInt_FromLong ( $1 );
        if ( PyObject_SetAttr ( $3 ) == -1) goto label_$4;
        CLEARTEMP($0);
        temp[$0] = PyInt_FromLong ( $1 );
            """, v2): 
                TxRepl(o, i, """
                    temp[$0] = PyInt_FromLong ( $1 );
                    if ( PyObject_SetAttr ( $3 ) == -1) goto label_$4;
                        """, v2) 
                return True 
    if TxMatch(o, i, """            
        temp[$0] = PyInt_FromLong ( $1 );
        long_$2 = PyInt_AS_LONG ( temp[$0] );
        if (long_$2 < (LONG_MAX >> $3) && long_$2 >= 0) {
        temp[$4] = PyInt_FromLong ( (long_$2 << $3) );
        } else {
        if ((temp[$4] = PyNumber_Lshift(temp[$0], consts[$5])) == 0) goto label_$6;
        }
        CLEARTEMP($0);""", v2):          
                TxRepl(o, i, """
                    long_$2 = $1;
                    if (long_$2 < (LONG_MAX >> $3) && long_$2 >= 0) {
                    temp[$4] = PyInt_FromLong ( (long_$2 << $3) );
                    } else {
                    temp[$0] = PyInt_FromLong ( long_$2 );
                    if ((temp[$4] = PyNumber_Lshift(temp[$0], consts[$5])) == 0) goto label_$6;
                    CLEARTEMP($0);
                    }
                    """, v2)
                return True    

    if TxMatch(o, i, """             
        temp[$1] = PyInt_FromLong ( $4 );
        temp[$2] = PyInt_FromLong ( $5 PyInt_AS_LONG ( temp[$1] ) );
        CLEARTEMP($0);
        CLEARTEMP($1);""", v2) and v2[0] != v2[2]:          
                TxRepl(o, i, """ 
                    temp[$2] = PyInt_FromLong ( $5 ($4) );
                    CLEARTEMP($0);
                    """, v2)
                return True    

    if TxMatch(o, i, """              
        temp[$0] = PyInt_FromLong ( $10 );
        if (PyInt_CheckExact( temp[$2] )) {
        temp[$1] = PyInt_FromLong ( $13 );
        } else {
        if ((temp[$1] = $11) == 0) goto label_$12;
        }
        CLEARTEMP($2);
        CLEARTEMP($0);""", v2):          
                TxRepl(o, i, """ 
                    if (PyInt_CheckExact( temp[$2] )) {
                    temp[$0] = PyInt_FromLong ( $10 );
                    temp[$1] = PyInt_FromLong ( $13 );
                    CLEARTEMP($0);
                    } else {
                    temp[$0] = PyInt_FromLong ( $10 );
                    if ((temp[$1] = $11) == 0) goto label_$12;
                    CLEARTEMP($0);
                    }
                    CLEARTEMP($2);""", v2)
                return True 


    if TxMatch(o, i, """   
        temp[$0] = PyInt_FromLong ( $9 );
        CLEARTEMP($2);
        long_$3 = PyInt_AS_LONG ( temp[$0] );
        CLEARTEMP($0);""", v2) and ('temp[' + v2[0] + ']') not in v2[9]:
                TxRepl(o, i, """ 
                    long_$3 = $9;
                    CLEARTEMP($2);""", v2)
                return True    
    if TxMatch(o, i, """              
        temp[$0] = PyInt_FromLong ( $10 );
        long_$3 = PyInt_AS_LONG ( temp[$0] );
        if (long_$3 < (LONG_BIT-1)) {
        temp[$1] = PyInt_FromLong ( (0x1 << long_$3) );
        } else {
        if ((temp[$1] = PyNumber_Lshift(consts[$4], temp[$0])) == 0) goto label_$2;
        }
        CLEARTEMP($0);""", v2):                        
                TxRepl(o, i, """ 
                    long_$3 = $10;
                    if (long_$3 < (LONG_BIT-1)) {
                    temp[$1] = PyInt_FromLong ( (0x1 << long_$3) );
                    } else {
                    temp[$0] = PyInt_FromLong ( long_$3 );
                    if ((temp[$1] = PyNumber_Lshift(consts[$4], temp[$0])) == 0) goto label_$2;
                    CLEARTEMP($0);
                    }
                    """, v2)
                return True 
            
                     
    if TxMatch(o, i, """       
        temp[$1] = PyInt_FromLong ( $10 PyInt_AS_LONG ( temp[$0] ) );
        CLEARTEMP($0);
        temp[$0] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $11 );
        CLEARTEMP($1);""", v2) and v2[0] != v2[1]:                        
                TxRepl(o, i, """ 
                    temp[$1] = PyInt_FromLong ( ( $10 PyInt_AS_LONG ( temp[$0] ) ) $11 );
                    CLEARTEMP($0);
                    temp[$0] = temp[$1];
                    temp[$1] = 0;
                    """, v2)
                return True                      
    if TxMatch(o, i, """       
        temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $10 );
        CLEARTEMP($0);
        temp[$0] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $11 );
        CLEARTEMP($1);""", v2) and v2[0] != v2[1]:                        
                TxRepl(o, i, """ 
                    temp[$1] = PyInt_FromLong ( ( PyInt_AS_LONG ( temp[$0] ) $10 ) $11 );
                    CLEARTEMP($0);
                    temp[$0] = temp[$1];
                    temp[$1] = 0;
                    """, v2)
                return True                        
    if TxMatch(o, i, """       
        temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $10 );
        CLEARTEMP($0);
        temp[$2] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $11 );
        CLEARTEMP($1);""", v2) and v2[0] != v2[1] and v2[2] != v2[0] and v2[1] != v2[2]:                        
                TxRepl(o, i, """ 
                    temp[$2] = PyInt_FromLong ( ( PyInt_AS_LONG ( temp[$0] ) $10 ) $11 );
                    CLEARTEMP($0);
                    """, v2)
                return True    
    v2 = {}     
                    
   
    if TxMatch(o, i, 
            """temp[$1] = PyInt_FromLong ( $8 );
            CLEARTEMP($0);
            int_$6 = PyInt_AS_LONG ( temp[$1] ) $9;
            CLEARTEMP($1);""", v2):
                TxRepl(o, i, """int_$6 = ( ( $8 ) $9 );
                    CLEARTEMP($0);""", v2)
                return True              
            
    if TxMatch(o, i, """
        temp[$0] = PyInt_FromLong ( $3 );
        long_$2 = PyInt_AS_LONG ( $4 );
        temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $5 );
        CLEARTEMP($0);
        """, v2) and ('long_' + v2[2]) not in v2[3] and ('temp[' + v2[0] + ']') not in v2[4]:
                TxRepl(o, i, """
                    long_$2 = PyInt_AS_LONG ( $4 );
                    temp[$1] = PyInt_FromLong ( ( $3 ) $5 );
                    """, v2)
                return True 

            
    if TxMatch(o, i, """              
        temp[$0] = PyInt_FromLong ( $3 );
        if (PyInt_CheckExact( temp[$1] )) {
        int_$6 = PyInt_AS_LONG ( temp[$1] ) $11 PyInt_AS_LONG ( temp[$0] );
        } else {
        if ((int_$6 = PyObject_RichCompareBool ( temp[$1] , temp[$0] , $12 )) == -1) goto label_$10;
        }
        CLEARTEMP($1);
        CLEARTEMP($0);
            """, v2) and v2[1] != v2[0]:
                TxRepl(o, i, """
                    if (PyInt_CheckExact( temp[$1] )) {
                    int_$6 = PyInt_AS_LONG ( temp[$1] ) $11 ( $3 );
                    } else {
                    temp[$0] = PyInt_FromLong ( $3 );
                    if ((int_$6 = PyObject_RichCompareBool ( temp[$1] , temp[$0] , $12 )) == -1) goto label_$10;
                    CLEARTEMP($0);
                    }
                    CLEARTEMP($1);
                    """, v2)
                return True  

    if TxMatch(o, i, """              
        temp[$0] = PyInt_FromLong ( long_$2 );
        CLEARTEMP($0);
            """, v2) and type(v2[2]) is str and v2[2].isdigit():
                TxRepl(o, i, """
                    """, v2)
                return True   
    if TxMatch(o, i, """              
        temp[$1] = PyInt_FromLong ( $4 );
        long_$3 = PyInt_AS_LONG ( temp[$1] );
        if ( long_$3 < 0) {
        long_$3 += $5;
        }
        if ((temp[$2] = Py$6_GetItem ( $7 , long_$3 )) == 0) goto label_$8;
        Py_INCREF(temp[$2]);
        CLEARTEMP($1); 
            """, v2):
            TxRepl(o, i, """
                long_$3 = $4;
                if ( long_$3 < 0) {
                long_$3 += $5;
                }
                if ((temp[$2] = Py$6_GetItem ( $7 , long_$3 )) == 0) goto label_$8;
                Py_INCREF(temp[$2]);
                """, v2)
            return True       
    if TxMatch(o, i, """              
        temp[$1] = PyInt_FromLong ( $2 );
        if ($4) {
        temp[$3] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $5 );
        CLEARTEMP($1);
        } else {
        >1
        }
        """, v2) and ('temp[' + v2[1] + ']') not in v2[5]:
            TxRepl(o, i, """
                if ($4) {
                temp[$3] = PyInt_FromLong ( ($2) $5 );
                } else {
                temp[$1] = PyInt_FromLong ( $2 );
                >1
                }
                """, v2)
            return True
    if TxMatch(o,i, """ 
        temp[$5] = PyInt_FromLong( $8 );
        if ((int_$1 = PyDict_Contains ( $2 , temp[$5] )) == -1) goto label_$6;
        CLEARTEMP($5);
        if ( int_$1 ) {
        PyLine = $16;
        PyAddr = $17;
        temp[$5] = PyInt_FromLong( $8 );
        if ((temp[$3] = PyDict_GetItem ( $2 , temp[$5] )) == 0) goto label_$6;
        CLEARTEMP($5);
        Py_INCREF(temp[$3]);
        """, v2):
        TxRepl(o, i, """
            temp[$5] = PyInt_FromLong( $8 );
            temp[$3] = PyDict_GetItem ( $2 , temp[$5] );
            CLEARTEMP($5);
            int_$1 = temp[$3] != 0;
            if ( int_$1 ) {
            PyLine = $16;
            PyAddr = $17;
            Py_INCREF(temp[$3]);
            """, v2)
        return True  
    return False                 
                
def tune_if_dotcomma(o, i):
    v2 = {}
    assert type(i) is int
    oi = o[i]
    assert type(oi) is str
    if oi.startswith('if ( PyString_AsStringAndSize ('):
        if TxMatch(o, i, """
            if ( PyString_AsStringAndSize ( $0 , &charref_$4 , &Py_ssize_t_$3 ) == -1) goto label_$10;
            int_$11 = $16;
            if ( !int_$11 ) {
            if ( PyString_AsStringAndSize ( $0 , &charref_$4 , &Py_ssize_t_$3 ) == -1) goto label_$10;
            int_$11 = $17;
            }""", v2):   
                TxRepl(o, i, """
                    if ( PyString_AsStringAndSize ( $0 , &charref_$4 , &Py_ssize_t_$3 ) == -1) goto label_$10;
                    int_$11 = $16;
                    if ( !int_$11 ) {
                    int_$11 = $17;
                    }""", v2)
                return True         
        if TxMatch(o, i, """
            if ( PyString_AsStringAndSize ( $0 , &$1 , &$12 ) == -1) goto label_$3;
            int_$4 = $12 - $7;
            charref_$5 = $1 + int_$4;
            int_$6 = ($12 >= $7 && 0 == memcmp($8, charref_$5, $7));
            """, v2):   
                TxRepl(o, i, """
                    if ( PyString_AsStringAndSize ( $0 , &$1 , &$12 ) == -1) goto label_$3;
                    int_$6 = ($12 >= $7 && 0 == memcmp($8, $1 + ($12 - $7), $7));
                    """, v2)
                return True   

    elif oi.startswith('if ((Py_ssize_t_'):     
        pass
    elif oi.startswith('if ((int_'):     
        if ' = _Direct_' in oi:
            if TxMatch(o, i, """if (($2 = _Direct_$5) == -1) goto $3;
                temp[$0] = PyBool_FromLong($2);
                $12 = PyObject_IsTrue ( temp[$0] );
                CLEARTEMP($0);""", v2) and v2[2] != v2[12]:
                    TxRepl(o, i, """if (($12 = _Direct_$5) == -1) goto $3;""", v2)
                    return True    
                            
                
            if TxMatch(o, i, """if (($2 = _Direct_$5) == -1) goto $3;
                CLEARTEMP($6);              
                temp[$0] = PyBool_FromLong($2);
                $12 = PyObject_IsTrue ( temp[$0] );
                CLEARTEMP($0);""", v2) and v2[2] != v2[12]:
                    TxRepl(o, i, """if (($12 = _Direct_$5) == -1) goto $3;
                                CLEARTEMP($6);""", v2)
                    return True    
        if i+1 < len(o):
            if o[i+1].startswith('temp[') and TxMatch(o, i, """
                if ((int_$2 = $5) == -1) goto label_$10;
                temp[$0] = PyBool_FromLong ( !(int_$2) );
                CLEARTEMP($0);
                """, v2): 
                        TxRepl(o, i, """
                            if ($5 == -1) goto label_$10;
                            """, v2) 
                        return True

            if o[i+1].startswith('CLEARTEMP('):
                if TxMatch(o, i, """
                    if ((int_$1 = $9temp[$10]$11) == -1) goto label_$0;
                    CLEARTEMP($10);
                    Loc_int_$3 = int_$1;
                    """, v2): 
                            TxRepl(o, i, """
                                if ((Loc_int_$3 = $9temp[$10]$11) == -1) goto label_$0;
                                CLEARTEMP($10);
                                """, v2) 
                            return True
                if TxMatch(o, i, """
                    if ((int_$2 = PyObject_Not( temp[$1] )) == -1) goto label_$10;
                    CLEARTEMP($1);
                    temp[$0] = PyBool_FromLong ( int_$2 );
                    if ( int_$2 ) {
                    CLEARTEMP($0);                        
                    """, v2): 
                            TxRepl(o, i, """
                                if ((int_$2 = PyObject_Not( temp[$1] )) == -1) goto label_$10;
                                CLEARTEMP($1);
                                if ( !int_$2 ) {
                                temp[$0] = Py_False;
                                Py_INCREF(temp[$0]);
                                } else { 
                                """, v2) 
                            return True        
            if o[i+1].startswith('Loc_int_') and TxMatch(o, i, """
                if ((int_$3 = $4) == -1) goto label_$0;
                Loc_int_$5 = int_$3;
                """, v2): 
                        TxRepl(o, i, """
                            if ((Loc_int_$5 = $4) == -1) goto label_$0;
                            """, v2) 
                        return True

            
    elif oi.startswith('if ((temp['):     
        if '_c_BINARY_SUBSCR' in oi:
            if i+1 < len(o) and o[i+1].startswith('int_'):
                if TxMatch(o, i, """if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;
                    int_$1 = $12;
                    CLEARTEMP($0);
                    if (!( int_$1 )) {
                    if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;
                    int_$1 = $11;
                    CLEARTEMP($0);
                    }""", v2):
                        TxRepl(o, i, """if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;
                            int_$1 = ($12) || ($11);
                            CLEARTEMP($0);""", v2)
                        return True  
                if TxMatch(o, i, """if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;
                    int_$1 = $12;
                    CLEARTEMP($0);
                    if ( !int_$1 ) {
                    if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;
                    int_$1 = $11;
                    CLEARTEMP($0);
                    }""", v2):
                        TxRepl(o, i, """if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $4 , $3 )) == 0) goto $7;
                            int_$1 = ($12) || ($11);
                            CLEARTEMP($0);""", v2)
                        return True  
 
        elif 'PyList_GetItem' in oi:
                if TxMatch(o, i, """
                    if ((temp[$0] = PyList_GetItem ($10)) == 0) goto label_$11;
                    Py_INCREF(temp[$0]);
                    if ((temp[$1] = _Direct_$12 ( temp[$0] )) == 0) goto label_$11;
                    CLEARTEMP($0);""", v2):
                        TxRepl(o, i, """
                    if ((temp[$0] = PyList_GetItem ($10)) == 0) goto label_$11;
                    if ((temp[$1] = _Direct_$12 ( temp[$0] )) == 0) goto label_$11;
                    temp[$0] = 0;""", v2)
                        return True 
                if TxMatch(o, i, """
                    if ((temp[$0] = PyList_GetItem ($11)) == 0) goto label_$10;
                    Py_INCREF(temp[$0]);
                    if (($15 = _Direct_$12(temp[$0])) == -1) goto label_$10;
                    CLEARTEMP($0);""", v2):
                        TxRepl(o, i, """
                            if ((temp[$0] = PyList_GetItem ($11)) == 0) goto label_$10;
                            if (($15 = _Direct_$12(temp[$0])) == -1) goto label_$10;
                            temp[$0] = 0;""", v2)
                        return True 
                if TxMatch(o, i, """
                    if ((temp[$0] = PyList_GetItem ($10)) == 0) goto label_$11;
                    Py_INCREF(temp[$0]);
                    if (($5 = _Direct_$12 ($7temp[$0]$8))$6) goto label_$11;
                    CLEARTEMP($0);""", v2):
                        TxRepl(o, i, """
                    if ((temp[$0] = PyList_GetItem ($10)) == 0) goto label_$11;
                    if (($5 = _Direct_$12 ($7temp[$0]$8))$6) goto label_$11;
                    temp[$0] = 0;""", v2)
                        return True  
        elif 'PyObject_RichCompare' in oi:    
            if TxMatch(o, i, """
                if ((temp[$2] = PyObject_RichCompare ( $11, Py_$12 )) == 0) goto label_$14;
                if ((int_$15 = PyObject_IsTrue( temp[$2] )) == -1) goto label_$14;
                CLEARTEMP($2);""", v2):            
                    TxRepl(o, i, """
                        if ((int_$15 = PyObject_RichCompareBool ( $11, Py_$12 )) == -1) goto label_$14;""", v2)
                    return True                                  
        elif '_PyEval_ApplySlice' in oi: 
            pass
        elif 'PyBool_FromLong' in oi:    
            if TxMatch(o, i, """
                if ((temp[$1] = PyBool_FromLong ($9)) == 0) goto label_$0;
                if ((int_$3 = PyObject_Not ( temp[$1] )) == -1) goto label_$0;
                CLEARTEMP($1);""", v2):            
                    TxRepl(o, i, """
                        int_$3 = ! ($9);""", v2)
                    return True     
            if TxMatch(o, i, """if ((temp[$0] = PyBool_FromLong ( $2 )) == 0) goto $3;
                $2 = PyObject_IsTrue ( temp[$0] );
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, '', v2)
                    return True     
            if TxMatch(o, i, """if ((temp[$0] = PyBool_FromLong ( $1 )) == 0) goto $3;
                int_$2 = PyObject_IsTrue ( temp[$0] );
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """int_$2 = $1;""", v2)
                    return True                   
                        
            if TxMatch(o, i, """if ((temp[$1] = PyBool_FromLong ( $2 )) == 0) goto $0;
                if (($3 = PyObject_IsTrue ( temp[$1] )) == -1) goto $0;
                CLEARTEMP($1);""", v2):
                    TxRepl(o, i, """$3 = ($2);""", v2)
                    return True     
            if TxMatch(o, i, """if ((temp[$0] = PyBool_FromLong ($1)) == 0) goto $5;
                $2 = PyObject_IsTrue(temp[$0]);
                CLEARTEMP($0);""", v2):
                    v2[1] = v2[1].strip()
                    TxRepl(o, i, """$2 = $1;""", v2)                
                    return True  
            if TxMatch(o, i, """
                if ((temp[$0] = PyBool_FromLong ( int_$10 )) == 0) goto label_$12;
                if ((temp[$1] = PyTuple_New ( 1 )) == 0) goto label_$12;
                PyTuple_SET_ITEM ( temp[$1] , 0 , temp[$0] );
                if ((temp[$0] = PyBool_Type.tp_new ( &PyBool_Type , temp[$1] , NULL )) == 0) goto label_$12;
                CLEARTEMP($1);
                int_$10 = PyObject_IsTrue ( temp[$0] );""", v2):
                    TxRepl(o, i, '', v2)                
                    return True  


        elif 'PyInt_FromSsize_t' in oi:
            if TxMatch(o, i, """if ((temp[$1] = PyInt_FromSsize_t ($2)) == 0) goto $3;
                    Py_ssize_t_$4 = PyInt_AsSsize_t ( temp[$1] );
                    CLEARTEMP($1);""", v2):  
                v2[3] = v2[3].strip()
                TxRepl(o, i, """Py_ssize_t_$4 = $2;""", v2)
                return True
            
            
            if TxMatch(o, i, """if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $3;
                if (PyInt_CheckExact( $2 )) {
                $5 = PyInt_AS_LONG ( $2 );
                $6 = PyInt_AS_LONG ( temp[$0] );
                $7 = $5 + $6;
                if (( $7 ^ $5 ) < 0 && ( $7 ^ $6 ) < 0) goto $4 ;
                temp[$11] = PyInt_FromLong ( $7 );
                } else if (PyFloat_CheckExact( $2 )) {
                temp[$11] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) + (double)PyInt_AS_LONG ( temp[$0] ));
                } else { $4 :;
                if ((temp[$11] = PyNumber_InPlaceAdd ( $2 , temp[$0] )) == 0) goto $3;
                }
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """if (PyInt_CheckExact( $2 )) {
                        $5 = PyInt_AS_LONG ( $2 );
                        $6 = $1;
                        $7 = $5 + $6;
                        if (( $7 ^ $5 ) < 0 && ( $7 ^ $6 ) < 0) goto $4 ;
                        temp[$11] = PyInt_FromLong ( $7 );
                        } else if (PyFloat_CheckExact( $2 )) {
                        temp[$11] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) + (double)($1));
                        } else { $4 :;
                        if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $3;
                        if ((temp[$11] = PyNumber_InPlaceAdd ( $2 , temp[$0] )) == 0) goto $3;
                        CLEARTEMP($0);
                        }""", v2)
                    return True
                
            if TxMatch(o, i, """if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $3;
                if (PyInt_CheckExact( $2 )) {
                $5 = PyInt_AS_LONG ( $2 );
                $6 = PyInt_AS_LONG ( temp[$0] );
                $7 = $5 + $6;
                if (( $7 ^ $5 ) < 0 && ( $7 ^ $6 ) < 0) goto $4 ;
                temp[$11] = PyInt_FromLong ( $7 );
                } else { $4 :;
                if ((temp[$11] = PyNumber_InPlaceAdd ( $2 , temp[$0] )) == 0) goto $3;
                }
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """if (PyInt_CheckExact( $2 )) {
                        $5 = PyInt_AS_LONG ( $2 );
                        $6 = $1;
                        $7 = $5 + $6;
                        if (( $7 ^ $5 ) < 0 && ( $7 ^ $6 ) < 0) goto $4 ;
                        temp[$11] = PyInt_FromLong ( $7 );
                        } else { $4 :;
                        if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $3;
                        if ((temp[$11] = PyNumber_InPlaceAdd ( $2 , temp[$0] )) == 0) goto $3;
                        CLEARTEMP($0);
                        }""", v2)
                    return True

            if TxMatch(o, i, """if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $2;
                $3 = PyInt_AsLong(temp[$0]);
                Py_CLEAR(temp[$0]);
                temp[$0] = 0;""", v2):
                    TxRepl(o, i, """$3 = $1;""", v2)
                    return True   
                
            if TxMatch(o, i, """if ((temp[$0] = PyInt_FromSsize_t ($2)) == 0) goto $3;
                long_$5 = PyInt_AS_LONG ( temp[$0] );
                long_$4 = long_$5 - $6;
                temp[$1] = PyInt_FromLong ( long_$4 );
                CLEARTEMP($0);""", v2):
                    v2[2] = v2[2].strip()
                    TxRepl(o, i, """long_$4 = ($2) - $6; 
                                temp[$1] = PyInt_FromLong ( long_$4 );""", v2)
                    return True
                
            if TxMatch(o, i, """if ((temp[$0] = PyInt_FromSsize_t ($2)) == 0) goto $3;
                long_$5 = PyInt_AS_LONG ( temp[$0] );
                long_$4 = long_$5 + $6;
                temp[$1] = PyInt_FromLong ( long_$4 );
                CLEARTEMP($0);""", v2):
                    v2[2] = v2[2].strip()
                    TxRepl(o, i, """long_$4 = ($2) + $6; 
                                temp[$1] = PyInt_FromLong ( long_$4 );""", v2)
                    return True
                                            
            if TxMatch(o, i, """if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;
                if (PyInt_CheckExact( $3 )) {
                $4 = PyInt_AS_LONG ( $3 );
                $5 = PyInt_AS_LONG ( temp[$1] );
                $6 = $4 - $5;
                if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;
                temp[$2] = PyInt_FromLong ( $6 );
                } else if (PyFloat_CheckExact( $3 )) {
                temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) - (double)PyInt_AS_LONG ( temp[$1] ));
                } else { $7 :;
                if ((temp[$2] = PyNumber_Subtract ( $3 , temp[$1] )) == 0) goto $0;
                }
                CLEARTEMP($1);""",v2):
                    TxRepl(o, i, """if (PyInt_CheckExact( $3 )) {
                        $4 = PyInt_AS_LONG ( $3 );
                        $5 = $10;
                        $6 = $4 - $5;
                        if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;
                        temp[$2] = PyInt_FromLong ( $6 );
                        } else if (PyFloat_CheckExact( $3 )) {
                        temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) - (double)$10);
                        } else { $7 :;
                        if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;
                        if ((temp[$2] = PyNumber_Subtract ( $3 , temp[$1] )) == 0) goto $0;
                        CLEARTEMP($1);
                        }""", v2)
                    return True
                
            if TxMatch(o, i, """if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;
                if (PyInt_CheckExact( $3 )) {
                $4 = PyInt_AS_LONG ( $3 );
                $5 = PyInt_AS_LONG ( temp[$1] );
                $6 = $4 - $5;
                if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;
                temp[$2] = PyInt_FromLong ( $6 );
                } else { $7 :;
                if ((temp[$2] = PyNumber_Subtract ( $3 , temp[$1] )) == 0) goto $0;
                }
                CLEARTEMP($1);""",v2):
                    TxRepl(o, i, """if (PyInt_CheckExact( $3 )) {
                        $4 = PyInt_AS_LONG ( $3 );
                        $5 = $10;
                        $6 = $4 - $5;
                        if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;
                        temp[$2] = PyInt_FromLong ( $6 );
                        } else { $7 :;
                        if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;
                        if ((temp[$2] = PyNumber_Subtract ( $3 , temp[$1] )) == 0) goto $0;
                        CLEARTEMP($1);
                        }""", v2)
                    return True
                
                
            if TxMatch(o, i, """if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;
                if (PyInt_CheckExact( $3 )) {
                $4 = PyInt_AS_LONG ( temp[$1] );
                $5 = PyInt_AS_LONG ( $3 );
                $6 = $4 - $5;
                if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;
                temp[$2] = PyInt_FromLong ( $6 );
                } else if (PyFloat_CheckExact( $3 )) {
                temp[$2] = PyFloat_FromDouble((double)PyInt_AS_LONG ( temp[$1] ) - PyFloat_AS_DOUBLE($3));
                } else { $7 :;
                if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $3 )) == 0) goto $0;
                }
                CLEARTEMP($1);""",v2):
                    TxRepl(o, i, """if (PyInt_CheckExact( $3 )) {
                        $4 = $10;
                        $5 = PyInt_AS_LONG ( $3 );
                        $6 = $4 - $5;
                        if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;
                        temp[$2] = PyInt_FromLong ( $6 );
                        } else if (PyFloat_CheckExact( $3 )) {
                        temp[$2] = PyFloat_FromDouble((double)$10 - PyFloat_AS_DOUBLE($3));
                        } else { $7 :;
                        if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;
                        if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $3 )) == 0) goto $0;
                        CLEARTEMP($1);
                        }""", v2)
                    return True
                
            if TxMatch(o, i, """if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;
                if (PyInt_CheckExact( $3 )) {
                $4 = PyInt_AS_LONG ( temp[$1] );
                $5 = PyInt_AS_LONG ( $3 );
                $6 = $4 - $5;
                if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;
                temp[$2] = PyInt_FromLong ( $6 );
                } else { $7 :;
                if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $3 )) == 0) goto $0;
                }
                CLEARTEMP($1);""",v2):
                    TxRepl(o, i, """if (PyInt_CheckExact( $3 )) {
                        $4 = $10;
                        $5 = PyInt_AS_LONG ( $3 );
                        $6 = $4 - $5;
                        if (( $6 ^ $4 ) < 0 && ( $6 ^~ $5 ) < 0) goto $7 ;
                        temp[$2] = PyInt_FromLong ( $6 );
                        } else { $7 :;
                        if ((temp[$1] = PyInt_FromSsize_t ( $10 )) == 0) goto $0;
                        if ((temp[$2] = PyNumber_Subtract ( temp[$1] , $3 )) == 0) goto $0;
                        CLEARTEMP($1);
                        }""", v2)
                    return True
            if TxMatch(o, i, """if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $3;
                if ((long_$4 = PyInt_AsLong ( temp[$0] )) == -1) goto $3;
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """long_$4 = $1;""", v2)
                    return True

            if TxMatch(o, i, """if ((temp[$19] = PyInt_FromSsize_t ( $17 )) == 0) goto $12;
                if ($11) {
                long_$18 = PyInt_AS_LONG ( temp[$19] );                         
                if ((int_$3 = $14) == -1) goto $12;
                temp[$0] = PyBool_FromLong(int_$3);
                } else {
                if ((temp[$2] = $15) == 0) goto $12;
                if ((temp[$0] = $16) == 0) goto $12;
                CLEARTEMP($2);
                }
                CLEARTEMP($19);
                if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $12;
                CLEARTEMP($0);""", v2) and v2[19] != v2[0] and v2[19] != v2[2] and """temp[ + v2[19] + ]""" not in v2[14]:
                    TxRepl(o, i, """if ($11) {
                        long_$18 = $17;                         
                        if ((int_$1 = $14) == -1) goto $12;
                        } else {
                        if ((temp[$19] = PyInt_FromSsize_t ( $17 )) == 0) goto $12;
                        if ((temp[$2] = $15) == 0) goto $12;
                        if ((temp[$0] = $16) == 0) goto $12;
                        CLEARTEMP($2);
                        CLEARTEMP($19);                    
                        if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $12;
                        CLEARTEMP($0);
                        }""", v2)
                    return True 

            if TxMatch(o, i, """if ((temp[$0] = PyInt_FromSsize_t ( $1 )) == 0) goto $2;
                $3 = PyInt_AS_LONG ( temp[$0] );
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """$3 = $1;""", v2)
                    return True 
                
            if TxMatch(o, i, """if ((temp[$0] = PyInt_FromSsize_t ( $8 )) == 0) goto $4;
                if (PyInt_CheckExact( $2 )) {
                $5 = PyInt_AS_LONG ( $2 );
                $6 = PyInt_AS_LONG ( temp[$0] );
                $7 = $5 + $6;
                if (( $7 ^ $5 ) < 0 && ( $7 ^ $6 ) < 0) goto $3 ;
                temp[$1] = PyInt_FromLong ( $7 );
                } else { $3 :;
                if ((temp[$1] = PyNumber_Add ( $2 , temp[$0] )) == 0) goto $4;
                }
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """if (PyInt_CheckExact( $2 )) {
                        $5 = PyInt_AS_LONG ( $2 );
                        $6 = $8;
                        $7 = $5 + $6;
                        if (( $7 ^ $5 ) < 0 && ( $7 ^ $6 ) < 0) goto $3 ;
                        temp[$1] = PyInt_FromLong ( $7 );
                        } else { $3 :;
                        if ((temp[$0] = PyInt_FromSsize_t ( $8 )) == 0) goto $4;                                        
                        if ((temp[$1] = PyNumber_Add ( $2 , temp[$0] )) == 0) goto $4;
                        CLEARTEMP($0);
                        }""", v2)
                    return True 
                                
            if TxMatch(o, i, """if ((temp[$0] = PyInt_FromSsize_t ( $2 )) == 0) goto $3;
                $4 = PyInt_AS_LONG ( temp[$0] );
                $5 = $6 - $4;
                temp[$1] = PyInt_FromLong ( $5 );
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """$4 = $2;
                        $5 = $6 - $4;
                        temp[$1] = PyInt_FromLong ( $5 );""", v2)
                    return True             

            if TxMatch(o, i, """if ((temp[$2] = PyInt_FromSsize_t ( $7 )) == 0) goto $6;
                if (PyInt_CheckExact( $4 )) {
                $8 = PyInt_AS_LONG ( $4 );
                $9 = PyInt_AS_LONG ( temp[$2] );
                $10 = $8 + $9;
                if (( $10 ^ $8 ) < 0 && ( $10 ^ $9 ) < 0) goto $5 ;
                temp[$3] = PyInt_FromLong ( $10 );
                } else if (PyFloat_CheckExact( $4 )) {
                temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($4) + (double)PyInt_AS_LONG ( temp[$2] ));
                } else { $5 :;
                if ((temp[$3] = PyNumber_Add ( $4 , temp[$2] )) == 0) goto $6;
                }
                CLEARTEMP($2);""", v2):
                    TxRepl(o, i, """if (PyInt_CheckExact( $4 )) {
                        $8 = PyInt_AS_LONG ( $4 );
                        $9 = $7;
                        $10 = $8 + $9;
                        if (( $10 ^ $8 ) < 0 && ( $10 ^ $9 ) < 0) goto $5 ;
                        temp[$3] = PyInt_FromLong ( $10 );
                        } else if (PyFloat_CheckExact( $4 )) {
                        temp[$3] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($4) + (double)$7);
                        } else { $5 :;
                        if ((temp[$2] = PyInt_FromSsize_t ( $7 )) == 0) goto $6;                    
                        if ((temp[$3] = PyNumber_Add ( $4 , temp[$2] )) == 0) goto $6;
                        CLEARTEMP($2);
                        }""", v2)
                    return True   
            if TxMatch(o, i, """if ((temp[$0] = PyInt_FromSsize_t ( $2 )) == 0) goto $5;
                if ((temp[$1] = _PyEval_ApplySlice ( $4 , temp[$0] , NULL )) == 0) goto $5;
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """if ((temp[$1] = PySequence_GetSlice ( $4 , $2 , PY_SSIZE_T_MAX )) == 0) goto $5;""", v2)
                    return True 

        elif 'PyTuple_New' in oi:
            if TxMatch(o, i, """
                if ((temp[$1] = PyTuple_New ( 1 )) == 0) goto label_$2;
                PyTuple_SET_ITEM ( temp[$1] , 0 , temp[$0] );
                if ((temp[$0] = PyBool_Type.tp_new ( &PyBool_Type , temp[$1] , NULL )) == 0) goto label_$2;
                CLEARTEMP($1);
                int_$3 = PyObject_IsTrue ( temp[$0] );
                """, v2):
                    TxRepl(o, i, """if ((int_$3 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$2;""", v2)
                    return True 
        
        elif 'PyDict_GetItem' in oi:
            l_v_2 = []
            l_v_3 = []
            if TextMatch(oi, ('if ((temp[', '*', '] = PyDict_GetItem', '*'), l_v_2):
                if i < (len(o) - 4) and TextMatch(o[i+1], ('Py_INCREF(temp[', l_v_2[0], ']);'), []) and\
                    TextMatch(o[i+2], ('if ((temp[', '*', '] = PyList_GetItem ( temp[', l_v_2[0], ']', '*'), l_v_3) and\
                    TextMatch(o[i+3], ('Py_INCREF(temp[', l_v_3[0], ']);'), []) and\
                    TextMatch(o[i+4], ('CLEARTEMP(', l_v_2[0], ');'), []):
                        o[i+4] = 'temp[' + l_v_2[0] + '] = 0;'
                        del o[i+1]
                        return True
                                    
            if TxMatch(o, i, """if ((temp[$1] = PyDict_GetItem ($2)) == 0) goto $3;
                Py_INCREF(temp[$1]);
                $4 = PyInt_AsSsize_t ( temp[$1] ); 
                CLEARTEMP($1);""", v2):
                    TxRepl(o, i, """if ((temp[$1] = PyDict_GetItem ($2)) == 0) goto $3;
                        $4 = PyInt_AsSsize_t ( temp[$1] ); 
                        temp[$1] = 0;""", v2)
                    return True    
    
    
            
            if TxMatch(o, i, """if ((temp[$1] = PyDict_GetItem ( $6 , $5 )) == 0) goto $3;
                Py_INCREF(temp[$1]);
                if ((temp[$2] = PyObject_GetItem ( temp[$1] , $4 )) == 0) goto $3;
                CLEARTEMP($1);""", v2):
                    TxRepl(o, i, """if ((temp[$1] = PyDict_GetItem ( $6 , $5 )) == 0) goto $3;
                                if ((temp[$2] = PyObject_GetItem ( temp[$1] , $4 )) == 0) goto $3;
                                temp[$1] = 0;""", v2)
                    return True  
                
        
            if TxMatch(o, i, """if ((temp[$1] = PyDict_GetItem ( $3 , $4 )) == 0) goto $0;
                Py_INCREF(temp[$1]);
                if ((temp[$2] = PyObject_GetAttr ( temp[$1] , $5 )) == 0) goto $0;
                CLEARTEMP($1);""", v2):
                    TxRepl(o, i, """if ((temp[$1] = PyDict_GetItem ( $3 , $4 )) == 0) goto $0;
                        if ((temp[$2] = PyObject_GetAttr ( temp[$1] , $5 )) == 0) goto $0;
                        temp[$1] = 0;""", v2)
                    return True  
        
            if TxMatch(o, i, """if ((temp[$0] = PyDict_GetItem ($5)) == 0) goto $3;
                Py_INCREF(temp[$0]);
                if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $3;
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """if ((temp[$0] = PyDict_GetItem ($5)) == 0) goto $3;
                        if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto $3;
                        temp[$0] = 0;""", v2)
                    return True 
                
            if TxMatch(o, i, """
                if ((temp[$0] = PyDict_GetItem ( $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$0]);
                if (PyInt_CheckExact( $3 )) {
                long_$4 = PyInt_AS_LONG ( $3 );
                if ( long_$4 < 0) {
                long_$4 += PyList_GET_SIZE(temp[$0]);
                }
                if ((temp[$1] = PyList_GetItem ( temp[$0] , long_$4 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                } else {
                if ((temp[$1] = PyObject_GetItem ( temp[$0] , $3 )) == 0) goto label_$2;
                }
                CLEARTEMP($0);  
                LETLOCAL ( $10 , temp[$1] );
                temp[$1] = 0;                
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = PyDict_GetItem ( $5 )) == 0) goto label_$2;
                        if (PyInt_CheckExact( $3 )) {
                        long_$4 = PyInt_AS_LONG ( $3 );
                        if ( long_$4 < 0) {
                        long_$4 += PyList_GET_SIZE(temp[$0]);
                        }
                        if ((GETLOCAL($10) = PyList_GetItem ( temp[$0] , long_$4 )) == 0) goto label_$2;
                        Py_INCREF(GETLOCAL($10));
                        } else {
                        if ((GETLOCAL($10) = PyObject_GetItem ( temp[$0] , $3 )) == 0) goto label_$2;
                        }
                        temp[$0] = 0;                
                        """, v2)
                    return True 

            if TxMatch(o, i, """
                if ((temp[$0] = PyDict_GetItem ( $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$0]);
                if (PyInt_CheckExact( $3 )) {
                long_$4 = PyInt_AS_LONG ( $3 );
                if ( long_$4 < 0) {
                long_$4 += PyList_GET_SIZE(temp[$0]);
                }
                if ((temp[$1] = PyList_GetItem ( temp[$0] , long_$4 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                } else {
                if ((temp[$1] = PyObject_GetItem ( temp[$0] , $3 )) == 0) goto label_$2;
                }
                CLEARTEMP($0);  
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = PyDict_GetItem ( $5 )) == 0) goto label_$2;
                        if (PyInt_CheckExact( $3 )) {
                        long_$4 = PyInt_AS_LONG ( $3 );
                        if ( long_$4 < 0) {
                        long_$4 += PyList_GET_SIZE(temp[$0]);
                        }
                        if ((temp[$1] = PyList_GetItem ( temp[$0] , long_$4 )) == 0) goto label_$2;
                        Py_INCREF(temp[$1]);
                        } else {
                        if ((temp[$1] = PyObject_GetItem ( temp[$0] , $3 )) == 0) goto label_$2;
                        }
                        temp[$0] = 0;                
                        """, v2)
                    return True 
                        
            if TxMatch(o, i, """
                if ((temp[$2] = PyDict_GetItem ( $3 )) == 0) goto label_$0;
                Py_INCREF(temp[$2]);
                if ((int_$4 = PyObject_Not ( temp[$2] )) == -1) goto label_$0;
                CLEARTEMP($2);                        
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$2] = PyDict_GetItem ( $3 )) == 0) goto label_$0;
                        if ((int_$4 = PyObject_Not ( temp[$2] )) == -1) goto label_$0;
                        temp[$2] = 0;          
                        """, v2)
                    return True 
                        
                        
        elif 'PyObject_GetItem' in oi:            
            if TxMatch(o, i, """if ((temp[$0] = PyObject_GetItem ( $6 , $7 )) == 0) goto $5;
                if (PyInt_CheckExact( $7 ) && ($4 = PyInt_AS_LONG ( $7 )) < LONG_MAX ) {
                $4 = $4 + 1;
                if ((temp[$2] = __c_BINARY_SUBSCR_Int ( $6 , $4 )) == 0) goto $5;
                } else {
                if ((temp[$1] = PyNumber_Add ( $7 , consts[$3] )) == 0) goto $5;
                if ((temp[$2] = PyObject_GetItem ( $6 , temp[$1] )) == 0) goto $5;
                CLEARTEMP($1);
                }""", v2):
                    TxRepl(o, i, """if (PyInt_CheckExact( $7 ) && ($4 = PyInt_AS_LONG ( $7 )) < LONG_MAX ) {
                        if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $6 , $4 , $7 )) == 0) goto $5;          
                        if ((temp[$2] = __c_BINARY_SUBSCR_Int ( $6 , $4 + 1 )) == 0) goto $5;
                        } else {
                        if ((temp[$0] = PyObject_GetItem ( $6 , $7 )) == 0) goto $5;
                        if ((temp[$1] = PyNumber_Add ( $7 , consts[$3] )) == 0) goto $5;
                        if ((temp[$2] = PyObject_GetItem ( $6 , temp[$1] )) == 0) goto $5;
                        CLEARTEMP($1);
                        }""", v2)
                    return True   
        if i+1 < len(o) and o[i+1].startswith('Py_INCREF(temp['):
            if i < len(o) - 10:
                l_v_2 = []
                l_v_3 = []
                if TextMatch(oi, ('if ((temp[', '*', '] = PyList_GetItem', '*'), l_v_2):
                    if  TextMatch(o[i+1], ('Py_INCREF(temp[', l_v_2[0], ']);'), []) and\
                        TextMatch(o[i+2], ('if (PyList_CheckExact( temp[', l_v_2[0], '] )) {'), []) and\
                        TextMatch(o[i+3], ('if ( PyList_SetItem ( temp[', l_v_2[0], '] , ', '*'), []) and\
                        TextMatch(o[i+4], ('} else {',), []) and\
                        TextMatch(o[i+5], ('if ( PyObject_SetItem ( temp[', l_v_2[0], '] , ', '*'), []) and\
                        TextMatch(o[i+6], ('Py_CLEAR(temp[', '*', ']);'), l_v_3) and\
                        TextMatch(o[i+7], ('}',), []) and\
                        TextMatch(o[i+8], ('CLEARTEMP(', l_v_2[0],');'), []) and\
                        TextMatch(o[i+9], ('temp[', l_v_3[0], '] = 0;'), []) and l_v_3[0] != l_v_2[0]:
                            o[i+8] = 'temp[' + l_v_2[0] + '] = 0;'
                            del o[i+1]
                            return True

            if TxMatch(o, i, """if ((temp[$0] = Py$11_GetItem ( $1 , $2 )) == 0) goto $3;
                            Py_INCREF(temp[$0]);
                            $12
                            CLEARTEMP($0);""", v2):
                typ = v2[11]
                temp = v2[0]
                action = v2[12]
                assert type(action) is str
                assert type(typ) is str                
                if typ in ('Dict', 'List', 'Tuple') and '_Direct_' not in action and allowed_no_incref(action, temp, v2[3]):
                    TxRepl(o, i, ('if ((temp[$0] = Py$11_GetItem ( $1 , $2 )) == 0) goto $3;', 
                            '$12',
                            'temp[$0] = 0;'), v2)
                    return True  
            elif TxMatch(o, i, """if ((temp[$0] = Py$11_GetItem ( $1 , $2 )) == 0) goto $3;
                            Py_INCREF(temp[$0]);
                            CLEARTEMP($15);
                            $12
                            CLEARTEMP($0);""", v2) and v2[15] != v2[0] and ('temp['+v2[15]+']') in oi and ('temp['+v2[15]+']') != v2[1]:
                typ = v2[11]
                temp = v2[0]
                action = v2[12]
                assert type(action) is str
                assert type(typ) is str                                
                if typ in ('Dict', 'List', 'Tuple') and '_Direct_' not in action and allowed_no_incref(action, temp, v2[3]):
                    TxRepl(o, i, ('if ((temp[$0] = Py$11_GetItem ( $1 , $2 )) == 0) goto $3;', 
                            'CLEARTEMP($15);',
                            '$12',
                            'temp[$0] = 0;'), v2)
                    return True  
            if TxMatch(o, i, """
                if ((temp[$0] = PyTuple_GetItem ( $15 , $16 )) == 0) goto label_$10;
                Py_INCREF(temp[$0]);
                if ((temp[$1] = Py$3_GetItem($2, temp[$0])) == 0) goto label_$12;
                Py_INCREF(temp[$1]);
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = PyTuple_GetItem ( $15 , $16 )) == 0) goto label_$10;
                        if ((temp[$1] = Py$3_GetItem($2, temp[$0])) == 0) goto label_$12;
                        Py_INCREF(temp[$1]);
                        temp[$0] = 0;""", v2)
                    return True                  
            elif TxMatch(o, i, """
                if ((temp[$0] = PyList_GetItem ( $15 , $16 )) == 0) goto label_$10;
                Py_INCREF(temp[$0]);
                if ((temp[$1] = Py$3_GetItem($2, temp[$0])) == 0) goto label_$12;
                Py_INCREF(temp[$1]);
                CLEARTEMP($0);""", v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = PyList_GetItem ( $15 , $16 )) == 0) goto label_$10;
                        if ((temp[$1] = Py$3_GetItem($2, temp[$0])) == 0) goto label_$12;
                        Py_INCREF(temp[$1]);
                        temp[$0] = 0;""", v2)
                    return True                  
            elif TxMatch(o, i, """
                if ((temp[$2] = PyTuple_GetItem ( $10 , $12 )) == 0) goto label_$0;
                Py_INCREF(temp[$2]);
                if ((temp[$3] = PyTuple_GetItem ( $11 , $13 )) == 0) goto label_$0;
                Py_INCREF(temp[$3]);
                int_$5 = temp[$2] == temp[$3];
                CLEARTEMP($2);
                CLEARTEMP($3);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$2] = PyTuple_GetItem ( $10 , $12 )) == 0) goto label_$0;
                        if ((temp[$3] = PyTuple_GetItem ( $11 , $13 )) == 0) goto label_$0;
                        int_$5 = temp[$2] == temp[$3];
                        temp[$2] = 0;
                        temp[$3] = 0;
                        """, v2)
                    return True    
            elif TxMatch(o, i, """
                if ((temp[$2] = PyList_GetItem ( $10 , $12 )) == 0) goto label_$0;
                Py_INCREF(temp[$2]);
                if ((temp[$3] = PyList_GetItem ( $11 , $13 )) == 0) goto label_$0;
                Py_INCREF(temp[$3]);
                int_$5 = temp[$2] == temp[$3];
                CLEARTEMP($2);
                CLEARTEMP($3);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$2] = PyList_GetItem ( $10 , $12 )) == 0) goto label_$0;
                        if ((temp[$3] = PyList_GetItem ( $11 , $13 )) == 0) goto label_$0;
                        int_$5 = temp[$2] == temp[$3];
                        temp[$2] = 0;
                        temp[$3] = 0;
                        """, v2)
                    return True    
            elif TxMatch(o, i, """
                if ((temp[$0] = PyDict_GetItem($3, $4)) == 0) goto label_$1;
                Py_INCREF(temp[$0]);
                if ((int_$5 = PySequence_Contains ( temp[$0] , $6 )) == -1) goto label_$2;
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = PyDict_GetItem($3, $4)) == 0) goto label_$1;
                        if ((int_$5 = PySequence_Contains ( temp[$0] , $6 )) == -1) goto label_$2;
                        temp[$0] = 0;
                        """, v2)
                    return True                                                                    
            elif TxMatch(o, i, """
                if ((temp[$0] = PyDict_GetItem($9)) == 0) goto label_$7;
                Py_INCREF(temp[$0]);
                if ((temp[$1] = _c_BINARY_SUBSCR_Int ( temp[$0] , $8 , $6 )) == 0) goto label_$5;
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = PyDict_GetItem($9)) == 0) goto label_$7;
                        if ((temp[$1] = _c_BINARY_SUBSCR_Int ( temp[$0] , $8 , $6 )) == 0) goto label_$5;
                        temp[$0] = 0;
                        """, v2)
                    return True  
            elif TxMatch(o, i, """
                if ((temp[$0] = PyDict_GetItem($9)) == 0) goto label_$7;
                Py_INCREF(temp[$0]);
                if ((temp[$1] = PyNumber_Int ( temp[$0] )) == 0) goto label_$5;
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = PyDict_GetItem($9)) == 0) goto label_$7;
                        if ((temp[$1] = PyNumber_Int ( temp[$0] )) == 0) goto label_$5;
                        temp[$0] = 0;
                        """, v2)
                    return True  
            elif TxMatch(o, i, """
                if ((temp[$0] = $7) == 0) goto label_$6;
                Py_INCREF(temp[$0]);
                if ((temp[$1] = $8) == 0) goto label_$5;
                Py_INCREF(temp[$1]);
                if ((int_$3 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$2 )) == -1) goto label_$4;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $7) == 0) goto label_$6;
                        if ((temp[$1] = $8) == 0) goto label_$5;
                        if ((int_$3 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$2 )) == -1) goto label_$4;
                        temp[$0] = 0;
                        temp[$1] = 0;
                        """, v2)
                    return True  
            elif TxMatch(o, i, """
                if ((temp[$0] = $16) == 0) goto label_$15;
                Py_INCREF(temp[$0]);
                if (($11 = STR_CONCAT2 ( $12 , temp[$0] )) == 0) goto label_$14;
                CLEARTEMP($0);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $16) == 0) goto label_$15;
                        if (($11 = STR_CONCAT2 ( $12 , temp[$0] )) == 0) goto label_$14;
                        temp[$0] = 0;
                        """, v2)
                    return True  

        if i+2 < len(o) and o[i+2].startswith('Py_INCREF(temp['):
            if TxMatch(o, i, """ 
                if ((temp[$0] = $3) == 0) goto label_$2;
                if ((temp[$1] = PyTuple_GetItem ( $4 , $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                if ((int_$6 = PySequence_Contains ( temp[$0] , temp[$1] )) == -1) goto label_$2;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $3) == 0) goto label_$2;
                        if ((temp[$1] = PyTuple_GetItem ( $4 , $5 )) == 0) goto label_$2;
                        if ((int_$6 = PySequence_Contains ( temp[$0] , temp[$1] )) == -1) goto label_$2;
                        CLEARTEMP($0);
                        temp[$1] = 0;
                        """, v2)
                    return True  
            elif TxMatch(o, i, """ 
                if ((temp[$0] = $3) == 0) goto label_$2;
                if ((temp[$1] = PyList_GetItem ( $4 , $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                if ((int_$6 = PySequence_Contains ( temp[$0] , temp[$1] )) == -1) goto label_$2;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $3) == 0) goto label_$2;
                        if ((temp[$1] = PyList_GetItem ( $4 , $5 )) == 0) goto label_$2;
                        if ((int_$6 = PySequence_Contains ( temp[$0] , temp[$1] )) == -1) goto label_$2;
                        CLEARTEMP($0);
                        temp[$1] = 0;
                        """, v2)
                    return True  
            elif TxMatch(o, i, """ 
                if ((temp[$0] = $3) == 0) goto label_$2;
                if ((temp[$1] = PyDict_GetItem ( $4 , $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                if ((int_$6 = PySequence_Contains ( temp[$0] , temp[$1] )) == -1) goto label_$2;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $3) == 0) goto label_$2;
                        if ((temp[$1] = PyDict_GetItem ( $4 , $5 )) == 0) goto label_$2;
                        if ((int_$6 = PySequence_Contains ( temp[$0] , temp[$1] )) == -1) goto label_$2;
                        CLEARTEMP($0);
                        temp[$1] = 0;
                        """, v2)
            elif TxMatch(o, i, """ 
                if ((temp[$0] = $3) == 0) goto label_$2;
                if ((temp[$1] = PyTuple_GetItem ( $4 , $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$18 )) == -1) goto label_$2;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $3) == 0) goto label_$2;
                        if ((temp[$1] = PyTuple_GetItem ( $4 , $5 )) == 0) goto label_$2;
                        if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$18 )) == -1) goto label_$2;
                        CLEARTEMP($0);
                        temp[$1] = 0;
                        """, v2)
                    return True  
            elif TxMatch(o, i, """ 
                if ((temp[$0] = $3) == 0) goto label_$2;
                if ((temp[$1] = PyList_GetItem ( $4 , $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$18 )) == -1) goto label_$2;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $3) == 0) goto label_$2;
                        if ((temp[$1] = PyList_GetItem ( $4 , $5 )) == 0) goto label_$2;
                        if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$18 )) == -1) goto label_$2;
                        CLEARTEMP($0);
                        temp[$1] = 0;
                        """, v2)
                    return True  
            elif TxMatch(o, i, """ 
                if ((temp[$0] = $3) == 0) goto label_$2;
                if ((temp[$1] = PyDict_GetItem ( $4 , $5 )) == 0) goto label_$2;
                Py_INCREF(temp[$1]);
                if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$18 )) == -1) goto label_$2;
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2):
                    TxRepl(o, i, """
                        if ((temp[$0] = $3) == 0) goto label_$2;
                        if ((temp[$1] = PyDict_GetItem ( $4 , $5 )) == 0) goto label_$2;
                        if ((int_$6 = PyObject_RichCompareBool ( temp[$0] , temp[$1] , Py_$18 )) == -1) goto label_$2;
                        CLEARTEMP($0);
                        temp[$1] = 0;
                        """, v2)
                    return True 

            
        if i+3 <len(o) and o[i+3].startswith('LETLOCAL (') and TxMatch(o, i, """
            if ((temp[$2] = $10) == 0) goto label_$11;
            CLEARTEMP($1);
            CLEARTEMP($0);
            LETLOCAL ( $5 , temp[$2] );
            temp[$2] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if ((GETLOCAL($5) = $10) == 0) goto label_$11;
                        CLEARTEMP($1);
                        CLEARTEMP($0);""", v2) 
                    return True
    
        if i+4 <len(o) and o[i+4].startswith('LETLOCAL (') and TxMatch(o, i, """
            if ((temp[$2] = $10) == 0) goto label_$11;
            CLEARTEMP($1);
            CLEARTEMP($0);
            CLEARTEMP($12);
            LETLOCAL ( $5 , temp[$2] );
            temp[$2] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if ((GETLOCAL($5) = $10) == 0) goto label_$11;
                        CLEARTEMP($1);
                        CLEARTEMP($0);
                        CLEARTEMP($12);
                        """, v2) 
                    return True
    
    
        if i+2 <len(o) and o[i+2].startswith('LETLOCAL (') and TxMatch(o, i, """
            if ((temp[$2] = $10) == 0) goto label_$11;
            CLEARTEMP($1);
            LETLOCAL ( $5 , temp[$2] );
            temp[$2] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if ((GETLOCAL($5) = $10) == 0) goto label_$11;
                        CLEARTEMP($1);
                        """, v2) 
                    return True
    
        if i+1 <len(o) and o[i+1].startswith('LETLOCAL (') and TxMatch(o, i, """
            if ((temp[$0] = $10) == 0) goto label_$11;
            LETLOCAL ( $5 , temp[$0] );
            temp[$0] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if ((GETLOCAL($5) = $10) == 0) goto label_$11;
                        """, v2) 
                    return True
        if i+2 <len(o) and o[i+2].startswith('LETLOCAL ('):
            if TxMatch(o, i, """
                if ((temp[$0] = $1) == 0) goto label_$10;
                Py_INCREF(temp[$0]);
                LETLOCAL ( $5 , temp[$0] );
                temp[$0] = 0;
                """, v2): 
                        TxRepl(o, i, """
                            if ((GETLOCAL($5) = $1) == 0) goto label_$10;
                            Py_INCREF(GETLOCAL($5));
                            """, v2) 
                        return True
        
    
        if i+3 <len(o) and o[i+3].startswith('LETLOCAL (') and TxMatch(o, i, """
            if ((temp[$0] = $6) == 0) goto label_$10;
            if ((temp[$1] = $7) == 0) goto label_$10;
            temp[$0] = 0;
            LETLOCAL ( $5 , temp[$1] );
            temp[$1] = 0;
            """, v2): 
                    TxRepl(o, i, """
                        if ((temp[$0] = $6) == 0) goto label_$10;
                        if ((GETLOCAL($5) = $7) == 0) goto label_$10;
                        temp[$0] = 0;
                        """, v2) 
                    return True
    
        if 'PyInt_FromLong' in oi:
            if TxMatch(o, i, """if ((temp[$0] = PyInt_FromLong ($1)) == 0) goto label_$2;""", v2):
                TxRepl(o, i, """temp[$0] = PyInt_FromLong ($1);""", v2)
                return True
        if 'PyInt_FromSsize_t' in oi:
            if TxMatch(o, i, """
                if ((temp[$4] = PyInt_FromSsize_t ( $2 )) == 0) goto $1;
                if (PyInt_CheckExact( temp[$3] )) {
                long_$7 = PyInt_AS_LONG ( temp[$3] );
                long_$8 = PyInt_AS_LONG ( temp[$4] );
                long_$9 = long_$7 + long_$8;
                if (( long_$9 ^ long_$7 ) < 0 && ( long_$9 ^ long_$8 ) < 0) goto $0 ;
                temp[$5] = PyInt_FromLong ( long_$9 );
                } else if (PyFloat_CheckExact( temp[$3] )) {
                temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$3]) + (double)PyInt_AS_LONG ( temp[$4] ));
                } else { $0 :;
                if ((temp[$5] = PyNumber_Add ( temp[$3] , temp[$4] )) == 0) goto $1;
                }
                """, v2):
                TxRepl(o, i, """
                    if ((temp[$4] = PyInt_FromSsize_t ( $2 )) == 0) goto $1;
                    if (PyInt_CheckExact( temp[$3] )) {
                    long_$7 = PyInt_AS_LONG ( temp[$3] );
                    long_$8 = $2;
                    long_$9 = long_$7 + long_$8;
                    if (( long_$9 ^ long_$7 ) < 0 && ( long_$9 ^ long_$8 ) < 0) goto $0 ;
                    temp[$5] = PyInt_FromLong ( long_$9 );
                    } else if (PyFloat_CheckExact( temp[$3] )) {
                    temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$3]) + (double)$2);
                    } else { $0 :;
                    if ((temp[$5] = PyNumber_Add ( temp[$3] , temp[$4] )) == 0) goto $1;
                    }
                    """, v2)
                return True  
        

            if TxMatch(o, i, """
                if ((temp[$0] = PyInt_FromSsize_t ( $14 )) == 0) goto $4;
                if (_self_dict && (temp[$1] = $5) != 0) {
                Py_INCREF(temp[$1]);
                } else {
                if ((temp[$1] = $6) == 0) goto $4;
                }
                if (PyInt_CheckExact( temp[$1] )) {
                $7 = PyInt_AS_LONG ( temp[$0] );
                $8 = PyInt_AS_LONG ( temp[$1] );
                $11 = $7 $9 $8;
                if ($10) goto $3 ;
                temp[$2] = PyInt_FromLong ( $11 );
                } else if (PyFloat_CheckExact( temp[$1] )) {
                temp[$2] = PyFloat_FromDouble((double)PyInt_AS_LONG ( temp[$0] ) - PyFloat_AS_DOUBLE(temp[$1]));
                } else { $3 :;
                if ((temp[$2] = PyNumber_$12) == 0) goto $4;
                }
                CLEARTEMP($0);
                CLEARTEMP($1);     
                """, v2): 
                        TxRepl(o, i, """
                            if (_self_dict && (temp[$1] = $5) != 0) {
                            Py_INCREF(temp[$1]);
                            } else {
                            if ((temp[$1] = $6) == 0) goto $4;
                            }
                            if (PyInt_CheckExact( temp[$1] )) {
                            $7 = $14;
                            $8 = PyInt_AS_LONG ( temp[$1] );
                            $11 = $7 $9 $8;
                            if ($10) goto $3 ;
                            temp[$2] = PyInt_FromLong ( $11 );
                            } else if (PyFloat_CheckExact( temp[$1] )) {
                            temp[$2] = PyFloat_FromDouble((double)($14) - PyFloat_AS_DOUBLE(temp[$1]));
                            } else { $3 :;
                            if ((temp[$0] = PyInt_FromSsize_t ( $14 )) == 0) goto $4;
                            if ((temp[$2] = PyNumber_$12) == 0) goto $4;
                            CLEARTEMP($0);
                            }
                            CLEARTEMP($1);   
                            """, v2) 
                        return True
        
            if TxMatch(o, i, """
                if ((temp[$0] = PyInt_FromSsize_t ( $14 )) == 0) goto $4;
                if ((temp[$1] = $5) == 0) goto $4;
                Py_INCREF(temp[$1]);
                if (PyInt_CheckExact( temp[$1] )) {
                $7 = PyInt_AS_LONG ( temp[$0] );
                $8 = PyInt_AS_LONG ( temp[$1] );
                $11 = $7 $9 $8;
                if ($10) goto $3 ;
                temp[$2] = PyInt_FromLong ( $11 );
                } else if (PyFloat_CheckExact( temp[$1] )) {
                temp[$2] = PyFloat_FromDouble((double)PyInt_AS_LONG ( temp[$0] ) - PyFloat_AS_DOUBLE(temp[$1]));
                } else { $3 :;
                if ((temp[$2] = PyNumber_$12) == 0) goto $4;
                }
                CLEARTEMP($0);
                CLEARTEMP($1);     
                """, v2): 
                        TxRepl(o, i, """
                            if ((temp[$1] = $5) == 0) goto $4;
                            if (PyInt_CheckExact( temp[$1] )) {
                            $7 = $14;
                            $8 = PyInt_AS_LONG ( temp[$1] );
                            $11 = $7 $9 $8;
                            if ($10) goto $3 ;
                            temp[$2] = PyInt_FromLong ( $11 );
                            } else if (PyFloat_CheckExact( temp[$1] )) {
                            temp[$2] = PyFloat_FromDouble((double)($14) - PyFloat_AS_DOUBLE(temp[$1]));
                            } else { $3 :;
                            if ((temp[$0] = PyInt_FromSsize_t ( $14 )) == 0) goto $4;
                            if ((temp[$2] = PyNumber_$12) == 0) goto $4;
                            CLEARTEMP($0);
                            }
                            CLEARTEMP($1);   
                            """, v2) 
                        return True
            if TxMatch(o, i, """
                if ((temp[$3] = PyInt_FromSsize_t ( $1 )) == 0) goto $0;
                long_$13 = PyInt_AS_LONG ( temp[$3] );
                temp[$4] = PyInt_FromLong ( long_$13 $14 );
                CLEARTEMP($3);
                """, v2): 
                        TxRepl(o, i, """
                            temp[$4] = PyInt_FromLong ( ($1) $14 );
                            """, v2) 
                        return True
        
            if TxMatch(o, i, """
                if ((temp[$1] = PyInt_FromSsize_t ( $5 )) == 0) goto $3;
                if (PyInt_CheckExact( temp[$0] )) {
                long_$14 = PyInt_AS_LONG ( temp[$0] );
                long_$15 = $5;
                long_$13 = long_$14 $16 long_$15;
                if ($18) goto $4 ;
                temp[$2] = PyInt_FromLong ( long_$13 );
                } else if (PyFloat_CheckExact( temp[$0] )) {
                temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $16 (double)$5);
                } else { $4 :;
                if ((temp[$2] = PyNumber_$17 ( temp[$0] , temp[$1] )) == 0) goto $3;
                }
                CLEARTEMP($0);
                CLEARTEMP($1);
                """, v2): 
                        TxRepl(o, i, """
                            if (PyInt_CheckExact( temp[$0] )) {
                            long_$14 = PyInt_AS_LONG ( temp[$0] );
                            long_$15 = $5;
                            long_$13 = long_$14 $16 long_$15;
                            if ($18) goto $4 ;
                            temp[$2] = PyInt_FromLong ( long_$13 );
                            } else if (PyFloat_CheckExact( temp[$0] )) {
                            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) $16 (double)$5);
                            } else { $4 :;
                            if ((temp[$1] = PyInt_FromSsize_t ( $5 )) == 0) goto $3;
                            if ((temp[$2] = PyNumber_$17 ( temp[$0] , temp[$1] )) == 0) goto $3;
                            CLEARTEMP($1);
                            }
                            CLEARTEMP($0);
                            """, v2) 
                        return True
    
        if 'PyObject_Type' in oi:
            if TxMatch(o, i, """
                if ((temp[$0] = PyObject_Type ( $11 )) == 0) goto label_$10;
                int_$15 = temp[$0] == loaded_builtin[$14];
                CLEARTEMP($0);
                """, v2): 
                        TxRepl(o, i, """
                            int_$15 = (PyObject *)Py_TYPE ( $11 ) == loaded_builtin[$14];
                            """, v2) 
                        return True
        if i+3 <len(o) and o[i+1].startswith('calculated_const_') and TxMatch(o,i, """        
            if ((temp[$0] = $1) == 0) goto label_$2;
            calculated_const_$3 = temp[$0];
            temp[$0] = 0;""", v2):
            TxRepl(o, i, """if ((calculated_const_$3 = $1) == 0) goto label_$2;""", v2)
            return True 

    if i+1 < len(o) and 'PyInt_FromSsize_t' in o[i+1]:

        if oi.startswith('if ((Py_ssize_t_') and TxMatch(o, i, """
            if ((Py_ssize_t_$1 = $2) == -1) goto $7;
            if ((temp[$11] = PyInt_FromSsize_t ( Py_ssize_t_$1 )) == 0) goto $7;
            if (PyInt_CheckExact( temp[$10] )) {
            temp[$12] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$10] ) / PyInt_AS_LONG ( temp[$11] ));
            } else {
            if ((temp[$12] = PyNumber_Divide ( temp[$10] , temp[$11] )) == 0) goto $7;
            }
            CLEARTEMP($10);
            CLEARTEMP($11);
            """, v2): 
                    TxRepl(o, i, """
                        if ((Py_ssize_t_$1 = $2) == -1) goto $7;
                        if (PyInt_CheckExact( temp[$10] )) {
                        temp[$12] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$10] ) / (Py_ssize_t_$1));
                        } else {
                        if ((temp[$11] = PyInt_FromSsize_t ( Py_ssize_t_$1 )) == 0) goto $7;
                        if ((temp[$12] = PyNumber_Divide ( temp[$10] , temp[$11] )) == 0) goto $7;
                        CLEARTEMP($11);
                        }
                        CLEARTEMP($10);
                        """, v2) 
                    return True
    if '_PyEval_AssignSlice' in oi:
        if TxMatch(o, i, """if ( _PyEval_AssignSlice ( $1 , NULL , NULL , temp[$2] ) == -1) goto $3;""", v2):
                TxRepl(o, i, """if ( PySequence_SetSlice ( $1 , 0 , PY_SSIZE_T_MAX , temp[$2] ) == -1) goto $3;""", v2)
                return True            
        if TxMatch(o, i, """if ( _PyEval_AssignSlice ( $1 , NULL , NULL , GETLOCAL($2) ) == -1) goto $3;""", v2):
                TxRepl(o, i, """if ( PySequence_SetSlice ( $1 , 0 , PY_SSIZE_T_MAX , GETLOCAL($2) ) == -1) goto $3;""", v2)
                return True            
        if TxMatch(o, i, """if ( _PyEval_AssignSlice ( $1 , NULL , NULL , NULL ) == -1) goto $3;""", v2):
                TxRepl(o, i, """if ( PySequence_DelSlice ( $1 , 0 , PY_SSIZE_T_MAX ) == -1) goto $3;""", v2)
                return True            

                
    if 'PyObject_SetAttr' in oi:
        if TxMatch(o, i, """
            if ( PyObject_SetAttr ( $3 , $4 , temp[$1] ) == -1) goto label_$5;
            CLEARTEMP($1);
            if ((temp[$1] = PyObject_GetAttr ( $3 , $4 )) == 0) goto label_$5;
                """, v2): 
                    TxRepl(o, i, """
                        if ( PyObject_SetAttr ( $3 , $4 , temp[$1] ) == -1) goto label_$5;
                     """, v2) 
                    return True

        if TxMatch(o, i, """
            if ( PyObject_SetAttr ( $3 , $4 , temp[$1] ) == -1) goto label_$5;
            CLEARTEMP($1);
            if ((temp[$0] = PyObject_GetAttr ( $3 , $4 )) == 0) goto label_$5;
                """, v2) and v2[0] != v2[1]: 
                    TxRepl(o, i, """
                        if ( PyObject_SetAttr ( $3 , $4 , temp[$1] ) == -1) goto label_$5;
                        temp[$0] = temp[$1];
                        temp[$1] = 0;
                            """, v2) 
                    return True
    if oi.startswith('if ((int_') and 'PyDict_Contains'  in oi:
        if TxMatch(o, i, """   
            if ((int_$1 = PyDict_Contains ( $5 , $6 )) == -1) goto label_$3;
            if ( int_$1 ) {
            PyLine = $8;
            PyAddr = $9;
            if ((temp[$0] = PyDict_GetItem ( $5 , $6 )) == 0) goto label_$2;
            """, v2):  
                TxRepl(o, i, """
                    temp[$0] = PyDict_GetItem ( $5 , $6 );
                    int_$1 = temp[$0] != 0;
                    if ( int_$1 ) {
                    PyLine = $8;
                    PyAddr = $9;
                    """, v2)   
                return True  
        if TxMatch(o, i, """   
            if ((int_$1 = PyDict_Contains ( $5 , $6 )) == -1) goto label_$3;
            if ( int_$1 ) {
            PyLine = $8;
            PyAddr = $9;
            if (ping_threading () == -1) goto label_$3;
            if ((temp[$0] = PyDict_GetItem ( $5 , $6 )) == 0) goto label_$2;
            """, v2):  
                TxRepl(o, i, """
                    temp[$0] = PyDict_GetItem ( $5 , $6 );
                    int_$1 = temp[$0] != 0;
                    if ( int_$1 ) {
                    PyLine = $8;
                    PyAddr = $9;
                    if (ping_threading () == -1) goto label_$3;
                    """, v2)   
                return True  

        if TxMatch(o, i, """   
            if ((int_$1 = PyDict_Contains ( $5 , $6 )) == -1) goto label_$3;
            if ( int_$1 ) {
            f->f_lineno = $8;
            f->f_lasti = $9;
            if ((temp[$0] = PyDict_GetItem ( $5 , $6 )) == 0) goto label_$2;
            """, v2):  
                TxRepl(o, i, """
                    temp[$0] = PyDict_GetItem ( $5 , $6 );
                    int_$1 = temp[$0] != 0;
                    if ( int_$1 ) {
                    f->f_lineno = $8;
                    f->f_lasti = $9;
                    """, v2)   
                return True  
        if TxMatch(o, i, """   
            if ((int_$1 = PyDict_Contains ( $5 , $6 )) == -1) goto label_$3;
            if ( int_$1 ) {
            f->f_lineno = $8;
            f->f_lasti = $9;
            if (ping_threading () == -1) goto label_$3;
            if ((temp[$0] = PyDict_GetItem ( $5 , $6 )) == 0) goto label_$2;
            """, v2):  
                TxRepl(o, i, """
                    temp[$0] = PyDict_GetItem ( $5 , $6 );
                    int_$1 = temp[$0] != 0;
                    if ( int_$1 ) {
                    f->f_lineno = $8;
                    f->f_lasti = $9;
                    if (ping_threading () == -1) goto label_$3;
                    """, v2)   
                return True  
        if TxMatch(o, i, """   
            if ((int_$1 = PyDict_Contains ( $5 , $6 )) == -1) goto label_$3;
            if ( int_$1 ) {
            if ((temp[$0] = PyDict_GetItem ( $5 , $6 )) == 0) goto label_$2;
            """, v2):  
                TxRepl(o, i, """
                    temp[$0] = PyDict_GetItem ( $5 , $6 );
                    int_$1 = temp[$0] != 0;
                    if ( int_$1 ) {
                    """, v2)   
                return True  
        if TxMatch(o, i, """   
            if ((int_$1 = PyDict_Contains ( $5 , $6 )) == -1) goto label_$3;
            if ( int_$1 ) {
            if (ping_threading () == -1) goto label_$3;
            if ((temp[$0] = PyDict_GetItem ( $5 , $6 )) == 0) goto label_$2;
            """, v2):  
                TxRepl(o, i, """
                    temp[$0] = PyDict_GetItem ( $5 , $6 );
                    int_$1 = temp[$0] != 0;
                    if ( int_$1 ) {
                    if (ping_threading () == -1) goto label_$3;
                    """, v2)   
                return True  
    if 'PyTuple_GET_ITEM' in oi:        
        if oi.startswith('if ((temp[') and TxMatch(o, i, """   
            if ((temp[$0] = PyTuple_GET_ITEM ( $3 )) == 0) goto label_$10;
            """, v2):  
                TxRepl(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $3 );
                    """, v2)   
                return True 
    if 'PyTuple_GET_ITEM' in oi:        
        if oi.startswith('if ((temp[') and TxMatch(o, i, """   
            if ((temp[$0] = PyTuple_GET_ITEM ( $3 )) == 0) goto label_$10;
            """, v2):  
                TxRepl(o, i, """
                    temp[$0] = PyTuple_GET_ITEM ( $3 );
                    """, v2)   
                return True 
        if oi.startswith('if ((GETLOCAL(') and TxMatch(o, i, """   
            if ((GETLOCAL($11) = PyTuple_GET_ITEM ( $3 )) == 0) goto label_$10;
            """, v2):  
                TxRepl(o, i, """
                    GETLOCAL($11) = PyTuple_GET_ITEM ( $3 );
                    """, v2)   
                return True      
    if 'PyList_GET_ITEM' in oi: 
        if oi.startswith('if ((temp[') and TxMatch(o, i, """   
            if ((temp[$0] = PyList_GET_ITEM ( $3 )) == 0) goto label_$10;
            """, v2):  
                TxRepl(o, i, """
                    temp[$0] = PyList_GET_ITEM ( $3 );
                    """, v2)   
                return True       
 
        if oi.startswith('if ((GETLOCAL(') and TxMatch(o, i, """   
            if ((GETLOCAL($11) = PyList_GET_ITEM ( $3 )) == 0) goto label_$10;
            """, v2):  
                TxRepl(o, i, """
                    GETLOCAL($11) = PyList_GET_ITEM ( $3 );
                    """, v2)   
                return True             
 
    if oi.endswith(' ;'):
        if TxMatch(o,i, """if ( ($1 == $2) ) goto  label_$3 ;""", v2) and \
           not '&&' in v2[1] and not '||' in v2[1] and not '&&' in v2[2] and not '||' in v2[2] \
           and is_balansed(v2[1]) and is_balansed(v2[2]):
            TxRepl(o, i, """if ( $1 == $2 ) goto  label_$3 ;""", v2)
            return True
        if TxMatch(o,i, """if ( ($1) ) goto  label_$3 ;""", v2) and \
           not '&&' in v2[1] and not '||' in v2[1] \
           and is_balansed(v2[1]):
            TxRepl(o, i, """if ( $1 ) goto  label_$3 ;""", v2)
            return True 

    if i+5 < len(o) and 'PyDict_Contains' in o[i+1]:
        if TxMatch(o,i, """        
            if ($11 == 0) goto label_$12;
            if ((int_$13 = PyDict_Contains ( $11 , $14 )) == -1) goto label_$15;
            if ( int_$13 ) {
            PyLine = $16;
            PyAddr = $17;
            if ($11 == 0) goto label_$12;
            if ((GETLOCAL($18) = PyDict_GetItem ( $11 , $14 )) == 0) goto label_$15;
            Py_INCREF(GETLOCAL($18));
            """, v2):
            TxRepl(o, i, """
                if ($11 == 0) goto label_$12;
                GETLOCAL($18) = PyDict_GetItem ( $11 , $14 );
                int_$13 = GETLOCAL($18) != 0;
                if ( int_$13 ) {
                PyLine = $16;
                PyAddr = $17;
                Py_INCREF(GETLOCAL($18));
                """, v2)
            return True 
        if TxMatch(o,i, """        
            if ($2 == 0) goto label_$7;
            if ((int_$1 = PyDict_Contains ( $2 , $5 )) == -1) goto label_$6;
            if ( int_$1 ) {
            PyLine = $16;
            PyAddr = $17;
            if ($2 == 0) goto label_$7;
            if ((temp[$3] = PyDict_GetItem ( $2 , $5 )) == 0) goto label_$6;
            Py_INCREF(temp[$3]);
            """, v2):
            TxRepl(o, i, """
                if ($2 == 0) goto label_$7;
                temp[$3] = PyDict_GetItem ( $2 , $5 );
                int_$1 = temp[$3] != 0;
                if ( int_$1 ) {
                PyLine = $16;
                PyAddr = $17;
                Py_INCREF(temp[$3]);
                """, v2)
            return True        
        if TxMatch(o,i, """        
            if ($2 == 0) goto label_$7;
            if ((int_$1 = PyDict_Contains ( $2 , $5 )) == -1) goto label_$6;
            if ( int_$1 ) {
            PyLine = $16;
            PyAddr = $17;
            if (ping_threading () == -1) goto label_$6;
            if ($2 == 0) goto label_$7;
            if ((temp[$3] = PyDict_GetItem ( $2 , $5 )) == 0) goto label_$6;
            Py_INCREF(temp[$3]);
            """, v2):
            TxRepl(o, i, """
                if ($2 == 0) goto label_$7;
                temp[$3] = PyDict_GetItem ( $2 , $5 );
                int_$1 = temp[$3] != 0;
                if ( int_$1 ) {
                PyLine = $16;
                PyAddr = $17;
                if (ping_threading () == -1) goto label_$6;
                Py_INCREF(temp[$3]);
                """, v2)
            return True 
        if TxMatch(o,i, """   
            if ($2 == 0) goto label_$7;
            if ((int_$1 = PyDict_Contains ( $2 , $5 )) == -1) goto label_$6;
            if ( !int_$1 ) {
            PyLine = $16;
            PyAddr = $17;
            if ($2 == 0) goto label_$7;
            if ( PyDict_SetItem ( $2 , $5 , $8 ) == -1) goto label_$6;
            """, v2):
            TxRepl(o, i, """
                if ($2 == 0) goto label_$7;
                if ((int_$1 = PyDict_Contains ( $2 , $5 )) == -1) goto label_$6;
                if ( !int_$1 ) {
                PyLine = $16;
                PyAddr = $17;
                if ( PyDict_SetItem ( $2 , $5 , $8 ) == -1) goto label_$6;
                """, v2)
            return True         
        if TxMatch(o,i, """        
            if ($11 == 0) goto label_$12;
            if ((int_$13 = PyDict_Contains ( $11 , $14 )) == -1) goto label_$15;
            if ( int_$13 ) {
            f->f_lineno = $16;
            f->f_lasti = $17;
            if ($11 == 0) goto label_$12;
            if ((GETLOCAL($18) = PyDict_GetItem ( $11 , $14 )) == 0) goto label_$15;
            Py_INCREF(GETLOCAL($18));
            """, v2):
            TxRepl(o, i, """
                if ($11 == 0) goto label_$12;
                GETLOCAL($18) = PyDict_GetItem ( $11 , $14 );
                int_$13 = GETLOCAL($18) != 0;
                if ( int_$13 ) {
                f->f_lineno = $16;
                f->f_lasti = $17;
                Py_INCREF(GETLOCAL($18));
                """, v2)
            return True 
        if TxMatch(o,i, """        
            if ($2 == 0) goto label_$7;
            if ((int_$1 = PyDict_Contains ( $2 , $5 )) == -1) goto label_$6;
            if ( int_$1 ) {
            f->f_lineno = $16;
            f->f_lasti = $17;
            if ($2 == 0) goto label_$7;
            if ((temp[$3] = PyDict_GetItem ( $2 , $5 )) == 0) goto label_$6;
            Py_INCREF(temp[$3]);
            """, v2):
            TxRepl(o, i, """
                if ($2 == 0) goto label_$7;
                temp[$3] = PyDict_GetItem ( $2 , $5 );
                int_$1 = temp[$3] != 0;
                if ( int_$1 ) {
                f->f_lineno = $16;
                f->f_lasti = $17;
                Py_INCREF(temp[$3]);
                """, v2)
            return True 
        if TxMatch(o,i, """        
            if ($2 == 0) goto label_$7;
            if ((int_$1 = PyDict_Contains ( $2 , $5 )) == -1) goto label_$6;
            if ( int_$1 ) {
            if ($2 == 0) goto label_$7;
            if ((temp[$3] = PyDict_GetItem ( $2 , $5 )) == 0) goto label_$6;
            Py_INCREF(temp[$3]);
            """, v2):
            TxRepl(o, i, """
                if ($2 == 0) goto label_$7;
                temp[$3] = PyDict_GetItem ( $2 , $5 );
                int_$1 = temp[$3] != 0;
                if ( int_$1 ) {
                Py_INCREF(temp[$3]);
                """, v2)
            return True 
    return False

def end_call_1(action, nms, arg, label):
    assert type(action) is str
    assert type(label) is str
    assert type(arg) is str
    if arg not in action:
        return False
    for nm in nms:
        assert type(nm) is str
        if nm not in action:
            continue
        if 'goto' not in action:
            if action.endswith(' = ' + nm + '(' + arg + ');'):
                return True
            if action.endswith(' = ' + nm + '( ' + arg + ' );'):
                return True
            if action.endswith(' = ' + nm + ' ( ' + arg + ' );'):
                return True
        else:
            if action.startswith('if ('):
                if (' = ' + nm + ' ( ' + arg + ' )) == ') in action and action.endswith('goto ' + label + ';'):
                    return True
                if (' = ' + nm + '( ' + arg + ' )) == ') in action and action.endswith('goto ' + label + ';'):
                    return True
                if (' = ' + nm + '(' + arg + ')) == ') in action and action.endswith('goto ' + label + ';'):
                    return True
                if (' = ' + nm + ' (' + arg + ')) == ') in action and action.endswith('goto ' + label + ';'):
                    return True
        
    return False    

def end_call_first_of_two(action, nms, arg, label):
    if arg not in action:
        return False
    for nm in nms:
        if nm not in action:
            continue
        if 'goto' not in action:
            if TextMatch(action, ('*', ' = ' + nm + '(' + arg + ',', '*', ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + '(' + arg + ' ,', '*', ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + '( ' + arg + ',', '*', ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + '( ' + arg + ' ,', '*', ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + ' ( ' + arg + ',', '*', ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + ' ( ' + arg + ' ,', '*', ');'), []):
                return True 
        else:
            if action.startswith('if ('):
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' ( ', arg, ' ,', '*', ') goto ', label, ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '( ', arg, ' ,', '*', ') goto ', label, ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' ( ', arg, ',', '*', ') goto ', label, ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '( ', arg, ',', '*', ') goto ', label, ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '(', arg, ' ,', '*', ') goto ', label, ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' (', arg, ',', '*', ') goto ', label, ';'), []):
                    return True
    return False    

def end_call_second_of_two(action, nms, arg, label):
    if arg not in action:
        return False
    for nm in nms:
        if nm not in action:
            continue
        if 'goto' not in action:
            if TextMatch(action, ('*', ' = ' + nm + '(', '*',  ',', arg, ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + '(', '*', ', ', arg, ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + '(', '*', ', ', arg, ' );'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + ' (', '*',  ',', arg, ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + ' (', '*', ', ', arg, ');'), []):
                return True 
            if TextMatch(action, ('*', ' = ' + nm + ' (', '*', ', ', arg, ' );'), []):
                return True 
        else:
            if action.startswith('if ('):
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '(', '*', ',', arg, ')) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' (', '*', ',', arg, ')) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '(', '*', ', ', arg, ')) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' (', '*', ', ', arg, ')) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '(', '*', ',', arg, ' )) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' (', '*', ',', arg, ' )) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + '(', '*', ', ', arg, ' )) == ', '*', ';'), []):
                    return True
                if TextMatch(action, ('if ((', '*', ' = ' + nm + ' (', '*', ', ', arg, ' )) == ', '*', ';'), []):
                    return True
    return False    
 
def allowed_no_incref(action, temp, label):
    t_temp = 'temp[' + temp + ']'
    if end_call_1(action, ('PyLong_CheckExact', 'PyTuple_CheckExact', 
                         'PyBool_Check', 'PyList_CheckExact', 
                         'PySet_Check', 'PyFrozenSet_CheckExact', 
                         'PyGen_CheckExact', 'PyBytes_CheckExact', 
                         'PyComplex_CheckExact', 'PyByteArray_CheckExact', 
                         'PyFile_CheckExact', 'PySet_CheckExact', 
                         'PyAnySet_CheckExact', 'PyDict_CheckExact', 
                         'PyString_CheckExact', 'PyDate_CheckExact', 
                         'PyTime_CheckExact', 'PyDateTime_CheckExact', 
                         'PyType_CheckExact', 'PyUnicode_CheckExact', 
                         'PyModule_CheckExact', 'PyInt_CheckExact', 
                         'PyFloat_CheckExact', 
                         'PyTuple_GET_SIZE', 'PyList_GET_SIZE', 
                         'PyObject_Size'), t_temp, label):
        return True
    if end_call_first_of_two(action, ('_c_BINARY_SUBSCR_Int', 'PyObject_GetItem', 
                         'c_Py_EQ_String', 'c_Py_NE_String', 
                         'c_Py_GT_Int', 'c_Py_GE_Int',
                         'c_Py_LT_Int', 'c_Py_LE_Int',
                         'c_Py_EQ_Int', 'c_Py_NE_Int',
                         'PySequence_GetSlice', 'PyObject_GetAttr',
                         'PySequence_Contains', 'PyDict_Contains', 
                         'PySet_Contains'), t_temp, label):
        return True
    if end_call_second_of_two(action, 
                              ('PySequence_Contains', 'PyDict_Contains', 'PySet_Contains'), 
                              t_temp, label):
        return True
    if ( 'STR_CONCAT_N ( ' in action or 'STR_CONCAT3 ( ' in action or 'STR_CONCAT2 ( ' in action ) and t_temp in action:
        return True
    if  (' = ' + t_temp + ' == calculated_const[') in action or (' = ' + t_temp + ' != calculated_const[') in action:
        return True
    if  (' = ' + t_temp + ' == calculated_const_') in action or (' = ' + t_temp + ' != calculated_const_') in action:
        return True
    return False    

op_to_oper = {'Py_EQ':' == ', 'Py_NE':' != ', 'Py_LT':' < ', \
              'Py_LE':' <= ', 'Py_GT':' > ', 'Py_GE':' >= '}

def tune_if_sk(o, i):
    assert type(i) is int
    v2 = {}
    oi = o[i]
    assert type(oi) is str
    if oi == 'if (1) {':
        if TxMatch(o, i, """if (1) {
            $1;""", v2) and not ':' in o[i+1] and not '}' in o[i+1] and not '{' in o[i+1]:
                TxRepl(o, i, """$1; if (1) {""", v2)
                return True  
        if TxMatch(o, i, """if (1) {
            } else {""", v2):
                TxRepl(o, i, """if (0) {""", v2)
                return True  
        if TxMatch(o, i, """if (1) {
            long_$6 = PyInt_AS_LONG ( $1 );
            long_$7 = PyInt_AS_LONG ( $2 );
            long_$8 = long_$6 + long_$7;
            if (( long_$8 ^ long_$6 ) < 0 && ( long_$8 ^ long_$7 ) < 0) goto $5 ;
            temp[$3] = PyInt_FromLong ( long_$8 );
            } else { $5 :;
            if ((temp[$3] = PyNumber_Add ( $1 , $2 )) == 0) goto $9;
            }""", v2):
                TxRepl(o, i, """long_$6 = PyInt_AS_LONG ( $1 );
                    long_$7 = PyInt_AS_LONG ( $2 );
                    long_$8 = long_$6 + long_$7;
                    if (( long_$8 ^ long_$6 ) < 0 && ( long_$8 ^ long_$7 ) < 0) {
                    if ((temp[$3] = PyNumber_Add ( $1 , $2 )) == 0) goto $9;
                    } else {
                    temp[$3] = PyInt_FromLong ( long_$8 );
                    }""", v2)
                return True   
        if TxMatch(o, i, """if (1) {
            long_$2 = PyInt_AS_LONG ( $1 );
            long_$3 = long_$2 + 1;
            if (( long_$3 ^ long_$2 ) < 0 && ( long_$3 ^ 1 ) < 0) goto $8 ;
            temp[$0] = PyInt_FromLong ( long_$3 );
            } else { $8 :;
            if ((temp[$0] = PyNumber_Add ( $1 , consts[$11] )) == 0) goto $10;
            }""", v2):
                TxRepl(o, i, """if ((long_$2 = PyInt_AS_LONG ( $1 )) < LONG_MAX ) {
                        temp[$0] = PyInt_FromLong ( long_$2 + 1 );
                        } else {
                        if ((temp[$0] = PyNumber_Add ( $1 , consts[$11] )) == 0) goto $10;
                        }""", v2)
                return True  

        if TxMatch(o, i, """if (1) {
            } else { label_$4 :;""", v2):
                TxRepl(o, i, """if (0) { label_$4 :;""", v2)
                return True             
    if oi == 'if (_self_dict) {':    
        if TxMatch(o, i, """
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $1, $2) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $2 ) == -1) goto label_$0;
            }
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $3, $4) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $3 , $4 ) == -1) goto label_$0;
            }                     
            """, v2):
                TxRepl(o, i, """
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $1, $2) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $3, $4) == -1) goto label_$0;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $2 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $3 , $4 ) == -1) goto label_$0;
                    }
                    """, v2)
                return True         
        if TxMatch(o, i, """
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $2, temp[$0]) == -1) goto label_0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $2 , temp[$0] ) == -1) goto label_$10;
            }
            CLEARTEMP($0);
            if (_self_dict && (temp[$0] = PyDict_GetItem(_self_dict, $2)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL(self) , $2 )) == 0) goto label_$10;
            }
            """, v2):
                TxRepl(o, i, """
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $2, temp[$0]) == -1) goto label_0;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $2 , temp[$0] ) == -1) goto label_$10;
                    }
                    """, v2)
                return True         

        if TxMatch(o, i, """
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $1, $3) == -1) goto label_$0;
            if (PyDict_SetItem(_self_dict, $2, $4) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $3 ) == -1) goto label_$0;
            if ( PyObject_SetAttr ( GETLOCAL(self) , $2 , $4 ) == -1) goto label_$0;
            }
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $5, $6) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $5 , $6 ) == -1) goto label_$0;
            }
            """, v2):
                TxRepl(o, i, """
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $1, $3) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $2, $4) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $5, $6) == -1) goto label_$0;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $3 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $2 , $4 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $5 , $6 ) == -1) goto label_$0;
                    }
                    """, v2)
                return True         

        if TxMatch(o, i, """
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $1, $2) == -1) goto label_$0;
            if (PyDict_SetItem(_self_dict, $3, $4) == -1) goto label_$0;
            if (PyDict_SetItem(_self_dict, $5, $6) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $2 ) == -1) goto label_$0;
            if ( PyObject_SetAttr ( GETLOCAL(self) , $3 , $4 ) == -1) goto label_$0;
            if ( PyObject_SetAttr ( GETLOCAL(self) , $5 , $6 ) == -1) goto label_$0;
            }
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $7, $8) == -1) goto label_$0;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $7 , $8 ) == -1) goto label_$0;
            }
            """, v2):
                TxRepl(o, i, """
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $1, $2) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $3, $4) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $5, $6) == -1) goto label_$0;
                    if (PyDict_SetItem(_self_dict, $7, $8) == -1) goto label_$0;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $1 , $2 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $3 , $4 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $5 , $6 ) == -1) goto label_$0;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $7 , $8 ) == -1) goto label_$0;
                    }
                    """, v2)
                return True         


        if TxMatch(o, i, """
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $5, temp[$0]) == -1) goto label_$7;
            CLEARTEMP($0);
            if (PyDict_SetItem(_self_dict, $6, $12) == -1) goto label_$7;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $5 , temp[$0] ) == -1) goto label_$7;
            CLEARTEMP($0);
            if ( PyObject_SetAttr ( GETLOCAL(self) , $6 , $12 ) == -1) goto label_$7;
            }
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $8, $10) == -1) goto label_$7;
            if (PyDict_SetItem(_self_dict, $9, $11) == -1) goto label_$7;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $8 , $10 ) == -1) goto label_$7;
            if ( PyObject_SetAttr ( GETLOCAL(self) , $9 , $11 ) == -1) goto label_$7;
            }
            """, v2):
                TxRepl(o, i, """
                    if (_self_dict) {
                    if (PyDict_SetItem(_self_dict, $5, temp[$0]) == -1) goto label_$7;
                    CLEARTEMP($0);
                    if (PyDict_SetItem(_self_dict, $6, $12) == -1) goto label_$7;
                    if (PyDict_SetItem(_self_dict, $8, $10) == -1) goto label_$7;
                    if (PyDict_SetItem(_self_dict, $9, $11) == -1) goto label_$7;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $5 , temp[$0] ) == -1) goto label_$7;
                    CLEARTEMP($0);
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $6 , $12 ) == -1) goto label_$7;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $8 , $10 ) == -1) goto label_$7;
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $9 , $11 ) == -1) goto label_$7;
                    }
                    """, v2)
                return True         

    if oi.startswith('if (_self_dict'):    
        if TxMatch(o, i, """
            if (_self_dict && (temp[$0] = PyDict_GetItem(_self_dict, $1)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL(self) , $1 )) == 0) goto label_$10;
            }
            LETLOCAL ( $2 , temp[$0] );
            temp[$0] = 0;
            """,v2):
                TxRepl(o, i, """
                    if (_self_dict && (GETLOCAL($2) = PyDict_GetItem(_self_dict, $1)) != 0) {
                    Py_INCREF(GETLOCAL($2));
                    } else {
                    if ((GETLOCAL($2) = PyObject_GetAttr ( GETLOCAL(self) , $1 )) == 0) goto label_$10;
                    }
                    """, v2)
                return True         
        if TxMatch(o, i, """
            if (_self_dict && (temp[$0] = PyDict_GetItem(_self_dict, $1)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL(self) , $1 )) == 0) goto label_$10;
            }
            LETLOCAL ( $2 , temp[$0] );
            temp[$0] = 0;
            """,v2):
                TxRepl(o, i, """
                    if (_self_dict && (GETLOCAL($2) = PyDict_GetItem(_self_dict, $1)) != 0) {
                    Py_INCREF(GETLOCAL($2));
                    } else {
                    if ((GETLOCAL($2) = PyObject_GetAttr ( GETLOCAL(self) , $1 )) == 0) goto label_$10;
                    }
                    """, v2)
                return True         
    

        if TxMatch(o, i, """
            if (_self_dict && (temp[$0] = PyDict_GetItem(_self_dict, $4)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL(self) , $4 )) == 0) goto label_$3;
            }
            if ((temp[$1] = _Direct_$5 ($9temp[$0]$10)) == 0) goto label_$3;
            CLEARTEMP($0);
            if (_self_dict) {
            if (PyDict_SetItem(_self_dict, $4, temp[$1]) == -1) goto label_$3;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL(self) , $4 , temp[$1] ) == -1) goto label_$3;
            }
            CLEARTEMP($1);    
                        """,v2):
                TxRepl(o, i, """
                    if (_self_dict && (temp[$0] = PyDict_GetItem(_self_dict, $4)) != 0) {
                    if ((temp[$1] = _Direct_$5 ($9temp[$0]$10)) == 0) goto label_$3;
                    temp[$0] = 0;
                    if (PyDict_SetItem(_self_dict, $4, temp[$1]) == -1) goto label_$3;
                    CLEARTEMP($1);  
                    } else {
                    if ((temp[$0] = PyObject_GetAttr ( GETLOCAL(self) , $4 )) == 0) goto label_$3;
                    if ((temp[$1] = _Direct_$5 ($9temp[$0]$10)) == 0) goto label_$3;
                    CLEARTEMP($0);
                    if ( PyObject_SetAttr ( GETLOCAL(self) , $4 , temp[$1] ) == -1) goto label_$3;
                    CLEARTEMP($1);  
                    }
                    """, v2)
                return True  

        if TxMatch(o, i, """
            if (_$6_dict && (temp[$0] = PyDict_GetItem(_$6_dict, $3)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($6) , $3 )) == 0) goto label_$5;
            }
            if (_$6_dict && (temp[$1] = PyDict_GetItem(_$6_dict, $4)) != 0) {
            Py_INCREF(temp[$1]);
            } else {
            if ((temp[$1] = PyObject_GetAttr ( GETLOCAL($6) , $4 )) == 0) goto label_$5;
            }
            if ((temp[$2] = _Direct_$7 ( temp[$0] , temp[$1] )) == 0) goto label_$5;
            CLEARTEMP($0);
            CLEARTEMP($1);
            if (_$6_dict) {
            if (PyDict_SetItem(_$6_dict, $8, temp[$2]) == -1) goto label_$5;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL($6) , $8 , temp[$2] ) == -1) goto label_$5;
            }
            CLEARTEMP($2);
                        """,v2):
                TxRepl(o, i, """
                    if (_$6_dict && (temp[$0] = PyDict_GetItem(_$6_dict, $3)) != 0 && (temp[$1] = PyDict_GetItem(_$6_dict, $4)) != 0) {
                    if ((temp[$2] = _Direct_$7 ( temp[$0] , temp[$1] )) == 0) goto label_$5;
                    temp[$0] = 0;
                    temp[$1] = 0;
                    if (PyDict_SetItem(_$6_dict, $8, temp[$2]) == -1) goto label_$5;
                    } else {
                    if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($6) , $3 )) == 0) goto label_$5;
                    if ((temp[$1] = PyObject_GetAttr ( GETLOCAL($6) , $4 )) == 0) goto label_$5;
                    if ((temp[$2] = _Direct_$7 ( temp[$0] , temp[$1] )) == 0) goto label_$5;
                    CLEARTEMP($0);
                    CLEARTEMP($1);
                    if ( PyObject_SetAttr ( GETLOCAL($6) , $8 , temp[$2] ) == -1) goto label_$5;
                    }
                    CLEARTEMP($2);
                    """, v2)
                return True  
    
    if oi.endswith('_dict) {'):
        if TxMatch(o, i, """
            if (_$10_dict) {
            if (PyDict_SetItem(_$10_dict, $12, temp[$0]) == -1) goto label_$11;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL($10) , $12 , temp[$0] ) == -1) goto label_$11;
            }
            CLEARTEMP($0);
            if (_$10_dict) {
            if (PyDict_SetItem(_$10_dict, $14, $15) == -1) goto label_$11;
            } else {
            if ( PyObject_SetAttr ( GETLOCAL($10) , $14 , $15 ) == -1) goto label_$11;
            }
            """,v2):
                TxRepl(o, i, """
                    if (_$10_dict) {
                    if (PyDict_SetItem(_$10_dict, $12, temp[$0]) == -1) goto label_$11;
                    CLEARTEMP($0);
                    if (PyDict_SetItem(_$10_dict, $14, $15) == -1) goto label_$11;
                    } else {
                    if ( PyObject_SetAttr ( GETLOCAL($10) , $12 , temp[$0] ) == -1) goto label_$11;
                    CLEARTEMP($0);
                    if ( PyObject_SetAttr ( GETLOCAL($10) , $14 , $15 ) == -1) goto label_$11;
                    }
                    """, v2)
                return True         
        
    if oi.startswith('if (PyInt_CheckExact('):  
          
        if oi.startswith('if (PyInt_CheckExact( temp[') and TxMatch(o, i, """    
            if (PyInt_CheckExact( temp[$0] )$4) {
            temp[$1] = PyInt_FromLong ( $5 );
            } else {
            if ((temp[$1] = $6) == 0) goto label_$9;
            }
            CLEARTEMP($0);
            if (PyInt_CheckExact( temp[$2] ) && PyInt_CheckExact( temp[$1] )) {
            temp[$3] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$2] ) $7 PyInt_AS_LONG ( temp[$1] ) );
            } else {
            if ((temp[$3] = PyNumber_$8 ( temp[$2] , temp[$1] )) == 0) goto label_$9;
            }
            CLEARTEMP($2);
            CLEARTEMP($1);
            """, v2) and ('temp[%s]' % v2[0]) not in v2[5]:
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$2] ) && PyInt_CheckExact( temp[$0] )$4) {
                        CLEARTEMP($0); 
                        temp[$3] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$2] ) $7 ($5) );
                        CLEARTEMP($2);
                        } else {
                        if ((temp[$1] = $6) == 0) goto label_$9;
                        CLEARTEMP($0);
                        if ((temp[$3] = PyNumber_$8 ( temp[$2] , temp[$1] )) == 0) goto label_$9;
                        CLEARTEMP($2);
                        CLEARTEMP($1);
                        }
                        """, v2)
                    return True
        if TxMatch(o, i, """    
            if (PyInt_CheckExact( $0 )) {
            >0
            temp[$1] = PyInt_FromLong ( $4 );
            <1
            } else {
            >2
            if ((temp[$1] = $5) == 0) goto label_$3;
            <3
            }
            <4
            if (PyInt_CheckExact( $0 ) && PyInt_CheckExact( temp[$1] )) {
            >5
            if ($11) {
            temp[$2] = PyInt_FromLong ( $12 );
            } else {
            temp[$2] = PyInt_Type.tp_as_number->nb_multiply($13);
            }
            } else {
            if ((temp[$2] = $14) == 0) goto label_$3;
            }
            CLEARTEMP($1);
            """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $0 )) {
                        >0
                        temp[$1] = PyInt_FromLong ( $4 );
                        <1
                        <4
                        >5
                        if ($11) {
                        temp[$2] = PyInt_FromLong ( $12 );
                        } else {
                        temp[$2] = PyInt_Type.tp_as_number->nb_multiply($13);
                        }
                        CLEARTEMP($1);
                        } else {
                        >2
                        if ((temp[$1] = $5) == 0) goto label_$3;
                        <3
                        <4
                        if ((temp[$2] = $14) == 0) goto label_$3;
                        CLEARTEMP($1);
                        }
                        """, v2)
                    return True


        if TxMatch(o, i, """
            if ($10) {
            Py_DECREF($11);
            $11 = PyInt_FromLong ( $12 );
            } else {
            >0
            }
            if (PyInt_CheckExact( $11 )) {
            >1
            } else {
            >2
            }
            <3
            """, v2):
                TxRepl(o, i, """
                    if ($10) {
                    Py_DECREF($11);
                    $11 = PyInt_FromLong ( $12 );
                    >1
                    <3
                    } else {
                    >0
                    >2
                    <3
                    }
                       """, v2)
                return True    
                
            
        if TxMatch(o, i, """if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) < LONG_MAX ) {
            temp[$5] = PyInt_FromLong ( $2 + 1 );
            } else {
            if ((temp[$5] = PyNumber_Add ( $1 , $7 )) == 0) goto $3;
            }
            if ((temp[$6] = PyObject_GetItem ( $4 , temp[$5] )) == 0) goto $3;
            CLEARTEMP($5);""", v2):
                TxRepl(o, i, """if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) < LONG_MAX ) {
                    $2 = $2 + 1;
                    temp[$5] = PyInt_FromLong ( $2 );
                    if ((temp[$6] = _c_BINARY_SUBSCR_Int ( $4 , $2 , temp[$5] )) == 0) goto $3;
                    } else {
                    if ((temp[$5] = PyNumber_Add ( $1 , $7 )) == 0) goto $3;
                    if ((temp[$6] = PyObject_GetItem ( $4 , temp[$5] )) == 0) goto $3;
                    }
                    CLEARTEMP($5);""", v2, ('_c_BINARY_SUBSCR_Int',))
                return True
            
            
            
        if TxMatch(o, i, """if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {
            temp[$5] = PyInt_FromLong ( $2 - 1 );
            } else {
            if ((temp[$5] = PyNumber_Subtract ( $1 , $7 )) == 0) goto $3;
            }
            if ((temp[$6] = PyObject_GetItem ( $4 , temp[$5] )) == 0) goto $3;
            CLEARTEMP($5);""", v2):
                TxRepl(o, i, """if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {
                    $2 = $2 - 1;
                    temp[$5] = PyInt_FromLong ( $2 );
                    if ((temp[$6] = _c_BINARY_SUBSCR_Int ( $4 , $2 , temp[$5] )) == 0) goto $3;
                    } else {
                    if ((temp[$5] = PyNumber_Subtract ( $1 , $7 )) == 0) goto $3;
                    if ((temp[$6] = PyObject_GetItem ( $4 , temp[$5] )) == 0) goto $3;
                    }
                    CLEARTEMP($5);""", v2, ('_c_BINARY_SUBSCR_Int',))
                return True
        

        if oi.startswith('if (PyInt_CheckExact( temp['):
                                
            if TxMatch(o, i, """if (PyInt_CheckExact( temp[$0] ) && ($8 = PyInt_AS_LONG ( temp[$0] )) > $10 ) {
                temp[$1] = PyInt_FromLong ( $8 - $11 );
                } else if (PyFloat_CheckExact( temp[$0] )) {
                temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) - ((double)$11));
                } else {
                if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $9 )) == 0) goto $2;
                }
                CLEARTEMP($0);
                $6 = PyInt_AsSsize_t ( temp[$1] );
                CLEARTEMP($1);""", v2):
                    TxRepl(o, i, """if (PyInt_CheckExact( temp[$0] ) && ($8 = PyInt_AS_LONG ( temp[$0] )) > $10 ) {
                        CLEARTEMP($0);
                        $6 = $8 - $11;
                        } else {
                        if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $9 )) == 0) goto $2;
                        CLEARTEMP($0);
                        $6 = PyInt_AsSsize_t ( temp[$1] );
                        CLEARTEMP($1);
                        }""", v2)
                    return True              
            
        if TxMatch(o, i, """if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < $5 ) {
            temp[$9] = PyInt_FromLong ( $3 + $6 );
            } else if (PyFloat_CheckExact( $1 )) {
            temp[$9] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)$6));
            } else {
            if ((temp[$9] = PyNumber_Add ( $1 , $7 )) == 0) goto $8;
            }
            if (PyInt_CheckExact( temp[$9] )) {
            $4 = PyInt_AS_LONG ( temp[$9] );
            if ( $4 < 0) {
            $4 += PyList_GET_SIZE($2);
            }
            if ( PyList_SetItem ( $2 , $4 , temp[$10] ) == -1) goto $8;
            } else {
            if ( PyObject_SetItem ( $2 , temp[$9] , temp[$10] ) == -1) goto $8;
            Py_DECREF(temp[$10]);
            }
            CLEARTEMP($9);
            temp[$10] = 0;""", v2):
                TxRepl(o, i, """if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < $5 ) {
                    $4 = $3 + $6;
                    if ( $4 < 0) {
                    $4 += PyList_GET_SIZE($2);
                    }
                    if ( PyList_SetItem ( $2 , $4 , temp[$10] ) == -1) goto $8;
                    } else {
                    if ((temp[$9] = PyNumber_Add ( $1 , $7 )) == 0) goto $8;
                    if ( PyObject_SetItem ( $2 , temp[$9] , temp[$10] ) == -1) goto $8;
                    Py_DECREF(temp[$10]);
                    CLEARTEMP($9);
                    }
                    temp[$10] = 0;""", v2)
                return True    
            
            
        if TxMatch(o, i, """if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {
            temp[$3] = PyInt_FromLong ( $2 - 1 );
            } else {
            if ((temp[$3] = PyNumber_Subtract ( $1 , $5 )) == 0) goto $4;
            }
            if (PyInt_CheckExact( temp[$3] )) {
            $6 = PyInt_AS_LONG ( temp[$3] );
            if ( $6 < 0) {
            $6 += PyList_GET_SIZE($7);
            }
            if ((temp[$8] = PyList_GetItem ( $7 , $6 )) == 0) goto $4;
            Py_INCREF(temp[$8]);
            } else {
            if ((temp[$8] = PyObject_GetItem ( $7 , temp[$3] )) == 0) goto $4;
            }
            CLEARTEMP($3);""", v2):
                TxRepl(o, i, """if (PyInt_CheckExact( $1 ) && ($2 = PyInt_AS_LONG ( $1 )) > INT_MIN ) {
                    $6 = $2 - 1;
                    if ( $6 < 0) {
                    $6 += PyList_GET_SIZE($7);
                    }
                    if ((temp[$8] = PyList_GetItem ( $7 , $6 )) == 0) goto $4;
                    Py_INCREF(temp[$8]);
                    temp[$3] = 0;
                    } else {
                    if ((temp[$3] = PyNumber_Subtract ( $1 , $5 )) == 0) goto $4;
                    if ((temp[$8] = PyObject_GetItem ( $7 , temp[$3] )) == 0) goto $4;
                    CLEARTEMP($3);
                    }""", v2)
                return True    
    
   
        if TxMatch(o, i, """if (PyInt_CheckExact( $1 )) {
            $2 = PyInt_AS_LONG ( $1 );
            if ( $2 < 0) {
            $2 += PyList_GET_SIZE($0);
            }
            if ((temp[$4] = PyList_GetItem ( $0 , $2 )) == 0) goto $3;
            Py_INCREF(temp[$4]);
            } else {
            if ((temp[$4] = PyObject_GetItem ( $0 , $1 )) == 0) goto $3;
            }
            if ((int_$11 = PyObject_RichCompareBool ( temp[$4] , $5 , $6 )) == -1) goto $3;
            CLEARTEMP($4);""", v2):
                TxRepl(o, i, """if (PyInt_CheckExact( $1 )) {
                    $2 = PyInt_AS_LONG ( $1 );
                    if ( $2 < 0) {
                    $2 += PyList_GET_SIZE($0);
                    }
                    if ((temp[$4] = PyList_GetItem ( $0 , $2 )) == 0) goto $3;
                    if ((int_$11 = PyObject_RichCompareBool ( temp[$4] , $5 , $6 )) == -1) goto $3;
                    temp[$4] = 0;
                    } else {
                    if ((temp[$4] = PyObject_GetItem ( $0 , $1 )) == 0) goto $3;
                    if ((int_$11 = PyObject_RichCompareBool ( temp[$4] , $5 , $6 )) == -1) goto $3;
                    CLEARTEMP($4);
                    }""", v2)
            
            
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $11 ) && ((long_$12 = PyInt_AS_LONG ( $11 ) + 1), !((long_$12^PyInt_AS_LONG ( $11 )) < 0 && (long_$12^1) < 0))) {
            temp[$5] = PyInt_FromLong ( long_$12 );
            } else {
            if ((temp[$5] = PyNumber_$15Add ( $11 , consts[$14] )) == 0) goto $6;
            }
            """, v2): 
                TxRepl(o, i, """if (PyInt_CheckExact( $11 ) && (long_$12 = PyInt_AS_LONG ( $11 )) < LONG_MAX ) {
                    temp[$5] = PyInt_FromLong ( long_$12 + 1 );
                    } else {
                    if ((temp[$5] = PyNumber_$15Add ( $11 , consts[$14] )) == 0) goto $6;
                    }
                    """, v2)
                return True               
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $11 ) && ((long_$12 = PyInt_AS_LONG ( $11 ) + 1), !((long_$12^PyInt_AS_LONG ( $11 )) < 0 && (long_$12^1) < 0))) {
            temp[$5] = PyInt_FromLong ( long_$12 );
            } else if (PyFloat_CheckExact( $11 )) {
            temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) + ((double)1));            
            } else {
            if ((temp[$5] = PyNumber_$15Add ( $11 , consts[$14] )) == 0) goto $6;
            }
            """, v2): 
                TxRepl(o, i, """if (PyInt_CheckExact( $11 ) && (long_$12 = PyInt_AS_LONG ( $11 )) < LONG_MAX ) {
                    temp[$5] = PyInt_FromLong ( long_$12 + 1 );
                    } else if (PyFloat_CheckExact( $11 )) {
                    temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) + ((double)1));            
                    } else {
                    if ((temp[$5] = PyNumber_$15Add ( $11 , consts[$14] )) == 0) goto $6;
                    }
                    """, v2)
                return True     
            
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $11 ) && ((long_$12 = PyInt_AS_LONG ( $11 ) + $8), !((long_$12^PyInt_AS_LONG ( $11 )) < 0 && (long_$12^$8) < 0))) {
            temp[$5] = PyInt_FromLong ( long_$12 );
            } else if (PyFloat_CheckExact( $11 )) {
            temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) + ((double)$8));            
            } else {
            if ((temp[$5] = PyNumber_$15Add ( $11 , consts[$14] )) == 0) goto $6;
            }
            """, v2) and int(v2[8]) > 0: 
                v2[18] = str(int(v2[8])-1) 
                TxRepl(o, i, """if (PyInt_CheckExact( $11 ) && (long_$12 = PyInt_AS_LONG ( $11 )) < (LONG_MAX-$18) ) {
                    temp[$5] = PyInt_FromLong ( long_$12 + $8 );
                    } else if (PyFloat_CheckExact( $11 )) {
                    temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) + ((double)$8));            
                    } else {
                    if ((temp[$5] = PyNumber_$15Add ( $11 , consts[$14] )) == 0) goto $6;
                    }
                    """, v2)
                return True               
                      
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $11 ) && ((long_$12 = PyInt_AS_LONG ( $11 ) - 1), !((long_$12^PyInt_AS_LONG ( $11 )) < 0 && (long_$12^~1) < 0))) {
            temp[$5] = PyInt_FromLong ( long_$12 );
            } else if (PyFloat_CheckExact( $11 )) {
            temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) - ((double)1));            
            } else {
            if ((temp[$5] = PyNumber_$15Subtract ( $11 , consts[$14] )) == 0) goto $6;
            }
            """, v2): 
                TxRepl(o, i, """if (PyInt_CheckExact( $11 ) && (long_$12 = PyInt_AS_LONG ( $11 )) > INT_MIN ) {
                    temp[$5] = PyInt_FromLong ( long_$12 - 1 );
                    } else if (PyFloat_CheckExact( $11 )) {
                    temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) - ((double)1));            
                    } else {
                    if ((temp[$5] = PyNumber_$15Subtract ( $11 , consts[$14] )) == 0) goto $6;
                    }
                    """, v2)
                return True 
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $11 ) && ((long_$12 = PyInt_AS_LONG ( $11 ) - $8), !((long_$12^PyInt_AS_LONG ( $11 )) < 0 && (long_$12^~$8) < 0))) {
            temp[$5] = PyInt_FromLong ( long_$12 );
            } else if (PyFloat_CheckExact( $11 )) {
            temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) - ((double)$8));            
            } else {
            if ((temp[$5] = PyNumber_$15Subtract ( $11 , consts[$14] )) == 0) goto $6;
            }
            """, v2) and int(v2[8]) > 0: 
                v2[18] = str(int(v2[8])-1) 
                TxRepl(o, i, """if (PyInt_CheckExact( $11 ) && (long_$12 = PyInt_AS_LONG ( $11 )) > (INT_MIN+$18) ) {
                    temp[$5] = PyInt_FromLong ( long_$12 - $8 );
                    } else if (PyFloat_CheckExact( $11 )) {
                    temp[$5] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) - ((double)$8));            
                    } else {
                    if ((temp[$5] = PyNumber_$15Subtract ( $11 , consts[$14] )) == 0) goto $6;
                    }
                    """, v2)
                return True             
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $11 ) && ((long_$12 = PyInt_AS_LONG ( $11 ) - 1), !((long_$12^PyInt_AS_LONG ( $11 )) < 0 && (long_$12^~1) < 0))) {
            temp[$5] = PyInt_FromLong ( long_$12 );
            } else {
            if ((temp[$5] = PyNumber_$15Subtract ( $11 , consts[$14] )) == 0) goto $6;
            }
            """, v2): 
                TxRepl(o, i, """if (PyInt_CheckExact( $11 ) && (long_$12 = PyInt_AS_LONG ( $11 )) > INT_MIN ) {
                    temp[$5] = PyInt_FromLong ( long_$12 - 1 );
                    } else {
                    if ((temp[$5] = PyNumber_$15Subtract ( $11 , consts[$14] )) == 0) goto $6;
                    }
                    """, v2)
                return True     
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $11 ) && ((long_$12 = PyInt_AS_LONG ( $11 ) - $8), !((long_$12^PyInt_AS_LONG ( $11 )) < 0 && (long_$12^~$8) < 0))) {
            temp[$5] = PyInt_FromLong ( long_$12 );
            } else {
            if ((temp[$5] = PyNumber_$15Subtract ( $11 , consts[$14] )) == 0) goto $6;
            }
            """, v2) and int(v2[8]) > 0: 
                v2[18] = str(int(v2[8])-1) 
                TxRepl(o, i, """if (PyInt_CheckExact( $11 ) && (long_$12 = PyInt_AS_LONG ( $11 )) > (INT_MIN+$18) ) {
                    temp[$5] = PyInt_FromLong ( long_$12 - $8 );
                    } else {
                    if ((temp[$5] = PyNumber_$15Subtract ( $11 , consts[$14] )) == 0) goto $6;
                    }
                    """, v2)
                return True                       
            
                
        if TxMatch(o, i, """   
            if ($1) {
            >0
            temp[$10] = PyInt_FromLong ( $15 );
            <1
            } else {
            >2
            if ((temp[$10] = $14) == 0) goto label_$12;
            <3
            }
            <4
            if ((temp[$11] = _PyEval_ApplySlice ( $16 , temp[$10] , NULL )) == 0) goto label_$12;
            <5
            CLEARTEMP($10);
            """, v2) and ('CLEARTEMP(' + v2[11] + ');') not in repr(v2[64]):
                TxRepl(o, i, """
                    if ($1) {
                    >0
                    <1
                    if ((temp[$11] = PySequence_GetSlice ( $16 , $15 , PY_SSIZE_T_MAX )) == 0) goto label_$12;
                    <4
                    <5
                    } else {
                    >2
                    if ((temp[$10] = $14) == 0) goto label_$12;
                    <3
                    <4
                    if ((temp[$11] = _PyEval_ApplySlice ( $16 , temp[$10] , NULL )) == 0) goto label_$12;
                    <5
                    CLEARTEMP($10);
                    }
                    """, v2)
                return True

            
        if TxMatch(o, i, """            
            if (PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) $5 $2 ) {
            temp[$3] = PyInt_FromLong ($4);
            } else {
            if ((temp[$3] = PyNumber_$7 ( $0 , $6 )) == 0) goto label_$8;
            }
            if ((temp[$9] = _PyEval_ApplySlice ( $10 , $11 , temp[$3] )) == 0) goto label_$8;
            CLEARTEMP($3);            
            """, v2) and v2[0] != v2[11] and not 'NULL' in v2[11]:
                TxRepl(o, i, """            
                    if (PyInt_CheckExact( $11 ) && PyInt_CheckExact( $0 ) && (long_$1 = PyInt_AS_LONG ( $0 )) $5 $2 ) {
                    if ((temp[$9] = PySequence_GetSlice ( $10 , PyInt_AS_LONG ( $11 ) , $4 )) == 0) goto label_$8;
                    } else {
                    if ((temp[$3] = PyNumber_$7 ( $0 , $6 )) == 0) goto label_$8;
                    if ((temp[$9] = _PyEval_ApplySlice ( $10 , $11 , temp[$3] )) == 0) goto label_$8;
                    CLEARTEMP($3);            
                    }
                    """, v2)
                return True
            
            
        if TxMatch(o, i, """if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < LONG_MAX ) {
            temp[$1] = PyInt_FromLong ( $4 + 1 );
            } else {
            if ((temp[$1] = PyNumber_Add ( $3 , $7 )) == 0) goto $5;
            }
            if ((temp[$2] = _PyEval_ApplySlice ( $6 , temp[$1] , NULL )) == 0) goto $5;
            CLEARTEMP($1);""", v2):
                TxRepl(o, i, """if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < LONG_MAX ) {
                    if ((temp[$2] = PySequence_GetSlice ( $6 , $4 + 1 , PY_SSIZE_T_MAX )) == 0) goto $5;
                    } else {
                    if ((temp[$1] = PyNumber_Add ( $3 , $7 )) == 0) goto $5;
                    if ((temp[$2] = _PyEval_ApplySlice ( $6 , temp[$1] , NULL )) == 0) goto $5;
                    CLEARTEMP($1);
                    }""", v2)
                return True
    
            
        if TxMatch(o, i, """if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) > INT_MIN ) {
            temp[$1] = PyInt_FromLong ( $3 - 1 );
            } else if (PyFloat_CheckExact( $2 )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) - ((double)1));
            } else {
            if ((temp[$1] = PyNumber_Subtract ( $2 , $5 )) == 0) goto $4;
            }
            $6 = PyInt_AsSsize_t ( temp[$1] );
            CLEARTEMP($1);""", v2):
                TxRepl(o, i, """if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) > INT_MIN ) {
                    $6 = $3 - 1;
                    } else {
                    if ((temp[$1] = PyNumber_Subtract ( $2 , $5 )) == 0) goto $4;
                    $6 = PyInt_AsSsize_t ( temp[$1] );
                    CLEARTEMP($1);
                    }""", v2)
                return True    
            

        if TxMatch(o, i, """if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < LONG_MAX ) {
            $3 = $3 + 1;
            temp[$0] = PyInt_FromLong ( $3 );
            if ((temp[$1] = _c_BINARY_SUBSCR_Int ( $5 , $3 , temp[$0] )) == 0) goto $4;
            } else {
            if ((temp[$0] = PyNumber_Add ( $2 , $6 )) == 0) goto $4;
            if ((temp[$1] = PyObject_GetItem ( $5 , temp[$0] )) == 0) goto $4;
            }
            CLEARTEMP($0);""", v2):
                TxRepl(o, i, """if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < LONG_MAX ) {
                    $3 = $3 + 1;
                    if ((temp[$1] = __c_BINARY_SUBSCR_Int ( $5 , $3 )) == 0) goto $4;
                    } else {
                    if ((temp[$0] = PyNumber_Add ( $2 , $6 )) == 0) goto $4;
                    if ((temp[$1] = PyObject_GetItem ( $5 , temp[$0] )) == 0) goto $4;
                    CLEARTEMP($0);
                    }""", v2, ('__c_BINARY_SUBSCR_Int',))
                return True    
            
        if TxMatch(o, i, """if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) > INT_MIN ) {
            $3 = $3 - 1;
            temp[$0] = PyInt_FromLong ( $3 );
            if ((temp[$1] = _c_BINARY_SUBSCR_Int ( $5 , $3 , temp[$0] )) == 0) goto $4;
            } else {
            if ((temp[$0] = PyNumber_Subtract ( $2 , $6 )) == 0) goto $4;
            if ((temp[$1] = PyObject_GetItem ( $5 , temp[$0] )) == 0) goto $4;
            }
            CLEARTEMP($0);""", v2):
                TxRepl(o, i, """if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) > INT_MIN ) {
                    $3 = $3 - 1;
                    if ((temp[$1] = __c_BINARY_SUBSCR_Int ( $5 , $3 )) == 0) goto $4;
                    } else {
                    if ((temp[$0] = PyNumber_Subtract ( $2 , $6 )) == 0) goto $4;
                    if ((temp[$1] = PyObject_GetItem ( $5 , temp[$0] )) == 0) goto $4;
                    CLEARTEMP($0);
                    }""", v2, ('__c_BINARY_SUBSCR_Int',))
                return True     


    
        if TxMatch(o, i, """if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < LONG_MAX ) {
            temp[$0] = PyInt_FromLong ( $3 + 1 );
            } else if (PyFloat_CheckExact( $1 )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)1));
            } else {
            if ((temp[$0] = PyNumber_Add ( $1 , $5 )) == 0) goto $4;
            }
            SETLOCAL ( $2 , temp[$0] );
            temp[$0] = 0;""", v2):
                TxRepl(o, i, """if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < LONG_MAX ) {
                    temp[$0] = PyInt_FromLong ( $3 + 1 );
                    } else {
                    if ((temp[$0] = PyNumber_Add ( $1 , $5 )) == 0) goto $4;
                    }
                    SETLOCAL ( $2 , temp[$0] );
                    temp[$0] = 0;""", v2)                
                return True    
            
        if TxMatch(o, i, """if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < LONG_MAX ) {
            temp[$0] = PyInt_FromLong ( $3 + 1 );
            } else if (PyFloat_CheckExact( $1 )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)1));
            } else {
            if ((temp[$0] = PyNumber_InPlaceAdd ( $1 , $5 )) == 0) goto $4;
            }
            SETLOCAL ( $2 , temp[$0] );
            temp[$0] = 0;""", v2):
                TxRepl(o, i, """if (PyInt_CheckExact( $1 ) && ($3 = PyInt_AS_LONG ( $1 )) < LONG_MAX ) {
                    temp[$0] = PyInt_FromLong ( $3 + 1 );
                    } else {
                    if ((temp[$0] = PyNumber_InPlaceAdd ( $1 , $5 )) == 0) goto $4;
                    }
                    SETLOCAL ( $2 , temp[$0] );
                    temp[$0] = 0;""", v2)                
                return True  
            
                        
        if TxMatch(o, i, """if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < LONG_MAX ) {
            temp[$1] = PyInt_FromLong ( $3 + 1 );
            } else if (PyFloat_CheckExact( $2 )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($2) + ((double)1));
            } else {
            if ((temp[$1] = PyNumber_Add ( $2 , $5 )) == 0) goto $4;
            }
            if (($6 = PyObject_RichCompareBool ( $7 , temp[$1] , $12 )) == -1) goto $4;
            CLEARTEMP($1);""", v2) and v2[12] in op_to_oper:
                v2[15] = op_to_oper[v2[12]].strip()
                TxRepl(o, i, """if (PyInt_CheckExact( $2 ) && ($3 = PyInt_AS_LONG ( $2 )) < LONG_MAX && PyInt_CheckExact( $7 )) {
                    $6 = PyInt_AS_LONG ( $7 ) $15 $3;
                    } else if (PyFloat_CheckExact( $2 ) && PyFloat_CheckExact( $7 )) {
                    $6 = PyFloat_AS_DOUBLE ( $7 ) $15 (PyFloat_AS_DOUBLE($2) + ((double)1));
                    } else {
                    if ((temp[$1] = PyNumber_Add ( $2 , $5 )) == 0) goto $4;
                    if (($6 = PyObject_RichCompareBool ( $7 , temp[$1] , $12 )) == -1) goto $4;
                    CLEARTEMP($1);
                    }""", v2)
                return True   
            
            
                        
        if TxMatch(o, i, """if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < (LONG_MAX-$6) ) {
            temp[$0] = PyInt_FromLong ( $4 + $7 );
            } else if (PyFloat_CheckExact( $3 )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) + ((double)$7));
            } else {
            if ((temp[$0] = PyNumber_Add ( $3 , $9 )) == 0) goto $5;
            }
            if (($1 = PyObject_RichCompareBool ( $8 , temp[$0] , $10 )) == -1) goto $5;
            CLEARTEMP($0);""", v2) and v2[10] in op_to_oper:
                v2[15] = op_to_oper[v2[10]].strip()
                TxRepl(o, i, """if (PyInt_CheckExact( $3 ) && ($4 = PyInt_AS_LONG ( $3 )) < (LONG_MAX-$6) && PyInt_CheckExact( $8 )) {
                    $1 = PyInt_AS_LONG ( $8 ) $15 ( $4 + $7 );
                    } else if (PyFloat_CheckExact( $3 ) && PyFloat_CheckExact( $8 )) {
                    $1 = PyFloat_AS_DOUBLE ( $8 ) $15 (PyFloat_AS_DOUBLE($3) + ((double)$7));
                    } else {
                    if ((temp[$0] = PyNumber_Add ( $3 , $9 )) == 0) goto $5;
                    if (($1 = PyObject_RichCompareBool ( $8 , temp[$0] , $10 )) == -1) goto $5;
                    CLEARTEMP($0);
                    }""", v2)
                return True   
            

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $8 ) && (long_$6 = PyInt_AS_LONG ( GETLOCAL(i) )) < $5 ) {
            temp[$2] = PyInt_FromLong ( long_$6 + $7 );
            } else {
            if ((temp[$2] = PyNumber_Add ( $8 , $9 )) == 0) goto label_$4;
            }
            if ((temp[$3] = _PyEval_ApplySlice ( temp[$0] , temp[$2] , NULL )) == 0) goto label_$4;
            CLEARTEMP($0);
            CLEARTEMP($2);
            """, v2):
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $8 ) && (long_$6 = PyInt_AS_LONG ( GETLOCAL(i) )) < $5 ) {
                    if ((temp[$3] = PySequence_GetSlice ( temp[$0] , long_$6 + $7 , PY_SSIZE_T_MAX )) == 0) goto label_$4;
                    CLEARTEMP($0);
                    } else {
                    if ((temp[$2] = PyNumber_Add ( $8 , $9 )) == 0) goto label_$4;
                    if ((temp[$3] = _PyEval_ApplySlice ( temp[$0] , temp[$2] , NULL )) == 0) goto label_$4;
                    CLEARTEMP($0);
                    CLEARTEMP($2);
                    }
                    """, v2)
                return True 



        if TxMatch(o, i, """
            if (PyInt_CheckExact( $1 ) && (long_$2 = PyInt_AS_LONG ( $1 )) < $6 ) {
            temp[$0] = PyInt_FromLong ( long_$2 + $4 );
            } else if (PyFloat_CheckExact( $1 )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) + ((double)$4));
            } else {
            if ((temp[$0] = PyNumber_Add ( $1 , $5 )) == 0) goto label_$3;
            }
            if ( _PyEval_AssignSlice ( $7 , $1 , temp[$0] , NULL ) == -1) goto label_$3;
            CLEARTEMP($0);
            """, v2):       
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $1 ) && (long_$2 = PyInt_AS_LONG ( $1 )) < $6 ) {
                    if ( PySequence_DelSlice ( $7 , long_$2 , long_$2 + $4 ) == -1) goto label_$3;
                    } else {
                    if ((temp[$0] = PyNumber_Add ( $1 , $5 )) == 0) goto label_$3;
                    if ( _PyEval_AssignSlice ( $7 , $1 , temp[$0] , NULL ) == -1) goto label_$3;
                    CLEARTEMP($0);
                    }
                    """, v2)
                return True            
            
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $4 ) && (long_$3 = PyInt_AS_LONG ( $4 )) > $5 ) {
            temp[$0] = PyInt_FromLong ( long_$3 - $6 );
            } else if (PyFloat_CheckExact( $4 )) {
            temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($4) - ((double)$6));
            } else {
            if ((temp[$0] = PyNumber_Subtract ( $4 , $7 )) == 0) goto label_$2;
            }
            if (PyInt_CheckExact( $4 ) && (long_$3 = PyInt_AS_LONG ( $4 )) > $8 ) {
            temp[$1] = PyInt_FromLong ( long_$3 - $9 );
            } else if (PyFloat_CheckExact( $4 )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($4) - ((double)$9));
            } else {
            if ((temp[$1] = PyNumber_Subtract ( $4 , $10 )) == 0) goto label_$2;
            }
            if ( _PyEval_AssignSlice ( $11 , temp[$0] , temp[$1] , NULL ) == -1) goto label_$2;
            CLEARTEMP($0);
            CLEARTEMP($1);
            """, v2) and type(v2[6]) is str and v2[6].isdigit() and type(v2[9]) is str and v2[9].isdigit() and int(v2[6]) >= int(v2[9]):       
                TxRepl(o, i, """
                    if (PyInt_CheckExact( $4 ) && (long_$3 = PyInt_AS_LONG ( $4 )) > $5 ) {
                    if ( PySequence_DelSlice ( $11 , long_$3 - $6 , long_$3 - $9 ) == -1) goto label_$2;
                    } else {
                    if ((temp[$0] = PyNumber_Subtract ( $4 , $7 )) == 0) goto label_$2;
                    if ((temp[$1] = PyNumber_Subtract ( $4 , $10 )) == 0) goto label_$2;
                    if ( _PyEval_AssignSlice ( $11 , temp[$0] , temp[$1] , NULL ) == -1) goto label_$2;
                    CLEARTEMP($0);
                    CLEARTEMP($1);                       
                    }
                    """, v2)
                return True            
            
            
    
        if TxMatch(o, i, """if (PyInt_CheckExact( $10 ) && ($12 = PyInt_AS_LONG ( $10 )) < LONG_MAX ) {
            temp[$0] = PyInt_FromLong ( $12 + 1 );
            } else {
            if ((temp[$0] = PyNumber_Add ( $10 , $16 )) == 0) goto $14;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            $15 = PyInt_AS_LONG ( temp[$0] );
            if ( $15 < 0) {
            $15 += PyList_GET_SIZE($11);
            }
            if ((temp[$4] = PyList_GetItem ( $11 , $15 )) == 0) goto $14;
            Py_INCREF(temp[$4]);
            } else {
            if ((temp[$4] = PyObject_GetItem ( $11 , temp[$0] )) == 0) goto $14;
            }
            CLEARTEMP($0);""", v2):
                TxRepl(o, i, """if (PyInt_CheckExact( $10 ) && ($12 = PyInt_AS_LONG ( $10 )) < LONG_MAX ) {
                    $15 = $12 + 1;
                    if ( $15 < 0) {
                    $15 += PyList_GET_SIZE($11);
                    }
                    if ((temp[$4] = PyList_GetItem ( $11 , $15 )) == 0) goto $14;
                    Py_INCREF(temp[$4]);
                    } else {
                    if ((temp[$0] = PyNumber_Add ( $10 , $16 )) == 0) goto $14;
                    if ((temp[$4] = PyObject_GetItem ( $11 , temp[$0] )) == 0) goto $14;
                    CLEARTEMP($0);
                    }""", v2)
                return True            
            
        if TxMatch(o, i, """if (PyInt_CheckExact( $0 ) && ($1 = PyInt_AS_LONG ( $0 )) > INT_MIN ) {
            temp[$2] = PyInt_FromLong ( $1 - 1 );
            } else if (PyFloat_CheckExact( $0 )) {
            temp[$2] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($0) - ((double)1));
            } else {
            if ((temp[$2] = PyNumber_Subtract ( $0 , $5 )) == 0) goto $4;
            }
            if ( PyObject_SetItem ( $6 , temp[$2] , temp[$3] ) == -1) goto $4;
            CLEARTEMP($3);
            CLEARTEMP($2);
            temp[$3] = 0;""", v2):  
                TxRepl(o, i, """if (PyInt_CheckExact( $0 ) && ($1 = PyInt_AS_LONG ( $0 )) > INT_MIN ) {
                    temp[$2] = PyInt_FromLong ( $1 - 1 );
                    } else {
                    if ((temp[$2] = PyNumber_Subtract ( $0 , $5 )) == 0) goto $4;
                    }
                    if ( PyObject_SetItem ( $6 , temp[$2] , temp[$3] ) == -1) goto $4;
                    CLEARTEMP($3);
                    CLEARTEMP($2);
                    temp[$3] = 0;""", v2)
                return True     
        
        if oi.startswith('if (PyInt_CheckExact( temp['): 
            if TxMatch(o, i, """
                if (PyInt_CheckExact( temp[$0] )) {
                temp[$1] = PyInt_FromLong ($3);
                } else {
                if ((temp[$1] = PyNumber_$4) == 0) goto $5;
                }
                CLEARTEMP($0);
                if ((int_$6 = c_Py_EQ_Int ( temp[$1] , $7 , $8 )) == -1) goto $5;
                CLEARTEMP($1);
                """, v2):         
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] )) {
                        int_$6 = ($3) == $7;
                        CLEARTEMP($0);
                        } else {
                        if ((temp[$1] = PyNumber_$4) == 0) goto $5;
                        CLEARTEMP($0);
                        if ((int_$6 = c_Py_EQ_Int ( temp[$1] , $7 , $8 )) == -1) goto $5;
                        CLEARTEMP($1);
                        }
                        """, v2)
                    return True   


        if TxMatch(o, i, """
            if (PyInt_CheckExact($1)) {
            temp[$0] = PyInt_FromLong ($3);
            } else {
            if ((temp[$0] = PyNumber_$4) == 0) goto $2;
            }
            long_$5 = PyInt_AsLong ( temp[$0] );
            CLEARTEMP($0);
            """, v2): 
                TxRepl(o, i, """
                    if (PyInt_CheckExact($1)) {
                    long_$5 = ($3);
                    } else {
                    if ((temp[$0] = PyNumber_$4) == 0) goto $2;
                    long_$5 = PyInt_AsLong ( temp[$0] );
                    CLEARTEMP($0);
                    }
                    """, v2) 
                return True   

        if oi.startswith('if (PyInt_CheckExact( temp['): 
            if TxMatch(o, i, """
                if (PyInt_CheckExact( temp[$2] ) && ($4 = PyInt_AS_LONG ( temp[$2] )) < LONG_MAX ) {
                temp[$0] = PyInt_FromLong ( $4 + 1 );
                } else if (PyFloat_CheckExact( temp[$2] )) {
                temp[$0] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$2]) + ((double)1));
                } else {
                if ((temp[$0] = PyNumber_Add ( temp[$2] , $5 )) == 0) goto $3;
                }
                CLEARTEMP($2);
                Py_ssize_t_$7 = PyInt_AsSsize_t ( temp[$0] );
                CLEARTEMP($0);        
                """, v2): 
                        TxRepl(o, i, """
                            Py_ssize_t_$7 = PyInt_AS_LONG ( temp[$2] ) + 1;
                            CLEARTEMP($2);
                            """, v2) 
                        return True   
    
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $5 )) {
            temp[$0] = PyInt_FromLong ( $6 );
            } else {
            if ((temp[$0] = PyNumber_$7) == 0) goto $8;
            }
            $9 = PyInt_AsSsize_t ( temp[$0] );
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $5 )) {
                        $9 = $6;
                        } else {
                        if ((temp[$0] = PyNumber_$7) == 0) goto $8;
                        $9 = PyInt_AsSsize_t ( temp[$0] );
                        CLEARTEMP($0);
                        }
                        """, v2)   
                    return True

    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $10 )) {
            temp[$0] = PyInt_FromLong ( PyInt_AS_LONG ( $10 ) $11 );
            } else {
            if ((temp[$0] = PyNumber_$12) == 0) goto $13;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            temp[$1] = PyInt_FromLong ( $14 PyInt_AS_LONG ( temp[$0] ) );
            } else {
            if ((temp[$1] = PyNumber_$15 ( $16 , temp[$0] )) == 0) goto $13;
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $10 )) {
                        temp[$1] = PyInt_FromLong ( $14 (PyInt_AS_LONG ( $10 ) $11) );
                        } else {
                        if ((temp[$0] = PyNumber_$12) == 0) goto $13;
                        if ((temp[$1] = PyNumber_$15 ( $16 , temp[$0] )) == 0) goto $13;
                        CLEARTEMP($0);
                        }
                        """, v2)   
                    return True
    
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $2 )) {
            long_$3 = PyInt_AS_LONG ( $2 );
            long_$3 = $5;
            temp[$0] = PyInt_FromLong ( long_$3 );
            } else {
            if ((temp[$0] = PyNumber_$9) == 0) goto $6;
            }
            if (PyInt_CheckExact( temp[$0] )) {
            temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $7 );
            } else {
            if ((temp[$1] = PyNumber_$8) == 0) goto $6;
            }
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $2 )) {
                        long_$3 = PyInt_AS_LONG ( $2 );
                        long_$3 = $5;
                        temp[$1] = PyInt_FromLong ( long_$3 $7 );
                        } else {
                        if ((temp[$0] = PyNumber_$9) == 0) goto $6;
                        if ((temp[$1] = PyNumber_$8) == 0) goto $6;
                        CLEARTEMP($0);
                        }
                        """, v2)   
                    return True
        if oi.startswith('if (PyInt_CheckExact( GETLOCAL('): 
            if TxMatch(o, i, """
                if (PyInt_CheckExact( GETLOCAL($1) ) && (long_$5 = PyInt_AS_LONG ( GETLOCAL($1) )) < LONG_MAX ) {
                temp[$0] = PyInt_FromLong ( long_$5 + 1 );
                } else {
                if ((temp[$0] = PyNumber_$10Add ( GETLOCAL($1) , consts[$11] )) == 0) goto label_$12;
                }
                SETLOCAL ( $1 , temp[$0] );
                temp[$0] = 0;
                """, v2): 
                        TxRepl(o, i, """
                            if (PyInt_CheckExact( GETLOCAL($1) ) && (long_$5 = PyInt_AS_LONG ( GETLOCAL($1) )) < LONG_MAX ) {
                            Py_DECREF(GETLOCAL($1));
                            GETLOCAL($1) = PyInt_FromLong ( long_$5 + 1 );
                            } else {
                            SETLOCAL ( $1 , PyNumber_$10Add ( GETLOCAL($1) , consts[$11] ) );
                            if (GETLOCAL($1) == 0) goto label_$12;
                            }
                            """, v2) 
                        return True
    
            if TxMatch(o, i, """
                if (PyInt_CheckExact( GETLOCAL($1) ) && (long_$4 = PyInt_AS_LONG ( GETLOCAL($1) )) < LONG_MAX ) {
                long_$4 = long_$4 + 1;
                if ((temp[$10] = __c_BINARY_SUBSCR_Int ( $3 , long_$4 )) == 0) goto label_$12;
                } else {
                if ((temp[$0] = PyNumber_Add ( GETLOCAL($1) , consts[$11] )) == 0) goto label_$12;
                if ((temp[$10] = PyObject_GetItem ( $3 , temp[$0] )) == 0) goto label_$12;
                CLEARTEMP($0);
                }
                """, v2): 
                        TxRepl(o, i, """
                            if (PyInt_CheckExact( GETLOCAL($1) ) && (long_$4 = PyInt_AS_LONG ( GETLOCAL($1) )) < LONG_MAX ) {
                            if ((temp[$10] = __c_BINARY_SUBSCR_Int ( $3 , long_$4 + 1 )) == 0) goto label_$12;
                            } else {
                            if ((temp[$0] = PyNumber_Add ( GETLOCAL($1) , consts[$11] )) == 0) goto label_$12;
                            if ((temp[$10] = PyObject_GetItem ( $3 , temp[$0] )) == 0) goto label_$12;
                            CLEARTEMP($0);
                            }
                            """, v2) 
                        return True
    
        if oi.startswith('if (PyInt_CheckExact( temp['): 
            if TxMatch(o, i, """
                if (PyInt_CheckExact( temp[$0] )) {
                temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $10 );
                } else {
                if ((temp[$1] = PyNumber_$12 ( temp[$0] , $13 )) == 0) goto label_$11;
                }
                CLEARTEMP($0);
                if (PyInt_CheckExact( temp[$1] )) {
                temp[$2] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $14 );
                } else {
                if ((temp[$2] = PyNumber_$16 ( temp[$1] , $15 )) == 0) goto label_$11;
                }
                CLEARTEMP($1);                
                """, v2): 
                        TxRepl(o, i, """
                if (PyInt_CheckExact( temp[$0] )) {
                temp[$2] = PyInt_FromLong ( (PyInt_AS_LONG ( temp[$0] ) $10) $14 );
                } else {
                if ((temp[$1] = PyNumber_$12 ( temp[$0] , $13 )) == 0) goto label_$11;
                CLEARTEMP($0);
                if ((temp[$2] = PyNumber_$16 ( temp[$1] , $15 )) == 0) goto label_$11;
                CLEARTEMP($1);                
                }
                """, v2) 
                        return True 
                    

        if oi.startswith('if (PyInt_CheckExact( temp['): 
            if TxMatch(o, i, """
                if (PyInt_CheckExact( temp[$0] ) && (long_$3 = PyInt_AS_LONG ( temp[$0] )) > $4 ) {
                temp[$1] = PyInt_FromLong ( long_$3 $5 $6 );
                } else {
                if ((temp[$1] = PyNumber_$7 ( temp[$0] , $8 )) == 0) goto label_$9;
                }
                CLEARTEMP($0);
                if (PyInt_CheckExact( temp[$1] )) {
                int_$10 = $11 $12 PyInt_AS_LONG ( temp[$1] );
                } else {
                temp[$2] = PyInt_FromLong ( $11 );
                if ((int_$10 = PyObject_RichCompareBool ( temp[$2] , temp[$1] , $13 )) == -1) goto label_$9;
                CLEARTEMP($2);
                }
                CLEARTEMP($1);
                """, v2): 
                        TxRepl(o, i, """
                            if (PyInt_CheckExact( temp[$0] ) && (long_$3 = PyInt_AS_LONG ( temp[$0] )) > $4 ) {
                            CLEARTEMP($0);
                            int_$10 = $11 $12 ( long_$3 $5 $6 );
                            } else {
                            if ((temp[$1] = PyNumber_$7 ( temp[$0] , $8 )) == 0) goto label_$9;
                            CLEARTEMP($0);
                            temp[$2] = PyInt_FromLong ( $11 );
                            if ((int_$10 = PyObject_RichCompareBool ( temp[$2] , temp[$1] , $13 )) == -1) goto label_$9;
                            CLEARTEMP($2);
                            CLEARTEMP($1);
                            }
                            """, v2) 
                        return True 
    

        if TxMatch(o, i, """
            if (PyInt_CheckExact( $1 ) && (long_$2 = PyInt_AS_LONG ( $1 )) $3 ) {
            temp[$8] = PyInt_FromLong ( long_$2 $4 );
            } else if (PyFloat_CheckExact( $1 )) {
            temp[$8] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($1) $5);
            } else {
            if ((temp[$8] = PyNumber_$7 ( $1 , consts[$6] )) == 0) goto label_$10;
            }
            if (PyInt_CheckExact( temp[$8] )) {
            temp[$9] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$8] ) $11 );
            } else {
            if ((temp[$9] = PyNumber_$12 ( temp[$8] , consts[$14] )) == 0) goto label_$10;
            }
            CLEARTEMP($8);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $1 ) && (long_$2 = PyInt_AS_LONG ( $1 )) $3 ) {
                        temp[$9] = PyInt_FromLong ( ( long_$2 $4 ) $11 );
                        } else {
                        if ((temp[$8] = PyNumber_$7 ( $1 , consts[$6] )) == 0) goto label_$10;
                        if ((temp[$9] = PyNumber_$12 ( temp[$8] , consts[$14] )) == 0) goto label_$10;
                        CLEARTEMP($8);
                        }
                        """, v2) 
                    return True 

        if oi.startswith('if (PyInt_CheckExact( temp['): 
            if TxMatch(o, i, """
                if (PyInt_CheckExact( temp[$0] )$4) {
                temp[$1] = PyInt_FromLong ( $5 );
                } else {
                if ((temp[$1] = PyNumber_$6) == 0) goto label_$3;
                }
                CLEARTEMP($0);
                if (PyInt_CheckExact( $2 ) && PyInt_CheckExact( temp[$1] )) {
                temp[$0] = PyInt_FromLong ( PyInt_AS_LONG ( $2 ) $7 PyInt_AS_LONG ( temp[$1] ) );
                } else {
                if ((temp[$0] = PyNumber_$8) == 0) goto label_$3;
                }
                CLEARTEMP($1);
                """, v2):
                        TxRepl(o, i, """
                            if (PyInt_CheckExact( $2 ) && PyInt_CheckExact( temp[$0] )$4) {
                            temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( $2 ) $7 ( $5 ) );
                            CLEARTEMP($0);
                            temp[$0] = temp[$1];
                            temp[$1] = 0;
                            } else {
                            if ((temp[$1] = PyNumber_$6) == 0) goto label_$3;
                            CLEARTEMP($0);
                            if ((temp[$0] = PyNumber_$8) == 0) goto label_$3;
                            CLEARTEMP($1);
                            }
                            """, v2) 
                        return True 
        if TxMatch(o, i, """
            if (PyInt_CheckExact( $4 )) {
            temp[$2] = PyInt_FromLong ( $5 );
            } else {
            >1
            }
            if (PyInt_CheckExact( temp[$0] ) && PyInt_CheckExact( temp[$2] )) {
            temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $7 PyInt_AS_LONG ( temp[$2] ) );
            } else {
            if ((temp[$1] = PyNumber_$8) == 0) goto label_$3;
            }
            CLEARTEMP($0);
            CLEARTEMP($2);
            """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $4 ) && PyInt_CheckExact( temp[$0] )) {
                        temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $7 ( $5 ) );
                        } else {
                        >1
                        if ((temp[$1] = PyNumber_$8) == 0) goto label_$3;
                        CLEARTEMP($2);
                        }
                        CLEARTEMP($0);
                        """, v2) 
                    return True 
                
             
        if TxMatch(o, i, """ 
            if (PyInt_CheckExact( $3 )) {
            temp[$0] = PyInt_FromLong ( $6 );
            } else {
            >1
            }
            if (PyInt_CheckExact( $4 ) && PyInt_CheckExact( temp[$0] )) {
            temp[$2] = PyInt_FromLong ( $7 );
            } else {
            >3
            }
            CLEARTEMP($0);
            """, v2):         
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $3 ) && PyInt_CheckExact( $4 )) {
                        temp[$0] = PyInt_FromLong ( $6 );
                        temp[$2] = PyInt_FromLong ( $7 );
                        CLEARTEMP($0);
                        } else {
                        >1
                        >3
                        CLEARTEMP($0);
                        }
                        """, v2) 
                    return True 

        if TxMatch(o, i, """ 
            if (PyInt_CheckExact( $4 )) {
            temp[$0] = PyInt_FromLong ( $6 );
            } else {
            >0
            }
            if (PyInt_CheckExact( $5 )) {
            >1
            temp[$2] = PyInt_FromLong ( $7 );
            } else {
            >2
            }
            if (PyInt_CheckExact( temp[$0] ) && PyInt_CheckExact( temp[$2] )) {
            temp[$1] = PyInt_FromLong ( $8) );
            } else {
            >3
            }
            CLEARTEMP($0);
            CLEARTEMP($2);
            """, v2):
                    TxRepl(o, i, """
                    if (PyInt_CheckExact( $4 ) && PyInt_CheckExact( $5 )) {
                    temp[$0] = PyInt_FromLong ( $6 );
                    >1
                    temp[$2] = PyInt_FromLong ( $7 );
                    temp[$1] = PyInt_FromLong ( $8) );
                    CLEARTEMP($0);
                    CLEARTEMP($2);
                    } else {
                    >0
                    >2
                    >3
                    CLEARTEMP($0);
                    CLEARTEMP($2);
                    }
                    """, v2) 
                    return True       
                
        if TxMatch(o, i, """  
            if (PyInt_CheckExact$10) {
            >2
            temp[$1] = PyInt_FromLong ( $11 );
            } else if (PyFloat_CheckExact$12) {
            >0
            } else {
            >1
            }
            if (PyInt_CheckExact( temp[$1] )) {
            long_$13 = PyInt_AS_LONG ( temp[$1] );
            if ( long_$13 < 0) {
            long_$13 += PyList_GET_SIZE($14);
            }
            if ( PyList_SetItem ( $14 , long_$13 , temp[$0] ) == -1) goto label_$15;
            } else {
            if ( PyObject_SetItem ( $14 , temp[$1] , temp[$0] ) == -1) goto label_$15;
            Py_DECREF(temp[$0]);
            }
            CLEARTEMP($1);         
            """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact$10) {
                        >2
                        long_$13 = $11;
                        if ( long_$13 < 0) {
                        long_$13 += PyList_GET_SIZE($14);
                        }
                        if ( PyList_SetItem ( $14 , long_$13 , temp[$0] ) == -1) goto label_$15;
                        } else {
                        >1
                        if ( PyObject_SetItem ( $14 , temp[$1] , temp[$0] ) == -1) goto label_$15;
                        Py_DECREF(temp[$0]);
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True                             
                
           

        if TxMatch(o, i, """  
            if (PyInt_CheckExact$3) {
            temp[$1] = PyInt_FromLong ( $4 );
            } else {
            if ((temp[$1] = PyNumber_$5) == 0) goto label_$6;
            }
            if (PyInt_CheckExact( temp[$0] ) && PyInt_CheckExact( temp[$1] )) {
            temp[$2] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $7 PyInt_AS_LONG ( temp[$1] ) );
            } else {
            if ((temp[$2] = PyNumber_$8) == 0) goto label_$6;
            }
            CLEARTEMP($0);
            CLEARTEMP($1);
            """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( temp[$0] ) && PyInt_CheckExact$3) {
                        temp[$2] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $7 ( $4 ) );
                        } else {
                        if ((temp[$1] = PyNumber_$5) == 0) goto label_$6;
                        if ((temp[$2] = PyNumber_$8) == 0) goto label_$6;
                        CLEARTEMP($1);
                        }
                        CLEARTEMP($0);
                        """, v2) 
                    return True  
        
        
        if TxMatch(o, i, """  
            if (PyInt_CheckExact$10) {
            >1
            temp[$3] = PyInt_FromLong ( $11 );
            } else {
            >2
            }
            if ((temp[$4] = PyObject_GetItem ( $12 , temp[$3] )) == 0) goto label_$15;
            CLEARTEMP($3);                
            """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact$10) {
                        >1
                        temp[$3] = PyInt_FromLong ( $11 );
                        if ((temp[$4] = PyObject_GetItem ( $12 , temp[$3] )) == 0) goto label_$15;
                        CLEARTEMP($3); 
                        } else {
                        >2
                        if ((temp[$4] = PyObject_GetItem ( $12 , temp[$3] )) == 0) goto label_$15;
                        CLEARTEMP($3); 
                        }
                        """, v2)
                    return True

                
        if TxMatch(o, i, """                  
            if (PyInt_CheckExact$10) {
            temp[$0] = PyInt_FromLong ( $12 );
            } else {
            >1
            }
            if (PyInt_CheckExact$11) {
            temp[$2] = PyInt_FromLong ( $13 );
            } else {
            >2
            }
            if (PyInt_CheckExact( temp[$0] ) && PyInt_CheckExact( temp[$2] )) {
            temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $14 PyInt_AS_LONG ( temp[$2] ) );
            } else {
            >3
            }
            CLEARTEMP($0);
            CLEARTEMP($2);             
            """, v2) and type(v2[10]) is str and type(v2[11]) is str and (v2[10].count(' = ') + v2[11].count(' = ')) < 2:
                    TxRepl(o, i, """
                        if (PyInt_CheckExact$10 && PyInt_CheckExact$11) {
                        temp[$0] = PyInt_FromLong ( $12 );
                        temp[$2] = PyInt_FromLong ( $13 );
                        temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $14 PyInt_AS_LONG ( temp[$2] ) );
                        CLEARTEMP($0);
                        CLEARTEMP($2); 
                        } else {
                        >1
                        >2
                        >3
                        CLEARTEMP($0);
                        CLEARTEMP($2); 
                        }
                        """, v2)
                    return True
        if oi.startswith('if (PyInt_CheckExact( temp['): 
            if TxMatch(o, i, """                  
                if (PyInt_CheckExact( temp[$2] )) {
                temp[$3] = PyInt_FromLong ( $4 );
                } else {
                >1
                }
                CLEARTEMP($2);
                if (PyInt_CheckExact( temp[$1] ) && PyInt_CheckExact( temp[$3] )) {
                temp[$2] = PyInt_FromLong ( $5 );
                } else {
                >2
                }
                CLEARTEMP($1);
                CLEARTEMP($3);            
                """, v2):
                        TxRepl(o, i, """
                            if (PyInt_CheckExact( temp[$1] ) && PyInt_CheckExact( temp[$2] )) {
                            temp[$3] = PyInt_FromLong ( $4 );
                            CLEARTEMP($2);
                            temp[$2] = PyInt_FromLong ( $5 );
                            CLEARTEMP($1);
                            CLEARTEMP($3);                         
                            } else {
                            >1
                            CLEARTEMP($2);
                            >2
                            CLEARTEMP($1);
                            CLEARTEMP($3);                         
                            }
                            """, v2)
                        return True   


        if TxMatch(o, i, """                  
            if (PyInt_CheckExact( $3 )) {
            long_$4 = PyInt_AS_LONG ( $3 );
            if (!$5 || !long_$4 || ($5 * long_$4) / long_$4 == $5) {
            temp[$1] = PyInt_FromLong ( $5 * long_$4 );
            } else {
            temp[$1] = PyInt_Type.tp_as_number->nb_multiply($6, $3);
            }
            } else {
            if ((temp[$1] = PyNumber_Multiply ( $6 , $3 )) == 0) goto label_$7;
            }
            """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $3 ) && ( (long_$4 = PyInt_AS_LONG ( $3 )) , (!$5 || !long_$4 || ($5 * long_$4) / long_$4 == $5) )) {
                        temp[$1] = PyInt_FromLong ( $5 * long_$4 );
                        } else {
                        if ((temp[$1] = PyNumber_Multiply ( $6 , $3 )) == 0) goto label_$7;
                        }  
                        """, v2)
                    return True  
        if TxMatch(o, i, """                  
            if (PyInt_CheckExact( $11
            temp[$0] = PyInt_FromLong ( long_$2 );
            } else {
            >0
            }
            if (PyInt_CheckExact( temp[$0] )) {
            long_$2 = PyInt_AS_LONG ( temp[$0] );
            if ( long_$2 < 0) {
            long_$2 += $5;
            }
            if ((temp[$1] = PyList_GetItem ( $6 , long_$2 )) == 0) goto label_$7;
            Py_INCREF(temp[$1]);
            } else {
            >1
            }
            CLEARTEMP($0);                
            """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $11
                        if ( long_$2 < 0) {
                        long_$2 += $5;
                        }
                        if ((temp[$1] = PyList_GetItem ( $6 , long_$2 )) == 0) goto label_$7;
                        Py_INCREF(temp[$1]);                        
                        } else {
                        >0
                        >1
                        CLEARTEMP($0); 
                        }
                        """, v2)
                    return True 
                
        if TxMatch(o, i, """                  
            if (PyInt_CheckExact($11
            temp[$0] = PyInt_FromLong ( long_$2 );
            } else if (PyFloat_CheckExact($12
            temp[$0] = PyFloat_FromDouble($14
            } else {
            >1
            }
            Py_ssize_t_$3 = PyInt_AsSsize_t ( temp[$0] );
            CLEARTEMP($0);              
            """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact($11
                        Py_ssize_t_$3 = long_$2;
                        } else {
                        >1
                        Py_ssize_t_$3 = PyInt_AsSsize_t ( temp[$0] );
                        CLEARTEMP($0);                            
                        }
                        """, v2)
                    return True                 
        if TxMatch(o, i, """                  
            if (PyInt_CheckExact( $19 )) {
            temp[$2] = PyInt_FromLong ( $18 );
            } else {
            >1
            }
            <2
            if ((temp[$11] = PyTuple_New ( 1 )) == 0) goto label_$17;
            PyTuple_SET_ITEM ( temp[$11] , 0 , temp[$2] );
            if ((temp[$2] = PyBool_Type.tp_new ( &PyBool_Type , temp[$11] , NULL )) == 0) goto label_$17;
            CLEARTEMP($11);            
            """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact( $19 )) {
                        temp[$2] = PyBool_FromLong ( ( $18 ) != 0 );
                        <2
                        } else {
                        >1
                        <2
                        if ((temp[$11] = PyTuple_New ( 1 )) == 0) goto label_$17;
                        PyTuple_SET_ITEM ( temp[$11] , 0 , temp[$2] );
                        if ((temp[$2] = PyBool_Type.tp_new ( &PyBool_Type , temp[$11] , NULL )) == 0) goto label_$17;
                        CLEARTEMP($11);              
                        }
                        """, v2)
                    return True                     

        if TxMatch(o, i, """                  
            if (PyInt_CheckExact($1) && PyInt_AS_LONG($1) > $4) {
            temp[$10] = PyInt_FromLong ( PyInt_AS_LONG($1) - $3 );
            } else {
            if ((temp[$10] = PyNumber_Subtract( $1 , $2 )) == 0) goto label_$0;
            }
            CLEARTEMP($10);         
            """, v2):
                    TxRepl(o, i, """
                        if (!PyInt_CheckExact($1)) {
                        if ((temp[$10] = PyNumber_Subtract( $1 , $2 )) == 0) goto label_$0;
                        CLEARTEMP($10);
                        }
                    """, v2)
                    return True   
        if TxMatch(o, i, """                  
            if (PyInt_CheckExact(temp[$1]) && PyInt_AS_LONG(temp[$1]) <= $3) {
            temp[$2] = PyInt_FromLong ( $4 + PyInt_AS_LONG(temp[$1]) );
            } else {
            temp[$0] = PyInt_FromLong( $4 );
            if ((temp[$2] = PyLong_Type.tp_as_number->nb_add( temp[$0] , temp[$1] )) == 0) goto label_$10;
            CLEARTEMP($0);
            }
            CLEARTEMP($0);                                  
            """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact(temp[$1]) && PyInt_AS_LONG(temp[$1]) <= $3) {
                        temp[$2] = PyInt_FromLong ( $4 + PyInt_AS_LONG(temp[$1]) );
                        } else {
                        temp[$0] = PyInt_FromLong( $4 );
                        if ((temp[$2] = PyLong_Type.tp_as_number->nb_add( temp[$0] , temp[$1] )) == 0) goto label_$10;
                        CLEARTEMP($0);
                        }
                    """, v2)
                    return True   
        if TxMatch(o, i, """                  
            if (PyInt_CheckExact($7) && PyInt_AS_LONG($7) <= $8) {
            temp[$1] = PyInt_FromLong ( PyInt_AS_LONG($7) + $9 );
            } else {
            if ((temp[$1] = PyNumber_Add( $7 , $10 )) == 0) goto label_$11;
            }
            if (PyInt_CheckExact(temp[$1]) && PyInt_AS_LONG(temp[$1]) <= $12) {
            temp[$2] = PyInt_FromLong ( $13 + PyInt_AS_LONG(temp[$1]) );
            } else {
            temp[$0] = PyInt_FromLong( $13 );
            if ((temp[$2] = PyLong_Type.tp_as_number->nb_add( temp[$0] , temp[$1] )) == 0) goto label_$11;
            CLEARTEMP($0);
            }
            CLEARTEMP($1);
            """, v2):
                    TxRepl(o, i, """
                        if (PyInt_CheckExact($7) && PyInt_AS_LONG($7) <= $8 && (PyInt_AS_LONG($7) + $9)  <= $12) {
                        temp[$2] = PyInt_FromLong ( $13 + (PyInt_AS_LONG($7) + $9) );
                        } else {
                        if ((temp[$1] = PyNumber_Add( $7 , $10 )) == 0) goto label_$11;
                        temp[$0] = PyInt_FromLong( $13 );
                        if ((temp[$2] = PyLong_Type.tp_as_number->nb_add( temp[$0] , temp[$1] )) == 0) goto label_$11;
                        CLEARTEMP($0);
                        CLEARTEMP($1);
                        }
                    """, v2)
                    return True   
    if False:
        if TxMatch(o, i, """                  
            if ($9) {
            <0
            temp[$0] = PyInt_FromLong ( long_$3 );
            temp[$1] = PyInt_FromLong ( $4 );
            int_$5 = PyInt_AS_LONG ( temp[$0] ) $6 PyInt_AS_LONG ( temp[$1] );
            CLEARTEMP($0);
            } else {
            >1
            }
            CLEARTEMP($1);          
            """, v2) and ' ' not in v2[3] and ('long_' + v2[3]) not in v2[4] and ' ' not in v2[6]:
                    TxRepl(o, i, """
                        if ($9) {
                        <0
                        int_$5 = long_$3 $6 ( $4 );
                        } else {
                        >1
                        CLEARTEMP($1); 
                        }
                        """, v2)
                    return True                  
                    
        if TxMatch(o, i, """                  
            if ($9) {
            <0
            temp[$0] = PyInt_FromLong ( $3 );
            temp[$1] = PyInt_FromLong ( $4 );
            int_$5 = PyInt_AS_LONG ( temp[$0] ) $6 PyInt_AS_LONG ( temp[$1] );
            CLEARTEMP($0);
            } else {
            >1
            }
            CLEARTEMP($1);          
            """, v2) and 'long_' not in v2[4] and ' ' not in v2[6] and 'long_' in v2[3]:
                    TxRepl(o, i, """
                        if ($9) {
                        <0
                        int_$5 = ( $3 ) $6 ( $4 );
                        } else {
                        >1
                        CLEARTEMP($1); 
                        }
                        """, v2)
                    return True 
                
    if oi.startswith('if (PyInt_CheckExact'):

        if TxMatch(o, i, """   
            if (PyInt_CheckExact$10) {
            >0
            temp[$4] = PyInt_FromLong ( $11 );
            } else {
            >1
            }
            <2
            if (PyInt_CheckExact( $12 ) && PyInt_CheckExact( temp[$4] )) {
            >3
            temp[$3] = PyInt_FromLong ( $14 PyInt_AS_LONG ( temp[$4] ) );
            } else {
            >4
            }
            CLEARTEMP($4);                
            """, v2) and 'temp[' not in v2[12]: 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact$10) {
                        >0
                        temp[$4] = PyInt_FromLong ( $11 );
                        <2
                        >3
                        temp[$3] = PyInt_FromLong ( $14 PyInt_AS_LONG ( temp[$4] ) );
                        CLEARTEMP($4);
                        } else {
                        >1
                        <2
                        >4
                        CLEARTEMP($4);
                        }
                        """, v2) 
                    return True 
        if TxMatch(o, i, """   
            if (PyInt_CheckExact(temp[$0]) && PyInt_AS_LONG(temp[$0]) <= (LONG_MAX - $3)) {
            temp[$1] = PyInt_FromLong ( $3 + PyInt_AS_LONG(temp[$0]) );
            } else {
            if ((temp[$1] = PyLong_Type.tp_as_number->nb_add( $5 , temp[$0] )) == 0) goto label_$10;
            }
            CLEARTEMP($0);
            if (PyInt_CheckExact(temp[$1]) && PyInt_AS_LONG(temp[$1]) > LONG_MIN) {
            temp[$0] = PyInt_FromLong ( PyInt_AS_LONG(temp[$1]) - 1 );
            } else {
            if ((temp[$0] = PyNumber_Subtract( temp[$1] , $6 )) == 0) goto label_$10;
            }
            CLEARTEMP($1);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact(temp[$0]) && PyInt_AS_LONG(temp[$0]) <= (LONG_MAX - $3)) {
                        temp[$1] = PyInt_FromLong ( ($3 + PyInt_AS_LONG(temp[$0])) - 1 );
                        CLEARTEMP($0);
                        temp[$0] = temp[$1];
                        temp[$1] = 0;
                        } else {
                        if ((temp[$1] = PyLong_Type.tp_as_number->nb_add( $5 , temp[$0] )) == 0) goto label_$10;
                        CLEARTEMP($0);
                        if ((temp[$0] = PyNumber_Subtract( temp[$1] , $6 )) == 0) goto label_$10;
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True                 
        if TxMatch(o, i, """   
            if (PyInt_CheckExact(temp[$0])) {
            temp[$1] = PyInt_FromLong($3);
            } else {
            if ((temp[$1] = PyNumber_$5) == 0) goto label_$10;
            }
            CLEARTEMP($0);
            if (PyInt_CheckExact( temp[$1] )) {
            temp[$0] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $6 );
            } else {
            if ((temp[$0] = PyNumber_$7) == 0) goto label_$10;
            }
            CLEARTEMP($1);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact(temp[$0])) {
                        temp[$1] = PyInt_FromLong ( ($3) $6 );
                        CLEARTEMP($0);
                        temp[$0] = temp[$1];
                        temp[$1] = 0;
                        } else {
                        if ((temp[$1] = PyNumber_$5) == 0) goto label_$10;
                        CLEARTEMP($0);
                        if ((temp[$0] = PyNumber_$7) == 0) goto label_$10;
                        }
                        """, v2) 
                    return True    
        if TxMatch(o, i, """   
            if (PyInt_CheckExact(temp[$0])) {
            temp[$1] = PyInt_FromLong ( PyInt_AS_LONG(temp[$0]) $3 );
            } else {
            if ((temp[$1] = PyNumber_$5) == 0) goto label_$10;
            }
            CLEARTEMP($0);
            if ( PyInt_CheckExact(temp[$1]) ) {
            int_$9 = PyInt_AS_LONG(temp[$1])$12;
            } else {
            if ((int_$9 = PyObject_RichCompareBool ($15)) == -1) goto label_$10;
            }
            CLEARTEMP($1);
            """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_CheckExact(temp[$0])) {
                        int_$9 = ( PyInt_AS_LONG(temp[$0]) $3 )$12;
                        CLEARTEMP($0);
                        } else {
                        if ((temp[$1] = PyNumber_$5) == 0) goto label_$10;
                        CLEARTEMP($0);
                        if ((int_$9 = PyObject_RichCompareBool ($15)) == -1) goto label_$10;
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True    

        if oi.startswith('if (PyInt_CheckExact( temp['): 
            if TxMatch(o, i, """   
                if (PyInt_CheckExact( temp[$0] ) && (long_$3 = PyInt_AS_LONG ( temp[$0] )) > $2 ) {
                temp[$1] = PyInt_FromLong ( $4 );
                } else {
                if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $5 )) == 0) goto label_$8;
                }
                CLEARTEMP($0);
                if (PyInt_CheckExact( temp[$1] ) && (long_$3 = PyInt_AS_LONG ( temp[$1] )) < (LONG_MAX >> $6) && long_$3 >= 0) {
                temp[$0] = PyInt_FromLong ( (long_$3 << $6) );
                } else {
                if ((temp[$0] = PyNumber_Lshift(temp[$1], $7)) == 0) goto label_$8;
                }
                CLEARTEMP($1); 
                """, v2): 
                        TxRepl(o, i, """
                            if (PyInt_CheckExact( temp[$0] ) && (long_$3 = PyInt_AS_LONG ( temp[$0] )) > $2 && ( (long_$3 = $4) , (long_$3 < (LONG_MAX >> $6) && long_$3 >= 0) )) {
                            CLEARTEMP($0);
                            temp[$0] = PyInt_FromLong ( (long_$3 << $6) );
                            } else {
                            if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $5 )) == 0) goto label_$8;
                            CLEARTEMP($0);
                            if ((temp[$0] = PyNumber_Lshift(temp[$1], $7)) == 0) goto label_$8;
                            CLEARTEMP($1); 
                            }
                            """, v2) 
                        return True                 
                
    if 'PyFloat_CheckExact' in oi:
        if oi.startswith('if (PyFloat_CheckExact( temp['):
            if TxMatch(o, i, """
                if (PyFloat_CheckExact( temp[$0] )) {
                temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) * PyFloat_AS_DOUBLE(temp[$0]));
                } else if (PyInt_CheckExact( temp[$0] )) {
                long_$3 = PyInt_AS_LONG ( temp[$0] );
                if (!long_$3 || (long_$3 * long_$3) / long_$3 == long_$3) {
                temp[$1] = PyInt_FromLong ( long_$3 * long_$3 );
                } else {
                temp[$1] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], temp[$0]);
                }
                } else {
                if ((temp[$1] = PyNumber_Multiply ( temp[$0] , temp[$0] )) == 0) goto label_$2;
                }
                CLEARTEMP($0);
                if (PyFloat_CheckExact( temp[$1] )) {
                temp[$0] = PyFloat_FromDouble($5);
                } else {
                if ((temp[$0] = PyNumber_$6) == 0) goto label_$2;
                }
                CLEARTEMP($1);        
                """, v2): 
                        TxRepl(o, i, """
                if (PyFloat_CheckExact( temp[$0] )) {
                temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE(temp[$0]) * PyFloat_AS_DOUBLE(temp[$0]));
                } else {
                if ((temp[$1] = PyNumber_Multiply ( temp[$0] , temp[$0] )) == 0) goto label_$2;
                }
                CLEARTEMP($0);
                if (PyFloat_CheckExact( temp[$1] )) {
                temp[$0] = PyFloat_FromDouble($5);
                } else {
                if ((temp[$0] = PyNumber_$6) == 0) goto label_$2;
                }
                CLEARTEMP($1);   
                            """, v2) 
                        return True         
        if oi.startswith('if (PyFloat_CheckExact( '): 
            if TxMatch(o, i, """
                if (PyFloat_CheckExact( $3 )) {
                temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) * PyFloat_AS_DOUBLE($3));
                } else if (PyInt_CheckExact( $3 )) {
                long_$2 = PyInt_AS_LONG ( $3 );
                if (!long_$2 || (long_$2 * long_$2) / long_$2 == long_$2) {
                temp[$1] = PyInt_FromLong ( long_$2 * long_$2 );
                } else {
                temp[$1] = PyInt_Type.tp_as_number->nb_multiply($3, $3);
                }
                } else {
                if ((temp[$1] = PyNumber_Multiply ( $3 , $3 )) == 0) goto label_$4;
                }
                """, v2) : 
                        TxRepl(o, i, """
                            if (PyFloat_CheckExact( $3 )) {
                            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($3) * PyFloat_AS_DOUBLE($3));
                            } else if (PyInt_CheckExact( $3 ) && ( (long_$2 = PyInt_AS_LONG ( $3 )) , (!long_$2 || (long_$2 * long_$2) / long_$2 == long_$2) )){
                            temp[$1] = PyInt_FromLong ( long_$2 * long_$2 );
                            } else {
                            if ((temp[$1] = PyNumber_Multiply ( $3 , $3 )) == 0) goto label_$4;
                            }
                            """, v2) 
                        return True 

        
    
    
    if oi.startswith('if (_'):                
        if TxMatch(o, i, """if (_$1_dict && (temp[$3] = PyDict_GetItem(_$1_dict, $4)) != 0) {
            Py_INCREF(temp[$3]);
            } else {
            if ((temp[$3] = PyObject_GetAttr ( GETLOCAL($1) , $4 )) == 0) goto $2;
            }
            if ( PyList_SetItem ( temp[$3] , $5 , $6 ) == -1) goto $2;
            CLEARTEMP($3);""", v2):
                TxRepl(o, i, """if (_$1_dict && (temp[$3] = PyDict_GetItem(_$1_dict, $4)) != 0) {
                    if ( PyList_SetItem ( temp[$3] , $5 , $6 ) == -1) goto $2;
                    temp[$3] = 0;
                    } else {
                    if ((temp[$3] = PyObject_GetAttr ( GETLOCAL($1) , $4 )) == 0) goto $2;
                    if ( PyList_SetItem ( temp[$3] , $5 , $6 ) == -1) goto $2;
                    CLEARTEMP($3);
                    }""", v2)
                return True    
                                        
        if TxMatch(o, i, """if (_$1_dict && (temp[$3] = PyDict_GetItem(_$1_dict, $2)) != 0) {
            Py_INCREF(temp[$3]);
            } else {
            if ((temp[$3] = PyObject_GetAttr ( GETLOCAL($1) , $2 )) == 0) goto $5;
            }
            $4 = PyInt_AsSsize_t ( temp[$3] );
            CLEARTEMP($3);""", v2):
                TxRepl(o, i, """if (_$1_dict && (temp[$3] = PyDict_GetItem(_$1_dict, $2)) != 0) {
                    $4 = PyInt_AsSsize_t ( temp[$3] );
                    temp[$3] = 0;
                    } else {
                    if ((temp[$3] = PyObject_GetAttr ( GETLOCAL($1) , $2 )) == 0) goto $5;
                    $4 = PyInt_AsSsize_t ( temp[$3] );
                    CLEARTEMP($3);
                    }""", v2)
                return True    
            
        if TxMatch(o, i, """if (_$1_dict && (temp[$3] = PyDict_GetItem(_$1_dict, $2)) != 0) {
            Py_INCREF(temp[$3]);
            } else {
            if ((temp[$3] = PyObject_GetAttr ( GETLOCAL($1) , $2 )) == 0) goto $5;
            }
            if ((temp[$6] = PyList_GetItem ( temp[$3] , $7 )) == 0) goto $5;
            Py_INCREF(temp[$6]);
            CLEARTEMP($3);""", v2):
                TxRepl(o, i, """if (_$1_dict && (temp[$3] = PyDict_GetItem(_$1_dict, $2)) != 0) {
                    if ((temp[$6] = PyList_GetItem ( temp[$3] , $7 )) == 0) goto $5;
                    temp[$3] = 0;
                    } else {
                    if ((temp[$3] = PyObject_GetAttr ( GETLOCAL($1) , $2 )) == 0) goto $5;
                    if ((temp[$6] = PyList_GetItem ( temp[$3] , $7 )) == 0) goto $5;
                    CLEARTEMP($3);
                    }
                    Py_INCREF(temp[$6]);""", v2)
                return True       

            
        if TxMatch(o, i, """if (_$2_dict && (temp[$0] = PyDict_GetItem(_$2_dict, $3)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($2) , $3 )) == 0) goto $4;
            }
            if (PyInt_CheckExact( temp[$0] ) && ($5 = PyInt_AS_LONG ( temp[$0] )) > INT_MIN ) {
            CLEARTEMP($0);
            $6 = $5 - 1;
            } else {
            if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $7 )) == 0) goto $4;
            CLEARTEMP($0);
            $6 = PyInt_AsSsize_t ( temp[$1] );
            CLEARTEMP($1);
            }""", v2):
                TxRepl(o, i, """if (_$2_dict && (temp[$0] = PyDict_GetItem(_$2_dict, $3)) != 0) {
                    if (PyInt_CheckExact( temp[$0] ) && ($5 = PyInt_AS_LONG ( temp[$0] )) > INT_MIN ) {
                    $6 = $5 - 1;
                    } else {
                    Py_INCREF(temp[$0]);
                    if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $7 )) == 0) goto $4;
                    CLEARTEMP($0);
                    $6 = PyInt_AsSsize_t ( temp[$1] );
                    CLEARTEMP($1);
                    }
                    } else {
                    if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($2) , $3 )) == 0) goto $4;
                    if (PyInt_CheckExact( temp[$0] ) && ($5 = PyInt_AS_LONG ( temp[$0] )) > INT_MIN ) {
                    CLEARTEMP($0);
                    $6 = $5 - 1;
                    } else {
                    if ((temp[$1] = PyNumber_Subtract ( temp[$0] , $7 )) == 0) goto $4;
                    CLEARTEMP($0);
                    $6 = PyInt_AsSsize_t ( temp[$1] );
                    CLEARTEMP($1);
                    }
                    }""", v2)
                return True 


        if TxMatch(o, i, """
            if (_$9_dict && (temp[$0] = PyDict_GetItem(_$9_dict, $8)) != 0) {
            Py_INCREF(temp[$0]);
            } else {
            if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($9) , $8 )) == 0) goto label_$10;
            }
            if ((int_$11 = c_Py_$12_Int ($15)) == -1) goto label_$10;
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    if (_$9_dict && (temp[$0] = PyDict_GetItem(_$9_dict, $8)) != 0) {
                    if ((int_$11 = c_Py_$12_Int ($15)) == -1) goto label_$10;
                    } else {
                    if ((temp[$0] = PyObject_GetAttr ( GETLOCAL($9) , $8 )) == 0) goto label_$10;
                    if ((int_$11 = c_Py_$12_Int ($15)) == -1) goto label_$10;
                    CLEARTEMP($0);
                    }
                    """, v2)      
                return True 
            
        if TxMatch(o, i, """if ( int_$2 ) {
            temp[$0] = Py_True;
            } else {
            temp[$0] = Py_False;
            }
            Py_INCREF(temp[$0]);
            int_$2 = PyObject_IsTrue ( temp[$0] );
            CLEARTEMP($0);""", v2):
                TxRepl(o, i, "", v2)
                return True   
                                    
        if TxMatch(o, i, """if ( int_$2 ) {
            temp[$0] = Py_True;
            } else {
            temp[$0] = Py_False;
            }
            Py_INCREF(temp[$0]);
            if ((int_$2 = PyObject_IsTrue ( temp[$0] )) == -1) goto $3;""", v2):
                TxRepl(o, i, """if ( int_$2 ) {
                    temp[$0] = Py_True;
                    } else {
                    temp[$0] = Py_False;
                    }
                    Py_INCREF(temp[$0]);""", v2)
                return True                         

        if TxMatch(o, i, """
            if ( int_$2 ) {
            temp[$0] = Py_True;
            } else {
            temp[$0] = Py_False;
            }
            Py_INCREF(temp[$0]);
            if ( int_$2 ) {
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    if ( !(int_$2)) {
                    temp[$0] = Py_False;
                    Py_INCREF(temp[$0]);
                    } else {
                    """, v2)
                return True                         
        
    if 'PyString_GET_SIZE' in oi:
        if TxMatch(o, i, """
            if ($10) {
            long_$3 = (long)$16;
            } else if ($11) {
            long_$3 = (long)$17;
            } else if ($12) {
            long_$3 = (long)$18;
            } else {
            >0
            long_$3 = PyInt_AsLong ( temp[$1] );
            CLEARTEMP($1);
            }
            $15 = ( long_$3 );        
            """, v2):
                TxRepl(o, i, """
                    if ($10) {
                    $15 = (long)$16;
                    } else if ($11) {
                    $15 = (long)$17;
                    } else if ($12) {
                    $15 = (long)$18;
                    } else {
                    >0
                    $15 = PyInt_AsLong ( temp[$1] );
                    CLEARTEMP($1);
                    }
                    """, v2)
                return True 
        if oi.startswith('if (PyString_GET_SIZE( temp[') and TxMatch(o, i, """if (PyString_GET_SIZE( temp[$2] ) == 1) {
            $1 = (long)((unsigned char)*PyString_AS_STRING(temp[$2]));
            temp[$0] = PyInt_FromLong ( $1 );
            } else {
            if ((temp[$4] = PyTuple_New ( 1 )) == 0) goto $3;
            PyTuple_SET_ITEM ( temp[$4] , 0 , temp[$2] );
            temp[$2] = 0;
            if ((temp[$0] = PyCFunction_Call ( loaded_builtin[$5] , temp[$4] , NULL )) == 0) goto $3;
            CLEARTEMP($4);
            }
            CLEARTEMP($2);
            $6 = PyInt_AS_LONG ( temp[$0] );
            $9 = $6 * $10;
            if ($9 / $10 == $6) {
            temp[$7] = PyInt_FromLong ($9);
            } else {
            temp[$7] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], consts[$8]);
            }
            CLEARTEMP($0);""", v2) and abs(int(v2[10])) < 70000:
                TxRepl(o, i, """if (PyString_GET_SIZE( temp[$2] ) == 1) {
                    $9 = ((long)((unsigned char)*PyString_AS_STRING(temp[$2]))) * $10;
                    CLEARTEMP($2);
                    temp[$7] = PyInt_FromLong ( $9 );
                    } else {
                    if ((temp[$4] = PyTuple_New ( 1 )) == 0) goto $3;
                    PyTuple_SET_ITEM ( temp[$4] , 0 , temp[$2] );
                    temp[$2] = 0;
                    if ((temp[$0] = PyCFunction_Call ( loaded_builtin[$5] , temp[$4] , NULL )) == 0) goto $3;
                    CLEARTEMP($4);
                    $6 = PyInt_AS_LONG ( temp[$0] );
                    $9 = $6 * $10;
                    if ($9 / $10 == $6) {
                    temp[$7] = PyInt_FromLong ($9);
                    } else {
                    temp[$7] = PyInt_Type.tp_as_number->nb_multiply(temp[$0], consts[$8]);
                    }
                    CLEARTEMP($0);
                    }""", v2)
                return True 
        if oi.startswith('if (PyString_GET_SIZE( ') and TxMatch(o, i, """
            if (PyString_GET_SIZE( $9 ) == 1) {
            long_$3 = (long)((unsigned char)*PyString_AS_STRING ( $9 ));
            temp[$0] = PyInt_FromLong ( long_$3 );
            } else {
            if ((temp[$1] = PyTuple_Pack ( 1 , $9 )) == 0) goto label_$10;
            if ((temp[$0] = PyCFunction_Call ( loaded_builtin[$11] , temp[$1] , NULL )) == 0) goto label_$10;
            CLEARTEMP($1);
            }
            $15 = PyInt_AsLong(temp[$0]);
            CLEARTEMP($0);""", v2):
                TxRepl(o, i, """
                    if (PyString_GET_SIZE( $9 ) == 1) {
                    $15 = (long)((unsigned char)*PyString_AS_STRING ( $9 ));
                    } else {
                    if ((temp[$1] = PyTuple_Pack ( 1 , $9 )) == 0) goto label_$10;
                    if ((temp[$0] = PyCFunction_Call ( loaded_builtin[$11] , temp[$1] , NULL )) == 0) goto label_$10;
                    CLEARTEMP($1);
                    $15 = PyInt_AsLong(temp[$0]);
                    CLEARTEMP($0);
                    }""", v2)
                return True 
            
    
    if i+1 < len(o) and 'PyInt_FromLong' in o[i+1]:
        if TxMatch(o, i, """
            if ($3) {
            temp[$0] = PyInt_FromLong ( $4 );
            } else {
            if ((temp[$0] = $5) == 0) goto label_$6;
            }
            if ((temp[$1] = PyObject_GetItem ( $7 , temp[$0] )) == 0) goto label_$6;
            CLEARTEMP($0);""", v2):
                TxRepl(o, i, """
                    if ($3) {
                    if ((temp[$1] = __c_BINARY_SUBSCR_Int ( $7 , $4 )) == 0) goto label_$6;
                    } else {
                    if ((temp[$0] = $5) == 0) goto label_$6;
                    if ((temp[$1] = PyObject_GetItem ( $7 , temp[$0] )) == 0) goto label_$6;
                    CLEARTEMP($0);
                    }""", 
                    v2, ('__c_BINARY_SUBSCR_Int',))
                return True  
        if TxMatch(o, i, """
            if ($9) {
            temp[$1] = PyInt_FromLong ($8);
            } else {
            temp[$0] = $7;
            if ((temp[$1] = PyNumber_$6 ( temp[$0] , $5 )) == 0) goto label_$12;
            CLEARTEMP($0);
            }
            if ((temp[$10] = PyObject_GetItem ( $14 , temp[$1] )) == 0) goto label_$12;
            CLEARTEMP($1);""", v2):
                v2[9] = v2[9].strip()
                v2[8] = v2[8].strip()
                TxRepl(o, i, """
                    if ( $9 ) {
                    temp[$1] = PyInt_FromLong ( $8 );
                    if ((temp[$10] = PyObject_GetItem ( $14 , temp[$1] )) == 0) goto label_$12;
                    CLEARTEMP($1);
                    } else {
                    temp[$0] = $7;
                    if ((temp[$1] = PyNumber_$6 ( temp[$0] , $5 )) == 0) goto label_$12;
                    CLEARTEMP($0);
                    if ((temp[$10] = PyObject_GetItem ( $14 , temp[$1] )) == 0) goto label_$12;
                    CLEARTEMP($1);
                    }
                    """, v2)
                return True    
                    
    
        if TxMatch(o, i, """
            if ($5) {
            temp[$1] = PyInt_FromLong ($6);
            } else {
            temp[$0] = $7;
            temp[$1] = $8;
            CLEARTEMP($0);
            }
            if ((temp[$3] = PyObject_GetItem ( $9 , temp[$1] )) == 0) goto label_$10;
            CLEARTEMP($1);        
            """, v2): 
                TxRepl(o, i, """
                    if ($5) {
                    temp[$1] = PyInt_FromLong ($6);
                    if ((temp[$3] = PyObject_GetItem ( $9 , temp[$1] )) == 0) goto label_$10;
                    CLEARTEMP($1);   
                    } else {
                    temp[$0] = $7;
                    temp[$1] = $8;
                    CLEARTEMP($0);
                    if ((temp[$3] = PyObject_GetItem ( $9 , temp[$1] )) == 0) goto label_$10;
                    CLEARTEMP($1);   
                    }
                    """, v2)  
                return True   
            
            
        if TxMatch(o, i, """
            if ($3) {
            temp[$0] = PyInt_FromLong ($4);
            } else {
            if ((temp[$0] = PyNumber_$5) == 0) goto label_$10;
            }
            if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$10;
            CLEARTEMP($0);        
            """, v2): 
                TxRepl(o, i, """
                    if ($3) {
                    int_$1 = ($4) != 0;
                    } else {
                    if ((temp[$0] = PyNumber_$5) == 0) goto label_$10;
                    if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$10;
                    CLEARTEMP($0);   
                    }
                    """, v2)  
                return True   


        if TxMatch(o, i, """
            if ($2) {
            temp[$1] = PyInt_FromLong ( $4 );
            } else if ($3) {
            temp[$1] = PyFloat_FromDouble($5);
            } else {
            if ((temp[$1] = PyNumber_$6) == 0) goto $7;
            }
            CLEARTEMP($0);
            if (PyInt_CheckExact( temp[$1] )) {
            temp[$10] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$1] ) $8 );
            } else {
            if ((temp[$10] = PyNumber_$9 ( temp[$1] , $11 )) == 0) goto $7;
            }
            CLEARTEMP($1);
            """, v2) and not ('temp[' + v2[0] + ']') in v2[4] and not ('temp[' + v2[0] + ']') in v2[8]: 
                TxRepl(o, i, """
                    if ($2) {
                    CLEARTEMP($0);
                    temp[$10] = PyInt_FromLong ( ($4) $8 );
                    } else {
                    if ((temp[$1] = PyNumber_$6) == 0) goto $7;
                    CLEARTEMP($0);
                    if ((temp[$10] = PyNumber_$9 ( temp[$1] , $11 )) == 0) goto $7;
                    CLEARTEMP($1);
                    }
                    """, v2)  
                return True   
    
        if TxMatch(o, i, """
            if ($3) {
            temp[$1] = PyInt_FromLong ($4);
            } else {
            if ((temp[$1] = PyNumber_$5) == 0) goto $6;
            }
            CLEARTEMP($0);
            if ((int_$7 = c_Py_$11_Int ( temp[$1] , $8 , $9 )) == -1) goto $6;
            CLEARTEMP($1);
            """, v2): 
                pycmp = 'Py_' + v2[11]
                if pycmp in c_2_op_op:
                    v2[12] = c_2_op_op[pycmp]
                if v2[12] != None:
                    TxRepl(o, i, """
                        if ($3) {
                        int_$7 = ($4) $12 $8;
                        CLEARTEMP($0);
                        } else {
                        if ((temp[$1] = PyNumber_$5) == 0) goto $6;
                        CLEARTEMP($0);
                        if ((int_$7 = c_Py_$11_Int ( temp[$1] , $8 , $9 )) == -1) goto $6;
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True   

        if TxMatch(o, i, """
            if ($11) {
            temp[$0] = PyInt_FromLong ( long_$4 );
            } else {
            >0
            }
            if (PyInt_CheckExact( temp[$0] )) {
            long_$2 = PyInt_AS_LONG ( temp[$0] );
            if ( long_$2 < 0) {
            long_$2 += PyList_GET_SIZE($5);
            }
            if ((temp[$1] = PyList_GetItem ( $5 , long_$2 )) == 0) goto label_$10;
            Py_INCREF(temp[$1]);
            } else {
            if ((temp[$1] = PyObject_GetItem ( $5 , temp[$0] )) == 0) goto label_$10;
            }
            CLEARTEMP($0);
                """, v2) and type(v2[4]) is str and v2[4].isdigit(): 
                    TxRepl(o, i, """
                        if ($11) {
                        if ( long_$4 < 0) {
                        long_$4 += PyList_GET_SIZE($5);
                        }
                        if ((temp[$1] = PyList_GetItem ( $5 , long_$4 )) == 0) goto label_$10;
                        Py_INCREF(temp[$1]);
                        } else {
                        >0
                        if ((temp[$1] = PyObject_GetItem ( $5 , temp[$0] )) == 0) goto label_$10;
                        CLEARTEMP($0);
                        }
                        """, v2)   
                    return True
        if TxMatch(o, i, """
            if (PyInt_AS_LONG ( $1 ) <= (LONG_MAX - $2)) {
            temp[$0] = PyInt_FromLong ( PyInt_AS_LONG ( $1 ) + $2 );
            } else {
            if ((temp[$0] = PyLong_Type.tp_as_number->nb_add( $1 , $3 )) == 0) goto label_$10;
            }
            if ((temp[$9] = _PyEval_ApplySlice ( $8 , $1 , temp[$0] )) == 0) goto label_$10;
            CLEARTEMP($0);
                """, v2): 
                    TxRepl(o, i, """
                        if (PyInt_AS_LONG ( $1 ) <= (LONG_MAX - $2)) {
                        if ((temp[$9] = PySequence_GetSlice ( $8 , PyInt_AS_LONG ( $1 ) , PyInt_AS_LONG ( $1 ) + $2 )) == 0) goto label_$10;
                        } else {
                        if ((temp[$0] = PyLong_Type.tp_as_number->nb_add( $1 , $3 )) == 0) goto label_$10;
                        if ((temp[$9] = _PyEval_ApplySlice ( $8 , $1 , temp[$0] )) == 0) goto label_$10;
                        CLEARTEMP($0);
                        }
                        """, v2) 
                    return True

    if oi.startswith('if (((PyObject *)Py_TYPE(') and ' == ' in oi and 'ATTR(' in o[i+1]:
        if handle_GETATTR(o, i):
            return True
                    
    if 'int_' in oi and '=' not in oi:  
        if '!' in oi:  
            if oi.startswith('if ( !(int_') and TxMatch(o, i, """if ( !(int_$1) ) {""", v2) and type(v2[1]) is str and v2[1].isdigit():
                    TxRepl(o, i, """if ( !int_$1 ) {""", v2)
                    return True    
            if oi.startswith('if ( (!(int_') and TxMatch(o, i, """if ( (!(int_$1)) ) {""", v2) and type(v2[1]) is str and v2[1].isdigit():
                    TxRepl(o, i, """if ( !int_$1 ) {""", v2)
                    return True    
            if oi.startswith('if (!( int_') and TxMatch(o, i, """if (!( int_$1 )) {""", v2) and type(v2[1]) is str and  v2[1].isdigit():
                    TxRepl(o, i, """if ( !int_$1 ) {""", v2)
                    return True    
        else:        
            if oi.startswith('if ( ((int_') and TxMatch(o, i, """if ( ((int_$1)) ) {""", v2) and type(v2[1]) is str and v2[1].isdigit():
                    TxRepl(o, i, """if ( int_$1 ) {""", v2)
                    return True    
            if oi.startswith('if ( (int_') and TxMatch(o, i, """if ( (int_$1) ) {""", v2) and type(v2[1]) is str and v2[1].isdigit():
                    TxRepl(o, i, """if ( int_$1 ) {""", v2)
                    return True    
            if oi.startswith('if (( int_') and TxMatch(o, i, """if (( int_$1 )) {""", v2) and type(v2[1]) is str and v2[1].isdigit():
                    TxRepl(o, i, """if ( int_$1 ) {""", v2)
                    return True   

    if i+1 < len(o) and o[i+1].startswith('long_'):
        pass
    if i+1 < len(o):
        if 'Py_True' in o[i+1]:
            if TxMatch(o, i, """
                if ($9) {
                temp[$0] = Py_True;
                } else {
                temp[$0] = Py_False;
                }
                Py_INCREF(temp[$0]);
                $2 = PyObject_IsTrue(temp[$0]);
                CLEARTEMP($0);            
                """, v2): 
                    TxRepl(o, i, """
                        $2 = $9;
                        """, v2)   
                    return True
        if 'PyInt_FromLong' in o[i+1]:
            if TxMatch(o, i, """     
                if ($10) {
                temp[$1] = PyInt_FromLong ( $12 );
                } else {
                >1
                }
                CLEARTEMP($0);
                if ((int_$14 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$15;
                CLEARTEMP($1); 
                """, v2):     
                        TxRepl(o, i, """
                            if ($10) {
                            int_$14 = ( $12 ) != 0;
                            CLEARTEMP($0);
                            } else {
                            >1
                            CLEARTEMP($0);
                            if ((int_$14 = PyObject_IsTrue ( temp[$1] )) == -1) goto label_$15;
                            CLEARTEMP($1); 
                            }
                            """, v2)   
                        return True       
            if TxMatch(o, i, """
                if ($10) {
                temp[$0] = PyInt_FromLong ( $11 );
                } else {
                >0
                }
                <1
                int_$12 = PyInt_AS_LONG ( temp[$0] ) $14;
                CLEARTEMP($0);
                """, v2):   
                        TxRepl(o, i, """
                            if ($10) {
                            temp[$0] = PyInt_FromLong ( $11 );
                            <1
                            int_$12 = PyInt_AS_LONG ( temp[$0] ) $14;
                            CLEARTEMP($0);
                            } else {
                            >0
                            <1
                            int_$12 = PyInt_AS_LONG ( temp[$0] ) $14;
                            CLEARTEMP($0);
                            }
                            """, v2)   
                        return True 
            if TxMatch(o, i, """            
                if ($4) {
                temp[$0] = PyInt_FromLong ( $5 );
                } else {
                >0
                }
                <1
                if ((temp[$1] = PyNumber_Int ( temp[$0] )) == 0) goto label_$6;
                CLEARTEMP($0);            
                """, v2) and 'temp[' not in v2[5]:
                        TxRepl(o, i, """
                            if ($4) {
                            <1
                            temp[$1] = PyInt_FromLong ( $5 );
                            } else {
                            >0
                            <1
                            if ((temp[$1] = PyNumber_Int ( temp[$0] )) == 0) goto label_$6;
                            CLEARTEMP($0); 
                            }
                            """, v2)   
                        return True      
                                 
            if TxMatch(o, i, """ 
                if ($10) {
                temp[$0] = PyInt_FromLong ( $11 );
                } else {
                if ((temp[$0] = PyNumber_$12) == 0) goto label_$14;
                }
                if (PyInt_CheckExact( temp[$0] ) && PyInt_CheckExact( GETLOCAL($15) )) {
                temp[$1] = PyInt_FromLong ( PyInt_AS_LONG ( temp[$0] ) $16 );
                } else {
                if ((temp[$1] = PyNumber_$17) == 0) goto label_$14;
                }
                CLEARTEMP($0);""", v2):
                        TxRepl(o, i, """
                            if ($10 && PyInt_CheckExact( GETLOCAL($15) ) ) {
                            temp[$1] = PyInt_FromLong ( ( $11 ) $16 );
                            } else {
                            if ((temp[$0] = PyNumber_$12) == 0) goto label_$14;
                            if ((temp[$1] = PyNumber_$17) == 0) goto label_$14;
                            CLEARTEMP($0);
                            }
                            """, v2)
                        return True                     
        if '] = GETATTR(' in o[i+1]:
            if TxMatch(o, i, """
                if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                temp[$10] = GETATTR($2, $1, $3);
                Py_INCREF(temp[$10]);
                } else {
                if ((temp[$10] = PyObject_GetAttr( $1, $4 )) == 0) goto label_$0;
                }
                SETATTR($5,$6,$7,temp[$10]);
                CLEARTEMP($10);
                """, v2):                   
                        TxRepl(o, i, """
                            if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                            SETATTR($5,$6,$7,GETATTR($2, $1, $3));
                            } else {
                            if ((temp[$10] = PyObject_GetAttr( $1, $4 )) == 0) goto label_$0;
                            SETATTR($5,$6,$7,temp[$10]);
                            CLEARTEMP($10);
                            }
                            """, v2)
                        return True     
        if o[i+1].startswith('SETATTR('):
            if TxMatch(o, i, """ 
                if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                >10
                } else {
                >11
                }
                f->f_lineno = $5;
                f->f_lasti = $6;                
                if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                SETATTR($2,$1,$3,$4);
                } else {
                >12
                }
                f->f_lineno = $7;
                f->f_lasti = $8;                
                if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                >13
                } else {
                >14
                }
                """, v2):
                        TxRepl(o, i, """
                            if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                            >10
                            } else {
                            >11
                            }
                            f->f_lineno = $5;
                            f->f_lasti = $6;                
                            if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                            SETATTR($2,$1,$3,$4);
                            >13
                            } else {
                            >12
                            f->f_lineno = $7;
                            f->f_lasti = $8; 
                            >14
                            }
                            """, v2)
                        return True     
            if TxMatch(o, i, """ 
                if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                SETATTR($2,$1,$3,$4);
                } else {
                >5
                }
                f->f_lineno = $8;
                f->f_lasti = $9;                
                if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                SETATTR($2,$1,$13,$44);
                } else {
                >7
                }
                """, v2):
                        TxRepl(o, i, """
                            if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                            SETATTR($2,$1,$3,$4);
                            SETATTR($2,$1,$13,$44);
                            } else {
                            >5
                            f->f_lineno = $8;
                            f->f_lasti = $9;     
                            >7
                            }
                            """, v2)
                        return True 
            if TxMatch(o, i, """ 
                if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                SETATTR($2,$1,$3,$4);
                } else {
                >5
                }
                f->f_lineno = $8;
                f->f_lasti = $9;                
                if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                >6
                } else {
                >7
                }
                """, v2):
                        TxRepl(o, i, """
                            if (((PyObject *)Py_TYPE($1)) == calculated_const_$2) {
                            SETATTR($2,$1,$3,$4);
                            f->f_lineno = $8;
                            f->f_lasti = $9;                                 
                            >6
                            } else {
                            >5
                            f->f_lineno = $8;
                            f->f_lasti = $9;     
                            >7
                            }
                            """, v2)
                        return True                     

    k = i + 1
    while k < len(o):
        ok = o[k]
        assert type(ok) is str
        if ok.startswith('/*'):
            k += 1
            continue
        if '{' in ok and '"{' not in ok and '{"' not in ok and "'{" not in ok and "{'" not in ok:
            break
        if '}' in ok and '"}' not in ok and '}"' not in ok and "'}" not in ok and "}'" not in ok:
            break
        k += 1
    ok = o[k]
    assert type(ok) is str    
    assert ok.startswith('}') or ok.endswith('{') or ':;' in ok or ok.endswith('}')
    if ok.startswith('if ( long_'):
        if TxMatch(o, i, """    
            if ($11) {
            >0
            if ( long_$13 < 0) {
            long_$13 += PyString_GET_SIZE($10);
            }
            if (long_$13 < 0 || long_$13 >= PyString_GET_SIZE($10)) goto label_$4;
            temp[$2] = PyString_FromStringAndSize((PyString_AS_STRING ( $3 ) + long_$13), 1);
            <1
            } else {
            >2
            }
            if (PyString_GET_SIZE( temp[$2] ) == 1) {
            temp[$0] = PyInt_FromLong ( (long)((unsigned char)*PyString_AS_STRING ( temp[$2] )) );
            } else {
            >3
            }
            CLEARTEMP($2);
            """, v2):
                TxRepl(o, i, """
                    if ($11) {
                    >0
                    if ( long_$13 < 0) {
                    long_$13 += PyString_GET_SIZE($10);
                    }
                    if (long_$13 < 0 || long_$13 >= PyString_GET_SIZE($10)) goto label_$4;
                    temp[$0] = PyInt_FromLong ( (long)((unsigned char)*(PyString_AS_STRING ( $3 ) + long_$13)) );
                    <1
                    } else {
                    >2
                    >3
                    CLEARTEMP($2);
                    }
                    """, v2)
                return True
    
        if TxMatch(o, i, """    
            if ($18) {
            >0
            if ( long_$13 < 0) {
            long_$13 += $14;
            }
            >1
            temp[$0] = PyInt_FromLong ($15);
            } else {
            >2
            }
            long_$16 = PyInt_AS_LONG ( temp[$0] );
            CLEARTEMP($0);
            """, v2):
                TxRepl(o, i, """
                    if ($18) {
                    >0
                    if ( long_$13 < 0) {
                    long_$13 += $14;
                    }
                    >1
                    long_$16 = ($15);
                    } else {
                    >2
                    long_$16 = PyInt_AS_LONG ( temp[$0] );
                    CLEARTEMP($0);
                    }
                    """, v2)
                return True
    if ok.startswith('} else if ('):
    
        if TxMatch(o, i, """    
            if ($10) {
            >0
            temp[$1] = PyInt_FromLong ( $4 );
            <1
            } else if ($13) {
            >2
            temp[$1] = PyFloat_FromDouble($5);
            <3
            } else {
            >4
            if ((temp[$1] = $6) == 0) goto label_$9;
            <5
            }
            <6
            if ( PyObject_SetAttr ($8 temp[$1] ) == -1) goto label_$9;
            temp[$0] = temp[$1];
            temp[$1] = 0;
            if ((int_$16 = c_$7_Int ( temp[$0] , $12 , $11 )) == -1) goto label_$9;
            CLEARTEMP($0);""", v2):
                
                v2[14] = op_to_oper[v2[7]]
                TxRepl(o, i, """
                    if ($10) {
                    >0
                    temp[$1] = PyInt_FromLong ( $4 );
                    int_$16 = ($4) $14 $12;
                    <1
                    <6
                    } else if ($13) {
                    >2
                    temp[$1] = PyFloat_FromDouble($5);
                    int_$16 = PyFloat_AS_DOUBLE(temp[$1]) $14 $12;
                    <3
                    <6
                    } else {
                    >4
                    if ((temp[$1] = $6) == 0) goto label_$9;
                    if ((int_$16 = PyObject_RichCompareBool ( temp[$1] , $11 , $7 )) == -1) goto label_$9;
                    <5
                    <6
                    }
                    if ( PyObject_SetAttr ($8 temp[$1] ) == -1) goto label_$9;
                    CLEARTEMP($1);            
                    """, v2)
                return True
                
        if TxMatch(o, i, """                  
            if ($4) {
            >0
            temp[$1] = PyInt_FromLong ( $5 );
            } else if ($6) {
            >6
            temp[$1] = PyFloat_FromDouble($8);
            } else {
            >1
            }
            if (PyInt_CheckExact( temp[$1] )) {
            >2
            if ($7) {
            >3
            }
            >4
            } else {
            >5
            }
            CLEARTEMP($1);
            """, v2):
                    TxRepl(o, i, """
                        if ($4) {
                        >0
                        temp[$1] = PyInt_FromLong ( $5 );
                        >2
                        if ($7) {
                        >3
                        }
                        >4    
                        CLEARTEMP($1);                
                        } else {
                        >1
                        >5
                        CLEARTEMP($1);
                        }
                        """, v2)   
                    return True                
   
    if ok == '} else {':        
        if TxMatch(o, i, """    
            if ($11) {
            >0
            temp[$10] = PyInt_FromLong ( $12 );
            <1
            } else {
            >2
            if ((temp[$10] = $14) == 0) goto label_$15;
            <3
            }
            <4
            if (PyInt_CheckExact( temp[$10] )) {
            >5
            } else {
            >6
            }
            <7
            """, v2):
                TxRepl(o, i, """
                    if ($11) {
                    >0
                    temp[$10] = PyInt_FromLong ( $12 );
                    <1
                    <4
                    >5
                    <7
                    } else {
                    >2
                    if ((temp[$10] = $14) == 0) goto label_$15;
                    <3
                    <4
                    >6  
                    <7              
                    }
                    """, v2)
                return True
    
        if TxMatch(o, i, """    
            if ($0) {
            >0
            temp[$2] = PyInt_FromLong ($1);
            <1
            } else {
            >2
            }
            if (PyInt_CheckExact( temp[$2] )) {
            long_$6 = PyInt_AS_LONG ( temp[$2] );
            if ( long_$6 < 0) {
            long_$6 += PyList_GET_SIZE($4);
            }
            if ((temp[$5] = PyList_GetItem ( $4 , long_$6 )) == 0) goto label_$10;
            Py_INCREF(temp[$5]);
            } else {
            if ((temp[$5] = PyObject_GetItem ( $4 , temp[$2] )) == 0) goto label_$10;
            }
            CLEARTEMP($2);
            """, v2):
                TxRepl(o, i, """
                    if ($0) {
                    >0
                    temp[$2] = PyInt_FromLong ($1);
                    <1
                    long_$6 = PyInt_AS_LONG ( temp[$2] );
                    CLEARTEMP($2);
                    if ( long_$6 < 0) {
                    long_$6 += PyList_GET_SIZE($4);
                    }
                    if ((temp[$5] = PyList_GetItem ( $4 , long_$6 )) == 0) goto label_$10;
                    Py_INCREF(temp[$5]);
                    } else {
                    >2
                    if ((temp[$5] = PyObject_GetItem ( $4 , temp[$2] )) == 0) goto label_$10;
                    CLEARTEMP($2);
                    }
                        """, v2)
                return True 

        if TxMatch(o, i, """
            if ($10) {
            >0
            temp[$0] = PyInt_FromLong ( $1 );
            <1
            } else {
            >2
            }
            long_$11 = PyInt_AS_LONG ( temp[$0] );
            CLEARTEMP($0);
            """, v2): 
                    TxRepl(o, i, """
                        if ($10) {
                        >0
                        temp[$0] = PyInt_FromLong ( $1 );
                        <1
                        long_$11 = PyInt_AS_LONG ( temp[$0] );
                        CLEARTEMP($0);                    
                        } else {
                        >2
                        long_$11 = PyInt_AS_LONG ( temp[$0] );
                        CLEARTEMP($0);
                        }
                        """, v2) 
                    return True 
          
        if TxMatch(o, i, """                  
            if ($4) {
            >0
            temp[$1] = PyInt_FromLong ( $5 );
            } else {
            >1
            }
            <6
            if (PyInt_CheckExact( temp[$1] )) {
            >2
            if ($7) {
            >3
            }
            >4
            } else {
            >5
            }
            CLEARTEMP($1);
            """, v2):
                    TxRepl(o, i, """
                        if ($4) {
                        >0
                        temp[$1] = PyInt_FromLong ( $5 );
                        <6
                        >2
                        if ($7) {
                        >3
                        }
                        >4    
                        CLEARTEMP($1);                
                        } else {
                        >1
                        <6
                        >5
                        CLEARTEMP($1);
                        }
                        """, v2)   
                    return True    
        if TxMatch(o, i, """  
            if ($1) {
            >2
            temp[$3] = PyInt_FromLong ($4);
            } else {
            >5
            }
            long_$6 = PyInt_AsLong ( temp[$3] );
            CLEARTEMP($3);
            """, v2):
                    TxRepl(o, i, """
                        if ($1) {
                        >2
                        temp[$3] = PyInt_FromLong ($4);
                        long_$6 = PyInt_AsLong ( temp[$3] );
                        CLEARTEMP($3);
                        } else {
                        >5
                        long_$6 = PyInt_AsLong ( temp[$3] );
                        CLEARTEMP($3);
                        }
                        """, v2)
                    return True 
        if TxMatch(o, i, """  
            if ($0) {
            >1
            if ((temp[$2] = PyBool_FromLong ($3)) == 0) goto label_$10;
            } else {
            >4
            }
            if ((int_$5 = PyObject_IsTrue ( temp[$2] )) == -1) goto label_$10;
            CLEARTEMP($2);
            """, v2):
                    TxRepl(o, i, """
                        if ($0) {
                        >1
                        int_$5 = ($3);
                        } else {
                        >4
                        if ((int_$5 = PyObject_IsTrue ( temp[$2] )) == -1) goto label_$10;
                        CLEARTEMP($2);
                        }
                        """, v2)
                    return True 
                        
        if TxMatch(o, i, """if ($5) {
            >0
            temp[$0] = PyInt_FromLong ( $4 );
            } else {
            >1
            }
            <5
            if (PyInt_CheckExact( temp[$0] )) {
            >2
            } else {
            >3
            }
            CLEARTEMP($0);""", v2):   
                    TxRepl(o, i, """if ($5) {
                        >0
                        temp[$0] = PyInt_FromLong ( $4 );
                        <5
                        >2
                        CLEARTEMP($0);
                        } else {
                        >1
                        <5
                        >3
                        CLEARTEMP($0);
                        }""", v2)   
                    return True        
                
        if TxMatch(o, i, """
            if ($17) {
            >0
            temp[$1] = PyInt_FromLong ( $18 );
            } else {
            >1
            }
            <2
            if ((int_$19 = c_Py_$11_Int ( temp[$1] , $14 , $15 )) == -1) goto label_$16;
            CLEARTEMP($1);
            """, v2): 
                pycmp = 'Py_' + v2[11]
                if pycmp in c_2_op_op:
                    v2[12] = c_2_op_op[pycmp]
                if v2[12] != None:
                    TxRepl(o, i, """
                        if ($17) {
                        >0
                        int_$19 = ($18) $12 $14;
                        <2
                        } else {
                        >1
                        <2
                        if ((int_$19 = c_Py_$11_Int ( temp[$1] , $14 , $15 )) == -1) goto label_$16;
                        CLEARTEMP($1);
                        }
                        """, v2) 
                    return True          

    if ok.startswith('if (') and ok.endswith(') {'):
        if TxMatch(o, i, """    
            if ($10) {
            >0
            if ($11) {
            >1
            temp[$1] = PyInt_FromLong ( $12 );
            <2
            } else {
            >3
            }
            } else {
            >5
            }
            if (PyInt_CheckExact( temp[$1] )) {
            >7
            } else {
            >8
            }
            CLEARTEMP($1);
            """, v2):
                TxRepl(o, i, """
                    if ($10) {
                    >0
                    if ($11) {
                    >1
                    temp[$1] = PyInt_FromLong ( $12 );
                    <2
                    >7
                    CLEARTEMP($1);
                    } else {
                    >3
                    >8
                    CLEARTEMP($1);
                    }
                    } else {
                    >5
                    >8
                    CLEARTEMP($1);
                    }
                        """, v2)
                return True
    if False:
        if TxMatch(o,i, """
            if ($10) {
            >1
            temp[$0] = PyInt_FromLong ( $11 );
            temp[$1] = PyInt_FromLong ( $12 );
            } else {
            >2
            }
            Loc_long_$3 = PyInt_AS_LONG ( temp[$1] );
            CLEARTEMP($0);
            CLEARTEMP($1);
            """, v2) and v2[1] != v2[0]:
                TxRepl(o, i, """
                    if ($10) {
                    >1
                    temp[$0] = PyInt_FromLong ( $11 );
                    temp[$1] = PyInt_FromLong ( $12 );
                    CLEARTEMP($0);
                    Loc_long_$3 = PyInt_AS_LONG ( temp[$1] );
                    CLEARTEMP($1);
                    } else {
                    >2
                    CLEARTEMP($0);
                    Loc_long_$3 = PyInt_AS_LONG ( temp[$1] );
                    CLEARTEMP($1);
                    }
                        """, v2)
                return True  
    if oi.startswith('if ( ('):
        if TxMatch(o,i, """if ( ($1 == $2) ) {""", v2) and \
           '&&' not in v2[1] and '||' not in v2[1] and '&&' not in v2[2] and '||' not in v2[2] \
           and is_balansed(v2[1]) and is_balansed(v2[2]):
            TxRepl(o, i, """if ( $1 == $2 ) {""", v2)
            return True
        if TxMatch(o,i, """if ( ($1) ) {""", v2) and \
           '&&' not in v2[1] and '||' not in v2[1] \
           and is_balansed(v2[1]):
            TxRepl(o, i, """if ( $1 ) {""", v2)
            return True 

    if oi.startswith('if (int_'):
        if TxMatch(o,i, """if (int_$1) {
                int_$1 = 1;
                }""", v2):
            TxRepl(o, i, """""", v2)
            return True 
        if TxMatch(o,i, """if (int_$1) {
                int_$1 = 1;""", v2):
            TxRepl(o, i, """if (int_$1) {""", v2)
            return True 
    return False

def handle_GETATTR(o,i):
    v2 = {}
    if TxMatch(o, i, """
        if (((PyObject *)Py_TYPE($1)) == calculated_const_$3) {
        temp[$0] = GETATTR($3, $1, $5);
        Py_INCREF(temp[$0]);
        """, v2):                   
            detected_GETATTR = detect_variant_GETATTR(o, i)
            if detected_GETATTR is not None:
                i6 = detected_GETATTR[0]
                v2.clear()
                detected_GETATTR2 = None
                while i6 < len(o) and i6 < detected_GETATTR[0]+12:
                    detected_GETATTR2 = detect_variant_GETATTR(o, i6)
                    if detected_GETATTR2 is not None and detected_GETATTR[1][1] == detected_GETATTR2[1][1] and \
                       detected_GETATTR[1][5] != detected_GETATTR2[1][5]:
                        d10 = [x[3] for x in detected_GETATTR[1:-1]]
                        d12 = [x[3] for x in detected_GETATTR2[1:-1]]
                        ## d10.sort()
                        ## d12.sort()
                        if d10 == d12:
                            v2.clear()
                            if TxMatch(o, detected_GETATTR[0], """
                                if ((int_$1 = PyObject_IsTrue ( temp[$0] )) == -1) goto label_$10;
                                if ( int_$1 ) {
                                CLEARTEMP($0);                                
                                """, v2) and v2[0] == detected_GETATTR[1][0] and detected_GETATTR[1][0] == detected_GETATTR2[1][0]: 
                                    li = Out()
                                    ## for kk, d in enumerate(detected_GETATTR[1:-1]):
                                        ## li.extend(d['lines'])
                                        ## del li[-1]
                                        ## li.append(o[detected_GETATTR[0])
                                        

                            ## print '///two GETATTR'
                            ## ##pprint(detected_GETATTR[1])
                            ## pprint(o[detected_GETATTR[0]:i6])
                            ## ##pprint(detected_GETATTR2[1])
                            v2.clear()
                            break
                    i6 += 1
                if detected_GETATTR2 is None:
                    le = 0
                    if TxMatch(o, detected_GETATTR[0], """
                        int_$1 = (temp[$0] == $3);
                        CLEARTEMP($0);
                        """, v2): 
                            le = 2
                    elif TxMatch(o, detected_GETATTR[0], """
                        if ((int_$3 = PyObject_Not( temp[$1] )) == -1) goto label_$0;
                        CLEARTEMP($1);                                
                        """, v2): 
                            le = 2
                    elif TxMatch(o, detected_GETATTR[0], """
                        SETATTR($1,$2,$3,temp[$0]);
                        CLEARTEMP($0);
                        """, v2): 
                            le = 2
                    elif TxMatch(o, detected_GETATTR[0], """
                        LETLOCAL ( $1 , temp[$0] );
                        temp[$0] = 0;
                        """, v2): 
                            le = 2
                    elif TxMatch(o, detected_GETATTR[0], """
                        SETLOCAL ( $1 , temp[$0] );
                        temp[$0] = 0;
                        """, v2): 
                            le = 2
                    elif TxMatch(o, detected_GETATTR[0], """
                        if ( PyInt_CheckExact(temp[$0]) ) {
                        int_$11 = PyInt_AS_LONG(temp[$0]) $12;
                        } else {
                        if ((int_$11 = PyObject_RichCompareBool ( temp[$0] , $7 )) == -1) goto label_$10;
                        }
                        CLEARTEMP($0);                                
                        """, v2): 
                            le = 6
                    if le > 0:
                        li = Out()
                        for d in detected_GETATTR[1:-1]:
                            li.extend(d['lines'])
                            li.extend(o[detected_GETATTR[0]:detected_GETATTR[0]+le])
                        d = detected_GETATTR[-1]              
                        li.extend(d['lines'][:-1])
                        li.extend(o[detected_GETATTR[0]:detected_GETATTR[0]+le])
                        li.append('}')
                        o[i:detected_GETATTR[0]+le] = li
                        return True
    return False                        
    

def detect_variant_GETATTR(o, i):
    assert type(o) is Out
    assert type(i) is int and i >= 0 and i < len(o)
    dete = []
    dete.append(0)
    v2 = {}
    if TxMatch(o, i, """
        if (((PyObject *)Py_TYPE($1)) == calculated_const_$3) {
        temp[$0] = GETATTR($3, $1, $5);
        Py_INCREF(temp[$0]);
        """, v2): 
            v2['lines'] = o[i:i+3]
            dete.append(v2)
            i+= 3
    else:
        return None
    v2 = {}
    if o[i].startswith('}'):
        pass
    else:
        return None
    while TxMatch(o, i, """
        } else if (((PyObject *)Py_TYPE($1)) == calculated_const_$3) {
        temp[$0] = GETATTR($3, $1, $5);
        Py_INCREF(temp[$0]);
        """, v2): 
            v2['lines'] = o[i:i+3]
            dete.append(v2)
            i+= 3
            v2 = {}
    if TxMatch(o, i, """
        } else {
        if ((temp[$0] = PyObject_GetAttr( $3, $6 )) == 0) goto label_$7;
        }
        """, v2): 
            v2['lines'] = o[i:i+3]
            dete.append(v2)
            i+= 3
    else:
        return None
    dete[0] = i
    return dete    
 

parenthes = {'{':'}', '(':')', '[':']', '"':'"', "'":"'"}
r_parenthes = {'}':'{', ')':'(', ']':'[', '"':'"', "'":"'"}

def is_balansed(s):
    global r_parenthes
    global parenthes
    if len(s) == 3 and s[0] == "'" and s[2] == "'" and s[1] != "'" and s[1] != '\\':
        return True
    stack = []
    assert type(s) is str
    for c in s:
        if len(stack) > 0 and stack[-1] == c:
            stack.pop()
            continue
        if c in parenthes:
            stack.append(parenthes[c])
            continue
        if c in r_parenthes:
            return False
    if len(stack) > 0:
        return False
    return True
            
def ConC(*t):
    return ''.join([CVar(it) for it in t])

def mk_t2(t):
    t2 = ['if (', t[0], '(']
    for v in t[1:]:
        t2.append(v)
        t2.append(',')
    if len(t) == 1:
        t2.append(')')    
    return t2[:-1]

def maybe_call(to):
    if to != 'f->f_lineno' and not istempref(to) and not istemptyped(to):
        if type(to) is str:
            return (to[0] not in ('{', '}') and to[-1] not in ('{', '}') and to[0:3] != 'if ' and to not in ('continue;', 'break;', 'return') and to[0:4] not in ('for ', 'for(') and to != 'goto')
    return False

def do_str(add2):
    add3 = [CVar(x) for x in add2] 
    s = ''
    if add3[0] in ('{', '}') and len(add3) == 1:
        return add3[0]
    for i, st in enumerate(add3):
        if i != len(add3)-1:
            s += st + ' '
        elif st[-1] in ('{', '}'):
            s += st    
        else:
            if st[-1] != ';':
                s += st + ';' 
            else:
                s += st  
 
    return s        

def generate(cmds, co, filename_):
    global filename, func, tempgen, typed_gen, _n2c, pregenerated, genfilename, g_co, is_current, Line2Addr, labl
    assert len(cmds) == 2
    assert type(co) is code_extended
    func = co.c_name
    filename = filename_    
    genfilename = Pynm2Cnm(filename)[0]
    if not co.can_be_codefunc(): ##co.co_flags & CO_GENERATOR:
        stub_generator(co)
        return
    is_current = IS_CODEFUNC
    if co.can_be_cfunc():
       is_current = IS_CFUNC
       if can_be_dictionable_cfunc(co.cmds[1]):
           is_current = IS_CFUNC + IS_DICTIONABLE_CFUNC
    del tempgen[:]
    del typed_gen[:]
    o = Out()
    global try_jump_context, dropped_temp
    del try_jump_context[:]
    del dropped_temp[:]
    labl = None
    label_exc = New('label')
    set_toerr_new(o, label_exc)
    g_co = co
    Line2Addr = line2addr(co)

    g_co.to_exception = {}
    if not (co.co_flags & CO_GENERATOR) and func in direct_args and direct_call and not is_current & IS_ANY_CFUNC:
        seq2 = co.direct_cmds
        if seq2 == cmds[1] and len(co.hidden_arg_direct) == 0 and len(co.typed_arg_direct) == 0:
            generate_from_frame_to_direct_stube(co, o, co.c_name, cmds)
            return 
    if co.co_flags & CO_GENERATOR:
        co.yield_labels.append((New('label'), -1))
        o.Raw(co.yield_labels[0][0], ':;')
    if stat_func == func:
        o.append('{')
        o.Raw('FILE * _refs = fopen(\"%s_start\", \"w+\");' % func)
        o.Raw('_Py_PrintReferences(_refs);')   
        o.Raw('fclose(_refs);')     
        o.append('}')
    o = generate_list(cmds[1], o)
    optimize(o) 
    i = len(tempgen) - 1
    while i >= 0:
        s1 = 'temp[%d]' % i
        s2 = 'CLEARTEMP(%d)' % i
        if not string_in_o(s1, o) and not string_in_o(s2, o):
            del tempgen[i]
            i -= 1
            continue
        else:
            break   
    ## l1 = len(o)   
    generate_default_exception_handler(o, co.c_name, None)
    ## l2 = len(o)    

    o.append('}')
    if not (is_current & IS_ANY_CFUNC):
        set_toerr_back(o)  
    del_unused_ret_label(o)
    optimize(o) 
    post_optimize(o)
    if len(tempgen) > co.co_stacksize:
        co.co_stacksize = len(tempgen)
    cnt = None
    if is_current & IS_ANY_CFUNC:
        generate_cfunc_header(cmds[0][1], o, co, typed_gen, co.detected_type)
        set_toerr_back(o)  
    else:
        generate_header(cmds[0][1], o, co, typed_gen, co.detected_type) 
        
    pregenerated.append((cmds, o, co))    

def list_direct_args(nm):
    if nm in direct_args:
        return direct_args[nm].keys()
    return []

def add_direct_arg(nm, tupl):
    global g_co
    
    a = N2C(nm)
    if a.can_be_direct_call is None:
        a.can_be_direct_call = can_be_direct_call(a.cmds[1])
    if a.can_be_direct_call != True:
        return None
    if nm not in direct_args:
        direct_args[nm] = {}
    dic = direct_args[nm]
    assert type(tupl) is tuple # and len(tupl) == 2:
    tupl0 = tupl[0]
    assert type(tupl0) is str
    if tupl0 == '!BUILD_TUPLE':
        typ = tuple([TypeExpr(x) for x in tupl[1]])
    elif tupl0 == 'CONST':    
        typ = tuple([TypeExpr(('CONST', x)) for x in tupl[1]])
    elif tupl0 == '!PyNumber_Add' and tupl[1][0] == '!BUILD_TUPLE' and IsTuple(TypeExpr(tupl[2])): 
        typ = tuple([TypeExpr(x) for x in (tupl[1][1] + (tupl[2],))])
    else:
        pprint(tupl)
        assert False 
    dic[(tupl, typ, g_co.c_name)] = True        
        
def fill_direct_args(it, nm):
    if type(it) is tuple and len(it) >= 1 and type(it[0]) is str:
        if it[0] == '!CALL_CALC_CONST':
            add_direct_arg(it[1], it[2])
        elif it[0] == '!CLASS_CALC_CONST_NEW' and IsMethod(it[1], '__init__'):
            if it[2][0] == '!BUILD_TUPLE':  
                slf = ('PY_TYPE', T_NEW_CL_INST, it[1], ('PSEVDO', 'self'), None)          
                add_direct_arg(CodeInit(it[1]), ('!BUILD_TUPLE', (slf,) +it[2][1]))
            elif it[2][0] == 'CONST':  
                slf = ('PY_TYPE', T_NEW_CL_INST, it[1], ('PSEVDO', 'self'), None)          
                tu = tuple([('CONST', x) for x in it[2][1]])            
                add_direct_arg(CodeInit(it[1]), ('!BUILD_TUPLE', (slf,) +tu))

    return      
  
           
def concretize_code_direct_call(nm, seq, co, n):
    assert type(seq) is list
    assert type(nm) is str
    assert type(co) is code_extended
    assert nm == co.c_name
    calls = list_direct_args(nm)
    ## assert 'PSEVDO' not in repr(seq) 
    ## if nm == '_format':
        ## ccalls = [(c, typs, called_from) for c, typs, called_from in calls if called_from == nm]
        ## pprint(ccalls)
    dic = {}
##    co.concretize_level += 1
    collect_store_and_delete_and_fast(seq, dic)
    call = join_defined_calls(calls, co.co_argcount, nm, (co.co_flags & 0x4) != 0, False, dic)[0]
 
##    eqarg = co.direct_call_args == call
    type_detected = any([x is not None and x != (None, None) for x in call])
    call_changed_arg = {}

    if type_detected:
        for i, arg in enumerate(call):
            assert i < co.co_argcount or (co.co_flags & 0x4 and i == co.co_argcount)
            s = ('DELETE_FAST', co.co_varnames[i])
            if s in dic:
                call[i] = None
                continue
            if arg is not None and arg[0] == 'PSEVDO':
                call[i] = None
                continue
            s = ('STORE_FAST', co.co_varnames[i])
            if s in dic and call[i] != (None, None) and call[i] is not None:
                call_changed_arg[i] = call[i]  
                call[i] = None
    seq2 = seq[:]            
    ## assert 'PSEVDO' not in repr(seq2)
    typed = {}
    typed_changed = {}

    ## if not type_detected:
        ## eqarg = True
    ## ## else:
        ## ## eqarg = True
    if True:
        for i, arg in enumerate(call):

            if i in call_changed_arg:
                continue
            if type(arg) is tuple and arg[0] == 'CALC_CONST':
                seq2 = replace_subexpr(seq2, ('FAST', co.co_varnames[i]), arg)
                t = TypeExpr(arg)
                if t is None:
                    t = (None, None)
                typed[i] = (t[0], t[1])   

            elif type(arg) is tuple and \
              (arg[0] == 'CONST' or (len(arg) != 2 and len(arg) >= 1 and type(arg[0]) is str) or \
               (len(arg) >= 1 and type(arg[0]) is str and arg[0][0] == '!') ):
                seq2 = replace_subexpr(seq2, ('FAST', co.co_varnames[i]), arg)
                t = TypeExpr(arg)
                if t is None:
                    t = (None, None)
                typed[i] = (t[0], t[1])      

            elif arg is not None and arg != (None, None) and arg != ('NIL', None):
                seq2 = replace_type_subexpr_at_code_list(seq2, ('FAST', co.co_varnames[i]), ('PY_TYPE',) + arg + (('FAST', co.co_varnames[i]),None))
                typed[i] = arg

            elif arg is None or arg == (None, None) or arg == ('NIL', None):
                pass
            else:
                pp('/321', arg)

        for i, arg in call_changed_arg.items():
            old = ('FAST', co.co_varnames[i])
            stor = ('STORE_FAST', co.co_varnames[i])
            dele = ('DELETE_FAST', co.co_varnames[i])
            if type(arg) is tuple and arg[0] == 'CONST':
                new = arg
                replace_concretised_at_list_from_pos(seq2, 0, old, new, stor, dele)                
                t = TypeExpr(arg)
                typed_changed[i] = (t[0], t[1])          
                if i in typed:
                    del typed[i]  
            elif arg is not None and arg != (None, None) and arg != ('NIL', None) and arg != TypeExpr(old):
                new = ('PY_TYPE',) + arg + (old, None)
                if not expr_in_expr(arg, seq2):
                    replace_concretised_at_list_from_pos(seq2, 0, old, new, stor, dele)                
                    typed_changed[i] = arg
                    if i in typed:
                        del typed[i]  
        co.typed_arg_direct_changed = typed_changed
        i = 12
        while i > 1:  
            i -= 1
            seq2_ = seq2
            seq2 = tree_pass_upgrade_op2(seq2, None, nm)     
            seq2 = recursive_type_detect(seq2, nm)  
            if eqexpr(seq2, seq2_):
                break
            if i == 1:
                pp('>>>>--', nm, n, co)
                # printer = PrettyPrinter(4, 128, [''])
                # printer.pprint(seq2_)
                # a1 = printer._stream:
 
            if i < 4:
                pp('???', call, co.c_name, i)
                lpp = PrettyPrinter(2, 144, [''])
                ls1 = ['']
                lpp._format(seq2_, ls1, 0, 0, 0)                
                ##pprint(seq2_, 2, 180)
                pp('[[[[[[[[[[')
                lpp = PrettyPrinter(2, 144, [''])
                ls2 = ['']
                lpp._format(seq2, ls2, 0, 0, 0)                
##                pprint(seq2_, 2, 180)
##                pprint(seq2, 2, 180)
                diff = difflib.ndiff(ls1, ls2)
                pp('\n'.join(list(diff)))
                pp('))))))))))))))))')
                ##assert False
    if co.co_flags & 0x4 or not type_detected:
        hidden = []
    else:    
        hidden = [i9 for i9, arg in enumerate(call) if type(arg) is tuple and (arg[0] == 'CONST' or arg[0] == 'CALC_CONST') and i9 not in call_changed_arg]
    seq2 = tree_pass_upgrade_op2(seq2, None, nm)        
    
    for k,v in typed.items():
        Debug('def %s, arg %s -- local type %s' %(nm, co.co_varnames[k], v))
    for k,v in typed_changed.items():
        Debug('def %s, arg %s changed -- local type %s' %(nm, co.co_varnames[k], v))
    co.direct_cmds = seq2
    if co.no_codefunc:
        co.cmds = [('(BEGIN_DEF', nm), co.direct_cmds]        
    
    co.hidden_arg_direct = hidden
    co.typed_arg_direct = typed
    ## if nm == '_format':
        ## pprint(typed)
    co.direct_call_args = call

def split_code_direct_call(nm, seq, co):
    return []
    assert type(seq) is list
    assert type(nm) is str
    assert nm == co.c_name
    calls = list_direct_args(nm)
    dic = {}
    collect_store_and_delete_and_fast(seq, dic)
    call, prejoined_calls = join_defined_calls(calls, co.co_argcount, nm, (co.co_flags & 0x4) != 0, False, dic)
    type_detected = any([x is not None and x != (None, None) for x in call])
    call_changed_arg = {}

    if type_detected:
        for i, arg in enumerate(call):
            assert i < co.co_argcount or (co.co_flags & 0x4 and i == co.co_argcount)
            s = ('DELETE_FAST', co.co_varnames[i])
            if s in dic:
                call[i] = None
                continue
            s = ('STORE_FAST', co.co_varnames[i])
            if s in dic and call[i] != (None, None) and call[i] is not None:
                call_changed_arg[i] = call[i]  
                call[i] = None
    seq2 = seq[:]            
    typed = {}
    typed_changed = {}

    if True:
        for i, arg in enumerate(call):
            if i in call_changed_arg:
                continue
            if type(arg) is tuple and arg[0] == 'CALC_CONST':
                seq2 = replace_subexpr(seq2, ('FAST', co.co_varnames[i]), arg)
                t = TypeExpr(arg)
                if t is None:
                    t = (None, None)
                typed[i] = (t[0], t[1])   

            elif type(arg) is tuple and \
              (arg[0] == 'CONST' or (len(arg) != 2 and len(arg) >= 1 and type(arg[0]) is str) or \
               (len(arg) >= 1 and type(arg[0]) is str and arg[0][0] == '!') ):
                seq2 = replace_subexpr(seq2, ('FAST', co.co_varnames[i]), arg)
                t = TypeExpr(arg)
                if t is None:
                    t = (None, None)
                typed[i] = (t[0], t[1])      

            elif arg is not None and arg != (None, None) and arg != ('NIL', None):
                seq2 = replace_type_subexpr_at_code_list(seq2, ('FAST', co.co_varnames[i]), ('PY_TYPE',) + arg + (('FAST', co.co_varnames[i]),None))
                typed[i] = arg

            elif arg is None or arg == (None, None) or arg == ('NIL', None):
                pass
            else:
                pp('/321', arg)

        for i, arg in call_changed_arg.items():
            old = ('FAST', co.co_varnames[i])
            stor = ('STORE_FAST', co.co_varnames[i])
            dele = ('DELETE_FAST', co.co_varnames[i])
            if type(arg) is tuple and arg[0] == 'CONST':
                new = arg
                replace_concretised_at_list_from_pos(seq2, 0, old, new, stor, dele)                
                t = TypeExpr(arg)
                typed_changed[i] = (t[0], t[1])          
                if i in typed:
                    del typed[i]  
            elif arg is not None and arg != (None, None) and arg != ('NIL', None) and arg != TypeExpr(old):
                new = ('PY_TYPE',) + arg + (old, None)
                if not expr_in_expr(arg, seq2):
                    replace_concretised_at_list_from_pos(seq2, 0, old, new, stor, dele)                
                    typed_changed[i] = arg
                    if i in typed:
                        del typed[i]  
        co.typed_arg_direct_changed = typed_changed
        i = 12
        while i > 1:  
            i -= 1
            seq2_ = seq2
            seq2 = tree_pass_upgrade_op2(seq2, None, nm)     
            seq2 = recursive_type_detect(seq2, nm)    
            if eqexpr(seq2, seq2_):
                break
            if False:
                pp('???', call, co.c_name, i)
                lpp = PrettyPrinter(2, 144, [''])
                ls1 = ['']
                lpp._format(seq2_, ls1, 0, 0, 0)                
                ##pprint(seq2_, 2, 180)
                pp('[[[[[[[[[[')
                lpp = PrettyPrinter(2, 144, [''])
                ls2 = ['']
                lpp._format(seq2, ls2, 0, 0, 0)                
##                pprint(seq2_, 2, 180)
##                pprint(seq2, 2, 180)
                diff = difflib.ndiff(ls1, ls2)
                pp('\n'.join(list(diff)))
                pp('))))))))))))))))')
                ##assert False
    split_direct_call2(nm, calls, call, prejoined_calls, co)
    if co.co_flags & 0x4 or not type_detected:
        hidden = []
    else:    
        hidden = [i9 for i9, arg in enumerate(call) if type(arg) is tuple and (arg[0] == 'CONST' or arg[0] == 'CALC_CONST') and i9 not in call_changed_arg]
    seq2 = tree_pass_upgrade_op2(seq2, None, nm)        
    
    for k,v in typed.items():
        Debug('def %s, arg %s -- local type %s' %(nm, co.co_varnames[k], v))
    for k,v in typed_changed.items():
        Debug('def %s, arg %s changed -- local type %s' %(nm, co.co_varnames[k], v))
    co.direct_cmds = seq2
    if co.no_codefunc:
        co.cmds = [('(BEGIN_DEF', nm), co.direct_cmds]        
    
    co.hidden_arg_direct = hidden
    co.typed_arg_direct = typed
    ## if nm == '_format':
        ## pprint(typed)
    co.direct_call_args = call
    
def revert(a):
    i1 = len(a)
    i2 = len(a[0])
    assert all([len(v) == i2 for v in a])
    li = []
    for j2 in range(i2):
        li.append([a[j1][j2] for j1 in range(i1)])
    cardinality = [(-len(set(v)), i) for i, v in enumerate(li)]
    cardinality.sort()
    return li, cardinality
 
def split_direct_call2(nm, calls, call, prejoined_calls, co, n = 3):
##    return 
    assert type(co) is code_extended
    call = tuple(call)
    call = tuple([None if v == (None, None) else v for v in call])
    prejoined_calls = [tuple(v) for v in prejoined_calls]
    l2 = []
    for v in prejoined_calls:
        l3 = []
        for i, v2 in enumerate(v):
            if v2 == (None, None):
                v2 = None
            if v2 == ('NIL', None):
                l3 = None
                break
            l3.append(v2)
        if l3 != None:
            l2.append(tuple(l3))
    prejoined_calls = l2
    prejoined_calls = list(set(prejoined_calls))
    prejoined_calls = [v for v in prejoined_calls if v != call]
    if len(prejoined_calls) == 0:
        return
    if len(set(prejoined_calls)) <= 3:
        for v in list(set(prejoined_calls)):
            pp('//1-', nm, n, v, call)
            ## pprint(v)
            ## pprint(call)
        return
    return
    reverted, cardinality = revert(prejoined_calls)
    cardinality = [(-len(set(v)), i) for i, v in enumerate(reverted)]
    cardinality.sort()
    for neg_cnt, i in cardinality:
        if neg_cnt < -3:
            prejoined_calls = [v for v in prejoined_calls if v[i] is not None]

    prejoined_calls = [list(v) for v in prejoined_calls]
            
    reverted, cardinality = revert(prejoined_calls)
    for neg_cnt, i in cardinality:
        if neg_cnt < -3:
            for j in range(len(prejoined_calls)):
                v = prejoined_calls[j][i]
                if type(v) is tuple and len(v) == 2 and v[0] == 'CONST':
                    if type(v[1]) is str and len(v[1]) != 1:
                        prejoined_calls[j][i] = Kl_String
                    elif type(v[1]) is tuple:
                        prejoined_calls[j][i] = (tuple, len(v[1]))

    prejoined_calls = list(set([tuple(v) for v in prejoined_calls]))
    reverted, cardinality = revert(prejoined_calls)

    pp('l1')
    pprint(cardinality)
    pp('l2')
    pprint(reverted)
    pp('l3')
    pprint([tuple(set(v)) for v in reverted])
    if False:
        if len(prejoined_calls) > 3:
            l2 = []
            for v in prejoined_calls:
                l3 = []
                for i, v2 in enumerate(v):
                    if type(v2) is tuple and v2[0] == 'CONST':
                        if type(v2[1]) is str:
                            if type(v2[1]) is str and len(v2[1]) != 1:
                                v2 = Kl_String
                            elif type(v2[1]) is int and v2[1] != 1:
                                v2 = Kl_String
                        elif type(v2[1]) is int:
                            v2 = Kl_Int
                        elif type(v2[1]) is tuple:
                            v2 = (tuple, len(v2[1]))
                        else:
                            v2 = TypeExpr(v2)
                    if IsTuple(v2):
                        if type(v2[1]) is tuple:
                            v2 = (tuple, len(v2[1]))
                    l3.append(v2)
                l2.append(tuple(l3))
            prejoined_calls = l2

        prejoined_calls = list(set(prejoined_calls))
        prejoined_calls = [v for v in prejoined_calls if v != call]

        if len(prejoined_calls) > 3:
            l2 = []
            for v in prejoined_calls:
                l3 = []
                for i, v2 in enumerate(v):
                    if IsTuple(v2):
                        v2 = Kl_Tuple
                    l3.append(v2)
                l2.append(tuple(l3))
            prejoined_calls = l2


        prejoined_calls = list(set(prejoined_calls))
        prejoined_calls = [v for v in prejoined_calls if v != call] 


    if len(prejoined_calls) > 0:
        pp('-------------------------')
        pp('/1', nm)
    ##    pprint(calls)   
        pprint(call, 2, 180)
        pprint(prejoined_calls, 2, 180)
        pp('=========================')

def generate_direct(cmds, co, filename_):
    global filename, func, tempgen, typed_gen, _n2c, pregenerated, genfilename, g_co, is_current, labl
    assert len(cmds) == 2
    assert type(co) is code_extended
    func = co.c_name
    filename = filename_
    genfilename = Pynm2Cnm(filename)[0] 

    if func in direct_args and direct_call and co.direct_cmds is not None:
        is_current = IS_DIRECT
    else:
        return None
    del tempgen[:]
    del typed_gen[:]
    o = Out()
    global try_jump_context, dropped_temp
    del try_jump_context[:]
    del dropped_temp[:]
    labl = None
    label_exc = New('label')
    set_toerr_new(o, label_exc)
    g_co = co
    
    g_co.to_exception = {}
    if stat_func == func:
        o.append('{')
        o.Raw('FILE * _refs = fopen(\"%s_start\", \"w+\");' % func)
        o.Raw('_Py_PrintReferences(_refs);')   
        o.Raw('fclose(_refs);')     
        o.append('}')     
    strict_varnames(co)
    assert co.direct_cmds is not None

    o = generate_list(co.direct_cmds, o)
    optimize(o)  
    i = len(tempgen) - 1
    while i >= 0:
        s1 = 'temp[%d]' % i
        s2 = 'CLEARTEMP(%d)' % i
        if not string_in_o(s1, o) and not string_in_o(s2, o):
            del tempgen[i]
            i -= 1
            continue
        else:
            break    
    l1 = len(o)   
    generate_default_exception_handler(o, co.c_name, None)
    l2 = len(o)
    o.append('}')
    
    set_toerr_back(o) 
    
    del_unused_ret_label(o)
    
    optimize(o)   
    
    post_optimize(o) 
    
    co.co_stacksize = len(tempgen)
    
    generate_header_direct(cmds[0][1], o, co, typed_gen, \
                           co.typed_arg_direct, co.detected_type)
    
    if l2 == l1 and not have_try(co.direct_cmds):
        strip_pyline_pyaddr(o)    
    o = from_fastlocals_to_single(o)
     
    pregenerated.append((cmds, o, co))   
    
def have_try(cmds):
    assert type(cmds) is list
    for v in cmds:
        if type(v) is list:
            if have_try(v):
                return True
        if type(v) is tuple and len(v) > 0 and v[0] in ('(TRY', '(TRY_FINALLY'):
            return True
    return False
    
def string_in_o(s, o):
    assert type(o) is Out
    for s2 in o:
        if s in s2:
            return True
    return False
    
def strip_pyline_pyaddr(o):
    i = 0
    while i < len(o):
        assert type(i) is int
        oi = o[i]
        assert type(oi) is str
        if oi.startswith('PyLine = '):
            del o[i]
            continue
        if oi.startswith('PyAddr = '):
            del o[i]
            continue
        if oi.startswith('int PyLine = '):
            del o[i]
            continue
        if oi.startswith('int PyAddr = '):
            del o[i]
            continue
        i += 1

def from_fastlocals_to_single(o):
    global no_fastlocals
    if not no_fastlocals:
        return o
    o2 = Out()
    for v in o:
        assert type(v) is str
        v = v.replace('GETLOCAL(', 'GETFAST(')
        v = v.replace('SETLOCAL(', 'SETFAST(')
        v = v.replace('SETLOCAL (', 'SETFAST(')
        ## v = v.replace('SETLOCAL2(', 'SETFAST2(')
        ## v = v.replace('SETLOCAL2 (', 'SETFAST2(')
        v = v.replace('LETLOCAL(', 'LETFAST(')
        v = v.replace('LETLOCAL (', 'LETFAST(')
        for i_0 in range(g_co.co_stacksize):
            v = v.replace(ConC('(temp + ', i_0, ')'), ConC('(&temp__', i_0, ')'))
            v = v.replace(ConC('temp[', i_0, ']'), ConC('temp__', i_0))
            v = v.replace(ConC('CLEARTEMP(', i_0, ')'), ConC('Py_CLEAR(temp__', i_0, ')'))
        o2.append(v)
    return o2
    
def strict_varnames(co):
    li = []
    s2 = co.direct_cmds
    for i, v in enumerate(co.co_varnames):
        if i < co.co_argcount:
            li.append(v)    
            continue
        di = {('FAST', v):0, ('STORE_FAST', v):0, ('DELETE_FAST', v):0}
        if exprs_in_expr(di, s2):
            li.append(v)    
            continue
    co.co_varnames_direct = li    
    
def post_optimize(o):
    assert type(o) is Out
    i = 0
    while i < len(o):
        i += 1
        if i < len(o) and o[i] == 'if (0) {':
            i += 1
            while i < len(o):
                oi = o[i]
                assert type(oi) is str
                if not oi.endswith(':;'):
                    break
                checklabl = oi[:-2]
                is_used = False
                for j in range(i):
                    s2 = o[j]
                    if name_in(checklabl, s2):
                        is_used = True
                if not is_used:
                    del o[i]
                    while i < len(o) and ':;' not in o[i] and '{' not in o[i] and '}' not in o[i]:
                        del o[i]
                    continue
                else:
                    i += 1
                    while i <len(o) and ':;' not in o[i]:
                        i += 1                    
                    continue            

def generate_default_exception_handler(o, nm, cnt_temp):  
   assert type(o) is Out
   if IsUsedLabl(labl) or len(g_co.to_exception) > 0:
        ## pp(nm),cnt_temp, labl
        ##pprint(o)

        clabl = CVar(labl)
        found = False
        for s in o:
            if clabl in s:
                found = True
                break
        if not found and len(g_co.to_exception) == 0:
            return

        o.Raw('if (0) {')
        for tu, lb in g_co.to_exception.items():
            o.Raw(lb, ':;')
            o.extend(tu)
        o.Raw(labl, ':;')
        if is_current & IS_CODEFUNC:
            o.append('PyTraceBack_Here(f);')
        else:    
            cod = const_to(g_co)
            Used('Direct_AddTraceback')
            if line_number:
                o.Raw('Direct_AddTraceback((PyCodeObject *)', cod, ', PyLine, PyAddr);') 
            else:
                o.Raw('Direct_AddTraceback((PyCodeObject *)', cod, ', 0, 0);') 

        if is_current & IS_DIRECT:
            hid = {}
            for i in g_co.hidden_arg_direct: 
                hid[g_co.co_varnames[i]] = True               
            for i,v in enumerate(g_co.co_varnames_direct):
                if v in hid:
                    continue
                nmvar = nmvar_to_loc(v)
                if not g_co.IsCVar(('FAST', v)):
                    o.CLEAR('GETLOCAL(' + nmvar + ')')   
        if g_co.have_temp:
            if cnt_temp is not None:
                assert cnt_temp <= len(tempgen)
            for i in range(len(tempgen)):
                if cnt_temp is None or i < cnt_temp:
                    o.Raw('CLEARTEMP(', str(i), ');')
        if calc_ref_total:
            calc_reftotal_printed(o, nm)
        if is_current & IS_CODEFUNC:
            if check_recursive_call:
                o.append('Py_LeaveRecursiveCall();')
        if is_current & IS_CODEFUNC:
            o.frame_back()
        if is_current & IS_DIRECT and \
            (g_co.IsRetVoid() or IsCType(g_co.ReturnType())):
            if IsChar(g_co.ReturnType()):
                o.Raw('return \'\\xff\';')
            else:
                o.Raw('return -1;')        
        else:    
            if nm == 'Init_filename' and build_executable:
                o.Raw('PyErr_Print();')
            o.Stmt('return', 'NULL;')        
        o.append('}')        
      
c_head0 = """
// This is an open source non-commercial project. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com

/* Generated by 2C Python */

#include "Python.h"
#include "frameobject.h" 
#include "funcobject.h" 
#include "code.h" 
#include "dictobject.h" 
#include "listobject.h" 
#include "abstract.h" 
/*#include "setobject.h"*/

#include "structmember.h"
#include "object.h"
"""     
c_head1 = """

static PyObject * b = NULL;
static PyObject * bdict = NULL;

/*#define DEBUG_LOCAL_REFCNT*/

#define Py2C_CanBeIntMult(a) (((short int)a) == a)

#define NAME_OFFSET_ATTR(class, slot) offset_##class##_##slot

#define GETATTR(class,ref,slot) (*(PyObject **)(((char *)ref)+NAME_OFFSET_ATTR(class, slot)))
#define SETATTR(class,ref,slot,value)	do { PyObject *tmp = GETATTR(class,ref,slot); \
                                     Py_INCREF(value);                \
				     GETATTR(class,ref,slot) = value; \
                                     Py_XDECREF(tmp); } while (0) 

#define SETLISTITEM(ob,i,v)	do { PyObject *tmp = PyList_GET_ITEM(ob, i); \
				     PyList_SET_ITEM(ob, i, v); \
                                     Py_XDECREF(tmp); } while (0) 

 
/* Local variable macros */
#ifdef DEBUG_LOCAL_REFCNT
#define GETLOCAL(i)	printf("Get local %s line %5d refcnt %d\\n", #i, __LINE__, (int)(fastlocals[Loc_##i]->ob_refcnt)),fastlocals[Loc_##i]
#define GETFAST(i)	printf("Get local %s line %5d refcnt %d\\n", #i, __LINE__, (int)(_Fast_##i->ob_refcnt)), _Fast_##i
#else
#define GETLOCAL(i)	(fastlocals[Loc_##i])
#define GETFAST(i)	_Fast_##i
#endif
#define GETFREEVAR(i)	(freevars[Loc2_##i])
//#define GETSTATIC(i)	(fastglob[Glob_##i])
/* The SETLOCAL() macro must not DECREF the local variable in-place and
   then store the new value; it must copy the old value to a temporary
   value, then store the new value, and then DECREF the temporary value.
   This is because it is possible that during the DECREF the frame is
   accessed by other code (e.g. a __del__ method or gc.collect()) and the
   variable would be pointing to already-freed memory. */
#ifdef DEBUG_LOCAL_REFCNT
#define SETLOCAL(i, value)	do { PyObject *tmp = fastlocals[Loc_##i]; \
                                     if (tmp != NULL) \
                                     printf("Replace local %s line %5d refcnt %d\\n", #i, __LINE__, (int)(tmp->ob_refcnt));\
                                     fastlocals[Loc_##i] = value; \
                                     printf("New local %s line %5d refcnt %d\\n", #i, __LINE__, (int)(fastlocals[Loc_##i]->ob_refcnt));\
                                     Py_XDECREF(tmp); } while (0)
//#define SETLOCAL2(i, value) SETLOCAL(i, value)
#define SETFAST(i, value)	do { PyObject *tmp = _Fast_##i; \
                                     if (tmp != NULL) \
                                     printf("Replace local %s line %5d refcnt %d\\n", #i, __LINE__, (int)(tmp->ob_refcnt));\
                                     _Fast_##i = value; \
                                     printf("New local %s line %5d refcnt %d\\n", #i, __LINE__, (int)(_Fast_##i->ob_refcnt));\
                                     Py_XDECREF(tmp); } while (0)
#define SETFAST2(i, value)	SETFAST(i, value)

#else
#define SETLOCAL(i, value)	do { PyObject *tmp = fastlocals[Loc_##i]; \
				     fastlocals[Loc_##i] = value; \
                                     Py_XDECREF(tmp); } while (0)

//#define SETLOCAL2(i, value)	do { Py_XDECREF(fastlocals[Loc_##i]);\
//				     fastlocals[Loc_##i] = value; } while (0)

//#define SETLOCAL2(i, value) SETLOCAL(i, value)
                                     
#define SETFAST(i, value)	do { PyObject *tmp = _Fast_##i; \
				     _Fast_##i = value; \
                                     Py_XDECREF(tmp); } while (0)

#define SETFAST2(i, value) SETFAST(i, value)

#endif
#define LETLOCAL(i, value)	     fastlocals[Loc_##i] = (value)
#define LETFAST(i, value)	     _Fast_##i = (value)

//#define SETSTATIC(i, value)	do { PyObject *tmp = fastglob[Glob_##i]; \
//				     fastglob[Glob_##i] = value; \
//                                     Py_XDECREF(tmp); } while (0)

#define CLEARTEMP(x) Py_CLEAR(temp[x])

typedef char *charref;
typedef long *longref;

#ifndef LONG_BIT
#define LONG_BIT (8 * SIZEOF_LONG)
#endif

#define PyIF(a,b,c) ((a)?(b):(c))
"""
c_head2 = """
//static PyObject * consts[]; 
//static PyObject * loaded_builtin[];
//static PyObject * calculated_const[];
"""
c_head3 = """
//static PyObject * module = 0;
static PyObject * glob = 0;
static PyObject * empty_tuple;
/*void static check_const_refcnt(void);*/

/* Status code for main loop (reason for stack unwind) */
enum why_code {
		WHY_NOT =	0x0001,	/* No error */
		WHY_EXCEPTION = 0x0002,	/* Exception occurred */
		WHY_RERAISE =	0x0004,	/* Exception re-raised by 'finally' */
		WHY_RETURN =	0x0008,	/* 'return' statement */
		WHY_BREAK =	0x0010,	/* 'break' statement */
		WHY_CONTINUE =	0x0020,	/* 'continue' statement */
		WHY_YIELD =	0x0040	/* 'yield' operator */
};

#define NAME_ERROR_MSG \
	"name '%.200s' is not defined"
#define GLOBAL_NAME_ERROR_MSG \
	"global name '%.200s' is not defined"
#define UNBOUNDLOCAL_ERROR_MSG \
	"local variable '%.200s' referenced before assignment"
#define UNBOUNDFREE_ERROR_MSG \
	"free variable '%.200s' referenced before assignment" \
        " in enclosing scope"

#define c_Py_GT_Int(v,l,w) ((PyInt_CheckExact(v))?(PyInt_AS_LONG(v) > l) : (PyObject_RichCompareBool(v, w, Py_GT)))
#define c_Py_LT_Int(v,l,w) ((PyInt_CheckExact(v))?(PyInt_AS_LONG(v) < l) : (PyObject_RichCompareBool(v, w, Py_LT)))
#define c_Py_GE_Int(v,l,w) ((PyInt_CheckExact(v))?(PyInt_AS_LONG(v) >= l) : (PyObject_RichCompareBool(v, w, Py_GE)))
#define c_Py_LE_Int(v,l,w) ((PyInt_CheckExact(v))?(PyInt_AS_LONG(v) <= l) : (PyObject_RichCompareBool(v, w, Py_LE)))
#define c_Py_EQ_Int(v,l,w) ((PyInt_CheckExact(v))?(PyInt_AS_LONG(v) == l) : (PyObject_RichCompareBool(v, w, Py_EQ)))
#define c_Py_NE_Int(v,l,w) ((PyInt_CheckExact(v))?(PyInt_AS_LONG(v) != l) : (PyObject_RichCompareBool(v, w, Py_NE)))

#define c_Py_EQ_String(v,l,w,w2) ((PyString_CheckExact(v))?(PyString_GET_SIZE(v) == l && memcmp(PyString_AS_STRING(v),w,l) == 0) : (PyObject_RichCompareBool(v, w2, Py_EQ)))
#define c_Py_NE_String(v,l,w,w2) ((PyString_CheckExact(v))?(PyString_GET_SIZE(v) != l || memcmp(PyString_AS_STRING(v),w,l) != 0) : (PyObject_RichCompareBool(v, w2, Py_NE)))

#ifndef PYPY_VERSION
#define FirstCFunctionCall(a,b,c)  ((PyCFunction_Check (a)) ? ( PyCFunction_Call(a,b,c) ) : ( PyObject_Call(a,b,c) ))
#else
#define FirstCFunctionCall(a,b,c)  PyObject_Call(a,b,c)
#endif

#define GET_ATTR_LOCAL(n, nm, attr, labl) if (_ ##nm##_dict && (temp[n] = PyDict_GetItem(_##nm##_dict, attr)) != 0) { Py_INCREF(temp[n]); } else if ((temp[n] = PyObject_GetAttr ( GETLOCAL(nm) , attr )) == 0) goto labl; else 

Py_ssize_t _Py_RefTotal_Printed = 0;
"""
c_tail = """
#define ISINDEX(x) ((x) == 0 || \
		    PyInt_Check(x) || PyLong_Check(x) || PyIndex_Check(x))
"""


def UseLabl():
    g_co.used_label[labl] = True
    
    
def IsUsedLabl(labl):
    return bool(labl in g_co.used_label)
    
libr_depends = {'_PyEval_PRINT_ITEM_1' : ('_PyEval_PRINT_ITEM_TO_2',),\
            'from_ceval_call_exc_trace' : ('from_ceval_call_trace',),\
            'PyImport_Exec2CCodeModuleEx':('PyEval_Eval2CCodeEx',),
            'Py2CCode_New':('Py2CCodeObject',),
            'Py2CFunction_New':('Py2CFunction',),
            'fastsearch_slice1': ('fastsearch',)}
            
_Libr = {}
used_libr = set()            
if not is_code_ext:
    libr_depends['Py2CCode_New'] = libr_depends['Py2CCode_New'] + ('all_name_chars', 'intern_strings')

def Used(nm):
    used_libr.add(nm)
    if nm in libr_depends:
        for nm2 in libr_depends[nm]:
            Used(nm2)

def IsLibr(nm):
    return bool(nm in _Libr)

def IsUsedLibr(nm):
    if nm not in _Libr:
        return False
    if nm in used_libr:
        return True
    return False

def Libr(nm, dcl, defin, deps = None):
    global libr_depends
    _Libr[nm] = (dcl, defin)
    if deps is not None:
        libr_depends[nm] = deps

def LibrDcl(nm):
    return _Libr[nm][0]

def LibrDef(nm):
    return _Libr[nm][1]

Libr('_PyString_Strip',
'static PyObject * _PyString_Strip(PyStringObject * self);',
"""
static PyObject * _PyString_Strip(PyStringObject * self)
{
    char *s = PyString_AS_STRING(self);
    Py_ssize_t len = PyString_GET_SIZE(self), i, j;

    i = 0;
    while (i < len && isspace(Py_CHARMASK(s[i]))) {
        i++;
    }

    j = len;
    do {
        j--;
    } while (j >= i && isspace(Py_CHARMASK(s[j])));
    j++;

    if (i == 0 && j == len) {
        Py_INCREF(self);
        return (PyObject*)self;
    }
    else
        return PyString_FromStringAndSize(s+i, j-i);}
""")


Libr('_PyList_Index',
'static long _PyList_Index(PyListObject * self, PyObject * v);',
"""
static long _PyList_Index(PyListObject *self, PyObject *v)
{
    Py_ssize_t i;
    PyObject *format_tuple, *err_string;
    static PyObject *err_format = NULL;
    int cmp;

    if (PyString_CheckExact(v)) {
        for (i = 0; i < Py_SIZE(self); i++) {
            if (PyString_CheckExact(self->ob_item[i])) {
                if (PyString_GET_SIZE(self->ob_item[i]) != PyString_GET_SIZE(v)) continue;
                if (memcmp(PyString_AS_STRING(self->ob_item[i]), PyString_AS_STRING(v), PyString_GET_SIZE(v)) == 0) return i;
            } else {
                cmp = PyObject_RichCompareBool(self->ob_item[i], v, Py_EQ);
                if (cmp > 0)
                    return i;
                else if (cmp < 0)
                    return -1;
            }
        }
    } else {
        for (i = 0; i < Py_SIZE(self); i++) {
            cmp = PyObject_RichCompareBool(self->ob_item[i], v, Py_EQ);
            if (cmp > 0)
                return i;
            else if (cmp < 0)
                return -1;
        }
    }
    if (err_format == NULL) {
        err_format = PyString_FromString("%r is not in list");
        if (err_format == NULL)
            return -1;
    }
    format_tuple = PyTuple_Pack(1, v);
    if (format_tuple == NULL)
        return -1;
    err_string = PyString_Format(err_format, format_tuple);
    Py_DECREF(format_tuple);
    if (err_string == NULL)
        return -1;
    PyErr_SetObject(PyExc_ValueError, err_string);
    Py_DECREF(err_string);
    return -1;
}
""")
Libr('_PyInt_Power',
'static long _PyInt_Power(long, long);',
"""
static long _PyInt_Power(long iv, long iw)
{
    register long ix, temp, prev;

    assert(iw >= 0);
    /*
     * XXX: The original exponentiation code stopped looping
     * when temp hit zero; this code will continue onwards
     * unnecessarily, but at least it won't cause any errors.
     * Hopefully the speed improvement from the fast exponentiation
     * will compensate for the slight inefficiency.
     * XXX: Better handling of overflows is desperately needed.
     */
    temp = iv;
    ix = 1;
    while (iw > 0) {
        prev = ix;              /* Save value for overflow check */
        if (iw & 1) {
            /*
             * The (unsigned long) cast below ensures that the multiplication
             * is interpreted as an unsigned operation rather than a signed one
             * (C99 6.3.1.8p1), thus avoiding the perils of undefined behaviour
             * from signed arithmetic overflow (C99 6.5p5).  See issue #12973.
             */
            ix = (unsigned long)ix * temp;
            if (temp == 0)
                break; /* Avoid ix / 0 */
            assert (ix / temp == prev);
        }
        iw >>= 1;               /* Shift exponent down by 1 bit */
        if (iw==0) break;
        prev = temp;
        temp = (unsigned long)temp * temp;  /* Square the value of temp */
        assert (!(prev != 0 && temp / prev != prev));
    }
    return ix;
}
""")     
Libr('_PyInt_Rshift',
     'static long _PyInt_Rshift (long a, long b);',
"""
static long _PyInt_Rshift (long a, long b)
{
    if (a == 0 || b == 0)
        return a;
    if (b >= LONG_BIT) {
        if (a < 0)
            a = -1;
        else
            a = 0;
    }
    else {
#ifdef Py_ARITHMETIC_RIGHT_SHIFT
        a = Py_ARITHMETIC_RIGHT_SHIFT(long, a, b);
#else
        a = a >> b;
#endif
    }
    return a;
}
""")

Libr('_PyInt_Mod',
     'static long _PyInt_Mod (long x, long y);',
"""
static long _PyInt_Mod (long x, long y)
{
    long xdivy, xmody;

    xdivy = x / y;
    xmody = (long)(x - (unsigned long)xdivy * y);
    if (xmody && ((y ^ xmody) < 0) /* i.e. and signs differ */) {
        xmody += y;
        --xdivy;
        assert(xmody && ((y ^ xmody) >= 0));
    }
    return xmody;
}
""")

Libr('_PyInt_Div',
     'static long _PyInt_Div (long x, long y);',
"""
static long _PyInt_Div (long x, long y)
{
    long xdivy, xmody;

    xdivy = x / y;
    xmody = (long)(x - (unsigned long)xdivy * y);
    if (xmody && ((y ^ xmody) < 0) /* i.e. and signs differ */) {
        xmody += y;
        --xdivy;
        assert(xmody && ((y ^ xmody) >= 0));
    }
    return xdivy;
}
""")

Libr('_Py2C_ord',
     'static long _Py2C_ord(PyObject* obj);',
"""
static long _Py2C_ord(PyObject* obj)
{
    long ord;
    Py_ssize_t size;

    if (PyString_Check(obj)) {
        size = PyString_GET_SIZE(obj);
        if (size == 1) {
            ord = (long)((unsigned char)*PyString_AS_STRING(obj));
            return ord;
        }
    } else if (PyByteArray_Check(obj)) {
        size = PyByteArray_GET_SIZE(obj);
        if (size == 1) {
            ord = (long)((unsigned char)*PyByteArray_AS_STRING(obj));
            return ord;
        }

#ifdef Py_USING_UNICODE
    } else if (PyUnicode_Check(obj)) {
        size = PyUnicode_GET_SIZE(obj);
        if (size == 1) {
            ord = (long)*PyUnicode_AS_UNICODE(obj);
            assert(ord >= 0);
            return ord;
        }
#endif
    } else {
        PyErr_Format(PyExc_TypeError,
                     "ord() expected string of length 1, but " \
                     "%.200s found", obj->ob_type->tp_name);
        return -1;
    }

    PyErr_Format(PyExc_TypeError,
                 "ord() expected a character, "
                 "but string of length %zd found",
                 size);
    return -1;
}

""")     

Libr('refcopy',
"""static PyMethodDef refcopy_methods[];
""",
"""
static PyObject *
ref_copy(PyObject *mp)
{
    Py_INCREF(mp);
    return mp;
}

PyDoc_STRVAR(copy__doc__,
"C.__copy__() -> C");

static PyMethodDef refcopy_methods[] = {
    {"__copy__",      (PyCFunction)ref_copy,       METH_NOARGS,
     copy__doc__},
    {"__deepcopy__",      (PyCFunction)ref_copy,       METH_NOARGS,
     copy__doc__},
    {NULL,              NULL}   /* sentinel */
};
""")     

if is_code_ext:
    Libr('Py2CFunction', """
#define Py2CFunction_Type PyFunction_Type
#define Py2CFunction_CheckExact PyFunction_CheckExact
#define Py2CFunction_Check PyFunction_Check
""", "")
else:
    Libr('Py2CFunction',
"""
static void patch_Py2CFunction(void);

PyTypeObject Py2CFunction_Type;

#define Py2CFunction_CheckExact(op) (Py_TYPE(op) == &Py2CFunction_Type)
#define Py2CFunction_Check(op) PyObject_TypeCheck(op, &Py2CFunction_Type)
""",
"""

/* Function object implementation */

#include "eval.h"

static PyObject *
function_call(PyObject *func, PyObject *arg, PyObject *kw)
{
	PyObject *result;
	PyObject *argdefs;
	PyObject **d, **k;
	Py_ssize_t nk, nd;

	argdefs = PyFunction_GET_DEFAULTS(func);
	if (argdefs != NULL && PyTuple_Check(argdefs)) {
		d = &PyTuple_GET_ITEM((PyTupleObject *)argdefs, 0);
		nd = PyTuple_Size(argdefs);
	}
	else {
		d = NULL;
		nd = 0;
	}

	if (kw != NULL && PyDict_Check(kw)) {
		Py_ssize_t pos, i;
		nk = PyDict_Size(kw);
		k = PyMem_NEW(PyObject *, 2*nk);
		if (k == 0) {
			PyErr_NoMemory();
			return NULL;
		}
		pos = i = 0;
		while (PyDict_Next(kw, &pos, &k[i], &k[i+1]))
			i += 2;
		nk = i/2;
		/* XXX This is broken if the caller deletes dict items! */
	}
	else {
		k = NULL;
		nk = 0;
	}

	result = PyEval_Eval2CCodeEx(
		(PyCodeObject *)PyFunction_GET_CODE(func),
		(PyObject *)NULL,
		&PyTuple_GET_ITEM(arg, 0), PyTuple_Size(arg),
		k, nk, d, nd
#ifndef PYPY_VERSION
                ,
		PyFunction_GET_CLOSURE(func));
#else
                );
#endif

	if (k != NULL)
		PyMem_DEL(k);

	return result;
}

static void patch_Py2CFunction(void){
    Py2CFunction_Type = PyFunction_Type;
    Py2CFunction_Type.ob_type = &PyType_Type;
    Py2CFunction_Type.tp_new = 0;
    Py2CFunction_Type.tp_name = "function2c";
    Py2CFunction_Type.tp_call = function_call;
    Py2CFunction_Type.tp_methods = refcopy_methods;
    PyType_Ready(&Py2CFunction_Type);
}  
""", ('refcopy',))




Libr('Py2CGen_Type',
"""
static void patch_Py2CGen(void);

PyTypeObject Py2CGen_Type;

#define Py2CGen_CheckExact(op) (Py_TYPE(op) == &Py2CGen_Type)
#define Py2CGen_Check(op) PyObject_TypeCheck(op, &Py2CGen_Type)
""",
"""


static void patch_Py2CGen(void){
    Py2CGen_Type = PyGen_Type;
    Py2CGen_Type.ob_type = &PyType_Type;
    Py2CGen_Type.tp_new = 0;
    Py2CGen_Type.tp_name = "gen2c";
    Py2CGen_Type.tp_call = gen_call;
    Py2CGen_Type.tp_methods = refcopy_methods;
    PyType_Ready(&Py2CGen_Type);
}  
""")





if is_code_ext:
        Libr('Py2CCodeObject', """
#define Py2CCode_Check(op) (PyCode_Check(op) && ((PyCodeObject *)op)->co_cfunc)
#define Py2CCode_Type PyCode_Type
             """, """""")
else:
    Libr('Py2CCodeObject',
"""
static void patch_Py2CCode(void);
PyTypeObject Py2CCode_Type;

#define Py2CCode_Check(op) (Py_TYPE(op) == &Py2CCode_Type && ((Py2CCodeObject *)op)->co_cfunc)

""",
"""
static PyObject * code_repr(PyCodeObject *co)
{
	char buf[500];
	int lineno = -1;
	char *filename = "???";
	char *name = "???";
        PyObject * o_filename;
        PyObject * o_name;
        o_filename = 0;
        o_name = 0;

#ifdef PYPY_VERSION    
        {
        PyObject * o_first;
        o_first = PyObject_GetAttrString((PyObject *)co, "co_firstlineno");
        assert(o_first != 0);
        o_filename = PyObject_GetAttrString((PyObject *)co, "co_filename");
        assert(o_filename != 0);
        o_name = PyObject_GetAttrString((PyObject *)co, "co_name");
        assert(o_name != 0);
        lineno = PyInt_AsLong(o_first);
        Py_CLEAR(o_first);
        }
#else
        o_filename = co->co_filename;
        o_name = co->co_name;
	if (co->co_firstlineno != 0)
		lineno = co->co_firstlineno;
#endif               
	if (o_filename && PyString_Check(o_filename))
		filename = PyString_AS_STRING(o_filename);
	if (o_name && PyString_Check(o_name))
		name = PyString_AS_STRING(o_name);
	PyOS_snprintf(buf, sizeof(buf),
		      "<code object %.100s at %p(%p), file \\"%.300s\\", line %d>",
		      name, co, ((Py2CCodeObject *)co)->co_cfunc, filename, lineno);
#ifdef PYPY_VERSION  
        Py_CLEAR(o_filename);
        Py_CLEAR(o_name); 
#endif                      
	return PyString_FromString(buf);
}

static int code_compare(PyObject *co, PyObject *cp)
{
	int cmp;
        cmp = PyCode_Type.tp_compare(co, cp);
	if (cmp) return cmp;
        cmp = (long)((Py2CCodeObject *)co)->co_cfunc - (long)((Py2CCodeObject *)cp)->co_cfunc;
	if (cmp) goto normalize;
        return cmp;
    
 normalize:
	if (cmp > 0)
		return 1;
	else if (cmp < 0)
		return -1;
	else
		return 0;
}

static PyObject * code_richcompare(PyObject *self, PyObject *other, int op)
{
	int eq;
	PyObject *res;

        if ((op == Py_EQ || op == Py_NE) && Py2CCode_Check(self) && Py2CCode_Check(other)) {
                eq = ((Py2CCodeObject *)self)->co_cfunc == ((Py2CCodeObject *)other)->co_cfunc;
	        if (!eq) goto unequal;
        	if (op == Py_EQ)
		       res = Py_True;
                else
		       res = Py_False;
	        goto done;
  unequal:
	if (eq < 0)
		return NULL;
	if (op == Py_NE)
		res = Py_True;
	else
		res = Py_False;

  done:
	Py_INCREF(res);
	return res;
        }
	if ((op != Py_EQ && op != Py_NE) ||
	    !PyCode_Check(self) || 
	    !PyCode_Check(other)) {

		/* Py3K warning if types are not equal and comparison
		isn't == or !=  */
		if (PyErr_WarnPy3k("code inequality comparisons not supported "
				   "in 3.x", 1) < 0) {
			return NULL;
		}

		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}
        return PyCode_Type.tp_richcompare(self, other, op);
}


static long code_hash(PyCodeObject *co)
{
        return (long)(((Py2CCodeObject *)co)->co_cfunc);
}

static void patch_Py2CCode(void){
    Py2CCode_Type = PyCode_Type;
    Py2CCode_Type.ob_type = &PyType_Type;
    Py2CCode_Type.tp_richcompare = code_richcompare;
    Py2CCode_Type.tp_compare = (cmpfunc)code_compare;
    Py2CCode_Type.tp_repr = (reprfunc)code_repr;
    Py2CCode_Type.tp_hash = (hashfunc)code_hash;
    Py2CCode_Type.tp_new = 0;
    Py2CCode_Type.tp_name = "code2c";
    Py2CCode_Type.tp_methods = refcopy_methods;
    
    Py2CCode_Type.tp_basicsize = sizeof(Py2CCodeObject);
    PyType_Ready(&Py2CCode_Type);
}

""", ('refcopy',))

Libr('all_name_chars',
"""
static int
all_name_chars(unsigned char *s);
""",
"""
#define NAME_CHARS \
	"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"

/* all_name_chars(s): true iff all chars in s are valid NAME_CHARS */

static int
all_name_chars(unsigned char *s)
{
	static char ok_name_char[256];
	static unsigned char *name_chars = (unsigned char *)NAME_CHARS;

	if (ok_name_char[*name_chars] == 0) {
		unsigned char *p;
		for (p = name_chars; *p; p++)
			ok_name_char[*p] = 1;
	}
	while (*s) {
		if (ok_name_char[*s++] == 0)
			return 0;
	}
	return 1;
}
""")

Libr('intern_strings',
"""
static void intern_strings(PyObject *tuple);
""",
"""
static void intern_strings(PyObject *tuple){
	Py_ssize_t i;

	for (i = PyTuple_GET_SIZE(tuple); --i >= 0; ) {
		PyObject *v = PyTuple_GET_ITEM(tuple, i);
		if (v == 0 || !PyString_CheckExact(v)) {
			Py_FatalError("non-string found in code slot");
		}
		PyString_InternInPlace(&PyTuple_GET_ITEM(tuple, i));
	}
}
""")

if is_code_ext:
    Libr('Py2CCode_New', """
static Py2CCodeObject *
Py2CCode_New(int argcount, int nlocals, int stacksize, int flags,
	   PyObject *code, PyObject *consts, PyObject *names,
	   PyObject *varnames, PyObject *freevars, PyObject *cellvars,
	   PyObject *filename, PyObject *name, int firstlineno,
	   PyObject *lnotab, void * func);
             """, 
"""
static Py2CCodeObject *
Py2CCode_New(int argcount, int nlocals, int stacksize, int flags,
	   PyObject *code, PyObject *consts, PyObject *names,
	   PyObject *varnames, PyObject *freevars, PyObject *cellvars,
	   PyObject *filename, PyObject *name, int firstlineno,
	   PyObject *lnotab, void * func)
{
	PyCodeObject *co = PyCode_New(argcount, nlocals, stacksize, flags,
	   code, consts, names,
	   varnames, freevars, cellvars,
	   filename, name, firstlineno,
	   lnotab);
        if (co) co->co_cfunc = func;
        return co;
}
""")
else:
    Libr('Py2CCode_New',
"""
static Py2CCodeObject *
Py2CCode_New(int argcount, int nlocals, int stacksize, int flags,
	   PyObject *code, PyObject *consts, PyObject *names,
	   PyObject *varnames, PyObject *freevars, PyObject *cellvars,
	   PyObject *filename, PyObject *name, int firstlineno,
	   PyObject *lnotab, void * func);
""",
"""
static Py2CCodeObject *
Py2CCode_New(int argcount, int nlocals, int stacksize, int flags,
	   PyObject *code, PyObject *consts, PyObject *names,
	   PyObject *varnames, PyObject *freevars, PyObject *cellvars,
	   PyObject *filename, PyObject *name, int firstlineno,
	   PyObject *lnotab, void * func)
{
	PyCodeObject *co;
        assert(consts->ob_refcnt >= 1);
	Py_ssize_t i;
	/* Check argument types */
#define __CHE(a) if ( a ) { printf("Error Py2CCode_New, %s, %d\\n", #a, firstlineno); PyErr_BadInternalCall(); return NULL; } else

        __CHE(argcount < 0);
        __CHE(nlocals < 0);
        __CHE(code == 0);
        __CHE(consts == 0);
        __CHE(!PyTuple_Check(consts));
        __CHE(names == 0);
        __CHE(!PyTuple_Check(names));
        __CHE(varnames == 0);
        __CHE(!PyTuple_Check(varnames));
        __CHE(freevars == 0);
        __CHE(!PyTuple_Check(freevars));
        __CHE(cellvars == 0);
        __CHE(!PyTuple_Check(cellvars));
        __CHE(name == 0);
        __CHE(!PyString_Check(name));
        __CHE(filename == 0);
        __CHE(!PyString_Check(filename));
        __CHE(lnotab == 0);
        __CHE(!PyString_Check(lnotab));
        __CHE(func == 0);
        __CHE(!PyObject_CheckReadBuffer(code));
#ifndef PYPY_VERSION        
	intern_strings(names);
	intern_strings(varnames);
	intern_strings(freevars);
	intern_strings(cellvars);
	/* Intern selected string constants */
	for (i = PyTuple_Size(consts); --i >= 0; ) {
		PyObject *v = PyTuple_GetItem(consts, i);
		if (!PyString_Check(v))
			continue;
		if (!all_name_chars((unsigned char *)PyString_AS_STRING(v)))
			continue;
		PyString_InternInPlace(&PyTuple_GET_ITEM(consts, i));
	}
#endif        
	co = (PyCodeObject *)PyObject_NEW(Py2CCodeObject, &Py2CCode_Type);
	if (co != NULL) {
		co->co_argcount = argcount;
		co->co_nlocals = nlocals;
		co->co_stacksize = stacksize;
		co->co_flags = flags;
		Py_INCREF(code);
		co->co_code = code;
		Py_INCREF(consts);
		co->co_consts = consts;
		Py_INCREF(names);
		co->co_names = names;
		Py_INCREF(varnames);
		co->co_varnames = varnames;
		Py_INCREF(freevars);
		co->co_freevars = freevars;
		Py_INCREF(cellvars);
		co->co_cellvars = cellvars;
		Py_INCREF(filename);
		co->co_filename = filename;
		Py_INCREF(name);
		co->co_name = name;
		co->co_firstlineno = firstlineno;
		Py_INCREF(lnotab);
		co->co_lnotab = lnotab;
                co->co_zombieframe = NULL;
                ((Py2CCodeObject *)co)->co_cfunc = func;
	}
	return ((Py2CCodeObject *)co);
}
""")

Libr ('_RemoveModule', 
      """
static void _RemoveModule(const char *name);      
      """,
      """
/* Remove name from sys.modules, if it's there. */     
static void _RemoveModule(const char *name) {
	PyObject *modules = PyImport_GetModuleDict();
        if (PyDict_GetItemString(modules, name) == 0)
		return;
	if (PyDict_DelItemString(modules, name) < 0)
		Py_FatalError("import:  deleting existing key in"
			      "sys.modules failed");
}      
      """)
if is_code_ext:
    Libr('PyImport_Exec2CCodeModuleEx',
        """
#define PyImport_Exec2CCodeModuleEx(a,b) PyImport_ExecCodeModuleEx(a,b, NULL)
        """, '', ('package', 'absfilename'))
else:
    Libr('PyImport_Exec2CCodeModuleEx',
"""
static PyObject * PyImport_Exec2CCodeModuleEx(char *, PyObject *);
""",
"""
static PyObject *
PyImport_Exec2CCodeModuleEx(char *name, PyObject *co)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *m, *d, *v, *v2;
        int l;

	m = PyImport_AddModule(name);
	if (m == 0)
		return NULL;
	/* If the module is being reloaded, we get the old module back
	   and re-use its dict to exec the new code. */
	d = PyModule_GetDict(m);
	if (PyDict_GetItemString(d, "__builtins__") == 0) {
		if (PyDict_SetItemString(d, "__builtins__",
					 PyEval_GetBuiltins()) != 0)
			goto error;
	}
 	/* Remember the filename as the __file__ attribute */ 
        assert(co!= 0);
        if (absfilename) {
            v = PyString_FromString(absfilename);
            Py_INCREF(v);        
        } else {
#ifndef PYPY_VERSION
        v = ((PyCodeObject *)co)->co_filename;
/*      v = PyString_FromString(src_name);*/
        Py_INCREF(v);
#else
        v = PyObject_GetAttrString(co, "co_filename");
#endif        
        }
        l = PyString_GET_SIZE(v);
        if (l > 3 && !strcmp(PyString_AS_STRING(v) + (l-3), ".so")) {
          v2 = PyString_FromStringAndSize(NULL, l);
          strcpy(PyString_AS_STRING(v2), PyString_AS_STRING(v));
          memcpy(PyString_AS_STRING(v2)+ (l-3), ".py", 3);
          Py_DECREF(v);
          v = v2;
          Py_INCREF(v);
        }
            
	if (PyDict_SetItemString(d, "__file__", v) != 0)
		PyErr_Clear(); /* Not important enough to report */
	Py_DECREF(v);
        v = PyString_FromString(name);
        Py_INCREF(v);
	if (PyDict_SetItemString(d, "__name__", v) != 0)
		PyErr_Clear(); /* Not important enough to report */
	Py_DECREF(v);
        glob = d;
        module = m;
        if (package != NULL) {
            v = PyString_FromString(package);
            Py_INCREF(v);
            if (PyDict_SetItemString(d, "__package__", v) != 0)
                    PyErr_Clear(); /* Not important enough to report */
            Py_DECREF(v);  
        }
	v = PyEval_Eval2CCodeEx((PyCodeObject *)co,
			  d,
			  (PyObject **)NULL, 0,
			  (PyObject **)NULL, 0,
			  (PyObject **)NULL, 0
#ifndef PYPY_VERSION
                          ,
			  NULL);
#else
                        );
#endif

	if (v == 0)
		goto error;
	Py_DECREF(v);

	if ((m = PyDict_GetItemString(modules, name)) == 0) {
		PyErr_Format(PyExc_ImportError,
			     "Loaded module %.200s not found in sys.modules",
			     name);
		return NULL;
	}

	Py_INCREF(m);

	return m;

  error:
	_RemoveModule(name);
	return NULL;
}
""", ('_RemoveModule', 'module', 'package', 'absfilename'))

Libr('module', 'static PyObject * module = 0;', '')

Libr('package', 'static char * package = 0;', '')

Libr('absfilename', 'static char * absfilename = 0;', '')

Libr('PyImport_Init_Module',
"""
static PyObject * PyImport_Init_Module(char *, PyObject *);
""",
"""
static PyObject *
PyImport_Init_Module(char *name, PyObject *filename)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *m, *d, *v, *v2;
        int l;

	m = PyImport_AddModule(name);
	if (m == 0)
		return NULL;
	/* If the module is being reloaded, we get the old module back
	   and re-use its dict to exec the new code. */
	d = PyModule_GetDict(m);
	if (PyDict_GetItemString(d, "__builtins__") == 0) {
		if (PyDict_SetItemString(d, "__builtins__",
					 PyEval_GetBuiltins()) != 0)
			goto error;
	}
 	/* Remember the filename as the __file__ attribute */ 
        Py_INCREF(filename);
        l = PyString_GET_SIZE(filename);
        if (l > 3 && !strcmp(PyString_AS_STRING(filename) + (l-3), ".so")) {
          v2 = PyString_FromStringAndSize(NULL, l);
          strcpy(PyString_AS_STRING(v2), PyString_AS_STRING(filename));
          strcpy(PyString_AS_STRING(v2)+ (l-3), ".py");
          Py_DECREF(filename);
          filename = v2;
          Py_INCREF(filename);
        }      
	if (PyDict_SetItemString(d, "__file__", filename) != 0)
		PyErr_Clear(); /* Not important enough to report */
	Py_DECREF(filename);
        v = PyString_FromString(name);
        Py_INCREF(v);
	if (PyDict_SetItemString(d, "__name__", v) != 0)
		PyErr_Clear(); /* Not important enough to report */
	Py_DECREF(v);
        glob = d;
        module = m;
	v = cfunc_Init_filename(m, 0);

	if (v == 0)
		goto error;
	Py_DECREF(v);

	if ((m = PyDict_GetItemString(modules, name)) == 0) {
		PyErr_Format(PyExc_ImportError,
			     "Loaded module %.200s not found in sys.modules",
			     name);
		return NULL;
	}

	Py_INCREF(m);

	return m;

  error:
	_RemoveModule(name);
	return NULL;
}
""", ('_RemoveModule', 'module', 'package'))

if is_code_ext and py_version == 27:
    Libr('PyEval_Eval2CCodeEx', 
"""
#define PyEval_Eval2CCodeEx(a, b, c, d, e, f, g, h, i) PyEval_EvalCodeEx(a, glob, b, c, d, e, f, g, h, i)
""", '')
elif is_code_ext and py_version == 28:
    Libr('PyEval_Eval2CCodeEx', 
"""
#define PyEval_Eval2CCodeEx(a, b, c, d, e, f, g, h, i) PyEval_EvalCodeEx(a, glob, b, c, d, e, f, g, h, i)
""", '')
elif not is_code_ext and py_version == 27:
    Libr('PyEval_Eval2CCodeEx', 
"""
static PyObject *
PyEval_Eval2CCodeEx(PyCodeObject *, PyObject *,
	   PyObject **, int , PyObject **, int ,
	   PyObject **, int
#ifndef PYPY_VERSION
            , PyObject *);
#else
            );
#endif
""",
"""
/* Local variable macros */

#undef GETLOCAL
#undef SETLOCAL
#define GETLOCAL(i)	(fastlocals[i])

#define SETLOCAL(i, value)	do { PyObject *tmp = GETLOCAL(i); \
				     GETLOCAL(i) = value; \
                                     Py_XDECREF(tmp); } while (0)

static PyObject *
PyEval_Eval2CCodeEx(PyCodeObject *co, PyObject *locals,
	   PyObject **args, int argcount, PyObject **kws, int kwcount,
	   PyObject **defs, int defcount
#ifndef PYPY_VERSION
           , PyObject *closure)
#else
           )
#endif
{
	register PyFrameObject *f;
	register PyObject *retval = NULL;
	register PyObject **fastlocals, **freevars;
	PyThreadState * tstate = PyThreadState_GET();
	PyObject *x, *u;
        PyObject *(*c_func)(PyFrameObject *);

        assert(tstate != NULL);
        f = PyFrame_New(tstate, co, glob, locals);
	if (f == 0)
		return NULL;

	fastlocals = f->f_localsplus;
	freevars = f->f_localsplus + co->co_nlocals;

	if (co->co_argcount > 0 ||
	    co->co_flags & (CO_VARARGS | CO_VARKEYWORDS)) {
		int i;
		int n = argcount;
		PyObject *kwdict = NULL;
		if (co->co_flags & CO_VARKEYWORDS) {
			kwdict = PyDict_New();
			if (kwdict == 0)
				goto fail;
			i = co->co_argcount;
			if (co->co_flags & CO_VARARGS)
				i++;
			SETLOCAL(i, kwdict);
		}
		if (argcount > co->co_argcount) {
			if (!(co->co_flags & CO_VARARGS)) {
				PyErr_Format(PyExc_TypeError,
				    "%.200s() takes %s %d "
				    "%sargument%s (%d given)",
				    PyString_AsString(co->co_name),
				    defcount ? "at most" : "exactly",
				    co->co_argcount,
				    kwcount ? "non-keyword " : "",
				    co->co_argcount == 1 ? "" : "s",
				    argcount);
				goto fail;
			}
			n = co->co_argcount;
		}
		for (i = 0; i < n; i++) {
			x = args[i];
			Py_INCREF(x);
			SETLOCAL(i, x);
		}
		if (co->co_flags & CO_VARARGS) {
			u = PyTuple_New(argcount - n);
			if (u == 0)
				goto fail;
			SETLOCAL(co->co_argcount, u);
			for (i = n; i < argcount; i++) {
				x = args[i];
				Py_INCREF(x);
				PyTuple_SET_ITEM(u, i-n, x);
			}
		}
		for (i = 0; i < kwcount; i++) {
			PyObject **co_varnames;
			PyObject *keyword = kws[2*i];
			PyObject *value = kws[2*i + 1];
			int j;
                        if (keyword == 0 || !(PyString_Check(keyword)
#ifdef Py_USING_UNICODE
                                     || PyUnicode_Check(keyword)
#endif
                            )) {
				PyErr_Format(PyExc_TypeError,
				    "%.200s() keywords must be strings",
				    PyString_AsString(co->co_name));
				goto fail;
			}
			/* Speed hack: do raw pointer compares. As names are
			   normally interned this should almost always hit. */
                        co_varnames = ((PyTupleObject *)(co->co_varnames))->ob_item;
                        for (j = 0; j < co->co_argcount; j++) {
                            PyObject *nm = co_varnames[j];
                            if (nm == keyword)
                                goto kw_found;
                        }
                        /* Slow fallback, just in case */
                        for (j = 0; j < co->co_argcount; j++) {
                            PyObject *nm = co_varnames[j];
                            int cmp = PyObject_RichCompareBool(
                                keyword, nm, Py_EQ);
                            if (cmp > 0)
                                goto kw_found;
                            else if (cmp < 0)
                                goto fail;
                        }
                        if (kwdict == 0) {
                            PyObject *kwd_str = kwd_as_string(keyword);
                            if (kwd_str) {
                                PyErr_Format(PyExc_TypeError,
                                            "%.200s() got an unexpected "
                                            "keyword argument '%.400s'",
                                            PyString_AsString(co->co_name),
                                            PyString_AsString(kwd_str));
                                Py_DECREF(kwd_str);
                            }
                            goto fail;
                        }
                        PyDict_SetItem(kwdict, keyword, value);
                        continue;

kw_found:
			if (GETLOCAL(j) != NULL) {
                            PyObject *kwd_str = kwd_as_string(keyword);
                            if (kwd_str) {
                                PyErr_Format(PyExc_TypeError,
                                            "%.200s() got multiple "
                                            "values for keyword "
                                            "argument '%.400s'",
                                            PyString_AsString(co->co_name),
                                            PyString_AsString(kwd_str));
                                Py_DECREF(kwd_str);
                            }
			}
			Py_INCREF(value);
			SETLOCAL(j, value);
		}
		if (argcount < co->co_argcount) {
			int m = co->co_argcount - defcount;
			for (i = argcount; i < m; i++) {
				if (GETLOCAL(i) == 0) {
                                    int j, given = 0;
                                    for (j = 0; j < co->co_argcount; j++)
                                        if (GETLOCAL(j))
                                            given++;
                                    PyErr_Format(PyExc_TypeError,
                                        "%.200s() takes %s %d "
                                        "argument%s (%d given)",
                                        PyString_AsString(co->co_name),
                                        ((co->co_flags & CO_VARARGS) ||
                                        defcount) ? "at least"
                                                : "exactly",
                                        m, m == 1 ? "" : "s", given);
                                    goto fail;
				}
			}
			if (n > m)
				i = n - m;
			else
				i = 0;
			for (; i < defcount; i++) {
				if (GETLOCAL(m+i) == 0) {
					PyObject *def = defs[i];
					Py_INCREF(def);
					SETLOCAL(m+i, def);
				}
			}
		}
	}
	else {
		if (argcount > 0 || kwcount > 0) {
			PyErr_Format(PyExc_TypeError,
				     "%.200s() takes no arguments (%d given)",
				     PyString_AsString(co->co_name),
				     argcount + kwcount);
			goto fail;
		}
	}
	/* Allocate and initialize storage for cell vars, and copy free
	   vars into frame.  This isn't too efficient right now. */
	if (PyTuple_GET_SIZE(co->co_cellvars)) {
		int i, j, nargs, found;
		char *cellname, *argname;
		PyObject *c;

		nargs = co->co_argcount;
		if (co->co_flags & CO_VARARGS)
			nargs++;
		if (co->co_flags & CO_VARKEYWORDS)
			nargs++;

		/* Initialize each cell var, taking into account
		   cell vars that are initialized from arguments.

		   Should arrange for the compiler to put cellvars
		   that are arguments at the beginning of the cellvars
		   list so that we can march over it more efficiently?
		*/
		for (i = 0; i < PyTuple_GET_SIZE(co->co_cellvars); ++i) {
			cellname = PyString_AS_STRING(
				PyTuple_GET_ITEM(co->co_cellvars, i));
			found = 0;
			for (j = 0; j < nargs; j++) {
				argname = PyString_AS_STRING(
					PyTuple_GET_ITEM(co->co_varnames, j));
				if (strcmp(cellname, argname) == 0) {
					c = PyCell_New(GETLOCAL(j));
					if (c == 0)
						goto fail;
					GETLOCAL(co->co_nlocals + i) = c;
					found = 1;
					break;
				}
			}
			if (found == 0) {
				c = PyCell_New(NULL);
				if (c == 0)
					goto fail;
				SETLOCAL(co->co_nlocals + i, c);
			}
		}
	}
#ifndef PYPY_VERSION
	if (PyTuple_GET_SIZE(co->co_freevars)) {
		int i;
		for (i = 0; i < PyTuple_GET_SIZE(co->co_freevars); ++i) {
			PyObject *o = PyTuple_GET_ITEM(closure, i);
			Py_INCREF(o);
			freevars[PyTuple_GET_SIZE(co->co_cellvars) + i] = o;
		}
	}
#endif
#ifndef PY2C_GENERATOR
        assert(!(co->co_flags & CO_GENERATOR));
#else
    if (co->co_flags & CO_GENERATOR) {
        /* Don't need to keep the reference to f_back, it will be set
         * when the generator is resumed. */
        Py_CLEAR(f->f_back);

        /* Create a new generator that owns the ready to run frame
         * and return that as the value. */
        return Py2CGen_New(f);
    }
#endif
        c_func = ((Py2CCodeObject *)co)->co_cfunc;
        assert(c_func != 0);
        retval = c_func(f);

fail: /* Jump here from prelude on failure */

	/* decref'ing the frame can cause __del__ methods to get invoked,
	   which can call back into Python.  While we're done with the
	   current Python frame (f), the associated C stack is still in use,
	   so recursion_depth must be boosted for the duration.
	*/
	assert(tstate != NULL);
#ifndef PYPY_VERSION
	++tstate->recursion_depth;
#endif
	Py_DECREF(f);
#ifndef PYPY_VERSION
	--tstate->recursion_depth;
#endif
	return retval;
}
""", ('kwd_as_string',))

if py_version == 27 and not is_code_ext:
    Libr('kwd_as_string', 
    """static PyObject * kwd_as_string(PyObject *);""",
    """
    static PyObject *
    kwd_as_string(PyObject *kwd) {
    #ifdef Py_USING_UNICODE
        if (PyString_Check(kwd)) {
    #else
            assert(PyString_Check(kwd));
    #endif
            Py_INCREF(kwd);
            return kwd;
    #ifdef Py_USING_UNICODE
        }
        return _PyUnicode_AsDefaultEncodedString(kwd, "replace");
    #endif
    }
    """)
## else:
    ## Libr('kwd_as_string', 
    ## """
## #define kwd_as_string(a) (a)    
    ## """,
    ## """
    ## """)
    
Libr('ctype', 
     """
#include <ctype.h>
""", """
""")

Libr('fastsearch_slice1',
"""
     Py_ssize_t fastsearch_slice1(const char* s, Py_ssize_t n,
           const char* p, Py_ssize_t m, Py_ssize_t slice1,
           Py_ssize_t maxcount, int mode);""", 
     """
Py_ssize_t fastsearch_slice1(const char* s, Py_ssize_t n,
           const char* p, Py_ssize_t m, Py_ssize_t slice1,
           Py_ssize_t maxcount, int mode) {
    Py_ssize_t ret;
    if (slice1 < 0) {
        slice1 += n;
    }
    if (slice1 < 0) slice1 = 0;
    if (slice1 > n) slice1 = n;
    s += slice1;
    n -= slice1;
    ret = fastsearch(s, n, p, m, maxcount, mode);
    if (mode == FAST_COUNT) {
        return ret;
    }
    return ret + slice1;
}
     """)

Libr('fastsearch', """
#define FAST_COUNT 0
#define FAST_SEARCH 1
#define FAST_RSEARCH 2

     Py_ssize_t fastsearch(const char* s, Py_ssize_t n,
           const char* p, Py_ssize_t m,
           Py_ssize_t maxcount, int mode);""", 
     """
/* Copy from stringlib CPython 2.7.3 */

/* fast search/count implementation, based on a mix between boyer-
   moore and horspool, with a few more bells and whistles on the top.
   for some more background, see: http://effbot.org/zone/stringlib.htm */

/* note: fastsearch may access s[n], which isn't a problem when using
   Python's ordinary string types, but may cause problems if you're
   using this code in other contexts.  also, the count mode returns -1
   if there cannot possible be a match in the target string, and 0 if
   it has actually checked for matches, but didn't find any.  callers
   beware! */
 
#if LONG_BIT >= 128
#define STRINGLIB_BLOOM_WIDTH 128
#elif LONG_BIT >= 64
#define STRINGLIB_BLOOM_WIDTH 64
#elif LONG_BIT >= 32
#define STRINGLIB_BLOOM_WIDTH 32
#else
#error "LONG_BIT is smaller than 32"
#endif

#define STRINGLIB_BLOOM_ADD(mask, ch) \
    ((mask |= (1UL << ((ch) & (STRINGLIB_BLOOM_WIDTH -1)))))
#define STRINGLIB_BLOOM(mask, ch)     \
    ((mask &  (1UL << ((ch) & (STRINGLIB_BLOOM_WIDTH -1)))))

Py_ssize_t
fastsearch(const char* s, Py_ssize_t n,
           const char* p, Py_ssize_t m,
           Py_ssize_t maxcount, int mode)
{
    unsigned long mask;
    Py_ssize_t skip, count = 0;
    Py_ssize_t i, j, mlast, w;

    w = n - m;

    if (w < 0 || (mode == FAST_COUNT && maxcount == 0))
        return -1;

    /* look for special cases */
    if (m <= 1) {
        if (m <= 0) {
            if (m == 0) {
                if (mode == FAST_SEARCH) return 0;
                if (mode == FAST_RSEARCH) return m;
            }
            return -1;
        }
        /* use special case for 1-character strings */
        if (mode == FAST_COUNT) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0]) {
                    count++;
                    if (count == maxcount)
                        return maxcount;
                }
            return count;
        } else if (mode == FAST_SEARCH) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0])
                    return i;
        } else {    /* FAST_RSEARCH */
            for (i = n - 1; i > -1; i--)
                if (s[i] == p[0])
                    return i;
        }
        return -1;
    }

    mlast = m - 1;
    skip = mlast - 1;
    mask = 0;

    if (mode != FAST_RSEARCH) {

        /* create compressed boyer-moore delta 1 table */

        /* process pattern[:-1] */
        for (i = 0; i < mlast; i++) {
            STRINGLIB_BLOOM_ADD(mask, p[i]);
            if (p[i] == p[mlast])
                skip = mlast - i - 1;
        }
        /* process pattern[-1] outside the loop */
        STRINGLIB_BLOOM_ADD(mask, p[mlast]);

        for (i = 0; i <= w; i++) {
            /* note: using mlast in the skip path slows things down on x86 */
            if (s[i+mlast] == p[mlast]) {
                /* candidate match */
                for (j = 0; j < mlast; j++)
                    if (s[i+j] != p[j])
                        break;
                if (j == mlast) {
                    /* got a match! */
                    if (mode != FAST_COUNT)
                        return i;
                    count++;
                    if (count == maxcount)
                        return maxcount;
                    i = i + mlast;
                    continue;
                }
                /* miss: check if next character is part of pattern */
                if (!STRINGLIB_BLOOM(mask, s[i+m]))
                    i = i + m;
                else
                    i = i + skip;
            } else {
                /* skip: check if next character is part of pattern */
                if (!STRINGLIB_BLOOM(mask, s[i+m]))
                    i = i + m;
            }
        }
    } else {    /* FAST_RSEARCH */

        /* create compressed boyer-moore delta 1 table */

        /* process pattern[0] outside the loop */
        STRINGLIB_BLOOM_ADD(mask, p[0]);
        /* process pattern[:0:-1] */
        for (i = mlast; i > 0; i--) {
            STRINGLIB_BLOOM_ADD(mask, p[i]);
            if (p[i] == p[0])
                skip = i - 1;
        }

        for (i = w; i >= 0; i--) {
            if (s[i] == p[0]) {
                /* candidate match */
                for (j = mlast; j > 0; j--)
                    if (s[i+j] != p[j])
                        break;
                if (j == 0)
                    /* got a match! */
                    return i;
                /* miss: check if previous character is part of pattern */
                if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))
                    i = i - m;
                else
                    i = i - skip;
            } else {
                /* skip: check if previous character is part of pattern */
                if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))
                    i = i - m;
            }
        }
    }

    if (mode != FAST_COUNT)
        return -1;
    return count;
}
     
     """)

Libr('main', 'int main(int argc, char *argv[]);',
     """
#ifdef PYPY_VERSION
#include "PyPy.h"
#endif

int main(int argc, char *argv[])
{
#ifndef PYPY_VERSION    
    Py_Initialize();
    PySys_SetArgv(argc, argv);
    init_main();
    Py_Finalize();
#else
int res;
    rpython_startup_code();
    res = pypy_setup_home(NULL, 1);
    if (res) {
        return 1;
    }
    pypy_execute_source("print str(4)");
    init_main();
#endif
    return 0;
}
""")     

Libr('from_ceval_2_7_special_lookup',
"""
static PyObject * from_ceval_2_7_enter = NULL;
static PyObject * from_ceval_2_7_exit = NULL;
static PyObject * from_ceval_2_7_special_lookup(PyObject *, char *, PyObject **);
""",
"""
static PyObject *
from_ceval_2_7_special_lookup(PyObject *o, char *meth, PyObject **cache)
{
    PyObject *res;
    if (PyInstance_Check(o)) {
        if (!*cache)
            return PyObject_GetAttrString(o, meth);
        else
            return PyObject_GetAttr(o, *cache);
    }
    res = _PyObject_LookupSpecial(o, meth, cache);
    if (res == 0 && !PyErr_Occurred()) {
        PyErr_SetObject(PyExc_AttributeError, *cache);
        return NULL;
    }
    return res;
}
""")

Libr('Direct_AddTraceback',
"""
static void Direct_AddTraceback (PyCodeObject *, int, int);
""",
"""
static void Direct_AddTraceback (PyCodeObject * py_code, int lineno, int addr){
  PyFrameObject *py_frame = 0;

  py_frame = PyFrame_New (PyThreadState_GET (),	/*PyThreadState * tstate, */
			  py_code,	/*PyCodeObject *code, */
			  glob,	/*PyObject *globals, */
			  0	/*PyObject *locals */
    );
  if (!py_frame)
    goto bad;
/*  printf("--- line %d\\n", lineno);  */
  py_frame->f_lineno = lineno;
#ifndef PYPY_VERSION
  py_frame->f_lasti = addr;
#endif  
  PyTraceBack_Here (py_frame);
bad:
  Py_XDECREF (py_frame);
}
""")   
  
Libr('STR_CONCAT2',
"""
static PyObject * STR_CONCAT2( PyObject *, PyObject * );
""",
"""
static PyObject * STR_CONCAT2( PyObject *a, PyObject * b)
{
   if (PyString_CheckExact(a) && PyString_CheckExact(b)) {
      PyObject * r;
      char buf[1024];
      Py_ssize_t l_a, l_b, l_r;
      l_a = PyString_GET_SIZE(a); 
      l_b = PyString_GET_SIZE(b);
      if (l_b == 0) {
        Py_INCREF(a);
        return a;
      }
      if (l_a == 0) {
        Py_INCREF(b);
        return b;
      }
      if ((l_r = (l_a + l_b)) < 1024) {
        Py_MEMCPY(buf, PyString_AS_STRING(a), l_a);
        Py_MEMCPY(buf + l_a, PyString_AS_STRING(b), l_b);
        r = PyString_FromStringAndSize(buf, l_r);
      } else {  
        r = PyString_FromStringAndSize(PyString_AS_STRING(a), l_a);
        PyString_Concat(&r, b);
      }  
      return r;
   } else {
      return PyNumber_Add(a,b);
   }
}
""")   
  
Libr('STR_CONCAT3',
"""
static PyObject * STR_CONCAT3( PyObject *, PyObject *, PyObject *);
""",
"""
static PyObject * STR_CONCAT3( PyObject *a, PyObject * b, PyObject * c)
{
   PyObject * r, *r1;
   if (PyString_CheckExact(a) && PyString_CheckExact(b) && PyString_CheckExact(c)) {
      char buf[1024];
      Py_ssize_t l_a, l_b, l_c, l_r;
      l_a = PyString_GET_SIZE(a); 
      l_b = PyString_GET_SIZE(b);
      l_c = PyString_GET_SIZE(c);
      if ((l_r = (l_a + l_b + l_c)) < 1024) {
        Py_MEMCPY(buf, PyString_AS_STRING(a), l_a);
        Py_MEMCPY(buf + l_a, PyString_AS_STRING(b), l_b);
        Py_MEMCPY(buf + (l_a + l_b), PyString_AS_STRING(c), l_c);
        r = PyString_FromStringAndSize(buf, l_r);
      } else {  
        r = PyString_FromStringAndSize(PyString_AS_STRING(a), l_a);
        PyString_Concat(&r, b);
        PyString_Concat(&r, c);
      }  
      return r;
   } else {
      r = PyNumber_Add(a,b);
      r1 = PyNumber_Add(r,c);
      Py_DECREF(r);
      return r1;
   }
}
""")    

Libr('STR_CONCAT_N',
"""
static PyObject * STR_CONCAT_N( int, PyObject *, ...);
""",
"""
static PyObject * STR_CONCAT_N( int na, PyObject *a, ...)
{
    typedef PyObject * pyref;
    pyref args[64];
    int len[64];
    int i;
    va_list vargs;
    int strflag = 1;
    Py_ssize_t l_r;
    PyObject * r, *r1;
    char * s;
    
    assert(na>=2);
    args[0] = a; 
    va_start(vargs, a);
    for (i = 1; i < na; i++) {
        args[i] = va_arg(vargs, PyObject *);
    }    
    va_end(vargs);
    strflag = 1;
    l_r = 0;
    for (i = 0; i < na; i ++) {
        strflag = PyString_CheckExact(args[i]);
        if (!strflag) break;
        l_r += (len[i] = PyString_GET_SIZE(args[i]));
    }
    if (strflag) {   
        r = PyString_FromStringAndSize(NULL, l_r);
        s = PyString_AS_STRING(r);
        for (i = 0; i < na; i ++) {
            Py_MEMCPY(s, PyString_AS_STRING(args[i]), len[i]);
            s += len[i];
        }
        return r;
    }    
    r = PyNumber_Add(args[0], args[1]);
    for (i = 2; i < na; i ++) {
      r1 = PyNumber_Add(r, args[i]);
      Py_DECREF(r);
      r = r1;
    }
    return r;
}
""")
  
Libr('from_ceval_call_exc_trace',
"""
static void from_ceval_call_exc_trace(Py_tracefunc, PyObject *, PyFrameObject *);
""",
"""
static void from_ceval_call_exc_trace(Py_tracefunc func, PyObject *self, PyFrameObject *f){
	PyObject *type, *value, *traceback, *arg;
	int err;
	PyErr_Fetch(&type, &value, &traceback);
	if (value == 0) {
		value = Py_None;
		Py_INCREF(value);
	}
	arg = PyTuple_Pack(3, type, value, traceback);
	if (arg == 0) {
		PyErr_Restore(type, value, traceback);
		return;
	}
	err = from_ceval_call_trace(func, self, f, PyTrace_EXCEPTION, arg);
	Py_DECREF(arg);
	if (err == 0)
		PyErr_Restore(type, value, traceback);
	else {
		Py_XDECREF(type);
		Py_XDECREF(value);
		Py_XDECREF(traceback);
	}
}
""")   
  
Libr('from_ceval_call_trace',
"""
static int
from_ceval_call_trace(Py_tracefunc , PyObject *, PyFrameObject *,
	   int , PyObject *);
""",
"""
static int
from_ceval_call_trace(Py_tracefunc func, PyObject *obj, PyFrameObject *frame,
	   int what, PyObject *arg)
{
	register PyThreadState * tstate = frame->f_tstate;
	int result;
	if (tstate->tracing)
		return 0;
	tstate->tracing++;
	tstate->use_tracing = 0;
	result = func(obj, frame, what, arg);
	tstate->use_tracing = ((tstate->c_tracefunc != NULL)
			       || (tstate->c_profilefunc != NULL));
	tstate->tracing--;
	return result;
}
""")   
  
Libr('from_ceval_BINARY_SUBSCR',
"""
static PyObject * from_ceval_BINARY_SUBSCR ( PyObject *, PyObject *);
""",
"""
static PyObject * from_ceval_BINARY_SUBSCR ( PyObject *v, PyObject *w)
{
    PyObject * x = NULL;
/*#    goto slow_get;*/
    if (PyList_CheckExact(v) && PyInt_CheckExact(w)) {
            /* INLINE: list[int] */
            Py_ssize_t i = PyInt_AS_LONG(w);
            if (i < 0)
                    i += PyList_GET_SIZE(v);
            if (i >= 0 && i < PyList_GET_SIZE(v)) {
                    x = PyList_GET_ITEM(v, i);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else if (PyTuple_CheckExact(v) && PyInt_CheckExact(w)) {
            /* INLINE: list[int] */
            Py_ssize_t i = PyInt_AS_LONG(w);
            if (i < 0)
                    i += PyTuple_GET_SIZE(v);
            if (i >= 0 && i < PyTuple_GET_SIZE(v)) {
                    x = PyTuple_GET_ITEM(v, i);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
        slow_get:
            x = PyObject_GetItem(v, w);
    return x;
}
""")   
  
Libr('c_LOAD_NAME',
"""
static PyObject * c_LOAD_NAME (PyObject *, PyObject *);
""",
"""
static PyObject * c_LOAD_NAME (PyObject *v, PyObject *w)
{
        PyObject * x, * x2;
        int l;
        if (v == 0) {
#ifndef PYPY_VERSION        
                PyErr_Format(PyExc_SystemError,
                                "no locals when loading %s",
                                PyObject_REPR(w));
#else
                PyErr_Format(PyExc_SystemError,
                                "no locals when loading");
#endif                                
                return NULL;
        }
        if (PyDict_CheckExact(v)) {
                x = PyDict_GetItem(v, w);
                Py_XINCREF(x);
        }
        else {
                x = PyObject_GetItem(v, w);
                if (x == 0 && PyErr_Occurred()) {
                        if (!PyErr_ExceptionMatches(
                                        PyExc_KeyError))
                                return NULL;
                        PyErr_Clear();
                }
        }
        if (x == 0) {

                if (PyString_CheckExact(w) && PyString_GET_SIZE(w) == 8 &&
                    !strcmp(PyString_AS_STRING(w), "__file__") ) {
                    x = PyDict_GetItem(glob, w);
                    if (x == 0) {
                            x = PyDict_GetItem(bdict, w);
                            if (x == 0) {
                                PyErr_Format(PyExc_NameError, NAME_ERROR_MSG, "__file__");
                                return NULL;
                            }
                    }
                    if (PyString_CheckExact(x) ) {
                        l = PyString_GET_SIZE(x) - 3;
                        if ( l > 0 && !strcmp(PyString_AS_STRING(x)+l, ".so")) {
                            x2 = PyString_FromStringAndSize(NULL, l+3);
                            strncpy(PyString_AS_STRING(x2), PyString_AS_STRING(x), l);
                            memcpy(PyString_AS_STRING(x2)+l, ".py", 3);
                            x = x2;
                            return x;
                        }
                    }
                    Py_INCREF(x);
                    return x;

                }
        
                x = PyDict_GetItem(glob, w);
                if (x == 0) {
                        x = PyDict_GetItem(bdict, w);
                        if (x == 0) {
                            char *obj_str;
                            obj_str = PyString_AsString(w);
                            if (obj_str != 0) {
                                PyErr_Format(PyExc_NameError, NAME_ERROR_MSG, obj_str);
                            }
                            return NULL;
                        }
                }
                Py_INCREF(x);
        }
        return x;
}
""")   

if True:  
    Libr('c_LOAD_GLOBAL',
    """
    static PyObject * c_LOAD_GLOBAL ( PyObject *, long);
    """,
    """
    static PyObject * c_LOAD_GLOBAL ( PyObject *w, long hash)
    {
            PyObject * x, * x2;
            int l;
            if (PyString_CheckExact(w) && PyString_GET_SIZE(w) == 8 &&
                !strcmp(PyString_AS_STRING(w), "__file__") ) {
                x = PyDict_GetItem(glob, w);
                if (x == 0) {
                        x = PyDict_GetItem(b, w);
                        if (x == 0) {
                            goto load_global_error;
                        }
                }
                if (PyString_CheckExact(x) ) {
                    l = PyString_GET_SIZE(x) - 3;
                    if ( l > 0 && !strcmp(PyString_AS_STRING(x)+l, ".so")) {
                        x2 = PyString_FromStringAndSize(NULL, l+3);
                        strncpy(PyString_AS_STRING(x2), PyString_AS_STRING(x), l);
                        memcpy(PyString_AS_STRING(x2)+l, ".py", 3);
                        x = x2;
                        return x;
                    }
                }
                Py_INCREF(x);
                return x;

            }
                    /* Inline the PyDict_GetItem() calls.
                        WARNING: this is an extreme speed hack.
                        Do not try this at home. */
            if (hash != -1) {
                    PyDictObject *d;
                    PyDictEntry *e;
                    d = (PyDictObject *)(glob);
                    e = d->ma_lookup(d, w, hash);
                    if (e == 0) {
                            x = NULL;
                            return NULL;
                    }
                    x = e->me_value;
                    if (x != NULL) {
                            Py_INCREF(x);
                            return x;
                    }
                    d = (PyDictObject *)(bdict);
                    e = d->ma_lookup(d, w, hash);
                    if (e == 0) {
                            x = NULL;
                            return NULL;
                    }
                    x = e->me_value;
                    if (x != NULL) {
                            Py_INCREF(x);
                            return x;
                    }
                    goto load_global_error;
            }
            /* This is the un-inlined version of the code above */
            x = PyDict_GetItem(glob, w);
            if (x == 0) {
                    x = PyDict_GetItem(b, w);
                    if (x == 0) {
                        load_global_error:
                            PyErr_Format(PyExc_NameError, GLOBAL_NAME_ERROR_MSG, 
                                            PyString_AsString(w));
                            return NULL;
                    }
            }
            Py_INCREF(x);
            return x;
    }
    """)   
else:
    Libr('c_LOAD_GLOBAL',
    """
    static PyObject * c_LOAD_GLOBAL ( PyObject *, long);
    """,
    """
    static PyObject * c_LOAD_GLOBAL ( PyObject *w, long hash)
    {
            PyObject * x;
            /* This is the un-inlined version of the code above */
            x = PyDict_GetItem(glob, w);
            if (x == 0) {
                    x = PyDict_GetItem(b, w);
                    if (x == 0) {
                            PyErr_Format(PyExc_NameError, GLOBAL_NAME_ERROR_MSG, 
                                            PyString_AsString(w));
                            return NULL;
                    }
            }
            Py_INCREF(x);
            return x;
    }
    """)  

Libr('c_BINARY_SUBSCR_2_Int',
"""
static PyObject * c_BINARY_SUBSCR_2_Int(PyObject *, Py_ssize_t, Py_ssize_t);
""",
"""
static PyObject * c_BINARY_SUBSCR_2_Int(PyObject *v, Py_ssize_t i1, Py_ssize_t i2)
{
    int decref = 0;
    PyObject * x = NULL;
    PyObject * x0 = NULL;
    PyObject * const_i1 = NULL;
    if (PyList_CheckExact(v)) {
            Py_ssize_t l = PyList_GET_SIZE(v);
            /* INLINE: list[int] */
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyList_GET_ITEM(v, i1);
                    goto next;
            }
            else
                    goto slow_get;
    }
    else if (PyTuple_CheckExact(v)) {
            Py_ssize_t l = PyTuple_GET_SIZE(v);
            /* INLINE: list[int] */
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyTuple_GET_ITEM(v, i1);
                    goto next;
            }
            else
                    goto slow_get;
    }
    else
        slow_get:
            decref = 1;
            const_i1 = PyInt_FromLong(i1);
            x = PyObject_GetItem(v, const_i1);
            Py_CLEAR(const_i1);
    next:        
    x0 = x;
    v = x;        
    if (v == 0) return v;
    if (PyList_CheckExact(v)) {
            Py_ssize_t l = PyList_GET_SIZE(v);
            /* INLINE: list[int] */
            if (i2 < 0)
                    i2 += l;
            if (i2 >= 0 && i2 < l) {
                    x = PyList_GET_ITEM(v, i2);
                    Py_INCREF(x);
                    if (decref) Py_DECREF(x0);
                    return x;
            }
            else
                    goto slow_get2;
    }
    else if (PyTuple_CheckExact(v)) {
            Py_ssize_t l = PyTuple_GET_SIZE(v);
            /* INLINE: list[int] */
            if (i2 < 0)
                    i2 += l;
            if (i2 >= 0 && i2 < l) {
                    x = PyTuple_GET_ITEM(v, i2);
                    Py_INCREF(x);
                    if (decref) Py_DECREF(x0);
                    return x;
            }
            else
                    goto slow_get2;
    }
    else
        slow_get2:
            const_i1 = PyInt_FromLong(i2);
            x = PyObject_GetItem(v, const_i1);
            Py_CLEAR(const_i1);

    if (decref) Py_DECREF(x0);
    return x;
}
""")   


Libr('c_SUBSCR_INTS',
"""
static PyObject * c_SUBSCR_INTS(PyObject *, unsigned int);
""",
"""
static PyObject * c_SUBSCR_INTS(PyObject *v, unsigned int i)
{
    int decref;
    int decrefprev;
    PyObject * x = NULL;
    PyObject * ind = NULL;
    decrefprev = 0;
    while (i) {
        i1 = i % 100;
        i /= 100;
        decref = 0;
        if (PyList_CheckExact(v)) {
                Py_ssize_t l = PyList_GET_SIZE(v);
                /* INLINE: list[int] */
                if (i1 > 49) i1 = l-(i1 - 50);

                if (i1 >= 0 && i1 < l) {
                        x = PyList_GET_ITEM(v, i1);
                        goto next;
                }
                else
                        goto slow_get;
        }
        else if (PyTuple_CheckExact(v)) {
                Py_ssize_t l = PyTuple_GET_SIZE(v);
                /* INLINE: list[int] */
                if (i1 > 49) i1 = l-(i1 - 50);
                if (i1 >= 0 && i1 < l) {
                        x = PyTuple_GET_ITEM(v, i1);
                        goto next;
                }
                else
                        goto slow_get;
        }
        else
            slow_get:
                decref = 1;
                if (i1 > 49) i1 = -(i1 - 50);
                ind = PyInt_FromLong(i1);
                x = PyObject_GetItem(v, ind);
                Py_CLEAR(ind);
        if (decrefprev) Py_CLEAR(v);
        decrefprev = decref;
        v = x;
    }
    return x;
}
""")   

  
Libr('__c_BINARY_SUBSCR_Int',
"""
static PyObject * __c_BINARY_SUBSCR_Int(PyObject *, Py_ssize_t);
""",
"""
static PyObject * __c_BINARY_SUBSCR_Int(PyObject *v, Py_ssize_t i1)
{
    PyObject *const_i1 = NULL;
    PyObject * x = NULL;
    if (PyList_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyList_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyList_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else if (PyTuple_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyTuple_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyTuple_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else
        slow_get:
            const_i1 = PyInt_FromLong (i1);
            x = PyObject_GetItem(v, const_i1);
            Py_CLEAR(const_i1);
    return x;
}
""")   

Libr('_c_BINARY_SUBSCR_Int',
"""
static PyObject * _c_BINARY_SUBSCR_Int(PyObject *, Py_ssize_t, PyObject *);
""",
"""
static PyObject * _c_BINARY_SUBSCR_Int(PyObject *v, Py_ssize_t i1, PyObject *const_i1)
{
    PyObject * x = NULL;
    assert(v != 0);
    assert(const_i1 != 0);
    if (PyList_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyList_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyList_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else if (PyTuple_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyTuple_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyTuple_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else if (PyString_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyString_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyString_FromStringAndSize( PyString_AS_STRING ( v ) + i1 , 1);
                    return x;
            }
            else
                    goto slow_get;
    }
    else
        slow_get:
            x = PyObject_GetItem(v, const_i1);
    return x;
}
""")   


Libr('___c_BINARY_SUBSCR_Int',
"""
static PyObject * ___c_BINARY_SUBSCR_Int(PyObject *, Py_ssize_t);
""",
"""
static PyObject * ___c_BINARY_SUBSCR_Int(PyObject *v, Py_ssize_t i1)
{
    PyObject *const_i1 = NULL;
    PyObject * x = NULL;
    if (PyList_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyList_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyList_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else if (PyTuple_CheckExact(v)) {
            Py_ssize_t l;
            /* INLINE: list[int] */
            l = PyTuple_GET_SIZE(v);
            if (i1 < 0)
                    i1 += l;
            if (i1 >= 0 && i1 < l) {
                    x = PyTuple_GET_ITEM(v, i1);
                    Py_INCREF(x);
                    return x;
            }
            else
                    goto slow_get;
    }
    else
        slow_get:
            const_i1 = PyInt_FromLong (i1);
            Py_INCREF(v);
            x = PyObject_GetItem(v, const_i1);
            Py_DECREF(v);
            Py_DECREF(const_i1);
    return x;
}
""")   
if not is_code_ext:
    Libr('PY2C_GENERATOR',
"""
#define PY2C_GENERATOR
""",
"""
""", ('Py2CGen_New',))      

if not is_code_ext:
    Libr('Py2CGen_New',
"""
PyObject * Py2CGen_New(PyFrameObject *);
""",
"""
PyObject *
Py2CGen_New(PyFrameObject *f)
{
    PyGenObject *gen = PyObject_GC_New(PyGenObject, &Py2CGen_Type);
    if (gen == NULL) {
        Py_DECREF(f);
        return NULL;
    }
    gen->gi_frame = f;
    Py_INCREF(f->f_code);
    gen->gi_code = (PyObject *)(f->f_code);
    gen->gi_running = 0;
    gen->gi_weakreflist = NULL;
    _PyObject_GC_TRACK(gen);
    return (PyObject *)gen;
}
""", ('Py2CGen_Type',))      
   
if is_code_ext:
    Libr('Py2CFunction_New',
"""
#define Py2CFunction_New(a) PyFunction_New(a, glob)
""", '')
elif True:  
    Libr('Py2CFunction_New',
"""
static PyObject * Py2CFunction_New_(PyObject *, PyObject *);
#define Py2CFunction_New(a) Py2CFunction_New_(a, module)
""",
"""
static PyObject * Py2CFunction_New_(PyObject *code, PyObject *module)
{
	PyFunctionObject *op = PyObject_GC_New(PyFunctionObject,
					    &Py2CFunction_Type);
	if (op != NULL) {
		PyObject *doc;
		PyObject *consts;

		op->func_weakreflist = NULL;
		Py_INCREF(code);
		op->func_code = code;
		Py_INCREF(glob);
		op->func_globals = glob;
		op->func_name = ((PyCodeObject *)code)->co_name;
		Py_INCREF(op->func_name);
		op->func_defaults = NULL; /* No default arguments */
		op->func_closure = NULL;
		consts = ((PyCodeObject *)code)->co_consts;
		if (PyTuple_Size(consts) >= 1) {
			doc = PyTuple_GetItem(consts, 0);
			if (!PyString_Check(doc) && !PyUnicode_Check(doc))
				doc = Py_None;
		}
		else
			doc = Py_None;
		Py_INCREF(doc);
		op->func_doc = doc;
		op->func_dict = NULL;
                Py_INCREF(module);
                op->func_module = module;
	}
	else
		return NULL;
	PyObject_GC_Track(op);
	return (PyObject *)op;
}
""", ('module', 'Py2CFunction'))   
elif True:
    Libr('Py2CFunction_New',
"""
static PyObject * Py2CFunction_New_(PyObject *, PyObject *);
#define Py2CFunction_New(a) Py2CFunction_New_(a, module)
""",
"""
static PyObject * Py2CFunction_New_(PyObject *code, PyObject *module)
{
	PyFunctionObject *op = PyObject_GC_New(PyFunctionObject,
					    &Py2CFunction_Type);
	if (op != NULL) {
		PyObject *doc;
		PyObject *consts;

		Py_INCREF(code);
		PyObject_SetAttrString((PyObject *)op, "func_code",  code);
		Py_INCREF(glob);
                PyObject_SetAttrString((PyObject *)op, "func_globals",  glob);
		op->func_name = ((PyCodeObject *)code)->co_name;
		Py_INCREF(op->func_name);
		consts = PyObject_GetAttrString(code, "co_consts");
		if (PyTuple_Size(consts) >= 1) {
			doc = PyTuple_GetItem(consts, 0);
			if (!PyString_Check(doc) && !PyUnicode_Check(doc))
				doc = Py_None;
		}
		else
			doc = Py_None;
		Py_INCREF(doc);
		PyObject_SetAttrString((PyObject *)op, "func_doc", doc);
                Py_INCREF(module);
                PyObject_SetAttrString((PyObject *)op, "func_module", module);
	}
	else
		return NULL;
	PyObject_GC_Track(op);
	return (PyObject *)op;
}
""", ('module', 'Py2CFunction'))   
    
if is_code_ext:
    Libr('Py2CFunction_SetClosure',
"""
#define Py2CFunction_SetClosure PyFunction_SetClosure
""", '')
else:
    Libr('Py2CFunction_SetClosure',
"""
static int
Py2CFunction_SetClosure(PyObject *, PyObject *);
""",
"""
static int
Py2CFunction_SetClosure(PyObject *op, PyObject *closure)
{
	if (closure == Py_None)
		closure = NULL;
	else if (PyTuple_Check(closure)) {
		Py_INCREF(closure);
	}
	else {
		PyErr_Format(PyExc_SystemError, 
			     "expected tuple for closure, got '%.100s'",
			     closure->ob_type->tp_name);
		return -1;
	}
	Py_XDECREF(((PyFunctionObject *) op) -> func_closure);
	((PyFunctionObject *) op) -> func_closure = closure;
	return 0;
}
""")   
if is_code_ext:
    Libr('Py2CFunction_SetDefaults',
"""
#define Py2CFunction_SetDefaults PyFunction_SetDefaults
""", '')
else:  
    Libr('Py2CFunction_SetDefaults',
"""
static int
Py2CFunction_SetDefaults(PyObject *o, PyObject *);
""",
"""
static int
Py2CFunction_SetDefaults(PyObject *op, PyObject *defaults)
{
	if (defaults == Py_None)
		defaults = NULL;
	else if (defaults && PyTuple_Check(defaults)) {
		Py_INCREF(defaults);
	}
	else {
		PyErr_SetString(PyExc_SystemError, "non-tuple default args");
		return -1;
	}
	Py_XDECREF(((PyFunctionObject *) op) -> func_defaults);
	((PyFunctionObject *) op) -> func_defaults = defaults;
	return 0;
}
""")  
   
Libr('_PyEval_PRINT_ITEM_1',
"""
static int _PyEval_PRINT_ITEM_1 ( PyObject * );
""",
"""
static int _PyEval_PRINT_ITEM_1 ( PyObject * v)
{
    return _PyEval_PRINT_ITEM_TO_2 ( NULL, v );
}
""") 
    
Libr('_PyEval_PRINT_ITEM_TO_2',
"""
static int _PyEval_PRINT_ITEM_TO_2 ( PyObject * , PyObject *);
""",
"""
static int _PyEval_PRINT_ITEM_TO_2 ( PyObject * stream, PyObject * v)
{
        PyObject * w = stream; 
        int err = 0;
        if (stream == 0 || stream == Py_None) {
                w = PySys_GetObject("stdout");
                if (w == 0) {
                        PyErr_SetString(PyExc_RuntimeError,
                                        "lost sys.stdout");
                        err = -1;
                }
        }
        /* PyFile_SoftSpace() can exececute arbitrary code
            if sys.stdout is an instance with a __getattr__.
            If __getattr__ raises an exception, w will
            be freed, so we need to prevent that temporarily. */
        Py_XINCREF(w);
        if (w != NULL && PyFile_SoftSpace(w, 0))
                err = PyFile_WriteString(" ", w);
        if (err == 0)
                err = PyFile_WriteObject(v, w, Py_PRINT_RAW);
        if (err == 0) {
            /* XXX move into writeobject() ? */
            if (PyString_Check(v)) {
                char *s = PyString_AS_STRING(v);
                Py_ssize_t len = PyString_GET_SIZE(v);
                if (len == 0 ||
                    !isspace(Py_CHARMASK(s[len-1])) ||
                    s[len-1] == ' ')
                        PyFile_SoftSpace(w, 1);
            }
#ifdef Py_USING_UNICODE
            else if (PyUnicode_Check(v)) {
                Py_UNICODE *s = PyUnicode_AS_UNICODE(v);
                Py_ssize_t len = PyUnicode_GET_SIZE(v);
                if (len == 0 ||
                    !Py_UNICODE_ISSPACE(s[len-1]) ||
                    s[len-1] == ' ')
                    PyFile_SoftSpace(w, 1);
            }
#endif
            else
                    PyFile_SoftSpace(w, 1);
        }
        Py_XDECREF(w);
   /*     Py_DECREF(v); */
        if (w != stream) {
            Py_XDECREF(stream);
        }
        stream = NULL;
        return err;
}
""") 
    
Libr('_PyEval_PRINT_NEWLINE_TO_1',
"""
static int _PyEval_PRINT_NEWLINE_TO_1 ( PyObject * );
""",
"""
static int _PyEval_PRINT_NEWLINE_TO_1 ( PyObject * stream )
{
        PyObject * w = stream;
        int err = 0;
        if (stream == 0 || stream == Py_None) {
                w = PySys_GetObject("stdout");
                if (w == 0) {
                        PyErr_SetString(PyExc_RuntimeError,
                                        "lost sys.stdout");
                        return -1;
                }                    
        }
        if (w != NULL) {
                /* w.write() may replace sys.stdout, so we
                    * have to keep our reference to it */
                Py_INCREF(w);
                err = PyFile_WriteString("\\n", w);
                if (err == 0)
                        PyFile_SoftSpace(w, 0);                        
                Py_DECREF(w);
        }
        if (w != stream) {
            Py_XDECREF(stream);
        }
        stream = NULL;
        return err;
}
""") 
    
Libr('_PyEval_set_exc_info',
"""
static void _PyEval_set_exc_info(PyThreadState * tstate, PyObject *type, PyObject *value, PyObject *tb);
""",
"""
static void _PyEval_set_exc_info(PyThreadState * tstate, PyObject *type, PyObject *value, PyObject *tb){
#ifndef PYPY_VERSION
	PyFrameObject *frame = tstate->frame;
	PyObject *tmp_type, *tmp_value, *tmp_tb;

	assert(type != NULL);
	if (frame != NULL && frame->f_exc_type == 0) {
		assert(frame->f_exc_value == 0);
		assert(frame->f_exc_traceback == 0);
		/* This frame didn't catch an exception before. */
		/* Save previous exception of this thread in this frame. */
		if (tstate->exc_type == 0) {
			/* XXX Why is this set to Py_None? */
			Py_INCREF(Py_None);
			tstate->exc_type = Py_None;
		}
		Py_INCREF(tstate->exc_type);
		Py_XINCREF(tstate->exc_value);
		Py_XINCREF(tstate->exc_traceback);
		frame->f_exc_type = tstate->exc_type;
		frame->f_exc_value = tstate->exc_value;
		frame->f_exc_traceback = tstate->exc_traceback;
	}
	/* Set new exception for this thread. */
	tmp_type = tstate->exc_type;
	tmp_value = tstate->exc_value;
	tmp_tb = tstate->exc_traceback;
	Py_INCREF(type);
	Py_XINCREF(value);
	Py_XINCREF(tb);
	tstate->exc_type = type;
	tstate->exc_value = value;
	tstate->exc_traceback = tb;
	Py_XDECREF(tmp_type);
	Py_XDECREF(tmp_value);
	Py_XDECREF(tmp_tb);
	/* For b/w compatibility */
	PySys_SetObject("exc_type", type);
	PySys_SetObject("exc_value", value);
	PySys_SetObject("exc_traceback", tb);
#else
        PyErr_SetExcInfo(type, value, tb);
#endif
}
""")

if True:
    Libr('_PyEval_reset_exc_info',
"""
static void _PyEval_reset_exc_info(PyThreadState *);
""",
"""
static void _PyEval_reset_exc_info(PyThreadState * tstate){
	PyFrameObject *frame;
	PyObject *tmp_type, *tmp_value, *tmp_tb;

	/* It's a precondition that the thread state's frame caught an
	 * exception -- verify in a debug build.
	 */
	assert(tstate != NULL);
	frame = tstate->frame;
	assert(frame != NULL);
	assert(frame->f_exc_type != NULL);

	/* Copy the frame's exception info back to the thread state. */
	tmp_type = tstate->exc_type;
	tmp_value = tstate->exc_value;
	tmp_tb = tstate->exc_traceback;
	Py_INCREF(frame->f_exc_type);
	Py_XINCREF(frame->f_exc_value);
	Py_XINCREF(frame->f_exc_traceback);
	tstate->exc_type = frame->f_exc_type;
	tstate->exc_value = frame->f_exc_value;
	tstate->exc_traceback = frame->f_exc_traceback;
	Py_XDECREF(tmp_type);
	Py_XDECREF(tmp_value);
	Py_XDECREF(tmp_tb);

	/* For b/w compatibility */
	PySys_SetObject("exc_type", frame->f_exc_type);
	PySys_SetObject("exc_value", frame->f_exc_value);
	PySys_SetObject("exc_traceback", frame->f_exc_traceback);

	/* Clear the frame's exception info. */
	tmp_type = frame->f_exc_type;
	tmp_value = frame->f_exc_value;
	tmp_tb = frame->f_exc_traceback;
	frame->f_exc_type = NULL;
	frame->f_exc_value = NULL;
	frame->f_exc_traceback = NULL;
	Py_DECREF(tmp_type);
	Py_XDECREF(tmp_value);
	Py_XDECREF(tmp_tb);
}
""")
else:
    Libr('_PyEval_reset_exc_info',
"""
static void _PyEval_reset_exc_info(PyThreadState *);
""",
"""
static void _PyEval_reset_exc_info(PyThreadState * tstate){
return;
}
""")
       
Libr('_PyEval_ApplySlice',
"""
static PyObject *
_PyEval_ApplySlice(PyObject *, PyObject *, PyObject *);
""",
"""
static PyObject *
_PyEval_ApplySlice(PyObject *u, PyObject *v, PyObject *w) /* return u[v:w] */
{
	PyTypeObject *tp = u->ob_type;
	PySequenceMethods *sq = tp->tp_as_sequence;

	if (sq && sq->sq_slice && ISINDEX(v) && ISINDEX(w)) {
		Py_ssize_t ilow = 0, ihigh = PY_SSIZE_T_MAX;
		if (!_PyEval_SliceIndex(v, &ilow))
			return NULL;
		if (!_PyEval_SliceIndex(w, &ihigh))
			return NULL;
		return PySequence_GetSlice(u, ilow, ihigh);
	}
	else {
		PyObject *slice = PySlice_New(v, w, NULL);
		if (slice != NULL) {
			PyObject *res = PyObject_GetItem(u, slice);
			Py_DECREF(slice);
			return res;
		}
		else
			return NULL;
	}
}
""")     

Libr('_PyEval_AssignSlice',
"""
static int
_PyEval_AssignSlice(PyObject *, PyObject *, PyObject *, PyObject *);
""",
"""
static int
_PyEval_AssignSlice(PyObject *u, PyObject *v, PyObject *w, PyObject *x)
	/* u[v:w] = x */
{
	PyTypeObject *tp = u->ob_type;
	PySequenceMethods *sq = tp->tp_as_sequence;

	if (sq && sq->sq_ass_slice && ISINDEX(v) && ISINDEX(w)) {
		Py_ssize_t ilow = 0, ihigh = PY_SSIZE_T_MAX;
		if (!_PyEval_SliceIndex(v, &ilow))
			return -1;
		if (!_PyEval_SliceIndex(w, &ihigh))
			return -1;
		if (x == 0)
			return PySequence_DelSlice(u, ilow, ihigh);
		else
			return PySequence_SetSlice(u, ilow, ihigh, x);
	}
	else {
		PyObject *slice = PySlice_New(v, w, NULL);
		if (slice != NULL) {
			int res;
			if (x != NULL)
				res = PyObject_SetItem(u, slice, x);
			else
				res = PyObject_DelItem(u, slice);
			Py_DECREF(slice);
			return res;
		}
		else
			return -1;
	}
}
""")

Libr('_Call_CompiledWithFrame',
"""
static PyObject * _Call_CompiledWithFrame(void *, PyObject *, int, ...);
""",
"""
static PyObject * _Call_CompiledWithFrame(void * func, PyObject *_co, int cnt_arg, ...)
{
        PyCodeObject *co = (PyCodeObject *)_co;
        PyFrameObject *f;
        PyObject *retval = NULL;
        PyThreadState * tstate = PyThreadState_GET();
        PyObject **fastlocals;
        PyObject *o;
        int i;
        PyObject *(*c_func)(PyFrameObject *);
        va_list vargs;
        va_start(vargs, cnt_arg);
		/* XXX Perhaps we should create a specialized
		   PyFrame_New() that doesn't take locals, but does
		   take builtins without sanity checking them.
		*/
        assert(tstate != NULL);
        f = PyFrame_New(tstate, co, glob, NULL);
        if (f == 0)
                return NULL;

        fastlocals = f->f_localsplus;
        
        for (i = 0; i < cnt_arg; i++) {
                o = va_arg(vargs, PyObject *);
                Py_INCREF(o);
                fastlocals[i] = o;
        }
        va_end(vargs);
        c_func = func;
        retval = c_func(f);
#ifndef PYPY_VERSION
	++tstate->recursion_depth;
#endif
        Py_DECREF(f);
#ifndef PYPY_VERSION
	--tstate->recursion_depth;
#endif
        return retval;
}
""")

if is_code_ext:
    Libr('FastCall',
"""
static PyObject * FastCall(int, PyObject *, ...);
""",
"""
static PyObject * FastCall(int na, PyObject *v,...)
{
    typedef PyObject * pyref;
    pyref args[18];
    pyref * r_arg;
    PyObject *func;
    int i;
    va_list vargs;
//    r_arg = args+1;
//    printf ("=fastcall\\n");
    func = v;    
    Py_INCREF(func);

    va_start(vargs, v);
    args[0] = NULL;
    for (i = 0; i < na; i++) 
        args[i+1] = va_arg(vargs, PyObject *);
    va_end(vargs);
    r_arg = args+1;
            
    if (PyCFunction_Check(func)) {
        int flags = PyCFunction_GET_FLAGS(func);
        PyObject *x;
    
//        printf ("=cfunc 1\\n");
        if (flags & (METH_NOARGS | METH_O)) {
            PyCFunction meth = PyCFunction_GET_FUNCTION(func);
            PyObject *self = PyCFunction_GET_SELF(func);
            if (flags & METH_NOARGS && na == 0) {
                x = (*meth)(self,NULL);
                Py_DECREF(func);
                return x;
            }
            else if (flags & METH_O && na == 1) {
                Py_INCREF(args[1]);                           
                x = (*meth)(self,args[1]);
                Py_DECREF(args[1]);
                Py_DECREF(func);
                return x;
            } else
            goto stand_c;
        }
        else {  stand_c: 
            { 
                PyObject *callargs = PyTuple_New(na);
                for (i = 0; i < na; i++) {
                    Py_INCREF(args[i+1]);
                    PyTuple_SET_ITEM(callargs, i, args[i+1]);
                }
                x = PyCFunction_Call(func,callargs,NULL);
                Py_XDECREF(callargs);
                Py_DECREF(func);
                return x;
            }        
        }
    } 
    if (PyMethod_Check(func) && PyMethod_GET_SELF(func) != NULL) {
        PyObject *oldfunc = func;
        args[0] = PyMethod_GET_SELF(func);
        func = PyMethod_GET_FUNCTION(func);
        Py_INCREF(func);
        Py_DECREF(oldfunc);
        na++;
//        printf ("=meth 1\\n");
        r_arg = args;
    } // else {
      //  Py_INCREF(func);  
    //}

    if (PyFunction_Check(func)) {
        if (((PyCodeObject *)PyFunction_GET_CODE(func))->co_cfunc != 0 && !(((PyCodeObject *)PyFunction_GET_CODE(func))->co_flags & CO_GENERATOR) ) {
            Py2CCodeObject *co = (Py2CCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            PyObject *(*c_func)(PyFrameObject *);
            int nd = 0;

    //        printf ("=2Cfunc 1\\n");
            if (argdefs == 0 && co->co_argcount == na && co->co_cfunc != 0 &&
                    co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState * tstate = PyThreadState_GET();
                PyObject **fastlocals;
                int i;

                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0) {
                    return NULL;
                }

                fastlocals = f->f_localsplus;
                for (i = 0; i < na; i++) {
                    Py_INCREF(r_arg[i]);
                    fastlocals[i] = r_arg[i];
                }
                c_func = co->co_cfunc;
                retval = c_func(f);
                ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_EvalCodeEx((PyCodeObject *)co, globals,
                                    (PyObject *)NULL, r_arg, na,
                                    NULL, 0, d, nd
                                    ,
                                    PyFunction_GET_CLOSURE(func));
    } else {
        PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
        PyObject *globals = PyFunction_GET_GLOBALS(func);
        PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
        PyObject **d = NULL;
        int nd = 0;

//        printf ("=Func 1\\n");
        if (argdefs == 0 && co->co_argcount == na && 
                co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
            PyFrameObject *f;
            PyObject *retval = NULL;
            PyThreadState * tstate = PyThreadState_GET();
            PyObject **fastlocals;
            int i;

            assert(globals != NULL);
            assert(tstate != NULL);
            f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
            if (f == 0)
                return NULL;

            fastlocals = f->f_localsplus;
            for (i = 0; i < na; i++) {
                Py_INCREF(r_arg[i]);
                fastlocals[i] = r_arg[i];
            }
            retval = PyEval_EvalFrameEx(f,0);
	    ++tstate->recursion_depth;
            Py_DECREF(f);
            --tstate->recursion_depth;
            Py_DECREF(func);
            return retval;
        }
        if (argdefs != NULL) {
            d = &PyTuple_GET_ITEM(argdefs, 0);
            nd = Py_SIZE(argdefs);
        }
        Py_DECREF(func);
        return PyEval_EvalCodeEx(co, globals,
                                (PyObject *)NULL, r_arg, na,
                                NULL, 0, d, nd,
                                PyFunction_GET_CLOSURE(func));
    }
    } else {
//        printf ("=others 1\\n");
        PyObject *callargs = PyTuple_New(na);
        PyObject *x;
        for (i = 0; i < na; i++) {
            Py_INCREF(r_arg[i]);
            PyTuple_SET_ITEM(callargs, i, r_arg[i]);
        }
        x = PyObject_Call(func,callargs,NULL);
        Py_XDECREF(callargs);
        Py_DECREF(func);
        return x;
    }
}
""")

else:
    Libr('FastCall',
"""
static PyObject * FastCall(int, PyObject *, ...);
""",
"""
static PyObject * FastCall(int na, PyObject *v,...)
{
    typedef PyObject * pyref;
    pyref args[18];
    pyref * r_arg;
    PyObject *func;
    int i;
    va_list vargs;
//    r_arg = args+1;
//    printf ("=fastcall\\n");
    func = v;    
    Py_INCREF(func);

    va_start(vargs, v);
    args[0] = NULL;
    for (i = 0; i < na; i++) 
        args[i+1] = va_arg(vargs, PyObject *);
    va_end(vargs);
    r_arg = args+1;
            
    if (PyCFunction_Check(func)) {
        int flags = PyCFunction_GET_FLAGS(func);
        PyObject *x;
    
//        printf ("=cfunc 1\\n");
        if (flags & (METH_NOARGS | METH_O)) {
            PyCFunction meth = PyCFunction_GET_FUNCTION(func);
            PyObject *self = PyCFunction_GET_SELF(func);
            if (flags & METH_NOARGS && na == 0) {
                x = (*meth)(self,NULL);
                Py_DECREF(func);
                return x;
            }
            else if (flags & METH_O && na == 1) {
                Py_INCREF(args[1]);                           
                x = (*meth)(self,args[1]);
                Py_DECREF(args[1]);
                Py_DECREF(func);
                return x;
            } else
            goto stand_c;
        }
        else {  stand_c: 
            { 
                PyObject *callargs = PyTuple_New(na);
                for (i = 0; i < na; i++) {
                    Py_INCREF(args[i+1]);
                    PyTuple_SET_ITEM(callargs, i, args[i+1]);
                }
                x = PyCFunction_Call(func,callargs,NULL);
                Py_XDECREF(callargs);
                Py_DECREF(func);
                return x;
            }        
        }
    } 
    if (PyMethod_Check(func) && PyMethod_GET_SELF(func) != NULL) {
        PyObject *oldfunc = func;
        args[0] = PyMethod_GET_SELF(func);
        func = PyMethod_GET_FUNCTION(func);
        Py_INCREF(func);
        Py_DECREF(oldfunc);
        na++;
//        printf ("=meth 1\\n");
        r_arg = args;
    } // else {
      //  Py_INCREF(func);  
    //}

#ifdef Py2CFunction_Check
    if (Py2CFunction_Check(func) && !(((PyCodeObject *)PyFunction_GET_CODE(func))->co_flags & CO_GENERATOR) ) {
        Py2CCodeObject *co = (Py2CCodeObject *)PyFunction_GET_CODE(func);
        PyObject *globals = PyFunction_GET_GLOBALS(func);
        PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
        PyObject **d = NULL;
        PyObject *(*c_func)(PyFrameObject *);
        int nd = 0;

//        printf ("=2Cfunc 1\\n");
        if (argdefs == 0 && co->_body.co_argcount == na && 
                co->_body.co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
            PyFrameObject *f;
            PyObject *retval = NULL;
            PyThreadState * tstate = PyThreadState_GET();
            PyObject **fastlocals;
            int i;

            assert(globals != NULL);
            assert(tstate != NULL);
            f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
            if (f == 0) {
                return NULL;
            }

            fastlocals = f->f_localsplus;
            for (i = 0; i < na; i++) {
                Py_INCREF(r_arg[i]);
                fastlocals[i] = r_arg[i];
            }
            c_func = co->co_cfunc;
            retval = c_func(f);
#ifndef PYPY_VERSION
	    ++tstate->recursion_depth;
#endif
            Py_DECREF(f);
#ifndef PYPY_VERSION
            --tstate->recursion_depth;
#endif
            Py_DECREF(func);
            return retval;
        }
        if (argdefs != NULL) {
            d = &PyTuple_GET_ITEM(argdefs, 0);
            nd = Py_SIZE(argdefs);
        }
        Py_DECREF(func);
        return PyEval_Eval2CCodeEx((PyCodeObject *)co,
                                (PyObject *)NULL, r_arg, na,
                                NULL, 0, d, nd
#ifndef PYPY_VERSION
                                ,
                                PyFunction_GET_CLOSURE(func));
#else
                                );
#endif
    }
    else 
#endif
    
    if (PyFunction_Check(func)) {
        PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
        PyObject *globals = PyFunction_GET_GLOBALS(func);
        PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
        PyObject **d = NULL;
        int nd = 0;

//        printf ("=Func 1\\n");
        if (argdefs == 0 && co->co_argcount == na && 
                co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
            PyFrameObject *f;
            PyObject *retval = NULL;
            PyThreadState * tstate = PyThreadState_GET();
            PyObject **fastlocals;
            int i;

            assert(globals != NULL);
            assert(tstate != NULL);
            f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
            if (f == 0)
                return NULL;

            fastlocals = f->f_localsplus;
            for (i = 0; i < na; i++) {
                Py_INCREF(r_arg[i]);
                fastlocals[i] = r_arg[i];
            }
            retval = PyEval_EvalFrameEx(f,0);
#ifndef PYPY_VERSION
	    ++tstate->recursion_depth;
#endif
            Py_DECREF(f);
#ifndef PYPY_VERSION
            --tstate->recursion_depth;
#endif
            Py_DECREF(func);
            return retval;
        }
        if (argdefs != NULL) {
            d = &PyTuple_GET_ITEM(argdefs, 0);
            nd = Py_SIZE(argdefs);
        }
        Py_DECREF(func);
        return PyEval_EvalCodeEx(co, globals,
                                (PyObject *)NULL, r_arg, na,
                                NULL, 0, d, nd,
                                PyFunction_GET_CLOSURE(func));
    } else {
//        printf ("=others 1\\n");
        PyObject *callargs = PyTuple_New(na);
        PyObject *x;
        for (i = 0; i < na; i++) {
            Py_INCREF(r_arg[i]);
            PyTuple_SET_ITEM(callargs, i, r_arg[i]);
        }
        x = PyObject_Call(func,callargs,NULL);
        Py_XDECREF(callargs);
        Py_DECREF(func);
        return x;
    }
}
""")

if True:
    if is_code_ext:
        Libr('FastCall0',
"""
static PyObject * FastCall0(PyObject *);
""",
"""
static PyObject * FastCall0(PyObject *v)
{
    PyObject *func;
    PyObject *self = NULL;

    func = v;    
    Py_INCREF(func);
            
    if (PyCFunction_Check(func)) {
        int flags = PyCFunction_GET_FLAGS(func);
        PyObject *self = PyCFunction_GET_SELF(func);
        PyObject *x;
    
        if (flags & METH_NOARGS) {
            PyCFunction meth = PyCFunction_GET_FUNCTION(func);
            x = (*meth)(self,NULL);
        }
        else { 
            Py_INCREF(empty_tuple);
            x = PyCFunction_Call(func,empty_tuple,NULL);
            Py_DECREF(empty_tuple);
        }
        Py_DECREF(func);
        return x;
    } 
    if (PyMethod_Check(func) && PyMethod_GET_SELF(func) != NULL) {
        PyObject *oldfunc = func;
        self = PyMethod_GET_SELF(func);
        func = PyMethod_GET_FUNCTION(func);
        Py_INCREF(func);
        Py_DECREF(oldfunc);

#ifdef Py2CFunction_Check
        if (Py2CFunction_Check(func) && !(((PyCodeObject *)PyFunction_GET_CODE(func))->co_flags & CO_GENERATOR)) {
            Py2CCodeObject *co = (Py2CCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            PyObject *(*c_func)(PyFrameObject *);
            int nd = 0;
    
            if (argdefs == 0 && co->co_argcount == 1 && 
                    co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState * tstate = PyThreadState_GET();
                PyObject **fastlocals;
    
                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0) {
                    return NULL;
                }
    
                fastlocals = f->f_localsplus;
                Py_INCREF(self);
                fastlocals[0] = self;
                c_func = co->co_cfunc;
                retval = c_func(f);
	        ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_Eval2CCodeEx((PyCodeObject *)co,
                                    (PyObject *)NULL, &self, 1,
                                    NULL, 0, d, nd
#ifndef PYPY_VERSION
                                    ,
                                    PyFunction_GET_CLOSURE(func));
#else
                                    );
#endif
        }
        else 
#endif
        
        if (PyFunction_Check(func)) {
            PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            int nd = 0;
    
            if (argdefs == 0 && co->co_argcount == 1 && 
                    co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState * tstate = PyThreadState_GET();
                PyObject **fastlocals;
    
                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0)
                    return NULL;
    
                fastlocals = f->f_localsplus;
                Py_INCREF(self);
                fastlocals[0] = self;
    
                retval = PyEval_EvalFrameEx(f,0);
	        ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_EvalCodeEx(co, globals,
                                    (PyObject *)NULL, &self, 1,
                                    NULL, 0, d, nd,
                                    PyFunction_GET_CLOSURE(func));
        } else {
            PyObject *callargs = PyTuple_Pack(1, self);
            PyObject *x;
            x = PyObject_Call(func,callargs,NULL);
            Py_XDECREF(callargs);
            Py_DECREF(func);
            return x;
        }

    } else {

#ifdef Py2CFunction_Check
        if (Py2CFunction_Check(func) && !(((PyCodeObject *)PyFunction_GET_CODE(func))->co_flags & CO_GENERATOR)) {
            Py2CCodeObject *co = (Py2CCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            PyObject *(*c_func)(PyFrameObject *);
            int nd = 0;
    
            if (argdefs == 0 && co->co_argcount == 0 && co->co_cfunc != 0 &&
                    co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState * tstate = PyThreadState_GET();
    
                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0) {
                    return NULL;
                }
                c_func = co->co_cfunc;
                retval = c_func(f);
	        ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_EvalCodeEx(co, globals,
                                    (PyObject *)NULL, NULL, 0,
                                    NULL, 0, d, nd
#ifndef PYPY_VERSION
                                    ,
                                    PyFunction_GET_CLOSURE(func));
#else
                                    );
#endif
        }
        else 
#endif 

        if (PyFunction_Check(func)) {
            PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            int nd = 0;
    
            if (argdefs == 0 && co->co_argcount == 0 && 
                    co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState * tstate = PyThreadState_GET();
    
                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0)
                    return NULL;
    
                retval = PyEval_EvalFrameEx(f,0);
	        ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_EvalCodeEx(co, globals,
                                    (PyObject *)NULL, NULL, 0,
                                    NULL, 0, d, nd,
                                    PyFunction_GET_CLOSURE(func));
        } else {
            PyObject *x;
            x = PyObject_Call(func,empty_tuple,NULL);
            Py_DECREF(func);
            return x;
        }
    } 
}
""")
    else:
        Libr('FastCall0',
"""
static PyObject * FastCall0(PyObject *);
""",
"""
static PyObject * FastCall0(PyObject *v)
{
    PyObject *func;
    PyObject *self = NULL;

    func = v;    
    Py_INCREF(func);
            
    if (PyCFunction_Check(func)) {
        int flags = PyCFunction_GET_FLAGS(func);
        PyObject *self = PyCFunction_GET_SELF(func);
        PyObject *x;
    
        if (flags & METH_NOARGS) {
            PyCFunction meth = PyCFunction_GET_FUNCTION(func);
            x = (*meth)(self,NULL);
        }
        else { 
            Py_INCREF(empty_tuple);
            x = PyCFunction_Call(func,empty_tuple,NULL);
            Py_DECREF(empty_tuple);
        }
        Py_DECREF(func);
        return x;
    } 
    if (PyMethod_Check(func) && PyMethod_GET_SELF(func) != NULL) {
        PyObject *oldfunc = func;
        self = PyMethod_GET_SELF(func);
        func = PyMethod_GET_FUNCTION(func);
        Py_INCREF(func);
        Py_DECREF(oldfunc);

#ifdef Py2CFunction_Check
        if (Py2CFunction_Check(func) && !(((PyCodeObject *)PyFunction_GET_CODE(func))->co_flags & CO_GENERATOR)) {
            Py2CCodeObject *co = (Py2CCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            PyObject *(*c_func)(PyFrameObject *);
            int nd = 0;
    
            if (argdefs == 0 && co->_body.co_argcount == 1 && 
                    co->_body.co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState * tstate = PyThreadState_GET();
                PyObject **fastlocals;
    
                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0) {
                    return NULL;
                }
    
                fastlocals = f->f_localsplus;
                Py_INCREF(self);
                fastlocals[0] = self;
                c_func = co->co_cfunc;
                retval = c_func(f);
	        ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_Eval2CCodeEx((PyCodeObject *)co,
                                    (PyObject *)NULL, &self, 1,
                                    NULL, 0, d, nd
#ifndef PYPY_VERSION
                                    ,
                                    PyFunction_GET_CLOSURE(func));
#else
                                    );
#endif
        }
        else 
#endif
        
        if (PyFunction_Check(func)) {
            PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            int nd = 0;
    
            if (argdefs == 0 && co->co_argcount == 1 && 
                    co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState * tstate = PyThreadState_GET();
                PyObject **fastlocals;
    
                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0)
                    return NULL;
    
                fastlocals = f->f_localsplus;
                Py_INCREF(self);
                fastlocals[0] = self;
    
                retval = PyEval_EvalFrameEx(f,0);
	        ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_EvalCodeEx(co, globals,
                                    (PyObject *)NULL, &self, 1,
                                    NULL, 0, d, nd,
                                    PyFunction_GET_CLOSURE(func));
        } else {
            PyObject *callargs = PyTuple_Pack(1, self);
            PyObject *x;
            x = PyObject_Call(func,callargs,NULL);
            Py_XDECREF(callargs);
            Py_DECREF(func);
            return x;
        }

    } else {

#ifdef Py2CFunction_Check
        if (Py2CFunction_Check(func) && !(((PyCodeObject *)PyFunction_GET_CODE(func))->co_flags & CO_GENERATOR)) {
            Py2CCodeObject *co = (Py2CCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            PyObject *(*c_func)(PyFrameObject *);
            int nd = 0;
    
            if (argdefs == 0 && co->_body.co_argcount == 0 && 
                    co->_body.co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState * tstate = PyThreadState_GET();
    
                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0) {
                    return NULL;
                }
                c_func = co->co_cfunc;
                retval = c_func(f);
	        ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_Eval2CCodeEx((PyCodeObject *)co,
                                    (PyObject *)NULL, NULL, 0,
                                    NULL, 0, d, nd
#ifndef PYPY_VERSION
                                    ,
                                    PyFunction_GET_CLOSURE(func));
#else
                                    );
#endif
        }
        else 
#endif 

        if (PyFunction_Check(func)) {
            PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
            PyObject *globals = PyFunction_GET_GLOBALS(func);
            PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
            PyObject **d = NULL;
            int nd = 0;
    
            if (argdefs == 0 && co->co_argcount == 0 && 
                    co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
                PyFrameObject *f;
                PyObject *retval = NULL;
                PyThreadState * tstate = PyThreadState_GET();
    
                assert(globals != NULL);
                assert(tstate != NULL);
                f = PyFrame_New(tstate, (PyCodeObject *)co, globals, NULL);
                if (f == 0)
                    return NULL;
    
                retval = PyEval_EvalFrameEx(f,0);
	        ++tstate->recursion_depth;
                Py_DECREF(f);
                --tstate->recursion_depth;
                Py_DECREF(func);
                return retval;
            }
            if (argdefs != NULL) {
                d = &PyTuple_GET_ITEM(argdefs, 0);
                nd = Py_SIZE(argdefs);
            }
            Py_DECREF(func);
            return PyEval_EvalCodeEx(co, globals,
                                    (PyObject *)NULL, NULL, 0,
                                    NULL, 0, d, nd,
                                    PyFunction_GET_CLOSURE(func));
        } else {
            PyObject *x;
            x = PyObject_Call(func,empty_tuple,NULL);
            Py_DECREF(func);
            return x;
        }
    } 
}
""")
else:
    Libr('FastCall0',
"""
#define FastCall0(v) PyObject_Call(v,empty_tuple,NULL)
""",
"""
""")
    


Libr('_PyEval_DoRaise',
"""
static int
_PyEval_DoRaise(PyObject *, PyObject *, PyObject *);
""",
"""
static int
_PyEval_DoRaise(PyObject *type, PyObject *value, PyObject *tb)
{
	if (type == 0) {
		/* Reraise */
		PyThreadState * tstate = PyThreadState_GET();
#ifndef PYPY_VERSION                
		type = tstate->exc_type == 0 ? Py_None : tstate->exc_type;
		value = tstate->exc_value;
		tb = tstate->exc_traceback;
		Py_XINCREF(type);
		Py_XINCREF(value);
		Py_XINCREF(tb);
#else
		type = PyObject_GetAttrString((PyObject *)tstate, "exc_type");
                if (type == 0) {
                type = Py_None;
		Py_XINCREF(type);
                }
		value = PyObject_GetAttrString((PyObject *)tstate, "exc_value");
		tb = PyObject_GetAttrString((PyObject *)tstate, "exc_traceback");
#endif
	}

	/* We support the following forms of raise:
	   raise <class>, <classinstance>
	   raise <class>, <argument tuple>
	   raise <class>, None
	   raise <class>, <argument>
	   raise <classinstance>, None
	   raise <string>, <object>
	   raise <string>, None

	   An omitted second argument is the same as None.

	   In addition, raise <tuple>, <anything> is the same as
	   raising the tuple's first item (and it better have one!);
	   this rule is applied recursively.

	   Finally, an optional third argument can be supplied, which
	   gives the traceback to be substituted (useful when
	   re-raising an exception after examining it).  */

	/* First, check the traceback argument, replacing None with
	   NULL. */
	if (tb == Py_None) {
		Py_DECREF(tb);
		tb = NULL;
	}
	else if (tb != NULL && !PyTraceBack_Check(tb)) {
		PyErr_SetString(PyExc_TypeError,
			   "raise: arg 3 must be a traceback or None");
		goto raise_error;
	}

	/* Next, replace a missing value with None */
	if (value == 0) {
		value = Py_None;
		Py_INCREF(value);
	}

	/* Next, repeatedly, replace a tuple exception with its first item */
	while (PyTuple_Check(type) && PyTuple_Size(type) > 0) {
		PyObject *tmp = type;
		type = PyTuple_GET_ITEM(type, 0);
		Py_INCREF(type);
		Py_DECREF(tmp);
	}

	if (PyExceptionClass_Check(type))
		PyErr_NormalizeException(&type, &value, &tb);
#ifndef PYPY_VERSION
	else if (PyExceptionInstance_Check(type)) {
		/* Raising an instance.  The value should be a dummy. */
		if (value != Py_None) {
			PyErr_SetString(PyExc_TypeError,
			  "instance exception may not have a separate value");
			goto raise_error;
		}
		else {
			/* Normalize to raise <class>, <instance> */
			Py_DECREF(value);
			value = type;
			type = PyExceptionInstance_Class(type);
			Py_INCREF(type);
		}
	}
#endif
	else {
		/* Not something you can raise.  You get an exception
		   anyway, just not what you specified :-) */
		PyErr_Format(PyExc_TypeError,
			"exceptions must be classes or instances, not %s",
			type->ob_type->tp_name);
		goto raise_error;
	}

	assert(PyExceptionClass_Check(type));
	if (Py_Py3kWarningFlag && PyClass_Check(type)) {
		if (PyErr_WarnEx(PyExc_DeprecationWarning,
				"exceptions must derive from BaseException "
				"in 3.x", 1) < 0)
			goto raise_error;
	}

	PyErr_Restore(type, value, tb);
	if (tb == 0)
		return WHY_EXCEPTION;
	else
		return WHY_RERAISE;
 raise_error:
	Py_XDECREF(value);
	Py_XDECREF(type);
	Py_XDECREF(tb);
	return WHY_EXCEPTION;
}
""")     
Libr('_PyEval_ImportAllFrom',
"""
static int
_PyEval_ImportAllFrom(PyObject *, PyObject *);
""",
"""
static int
_PyEval_ImportAllFrom(PyObject *locals, PyObject *v)
{
	PyObject *all = PyObject_GetAttrString(v, "__all__");
	PyObject *dict, *name, *value;
	int skip_leading_underscores = 0;
	int pos, err;

	if (all == 0) {
		if (!PyErr_ExceptionMatches(PyExc_AttributeError))
			return -1; /* Unexpected error */
		PyErr_Clear();
		dict = PyObject_GetAttrString(v, "__dict__");
		if (dict == 0) {
			if (!PyErr_ExceptionMatches(PyExc_AttributeError))
				return -1;
			PyErr_SetString(PyExc_ImportError,
			"from-import-* object has no __dict__ and no __all__");
			return -1;
		}
		all = PyMapping_Keys(dict);
		Py_DECREF(dict);
		if (all == 0)
			return -1;
		skip_leading_underscores = 1;
	}

	for (pos = 0, err = 0; ; pos++) {
		name = PySequence_GetItem(all, pos);
		if (name == 0) {
			if (!PyErr_ExceptionMatches(PyExc_IndexError))
				err = -1;
			else
				PyErr_Clear();
			break;
		}
		if (skip_leading_underscores &&
		    PyString_Check(name) &&
		    PyString_AS_STRING(name)[0] == '_')
		{
			Py_DECREF(name);
			continue;
		}
		value = PyObject_GetAttr(v, name);
		if (value == 0)
			err = -1;
		else if (PyDict_CheckExact(locals))
			err = PyDict_SetItem(locals, name, value);
		else
			err = PyObject_SetItem(locals, name, value);
		Py_DECREF(name);
		Py_XDECREF(value);
		if (err != 0)
			break;
	}
	Py_DECREF(all);
	return err;
}
""")
Libr('_PyEval_BuildClass', 
"""
static PyObject *
_PyEval_BuildClass(PyObject *, PyObject *, PyObject *);
""",
"""
static PyObject *
_PyEval_BuildClass(PyObject *methods, PyObject *bases, PyObject *name)
{
	PyObject *metaclass = NULL, *result, *base;

	if (PyDict_Check(methods))
		metaclass = PyDict_GetItemString(methods, "__metaclass__");
	if (metaclass != NULL)
		Py_INCREF(metaclass);
	else if (PyTuple_Check(bases) && PyTuple_GET_SIZE(bases) > 0) {
		base = PyTuple_GET_ITEM(bases, 0);
		metaclass = PyObject_GetAttrString(base, "__class__");
		if (metaclass == 0) {
			PyErr_Clear();
			metaclass = (PyObject *)base->ob_type;
			Py_INCREF(metaclass);
		}
	}
	else {
		PyObject *g = PyEval_GetGlobals();
		if (g != NULL && PyDict_Check(g))
			metaclass = PyDict_GetItemString(g, "__metaclass__");
		if (metaclass == 0)
			metaclass = (PyObject *) &PyClass_Type;
		Py_INCREF(metaclass);
	}
	result = PyObject_CallFunctionObjArgs(metaclass, name, bases, methods,
					      NULL);
	Py_DECREF(metaclass);
	if (result == 0 && PyErr_ExceptionMatches(PyExc_TypeError)) {
		/* A type error here likely means that the user passed
		   in a base that was not a class (such the random module
		   instead of the random.random type).  Help them out with
		   by augmenting the error message with more information.*/

		PyObject *ptype, *pvalue, *ptraceback;

		PyErr_Fetch(&ptype, &pvalue, &ptraceback);
		if (PyString_Check(pvalue)) {
			PyObject *newmsg;
			newmsg = PyString_FromFormat(
				"Error when calling the metaclass bases\\n"
				"    %s",
				PyString_AS_STRING(pvalue));
			if (newmsg != NULL) {
				Py_DECREF(pvalue);
				pvalue = newmsg;
			}
		}
		PyErr_Restore(ptype, pvalue, ptraceback);
	}
	return result;
}
""")
     

Libr('_PyEval_ExecStatement',
"""static int
_PyEval_ExecStatement(PyFrameObject * , PyObject *, PyObject *, PyObject *);
""",
"""
static int
_PyEval_ExecStatement(PyFrameObject * f, PyObject *prog, PyObject *globals,
	       PyObject *locals)
{
	int n;
	PyObject *v;
	int plain = 0;

	if (PyTuple_Check(prog) && globals == Py_None && locals == Py_None &&
	    ((n = PyTuple_Size(prog)) == 2 || n == 3)) {
		/* Backward compatibility hack */
		globals = PyTuple_GetItem(prog, 1);
		if (n == 3)
			locals = PyTuple_GetItem(prog, 2);
		prog = PyTuple_GetItem(prog, 0);
	}
	if (globals == Py_None) {
		globals = PyEval_GetGlobals();
		if (locals == Py_None) {
			locals = PyEval_GetLocals();
			plain = 1;
		}
		if (!globals || !locals) {
			PyErr_SetString(PyExc_SystemError,
					"globals and locals cannot be NULL");
			return -1;
		}
	}
	else if (locals == Py_None)
		locals = globals;
	if (!PyString_Check(prog) &&
	    !PyUnicode_Check(prog) &&
	    !PyCode_Check(prog) &&
	    !PyFile_Check(prog)) {
		PyErr_SetString(PyExc_TypeError,
			"exec: arg 1 must be a string, file, or code object");
		return -1;
	}
	if (!PyDict_Check(globals)) {
		PyErr_SetString(PyExc_TypeError,
		    "exec: arg 2 must be a dictionary or None");
		return -1;
	}
	if (!PyMapping_Check(locals)) {
		PyErr_SetString(PyExc_TypeError,
		    "exec: arg 3 must be a mapping or None");
		return -1;
	}
	if (PyDict_GetItemString(globals, "__builtins__") == 0)
		PyDict_SetItemString(globals, "__builtins__", b);
	if (PyCode_Check(prog)) {
		if (PyCode_GetNumFree((PyCodeObject *)prog) > 0) {
			PyErr_SetString(PyExc_TypeError,
		"code object passed to exec may not contain free variables");
			return -1;
		}
		v = PyEval_EvalCode((PyCodeObject *) prog, globals, locals);
	}
	else if (PyFile_Check(prog)) {
		FILE *fp = PyFile_AsFile(prog);
		char *name = PyString_AsString(PyFile_Name(prog));
		PyCompilerFlags cf;
		if (name == 0)
			return -1;
		cf.cf_flags = 0;
		if (PyEval_MergeCompilerFlags(&cf))
			v = PyRun_FileFlags(fp, name, Py_file_input, globals,
					    locals, &cf);
		else
			v = PyRun_File(fp, name, Py_file_input, globals,
				       locals);
	}
	else {
		PyObject *tmp = NULL;
		char *str;
		PyCompilerFlags cf;
		cf.cf_flags = 0;
#ifdef Py_USING_UNICODE
		if (PyUnicode_Check(prog)) {
			tmp = PyUnicode_AsUTF8String(prog);
			if (tmp == 0)
				return -1;
			prog = tmp;
			cf.cf_flags |= PyCF_SOURCE_IS_UTF8;
		}
#endif
		if (PyString_AsStringAndSize(prog, &str, NULL))
			return -1;
		if (PyEval_MergeCompilerFlags(&cf))
			v = PyRun_StringFlags(str, Py_file_input, globals,
					      locals, &cf);
		else
			v = PyRun_String(str, Py_file_input, globals, locals);
		Py_XDECREF(tmp);
	}
	if (plain)
		PyFrame_LocalsToFast(f, 0);
	if (v == 0)
		return -1;
	Py_DECREF(v);
	return 0;
}
""")

Libr('Py2CFunction_NewFull',
"""
#define Py2CFunction_USED 1
#include <structmember.h>
#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
#define __Pyx_CYFUNCTION_CCLASS        0x04
#define Py2CFunction_GetClosure(f)\
    (((Py2CFunctionObject *) (f))->func_closure)
#define Py2CFunction_GetClassObj(f)\
    (((Py2CFunctionObject *) (f))->func_classobj)
#define Py2CFunction_Defaults(type, f)\
    ((type *)(((Py2CFunctionObject *) (f))->defaults))
#define Py2CFunction_SetDefaultsGetter(f, g)\
    ((Py2CFunctionObject *) (f))->defaults_getter = (g)
typedef struct {
    PyCFunctionObject func;
#if PY_VERSION_HEX < 0x030500A0
    PyObject *func_weakreflist;
#endif
    PyObject *func_dict;
    PyObject *func_name;
    PyObject *func_doc;
    PyObject *func_globals;
    PyObject *func_code;
    PyObject *func_closure;
    PyObject *func_classobj;
    void *defaults;
    int defaults_pyobjects;
    int flags;
    PyObject *defaults_tuple;
    PyObject *defaults_kwdict;
    PyObject *(*defaults_getter)(PyObject *);
    PyObject *func_annotations;
} Py2CFunctionObject;
static PyTypeObject *Py2CFunctionType = 0;
#define Py2CFunction_NewFull(ml, flags, self, module, globals, code)\
    Py2CFunction_NewFull_(Py2CFunctionType, ml, flags, self, module, globals, code)
static PyObject *Py2CFunction_NewFull_(PyTypeObject *, PyMethodDef *ml,
                                      int flags,
                                      PyObject *self,
                                      PyObject *module, PyObject *globals,
                                      PyObject* code);
static int Py2CFunction_init_full(void);

static PyTypeObject* Py2CFetchCommonType(PyTypeObject* type);

""",
"""
/* CythonFunction */
        static PyObject *
Py2CFunction_get_doc(Py2CFunctionObject *op,  void *closure)
{
    if (op->func_doc == NULL) {
        if (op->func.m_ml->ml_doc) {
#if PY_MAJOR_VERSION >= 3
            op->func_doc = PyUnicode_FromString(op->func.m_ml->ml_doc);
#else
            op->func_doc = PyString_FromString(op->func.m_ml->ml_doc);
#endif
            if (op->func_doc == NULL)
                return NULL;
        } else {
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    Py_INCREF(op->func_doc);
    return op->func_doc;
}
static int
Py2CFunction_set_doc(Py2CFunctionObject *op, PyObject *value)
{
    PyObject *tmp = op->func_doc;
    if (value == NULL) {
        value = Py_None;
    }
    Py_INCREF(value);
    op->func_doc = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
Py2CFunction_get_name(Py2CFunctionObject *op)
{
    if (op->func_name == NULL) {
#if PY_MAJOR_VERSION >= 3
        op->func_name = PyUnicode_InternFromString(op->func.m_ml->ml_name);
#else
        op->func_name = PyString_InternFromString(op->func.m_ml->ml_name);
#endif
        if (op->func_name == NULL)
            return NULL;
    }
    Py_INCREF(op->func_name);
    return op->func_name;
}
static int
Py2CFunction_set_name(Py2CFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if ((value == NULL || !PyUnicode_Check(value))) {
#else
    if ((value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = op->func_name;
    Py_INCREF(value);
    op->func_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
Py2CFunction_get_self(Py2CFunctionObject *m,  void *closure)
{
    PyObject *self;
    self = m->func_closure;
    if (self == NULL)
        self = Py_None;
    Py_INCREF(self);
    return self;
}
static PyObject *
Py2CFunction_get_dict(Py2CFunctionObject *op)
{
    if (op->func_dict == NULL) {
        op->func_dict = PyDict_New();
        if (op->func_dict == NULL)
            return NULL;
    }
    Py_INCREF(op->func_dict);
    return op->func_dict;
}
static int
Py2CFunction_set_dict(Py2CFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
    if (value == NULL) {
        PyErr_SetString(PyExc_TypeError,
               "function's dictionary may not be deleted");
        return -1;
    }
    if ((!PyDict_Check(value))) {
        PyErr_SetString(PyExc_TypeError,
               "setting function's dictionary to a non-dict");
        return -1;
    }
    tmp = op->func_dict;
    Py_INCREF(value);
    op->func_dict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
Py2CFunction_get_globals(Py2CFunctionObject *op)
{
    Py_INCREF(op->func_globals);
    return op->func_globals;
}
static PyObject *
Py2CFunction_get_closure( Py2CFunctionObject *op)
{
    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
Py2CFunction_get_code(Py2CFunctionObject *op)
{
    PyObject* result = (op->func_code) ? op->func_code : Py_None;
    Py_INCREF(result);
    return result;
}
static int
Py2CFunction_init_defaults(Py2CFunctionObject *op) {
    int result = 0;
    PyObject *res = op->defaults_getter((PyObject *) op);
    if (!res)
        return -1;
    #if 1
    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
    Py_INCREF(op->defaults_tuple);
    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
    Py_INCREF(op->defaults_kwdict);
    #else
    op->defaults_tuple = PySequence_ITEM(res, 0);
    if (!op->defaults_tuple) result = -1;
    else {
        op->defaults_kwdict = PySequence_ITEM(res, 1);
        if (!op->defaults_kwdict) result = -1;
    }
    #endif
    Py_DECREF(res);
    return result;
}
static int
Py2CFunction_set_defaults(Py2CFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyTuple_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__defaults__ must be set to a tuple object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_tuple;
    op->defaults_tuple = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
Py2CFunction_get_defaults(Py2CFunctionObject *op) {
    PyObject* result = op->defaults_tuple;
    if (!result) {
        if (op->defaults_getter) {
            if (Py2CFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_tuple;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
Py2CFunction_set_kwdefaults(Py2CFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__kwdefaults__ must be set to a dict object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_kwdict;
    op->defaults_kwdict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
Py2CFunction_get_kwdefaults(Py2CFunctionObject *op) {
    PyObject* result = op->defaults_kwdict;
    if (!result) {
        if (op->defaults_getter) {
            if (Py2CFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_kwdict;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
Py2CFunction_set_annotations(Py2CFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value || value == Py_None) {
        value = NULL;
    } else if (!PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__annotations__ must be set to a dict object");
        return -1;
    }
    Py_XINCREF(value);
    tmp = op->func_annotations;
    op->func_annotations = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
Py2CFunction_get_annotations(Py2CFunctionObject *op) {
    PyObject* result = op->func_annotations;
    if (!result) {
        result = PyDict_New();
        if (!result) return NULL;
        op->func_annotations = result;
    }
    Py_INCREF(result);
    return result;
}
static PyGetSetDef Py2CFunction_getsets[] = {
    {(char *) "func_doc", (getter)Py2CFunction_get_doc, (setter)Py2CFunction_set_doc, 0, 0},
    {(char *) "__doc__",  (getter)Py2CFunction_get_doc, (setter)Py2CFunction_set_doc, 0, 0},
    {(char *) "func_name", (getter)Py2CFunction_get_name, (setter)Py2CFunction_set_name, 0, 0},
    {(char *) "__name__", (getter)Py2CFunction_get_name, (setter)Py2CFunction_set_name, 0, 0},
    {(char *) "__self__", (getter)Py2CFunction_get_self, 0, 0, 0},
    {(char *) "func_dict", (getter)Py2CFunction_get_dict, (setter)Py2CFunction_set_dict, 0, 0},
    {(char *) "__dict__", (getter)Py2CFunction_get_dict, (setter)Py2CFunction_set_dict, 0, 0},
    {(char *) "func_globals", (getter)Py2CFunction_get_globals, 0, 0, 0},
    {(char *) "__globals__", (getter)Py2CFunction_get_globals, 0, 0, 0},
    {(char *) "func_closure", (getter)Py2CFunction_get_closure, 0, 0, 0},
    {(char *) "__closure__", (getter)Py2CFunction_get_closure, 0, 0, 0},
    {(char *) "func_code", (getter)Py2CFunction_get_code, 0, 0, 0},
    {(char *) "__code__", (getter)Py2CFunction_get_code, 0, 0, 0},
    {(char *) "func_defaults", (getter)Py2CFunction_get_defaults, (setter)Py2CFunction_set_defaults, 0, 0},
    {(char *) "__defaults__", (getter)Py2CFunction_get_defaults, (setter)Py2CFunction_set_defaults, 0, 0},
    {(char *) "__kwdefaults__", (getter)Py2CFunction_get_kwdefaults, (setter)Py2CFunction_set_kwdefaults, 0, 0},
    {(char *) "__annotations__", (getter)Py2CFunction_get_annotations, (setter)Py2CFunction_set_annotations, 0, 0},
    {0, 0, 0, 0, 0}
};
static PyMemberDef Py2CFunction_members[] = {
    {(char *) "__module__", T_OBJECT, offsetof(PyCFunctionObject, m_module), PY_WRITE_RESTRICTED, 0},
    {0, 0, 0,  0, 0}
};
static PyObject *
Py2CFunction_reduce(Py2CFunctionObject *m,  PyObject *args)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromString(m->func.m_ml->ml_name);
#else
    return PyString_FromString(m->func.m_ml->ml_name);
#endif
}
static PyMethodDef Py2CFunction_methods[] = {
    {"__reduce__", (PyCFunction)Py2CFunction_reduce, METH_VARARGS, 0},
    {0, 0, 0, 0}
};
#if PY_VERSION_HEX < 0x030500A0
#define Py2CFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
#else
#define Py2CFunction_weakreflist(cyfunc) ((cyfunc)->func.m_weakreflist)
#endif
static PyObject *Py2CFunction_NewFull_(PyTypeObject *type, PyMethodDef *ml, int flags, 
                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
    Py2CFunctionObject *op = PyObject_GC_New(Py2CFunctionObject, type);
    if (op == NULL)
        return NULL;
    op->flags = flags;
    Py2CFunction_weakreflist(op) = NULL;
    op->func.m_ml = ml;
    op->func.m_self = (PyObject *) op;
    Py_XINCREF(closure);
    op->func_closure = closure;
    Py_XINCREF(module);
    op->func.m_module = module;
    op->func_dict = NULL;
    op->func_name = NULL;
    op->func_doc = NULL;
    op->func_classobj = NULL;
    op->func_globals = globals;
    Py_INCREF(op->func_globals);
    Py_XINCREF(code);
    op->func_code = code;
    op->defaults_pyobjects = 0;
    op->defaults = NULL;
    op->defaults_tuple = NULL;
    op->defaults_kwdict = NULL;
    op->defaults_getter = NULL;
    op->func_annotations = NULL;
    PyObject_GC_Track(op);
    return (PyObject *) op;
}
static int
Py2CFunction_clear(Py2CFunctionObject *m)
{
    Py_CLEAR(m->func_closure);
    Py_CLEAR(m->func.m_module);
    Py_CLEAR(m->func_dict);
    Py_CLEAR(m->func_name);
    Py_CLEAR(m->func_doc);
    Py_CLEAR(m->func_globals);
    Py_CLEAR(m->func_code);
    Py_CLEAR(m->func_classobj);
    Py_CLEAR(m->defaults_tuple);
    Py_CLEAR(m->defaults_kwdict);
    Py_CLEAR(m->func_annotations);
    if (m->defaults) {
        PyObject **pydefaults = Py2CFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_XDECREF(pydefaults[i]);
        PyObject_Free(m->defaults);
        m->defaults = NULL;
    }
    return 0;
}
static void __Pyx__CyFunction_dealloc(Py2CFunctionObject *m)
{
    if (Py2CFunction_weakreflist(m) != NULL)
        PyObject_ClearWeakRefs((PyObject *) m);
    Py2CFunction_clear(m);
    PyObject_GC_Del(m);
}
static void Py2CFunction_dealloc(Py2CFunctionObject *m)
{
    PyObject_GC_UnTrack(m);
    __Pyx__CyFunction_dealloc(m);
}
static int Py2CFunction_traverse(Py2CFunctionObject *m, visitproc visit, void *arg)
{
    Py_VISIT(m->func_closure);
    Py_VISIT(m->func.m_module);
    Py_VISIT(m->func_dict);
    Py_VISIT(m->func_name);
    Py_VISIT(m->func_doc);
    Py_VISIT(m->func_globals);
    Py_VISIT(m->func_code);
    Py_VISIT(m->func_classobj);
    Py_VISIT(m->defaults_tuple);
    Py_VISIT(m->defaults_kwdict);
    if (m->defaults) {
        PyObject **pydefaults = Py2CFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_VISIT(pydefaults[i]);
    }
    return 0;
}
static PyObject *Py2CFunction_descr_get(PyObject *func, PyObject *obj, PyObject *type)
{
    Py2CFunctionObject *m = (Py2CFunctionObject *) func;
    if (m->flags & __Pyx_CYFUNCTION_STATICMETHOD) {
        Py_INCREF(func);
        return func;
    }
    if (m->flags & __Pyx_CYFUNCTION_CLASSMETHOD) {
        if (type == NULL)
            type = (PyObject *)(Py_TYPE(obj));
        return PyMethod_New(func, type, (PyObject *)(Py_TYPE(type)));
    }
    if (obj == Py_None)
        obj = NULL;
    return PyMethod_New(func, obj, type);
}
static PyObject*
Py2CFunction_repr(Py2CFunctionObject *op)
{
    return PyString_FromFormat("<Py2Cfunction %s at %p>",
                               PyString_AsString(op->func_name), (void *)op);
}
static PyObject * Py2CFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
    PyCFunctionObject* f = (PyCFunctionObject*)func;
    PyCFunction meth = f->m_ml->ml_meth;
    Py_ssize_t size;
    switch (f->m_ml->ml_flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
    case METH_VARARGS:
        if (kw == NULL || PyDict_Size(kw) == 0)
            return (*meth)(self, arg);
        break;
    case METH_VARARGS | METH_KEYWORDS:
        return (*(PyCFunctionWithKeywords)meth)(self, arg, kw);
    case METH_NOARGS:
        if (kw == NULL || PyDict_Size(kw) == 0) {
            size = PyTuple_GET_SIZE(arg);
            if (size == 0)
                return (*meth)(self, NULL);
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes no arguments (%d given)",
                f->m_ml->ml_name, (int)size);
            return NULL;
        }
        break;
    case METH_O:
        if (kw == NULL || PyDict_Size(kw) == 0) {
            size = PyTuple_GET_SIZE(arg);
            if (size == 1) {
                PyObject *result, *arg0;
                #if 1
                arg0 = PyTuple_GET_ITEM(arg, 0);
                #else
                arg0 = PySequence_ITEM(arg, 0); if (!arg0) return NULL;
                #endif
                result = (*meth)(self, arg0);
                #if !(1)
                Py_DECREF(arg0);
                #endif
                return result;
            }
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes exactly one argument (%d given)",
                f->m_ml->ml_name, (int)size);
            return NULL;
        }
        break;
    default:
        PyErr_SetString(PyExc_SystemError, "Bad call flags in "
                        "Py2CFunction_Call. METH_OLDARGS is no "
                        "longer supported!");
        return NULL;
    }
    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
                 f->m_ml->ml_name);
    return NULL;
}
static  PyObject *Py2CFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    return Py2CFunction_CallMethod(func, ((PyCFunctionObject*)func)->m_self, arg, kw);
}
static PyObject *Py2CFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
    PyObject *result;
    Py2CFunctionObject *cyfunc = (Py2CFunctionObject *) func;
    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
        Py_ssize_t argc;
        PyObject *new_args;
        PyObject *self;
        argc = PyTuple_GET_SIZE(args);
        new_args = PyTuple_GetSlice(args, 1, argc);
        if (!new_args)
            return NULL;
        self = PyTuple_GetItem(args, 0);
        if (!self) {
            Py_DECREF(new_args);
            return NULL;
        }
        result = Py2CFunction_CallMethod(func, self, new_args, kw);
        Py_DECREF(new_args);
    } else {
        result = Py2CFunction_Call(func, args, kw);
    }
    return result;
}
static PyTypeObject Py2CFunctionType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "cython_function_or_method",
    sizeof(Py2CFunctionObject),
    0,
    (destructor) Py2CFunction_dealloc,
    0,
    0,
    0,
#if PY_MAJOR_VERSION < 3
    0,
#else
    0,
#endif
    (reprfunc) Py2CFunction_repr,
    0,
    0,
    0,
    0,
    Py2CFunction_CallAsMethod,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
    0,
    (traverseproc) Py2CFunction_traverse,
    (inquiry) Py2CFunction_clear,
    0,
#if PY_VERSION_HEX < 0x030500A0
    offsetof(Py2CFunctionObject, func_weakreflist),
#else
    offsetof(PyCFunctionObject, m_weakreflist),
#endif
    0,
    0,
    Py2CFunction_methods,
    Py2CFunction_members,
    Py2CFunction_getsets,
    0,
    0,
    Py2CFunction_descr_get,
    0,
    offsetof(Py2CFunctionObject, func_dict),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if PY_VERSION_HEX >= 0x030400a1
    0,
#endif
};
static int Py2CFunction_init_full(void) {
    Py2CFunctionType = Py2CFetchCommonType(&Py2CFunctionType_type);
    if (Py2CFunctionType == NULL) {
        return -1;
    }
    return 0;
}


static PyTypeObject* Py2CFetchCommonType(PyTypeObject* type) {

    PyTypeObject* cached_type = NULL;

        if (PyType_Ready(type) < 0) goto bad;
        Py_INCREF(type);
        cached_type = type;

done:

    return cached_type;
bad:
    Py_XDECREF(cached_type);
    cached_type = NULL;
    goto done;
}
""")


  

Libr('empty_number_protocol',
"""static PyNumberMethods empty_number_protocol;""",
"""static PyNumberMethods empty_number_protocol = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_divide*/
  #endif
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_coerce*/
  #endif
  0, /*nb_int*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_long*/
  #else
  0, /*reserved*/
  #endif
  0, /*nb_float*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_oct*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*nb_hex*/
  #endif
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_inplace_divide*/
  #endif
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if PY_VERSION_HEX >= 0x02050000
  0, /*nb_index*/
  #endif
};
""")

Libr('empty_seq_protocol',
"""static PySequenceMethods empty_seq_protocol;""",
"""static PySequenceMethods empty_seq_protocol = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};
""")

Libr('empty_map_protocol',
"""static PyMappingMethods empty_map_protocol;""",
"""static PyMappingMethods empty_map_protocol = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};
""")

Libr('empty_buf_protocol',
"""static PyBufferProcs empty_buf_protocol;""",
"""static PyBufferProcs empty_buf_protocol = {
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getreadbuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getwritebuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getsegcount*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getcharbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_getbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_releasebuffer*/
  #endif
};
""")
Libr('ping_threading',
"""
#if PYTHON_VERSION < 300
// We share this with CPython bytecode main loop.
PyAPI_DATA(volatile int) _Py_Ticker;
#else
extern volatile int _Py_Ticker;
#endif
static int __ping_threading (void);
#define ping_threading() (--_Py_Ticker < 0 ? __ping_threading() : 0)
""",
"""
#if PYTHON_VERSION < 300
#else
#define _Py_CheckInterval 20
#endif
static int __ping_threading (void)
{
    PyThreadState * tstate = 0;
    _Py_Ticker = _Py_CheckInterval;
    if (Py_MakePendingCalls() < 0) return -1;
    tstate = PyThreadState_GET();
    assert (tstate);
    if (tstate->async_exc != NULL) {
        PyObject * x = tstate->async_exc;
        tstate->async_exc = NULL;
        PyErr_SetNone(x);
        Py_DECREF(x);
        return -1;\
    } 
    return 0;
}
""")

Libr('_Py_oct',
     """
static PyObject * _Py_oct(PyObject *);
     """,
     """
static PyObject * _Py_oct(PyObject *v)
{
    PyNumberMethods *nb;
    PyObject *res;

    if (v == NULL || (nb = v->ob_type->tp_as_number) == NULL ||
        nb->nb_oct == NULL) {
        PyErr_SetString(PyExc_TypeError,
                   "oct() argument can't be converted to oct");
        return NULL;
    }
    res = (*nb->nb_oct)(v);
    if (res && !PyString_Check(res)) {
        PyErr_Format(PyExc_TypeError,
                     "__oct__ returned non-string (type %.200s)",
                     res->ob_type->tp_name);
        Py_DECREF(res);
        return NULL;
    }
    return res;
}     """)

Libr('_Py_hex',
     """
static PyObject * _Py_hex(PyObject *);
     """,
     """
static PyObject * _Py_hex(PyObject *v)
{
    PyNumberMethods *nb;
    PyObject *res;

    if (v == NULL || (nb = v->ob_type->tp_as_number) == NULL ||
        nb->nb_hex == NULL) {
        PyErr_SetString(PyExc_TypeError,
                   "hex() argument can't be converted to hex");
        return NULL;
    }
    res = (*nb->nb_hex)(v);
    if (res && !PyString_Check(res)) {
        PyErr_Format(PyExc_TypeError,
                     "__hex__ returned non-string (type %.200s)",
                     res->ob_type->tp_name);
        Py_DECREF(res);
        return NULL;
    }
    return res;
}     """)

if True:
    Libr('parse_arguments',
"""
static int parse_arguments (PyObject *func, PyObject *arg, PyObject *kw, PyObject * co, PyObject * argdefs, PyObject ** fastlocals);
""",
"""

static int
PyEval_Eval3CCodeEx(PyCodeObject *co, PyObject *locals,
	   PyObject **args, int argcount, PyObject **kws, int kwcount,
	   PyObject **defs, int defcount
#ifndef PYPY_VERSION
           , PyObject *closure, PyObject ** fastlocals);
#else
           , PyObject ** fastlocals);
#endif

static int parse_arguments (PyObject *func, PyObject *arg, PyObject *kw, PyObject * co, PyObject * argdefs, PyObject ** fastlocals)
{
	int result;
	PyObject **d, **k;
	Py_ssize_t nk, nd;

	if (argdefs != NULL && PyTuple_Check(argdefs)) {
		d = &PyTuple_GET_ITEM((PyTupleObject *)argdefs, 0);
		nd = PyTuple_Size(argdefs);
	}
	else {
		d = NULL;
		nd = 0;
	}

	if (kw != NULL && PyDict_Check(kw)) {
		Py_ssize_t pos, i;
		nk = PyDict_Size(kw);
		k = PyMem_NEW(PyObject *, 2*nk);
		if (k == 0) {
			PyErr_NoMemory();
			return -1;
		}
		pos = i = 0;
		while (PyDict_Next(kw, &pos, &k[i], &k[i+1]))
			i += 2;
		nk = i/2;
		/* XXX This is broken if the caller deletes dict items! */
	}
	else {
		k = NULL;
		nk = 0;
	}

	result = PyEval_Eval3CCodeEx(
		(PyCodeObject *)co,
		(PyObject *)NULL,
		&PyTuple_GET_ITEM(arg, 0), PyTuple_Size(arg),
		k, nk, d, nd, 0, fastlocals);


	if (k != NULL)
		PyMem_DEL(k);

	return result;
}

/* Local variable macros */

#undef GETLOCAL
#undef SETLOCAL
#define GETLOCAL(i)	(fastlocals[i])

#define SETLOCAL(i, value)	do { PyObject *tmp = GETLOCAL(i); \
				     GETLOCAL(i) = value; \
                                     Py_XDECREF(tmp); } while (0)

static int
PyEval_Eval3CCodeEx(PyCodeObject *co, PyObject *locals,
	   PyObject **args, int argcount, PyObject **kws, int kwcount,
	   PyObject **defs, int defcount
#ifndef PYPY_VERSION
           , PyObject *closure, PyObject ** fastlocals)
#else
           , PyObject ** fastlocals)
#endif
{
	PyObject *x, *u;

	if (co->co_argcount > 0 ||
	    co->co_flags & (CO_VARARGS | CO_VARKEYWORDS)) {
		int i;
		int n = argcount;
		PyObject *kwdict = NULL;
		if (co->co_flags & CO_VARKEYWORDS) {
			kwdict = PyDict_New();
			if (kwdict == 0)
				goto fail;
			i = co->co_argcount;
			if (co->co_flags & CO_VARARGS)
				i++;
			SETLOCAL(i, kwdict);
		}
		if (argcount > co->co_argcount) {
			if (!(co->co_flags & CO_VARARGS)) {
				PyErr_Format(PyExc_TypeError,
				    "%.200s() takes %s %d "
				    "%sargument%s (%d given)",
				    PyString_AsString(co->co_name),
				    defcount ? "at most" : "exactly",
				    co->co_argcount,
				    kwcount ? "non-keyword " : "",
				    co->co_argcount == 1 ? "" : "s",
				    argcount);
				goto fail;
			}
			n = co->co_argcount;
		}
		for (i = 0; i < n; i++) {
			x = args[i];
			Py_INCREF(x);
			SETLOCAL(i, x);
		}
		if (co->co_flags & CO_VARARGS) {
			u = PyTuple_New(argcount - n);
			if (u == 0)
				goto fail;
			SETLOCAL(co->co_argcount, u);
			for (i = n; i < argcount; i++) {
				x = args[i];
				Py_INCREF(x);
				PyTuple_SET_ITEM(u, i-n, x);
			}
		}
		for (i = 0; i < kwcount; i++) {
			PyObject **co_varnames;
			PyObject *keyword = kws[2*i];
			PyObject *value = kws[2*i + 1];
			int j;
                        if (keyword == 0 || !(PyString_Check(keyword)
#ifdef Py_USING_UNICODE
                                     || PyUnicode_Check(keyword)
#endif
                            )) {
				PyErr_Format(PyExc_TypeError,
				    "%.200s() keywords must be strings",
				    PyString_AsString(co->co_name));
				goto fail;
			}
			/* Speed hack: do raw pointer compares. As names are
			   normally interned this should almost always hit. */
                        co_varnames = ((PyTupleObject *)(co->co_varnames))->ob_item;
                        for (j = 0; j < co->co_argcount; j++) {
                            PyObject *nm = co_varnames[j];
                            if (nm == keyword)
                                goto kw_found;
                        }
                        /* Slow fallback, just in case */
                        for (j = 0; j < co->co_argcount; j++) {
                            PyObject *nm = co_varnames[j];
                            int cmp = PyObject_RichCompareBool(
                                keyword, nm, Py_EQ);
                            if (cmp > 0)
                                goto kw_found;
                            else if (cmp < 0)
                                goto fail;
                        }
                        if (kwdict == 0) {
                            PyObject *kwd_str = kwd_as_string(keyword);
                            if (kwd_str) {
                                PyErr_Format(PyExc_TypeError,
                                            "%.200s() got an unexpected "
                                            "keyword argument '%.400s'",
                                            PyString_AsString(co->co_name),
                                            PyString_AsString(kwd_str));
                                Py_DECREF(kwd_str);
                            }
                            goto fail;
                        }
                        PyDict_SetItem(kwdict, keyword, value);
                        continue;

kw_found:
			if (GETLOCAL(j) != NULL) {
                            PyObject *kwd_str = kwd_as_string(keyword);
                            if (kwd_str) {
                                PyErr_Format(PyExc_TypeError,
                                            "%.200s() got multiple "
                                            "values for keyword "
                                            "argument '%.400s'",
                                            PyString_AsString(co->co_name),
                                            PyString_AsString(kwd_str));
                                Py_DECREF(kwd_str);
                            }
			}
			Py_INCREF(value);
			SETLOCAL(j, value);
		}
		if (argcount < co->co_argcount) {
			int m = co->co_argcount - defcount;
			for (i = argcount; i < m; i++) {
				if (GETLOCAL(i) == 0) {
                                    int j, given = 0;
                                    for (j = 0; j < co->co_argcount; j++)
                                        if (GETLOCAL(j))
                                            given++;
                                    PyErr_Format(PyExc_TypeError,
                                        "%.200s() takes %s %d "
                                        "argument%s (%d given)",
                                        PyString_AsString(co->co_name),
                                        ((co->co_flags & CO_VARARGS) ||
                                        defcount) ? "at least"
                                                : "exactly",
                                        m, m == 1 ? "" : "s", given);
                                    goto fail;
				}
			}
			if (n > m)
				i = n - m;
			else
				i = 0;
			for (; i < defcount; i++) {
				if (GETLOCAL(m+i) == 0) {
					PyObject *def = defs[i];
					Py_INCREF(def);
					SETLOCAL(m+i, def);
				}
			}
		}
	}
	else {
		if (argcount > 0 || kwcount > 0) {
			PyErr_Format(PyExc_TypeError,
				     "%.200s() takes no arguments (%d given)",
				     PyString_AsString(co->co_name),
				     argcount + kwcount);
			goto fail;
		}
	}
	/* Allocate and initialize storage for cell vars, and copy free
	   vars into frame.  This isn't too efficient right now. */
	if (PyTuple_GET_SIZE(co->co_cellvars)) {
		int i, j, nargs, found;
		char *cellname, *argname;
		PyObject *c;

		nargs = co->co_argcount;
		if (co->co_flags & CO_VARARGS)
			nargs++;
		if (co->co_flags & CO_VARKEYWORDS)
			nargs++;

		/* Initialize each cell var, taking into account
		   cell vars that are initialized from arguments.

		   Should arrange for the compiler to put cellvars
		   that are arguments at the beginning of the cellvars
		   list so that we can march over it more efficiently?
		*/
		for (i = 0; i < PyTuple_GET_SIZE(co->co_cellvars); ++i) {
			cellname = PyString_AS_STRING(
				PyTuple_GET_ITEM(co->co_cellvars, i));
			found = 0;
			for (j = 0; j < nargs; j++) {
				argname = PyString_AS_STRING(
					PyTuple_GET_ITEM(co->co_varnames, j));
				if (strcmp(cellname, argname) == 0) {
					c = PyCell_New(GETLOCAL(j));
					if (c == 0)
						goto fail;
					GETLOCAL(co->co_nlocals + i) = c;
					found = 1;
					break;
				}
			}
			if (found == 0) {
				c = PyCell_New(NULL);
				if (c == 0)
					goto fail;
				SETLOCAL(co->co_nlocals + i, c);
			}
		}
	}
#ifndef PYPY_VERSION
	if (PyTuple_GET_SIZE(co->co_freevars)) {
                assert(0);
	}
#endif
        assert(!(co->co_flags & CO_GENERATOR));

fail: /* Jump here from prelude on failure */
	return 0;
}
""", ('kwd_as_string',))

Libr('_Py2C_IntListNew',
"""
static PyObject * _Py2C_IntListNew(long *, int);
""",
"""
static PyObject * _Py2C_IntListNew(long * lis, int le) {
    PyObject * list = PyList_New(le);
    int i;
    for (i = 0; i <= le; i ++) {
        PyList_SET_ITEM( list, i, PyInt_FromLong( lis[i] ) );
    }
    return list;
}
""")

Libr('_Py2C_IntTupleNew',
"""
static PyObject * _Py2C_IntTupleNew(long *, int);
""",
"""
static PyObject * _Py2C_IntTupleNew(long * lis, int le) {
    PyObject * tupl = PyTuple_New(le);
    int i;
    for (i = 0; i <= le; i ++) {
        PyTuple_SET_ITEM( tupl, i, PyInt_FromLong( lis[i] ) );
    }
    return tupl;
}
""")

Libr('cfunc_parse_args', 
"""
static int cfunc_parse_args(PyObject *arg, PyObject *kw, PyObject *argdefs, PyCodeObject * co, PyObject ** fastlocals);
""",
"""
static int cfunc_parse_args(PyObject *arg, PyObject *kw, PyObject *argdefs, PyCodeObject * co, PyObject ** fastlocals)
{
	PyObject *result;
	PyObject **d, **k;
	Py_ssize_t nk, nd;

	if (argdefs != NULL)) {
		d = &PyTuple_GET_ITEM((PyTupleObject *)argdefs, 0);
		nd = PyTuple_Size(argdefs);
	}
	else {
		d = NULL;
		nd = 0;
	}

	if (kw != NULL && PyDict_Check(kw)) {
		Py_ssize_t pos, i;
		nk = PyDict_Size(kw);
		k = PyMem_NEW(PyObject *, 2*nk);
		if (k == 0) {
			PyErr_NoMemory();
			return -1
		}
		pos = i = 0;
		while (PyDict_Next(kw, &pos, &k[i], &k[i+1]))
			i += 2;
		nk = i/2;
		/* XXX This is broken if the caller deletes dict items! */
	}
	else {
		k = NULL;
		nk = 0;
	}

	result = PyEval_Eval2CCodeEx(
		co,
		(PyObject *)NULL,
		&PyTuple_GET_ITEM(arg, 0), PyTuple_Size(arg),
		k, nk, d, nd
#ifndef PYPY_VERSION
                ,
		PyFunction_GET_CLOSURE(func));
#else
                );
#endif

	if (k != NULL)
		PyMem_DEL(k);

	return result;
}


     """)
     
Libr('_PyTuple_Max',
"""static PyObject * _PyTuple_Max(PyObject *);
""",
"""
static PyObject * _PyTuple_Max(PyObject *v)
{
    Py_ssize_t i;
    Py_ssize_t maxitem;
    long max_val;
    long cur_val;
    int cmp;
    
    assert(PyTuple_CheckExact(v));
    if (PyTuple_GET_SIZE(v) == 0) {
        PyErr_Format(PyExc_ValueError,
                "max() arg is an empty sequence");
        return NULL;
    }
    maxitem = 0;
        
    if (PyInt_CheckExact(PyTuple_GET_ITEM(v, 0))) {
        i = 1;
        max_val = PyInt_AS_LONG(PyTuple_GET_ITEM(v, 0));
        while ( i < PyTuple_GET_SIZE(v) ) {
            if (!PyInt_CheckExact(PyTuple_GET_ITEM(v, i))) goto no_int; 
            cur_val = PyInt_AS_LONG(PyTuple_GET_ITEM(v, i));
            if ( cur_val > max_val ) {
                max_val = cur_val;
                maxitem = i;
            }
            i++;
        }
    } else {
        i = 1;
        while ( i < PyTuple_GET_SIZE(v) ) {
            no_int:
            cmp = PyObject_RichCompareBool(PyTuple_GET_ITEM(v, i), PyTuple_GET_ITEM(v, maxitem), Py_GT);
            if (cmp < 0)
                goto Fail_it;
            if (cmp > 0) maxitem = i;
            i ++;
        }
    }
    if (PyErr_Occurred())
        goto Fail_it;
    Py_INCREF(PyTuple_GET_ITEM(v, maxitem));
    return PyTuple_GET_ITEM(v, maxitem);

Fail_it:
    return NULL;
}
""")     

Libr('_PyTuple_Min',
"""static PyObject * _PyTuple_Min(PyObject *);
""",
"""
static PyObject * _PyTuple_Min(PyObject *v)
{
    Py_ssize_t i;
    Py_ssize_t maxitem;
    long max_val;
    long cur_val;
    int cmp;
    
    assert(PyTuple_CheckExact(v));
    if (PyTuple_GET_SIZE(v) == 0) {
        PyErr_Format(PyExc_ValueError,
                "min() arg is an empty sequence");
        return NULL;
    }
    maxitem = 0;
        
    if (PyInt_CheckExact(PyTuple_GET_ITEM(v, 0))) {
        i = 1;
        max_val = PyInt_AS_LONG(PyTuple_GET_ITEM(v, 0));
        while ( i < PyTuple_GET_SIZE(v) ) {
            if (!PyInt_CheckExact(PyTuple_GET_ITEM(v, i))) goto no_int; 
            cur_val = PyInt_AS_LONG(PyTuple_GET_ITEM(v, i));
            if ( cur_val < max_val ) {
                max_val = cur_val;
                maxitem = i;
            }
            i++;
        }
    } else {
        i = 1;
        while ( i < PyTuple_GET_SIZE(v) ) {
            no_int:
            cmp = PyObject_RichCompareBool(PyTuple_GET_ITEM(v, i), PyTuple_GET_ITEM(v, maxitem), Py_LT);
            if (cmp < 0)
                goto Fail_it;
            if (cmp > 0) maxitem = i;
            i ++;
        }
    }
    if (PyErr_Occurred())
        goto Fail_it;
    Py_INCREF(PyTuple_GET_ITEM(v, maxitem));
    return PyTuple_GET_ITEM(v, maxitem);

Fail_it:
    return NULL;
}
""")     

Libr('_PyList_Max',
"""static PyObject * _PyList_Max(PyObject *);
""",
"""
static PyObject * _PyList_Max(PyObject *v)
{
    Py_ssize_t i;
    Py_ssize_t maxitem;
    long max_val;
    long cur_val;
    int cmp;
    
    assert(PyList_CheckExact(v));
    if (PyList_GET_SIZE(v) == 0) {
        PyErr_Format(PyExc_ValueError,
                "max() arg is an empty sequence");
        return NULL;
    }
    maxitem = 0;
        
    if (PyInt_CheckExact(PyList_GET_ITEM(v, 0))) {
        i = 1;
        max_val = PyInt_AS_LONG(PyList_GET_ITEM(v, 0));
        while ( i < PyList_GET_SIZE(v) ) {
            if (!PyInt_CheckExact(PyList_GET_ITEM(v, i))) goto no_int; 
            cur_val = PyInt_AS_LONG(PyList_GET_ITEM(v, i));
            if ( cur_val > max_val ) {
                max_val = cur_val;
                maxitem = i;
            }
            i++;
        }
    } else {
        i = 1;
        while ( i < PyList_GET_SIZE(v) ) {
            no_int:
            cmp = PyObject_RichCompareBool(PyList_GET_ITEM(v, i), PyList_GET_ITEM(v, maxitem), Py_GT);
            if (cmp < 0)
                goto Fail_it;
            if (cmp > 0) maxitem = i;
            i ++;
        }
    }
    if (PyErr_Occurred())
        goto Fail_it;
    Py_INCREF(PyList_GET_ITEM(v, maxitem));
    return PyList_GET_ITEM(v, maxitem);

Fail_it:
    return NULL;
}
""")     

Libr('_PyList_Min',
"""static PyObject * _PyList_Min(PyObject *);
""",
"""
static PyObject * _PyList_Min(PyObject *v)
{
    Py_ssize_t i;
    Py_ssize_t maxitem;
    long max_val;
    long cur_val;
    int cmp;
    
    assert(PyList_CheckExact(v));
    if (PyList_GET_SIZE(v) == 0) {
        PyErr_Format(PyExc_ValueError,
                "min() arg is an empty sequence");
        return NULL;
    }
    maxitem = 0;
        
    if (PyInt_CheckExact(PyList_GET_ITEM(v, 0))) {
        i = 1;
        max_val = PyInt_AS_LONG(PyList_GET_ITEM(v, 0));
        while ( i < PyList_GET_SIZE(v) ) {
            if (!PyInt_CheckExact(PyList_GET_ITEM(v, i))) goto no_int; 
            cur_val = PyInt_AS_LONG(PyList_GET_ITEM(v, i));
            if ( cur_val < max_val ) {
                max_val = cur_val;
                maxitem = i;
            }
            i++;
        }
    } else {
        i = 1;
        while ( i < PyList_GET_SIZE(v) ) {
            no_int:
            cmp = PyObject_RichCompareBool(PyList_GET_ITEM(v, i), PyList_GET_ITEM(v, maxitem), Py_LT);
            if (cmp < 0)
                goto Fail_it;
            if (cmp > 0) maxitem = i;
            i ++;
        }
    }
    if (PyErr_Occurred())
        goto Fail_it;
    Py_INCREF(PyList_GET_ITEM(v, maxitem));
    return PyList_GET_ITEM(v, maxitem);

Fail_it:
    return NULL;
}
""")     

Libr('_PyList_All',
"""static int _PyList_All(PyObject *);
""",
"""
static int _PyList_All(PyObject *v)
{
    Py_ssize_t i;
    int cmp;
    
    assert(PyList_CheckExact(v));
    i = 0;
    while ( i < PyList_GET_SIZE(v) ) {
        cmp = PyObject_IsTrue( PyList_GET_ITEM(v, i) );
        if (cmp < 0)
            goto Fail_it;
        if (cmp == 0) return 0;
        i ++;
    }
    if (PyErr_Occurred())
        goto Fail_it;
    return 1;

Fail_it:
    return -1;
}
""")     

Libr('_PyList_Any',
"""static int _PyList_Any(PyObject *);
""",
"""
static int _PyList_Any(PyObject *v)
{
    Py_ssize_t i;
    int cmp;
    
    assert(PyList_CheckExact(v));
    i = 0;
    while ( i < PyList_GET_SIZE(v) ) {
        cmp = PyObject_IsTrue( PyList_GET_ITEM(v, i) );
        if (cmp < 0)
            goto Fail_it;
        if (cmp == 1) return 1;
        i ++;
    }
    if (PyErr_Occurred())
        goto Fail_it;
    return 0;

Fail_it:
    return -1;
}
""")     


Libr('_PyString_Replace',
"""
static PyStringObject * 
_PyString_Replace(PyStringObject *self,
    const char *from_s, Py_ssize_t from_len,
    const char *to_s, Py_ssize_t to_len,
    Py_ssize_t maxcount);
""",
"""

/* Algorithms for different cases of string replacement */

/* len(self)>=1, from="", len(to)>=1, maxcount>=1 */
static PyStringObject * 
replace_interleave(PyStringObject *self,
                   const char *to_s, Py_ssize_t to_len,
                   Py_ssize_t maxcount)
{
    char *self_s, *result_s;
    Py_ssize_t self_len, result_len;
    Py_ssize_t count, i;
    PyStringObject *result;

    self_len = PyString_GET_SIZE(self);

    /* 1 at the end plus 1 after every character;
       count = min(maxcount, self_len + 1) */
    if (maxcount <= self_len) {
        count = maxcount;
    }
    else {
        /* Can't overflow: self_len + 1 <= maxcount <= PY_SSIZE_T_MAX. */
        count = self_len + 1;
    }

    /* Check for overflow */
    /*   result_len = count * to_len + self_len; */
    assert(count > 0);
    if (to_len > (PY_SSIZE_T_MAX - self_len) / count) {
        PyErr_SetString(PyExc_OverflowError,
                        "replace string is too long");
        return NULL;
    }
    result_len = count * to_len + self_len;
    if (! (result = (PyStringObject *)
                     PyString_FromStringAndSize(NULL, result_len)) )
        return NULL;

    self_s = PyString_AS_STRING(self);
    result_s = PyString_AS_STRING(result);

    /* TODO: special case single character, which doesn't need memcpy */

    /* Lay the first one down (guaranteed this will occur) */
    Py_MEMCPY(result_s, to_s, to_len);
    result_s += to_len;
    count -= 1;

    for (i=0; i<count; i++) {
        *result_s++ = *self_s++;
        Py_MEMCPY(result_s, to_s, to_len);
        result_s += to_len;
    }

    /* Copy the rest of the original string */
    Py_MEMCPY(result_s, self_s, self_len-i);

    return result;
}

/* Special case for deleting a single character */
/* len(self)>=1, len(from)==1, to="", maxcount>=1 */
static PyStringObject * 
_PyString_Replace_delete_single_character(PyStringObject *self,
                                char from_c, Py_ssize_t maxcount)
{
    char *self_s, *result_s;
    char *start, *next, *end;
    Py_ssize_t self_len, result_len;
    Py_ssize_t count;
    PyStringObject *result;

    self_len = PyString_GET_SIZE(self);
    self_s = PyString_AS_STRING(self);

    count = countchar(self_s, self_len, from_c, maxcount);
    if (count == 0) {
        Py_INCREF(self);
        return self;
    }

    result_len = self_len - count;  /* from_len == 1 */
    assert(result_len>=0);

    if ( (result = (PyStringObject *)
                    PyString_FromStringAndSize(NULL, result_len)) == NULL)
        return NULL;
    result_s = PyString_AS_STRING(result);

    start = self_s;
    end = self_s + self_len;
    while (count-- > 0) {
        next = findchar(start, end-start, from_c);
        if (next == NULL)
            break;
        Py_MEMCPY(result_s, start, next-start);
        result_s += (next-start);
        start = next+1;
    }
    Py_MEMCPY(result_s, start, end-start);

    return result;
}

/* len(self)>=1, len(from)>=2, to="", maxcount>=1 */

static PyStringObject * 
_PyString_Replace_delete_substring(PyStringObject *self,
                         const char *from_s, Py_ssize_t from_len,
                         Py_ssize_t maxcount) {
    char *self_s, *result_s;
    char *start, *next, *end;
    Py_ssize_t self_len, result_len;
    Py_ssize_t count, offset;
    PyStringObject *result;

    self_len = PyString_GET_SIZE(self);
    self_s = PyString_AS_STRING(self);

    count = stringlib_count(self_s, self_len,
                            from_s, from_len,
                            maxcount);

    if (count == 0) {
        /* no matches */
        Py_INCREF(self);
        return self;
    }

    result_len = self_len - (count * from_len);
    assert (result_len>=0);

    if ( (result = (PyStringObject *)
          PyString_FromStringAndSize(NULL, result_len)) == NULL )
        return NULL;

    result_s = PyString_AS_STRING(result);

    start = self_s;
    end = self_s + self_len;
    while (count-- > 0) {
        offset = stringlib_find(start, end-start,
                                from_s, from_len,
                                0);
        if (offset == -1)
            break;
        next = start + offset;

        Py_MEMCPY(result_s, start, next-start);

        result_s += (next-start);
        start = next+from_len;
    }
    Py_MEMCPY(result_s, start, end-start);
    return result;
}

/* len(self)>=1, len(from)==len(to)==1, maxcount>=1 */
static PyStringObject * 
_PyString_Replace_single_character_in_place(PyStringObject *self,
                                  char from_c, char to_c,
                                  Py_ssize_t maxcount)
{
    char *self_s, *result_s, *start, *end, *next;
    Py_ssize_t self_len;
    PyStringObject *result;

    /* The result string will be the same size */
    self_s = PyString_AS_STRING(self);
    self_len = PyString_GET_SIZE(self);

    next = findchar(self_s, self_len, from_c);

    if (next == NULL) {
        /* No matches; return the original string */
        Py_INCREF(self);
        return self;
    }

    /* Need to make a new string */
    result = (PyStringObject *) PyString_FromStringAndSize(NULL, self_len);
    if (result == NULL)
        return NULL;
    result_s = PyString_AS_STRING(result);
    Py_MEMCPY(result_s, self_s, self_len);

    /* change everything in-place, starting with this one */
    start =  result_s + (next-self_s);
    *start = to_c;
    start++;
    end = result_s + self_len;

    while (--maxcount > 0) {
        next = findchar(start, end-start, from_c);
        if (next == NULL)
            break;
        *next = to_c;
        start = next+1;
    }

    return result;
}

/* len(self)>=1, len(from)==len(to)>=2, maxcount>=1 */
static PyStringObject * 
_PyString_Replace_substring_in_place(PyStringObject *self,
                           const char *from_s, Py_ssize_t from_len,
                           const char *to_s, Py_ssize_t to_len,
                           Py_ssize_t maxcount)
{
    char *result_s, *start, *end;
    char *self_s;
    Py_ssize_t self_len, offset;
    PyStringObject *result;

    /* The result string will be the same size */

    self_s = PyString_AS_STRING(self);
    self_len = PyString_GET_SIZE(self);

    offset = stringlib_find(self_s, self_len,
                            from_s, from_len,
                            0);
    if (offset == -1) {
        /* No matches; return the original string */
        Py_INCREF(self);
        return self;
    }

    /* Need to make a new string */
    result = (PyStringObject *) PyString_FromStringAndSize(NULL, self_len);
    if (result == NULL)
        return NULL;
    result_s = PyString_AS_STRING(result);
    Py_MEMCPY(result_s, self_s, self_len);

    /* change everything in-place, starting with this one */
    start =  result_s + offset;
    Py_MEMCPY(start, to_s, from_len);
    start += from_len;
    end = result_s + self_len;

    while ( --maxcount > 0) {
        offset = stringlib_find(start, end-start,
                                from_s, from_len,
                                0);
        if (offset==-1)
            break;
        Py_MEMCPY(start+offset, to_s, from_len);
        start += offset+from_len;
    }

    return result;
}

/* len(self)>=1, len(from)==1, len(to)>=2, maxcount>=1 */
static PyStringObject * 
_PyString_Replace_single_character(PyStringObject *self,
                         char from_c,
                         const char *to_s, Py_ssize_t to_len,
                         Py_ssize_t maxcount)
{
    char *self_s, *result_s;
    char *start, *next, *end;
    Py_ssize_t self_len, result_len;
    Py_ssize_t count;
    PyStringObject *result;

    self_s = PyString_AS_STRING(self);
    self_len = PyString_GET_SIZE(self);

    count = countchar(self_s, self_len, from_c, maxcount);
    if (count == 0) {
        /* no matches, return unchanged */
        Py_INCREF(self);
        return self;
    }

    /* use the difference between current and new, hence the "-1" */
    /*   result_len = self_len + count * (to_len-1)  */
    assert(count > 0);
    if (to_len - 1 > (PY_SSIZE_T_MAX - self_len) / count) {
        PyErr_SetString(PyExc_OverflowError, "replace string is too long");
        return NULL;
    }
    result_len = self_len + count * (to_len - 1);

    if ( (result = (PyStringObject *)
          PyString_FromStringAndSize(NULL, result_len)) == NULL)
        return NULL;
    result_s = PyString_AS_STRING(result);

    start = self_s;
    end = self_s + self_len;
    while (count-- > 0) {
        next = findchar(start, end-start, from_c);
        if (next == NULL)
            break;

        if (next == start) {
            /* replace with the 'to' */
            Py_MEMCPY(result_s, to_s, to_len);
            result_s += to_len;
            start += 1;
        } else {
            /* copy the unchanged old then the 'to' */
            Py_MEMCPY(result_s, start, next-start);
            result_s += (next-start);
            Py_MEMCPY(result_s, to_s, to_len);
            result_s += to_len;
            start = next+1;
        }
    }
    /* Copy the remainder of the remaining string */
    Py_MEMCPY(result_s, start, end-start);

    return result;
}

/* len(self)>=1, len(from)>=2, len(to)>=2, maxcount>=1 */
static PyStringObject * 
_PyString_Replace_substring(PyStringObject *self,
                  const char *from_s, Py_ssize_t from_len,
                  const char *to_s, Py_ssize_t to_len,
                  Py_ssize_t maxcount) {
    char *self_s, *result_s;
    char *start, *next, *end;
    Py_ssize_t self_len, result_len;
    Py_ssize_t count, offset;
    PyStringObject *result;

    self_s = PyString_AS_STRING(self);
    self_len = PyString_GET_SIZE(self);

    count = stringlib_count(self_s, self_len,
                            from_s, from_len,
                            maxcount);

    if (count == 0) {
        /* no matches, return unchanged */
        Py_INCREF(self);
        return self;
    }

    /* Check for overflow */
    /*    result_len = self_len + count * (to_len-from_len) */
    assert(count > 0);
    if (to_len - from_len > (PY_SSIZE_T_MAX - self_len) / count) {
        PyErr_SetString(PyExc_OverflowError, "replace string is too long");
        return NULL;
    }
    result_len = self_len + count * (to_len - from_len);

    if ( (result = (PyStringObject *)
          PyString_FromStringAndSize(NULL, result_len)) == NULL)
        return NULL;
    result_s = PyString_AS_STRING(result);

    start = self_s;
    end = self_s + self_len;
    while (count-- > 0) {
        offset = stringlib_find(start, end-start,
                                from_s, from_len,
                                0);
        if (offset == -1)
            break;
        next = start+offset;
        if (next == start) {
            /* replace with the 'to' */
            Py_MEMCPY(result_s, to_s, to_len);
            result_s += to_len;
            start += from_len;
        } else {
            /* copy the unchanged old then the 'to' */
            Py_MEMCPY(result_s, start, next-start);
            result_s += (next-start);
            Py_MEMCPY(result_s, to_s, to_len);
            result_s += to_len;
            start = next+from_len;
        }
    }
    /* Copy the remainder of the remaining string */
    Py_MEMCPY(result_s, start, end-start);

    return result;
}


static PyStringObject * 
_PyString_Replace(PyStringObject *self,
    const char *from_s, Py_ssize_t from_len,
    const char *to_s, Py_ssize_t to_len,
    Py_ssize_t maxcount)
{
    if (maxcount == 0 || PyString_GET_SIZE(self) == 0) {
        /* nothing to do; return the original string */
        Py_INCREF(self);
        return self;
    }

    if (maxcount == 0 ||
        (from_len == 0 && to_len == 0)) {
        /* nothing to do; return the original string */
        Py_INCREF(self);
        return self;
    }

    /* Handle zero-length special cases */

    if (from_len == 0) {
        /* insert the 'to' string everywhere.   */
        /*    >>> "Python".replace("", ".")     */
        /*    '.P.y.t.h.o.n.'                   */
        return replace_interleave(self, to_s, to_len, maxcount);
    }

    /* Except for "".replace("", "A") == "A" there is no way beyond this */
    /* point for an empty self string to generate a non-empty string */
    /* Special case so the remaining code always gets a non-empty string */
    if (PyString_GET_SIZE(self) == 0) {
        Py_INCREF(self);
        return self;
    }

    if (to_len == 0) {
        /* delete all occurrences of 'from' string */
        if (from_len == 1) {
            return _PyString_Replace_delete_single_character(
                self, from_s[0], maxcount);
        } else {
            return _PyString_Replace_delete_substring(self, from_s, from_len, maxcount);
        }
    }

    /* Handle special case where both strings have the same length */

    if (from_len == to_len) {
        if (from_len == 1) {
            return _PyString_Replace_single_character_in_place(
                self,
                from_s[0],
                to_s[0],
                maxcount);
        } else {
            return _PyString_Replace_substring_in_place(
                self, from_s, from_len, to_s, to_len, maxcount);
        }
    }

    /* Otherwise use the more generic algorithms */
    if (from_len == 1) {
        return _PyString_Replace_single_character(self, from_s[0],
                                        to_s, to_len, maxcount);
    } else {
        /* len('from')>=2, len('to')>=1 */
        return _PyString_Replace_substring(self, from_s, from_len, to_s, to_len, maxcount);
    }
}
""", ('countchar', 'findchar', 'stringlib_find', 'stringlib_count', 'stringlib_defs'))

Libr('findchar',
"""
#define findchar(target, target_len, c)  ((char *)memchr((const void *)(target), c, target_len))     
""",
"""""")

Libr('countchar',
"""
Py_LOCAL_INLINE(Py_ssize_t)
countchar(const char *target, Py_ssize_t target_len, char c, Py_ssize_t maxcount);
""",
"""
Py_LOCAL_INLINE(Py_ssize_t)
countchar(const char *target, Py_ssize_t target_len, char c, Py_ssize_t maxcount)
{
    Py_ssize_t count=0;
    const char *start=target;
    const char *end=target+target_len;

    while ( (start=findchar(start, end-start, c)) != NULL ) {
        count++;
        if (count >= maxcount)
            break;
        start += 1;
    }
    return count;
}
""", ('findchar',))

Libr('stringlib_find',
"""
Py_LOCAL_INLINE(Py_ssize_t)
stringlib_find(const char* str, Py_ssize_t str_len,
               const char* sub, Py_ssize_t sub_len,
               Py_ssize_t offset);
""",
"""
Py_LOCAL_INLINE(Py_ssize_t)
stringlib_find(const char* str, Py_ssize_t str_len,
               const char* sub, Py_ssize_t sub_len,
               Py_ssize_t offset)
{
    Py_ssize_t pos;

    if (str_len < 0)
        return -1;
    if (sub_len == 0)
        return offset;

    pos = fastsearch(str, str_len, sub, sub_len, -1, FAST_SEARCH);

    if (pos >= 0)
        pos += offset;

    return pos;
}
""", ('fastsearch', 'stringlib_defs'))

Libr('stringlib_defs',
"""
#define STRINGLIB_IS_UNICODE     0

#define STRINGLIB_OBJECT         PyStringObject
#define STRINGLIB_CHAR           char
#define STRINGLIB_TYPE_NAME      "string"
#define STRINGLIB_PARSE_CODE     "S"
#define STRINGLIB_EMPTY          nullstring
#define STRINGLIB_ISSPACE        Py_ISSPACE

#define STRINGLIB_ISDECIMAL(x)   ((x >= '0') && (x <= '9'))
#define STRINGLIB_TODECIMAL(x)   (STRINGLIB_ISDECIMAL(x) ? (x - '0') : -1)
#define STRINGLIB_TOUPPER        Py_TOUPPER
#define STRINGLIB_TOLOWER        Py_TOLOWER
#define STRINGLIB_FILL           memset
#define STRINGLIB_STR            PyString_AS_STRING
#define STRINGLIB_LEN            PyString_GET_SIZE
#define STRINGLIB_NEW            PyString_FromStringAndSize
#define STRINGLIB_RESIZE         _PyString_Resize
#define STRINGLIB_CHECK          PyString_Check
#define STRINGLIB_CHECK_EXACT    PyString_CheckExact
#define STRINGLIB_TOSTR          PyObject_Str
#define STRINGLIB_GROUPING       _PyString_InsertThousandsGrouping
#define STRINGLIB_GROUPING_LOCALE _PyString_InsertThousandsGroupingLocale

#define STRINGLIB_WANT_CONTAINS_OBJ 1
""", '')

Libr('stringlib_count',
"""
Py_LOCAL_INLINE(Py_ssize_t)
stringlib_count(const char* str, Py_ssize_t str_len,
                const char* sub, Py_ssize_t sub_len,
                Py_ssize_t maxcount)
{
    Py_ssize_t count;

    if (str_len < 0)
        return 0; /* start > len(str) */
    if (sub_len == 0)
        return (str_len < maxcount) ? str_len + 1 : maxcount;

    count = fastsearch(str, str_len, sub, sub_len, maxcount, FAST_COUNT);

    if (count < 0)
        return 0; /* no match */

    return count;
}
""", '')

Libr('_PyDict_Iterators',
"""
static PyObject * (*_PyDict_IterItems)(PyObject *dict, PyObject * unused) = 0;
static PyObject * (*_PyDict_IterValues)(PyObject *dict, PyObject * unused) = 0;
static PyObject * (*_PyDict_IterKeys)(PyObject *dict, PyObject * unused) = 0;
static void _PyDict_Get_Iterators(void);
""",
"""
static void _PyDict_Get_Iterators(void)
{
    PyMethodDef * met = PyDict_Type.tp_methods;
    while (met->ml_name) {
        if (met->ml_name[0] == 'i') {
            if (strcmp(met->ml_name, "iteritems") == 0) {
                _PyDict_IterItems = met->ml_meth;
            } else if (strcmp(met->ml_name, "itervalues") == 0) {
                _PyDict_IterValues = met->ml_meth;
            } else if (strcmp(met->ml_name, "iterkeys") == 0) {
                _PyDict_IterKeys = met->ml_meth;
            }
        }
        met++;
    }
    assert(_PyDict_IterItems != 0);
    assert(_PyDict_IterValues != 0);
    assert(_PyDict_IterKeys != 0);
}
""")

Libr('Py2C_GetSlice',
     'static PyObject * Py2C_GetSlice(PyObject *s, Py_ssize_t i1, Py_ssize_t i2);',
     """
PyObject * Py2C_GetSlice(PyObject *s, Py_ssize_t i1, Py_ssize_t i2)
{
    assert(i1 >= 0);
    assert(i2 >= 0);
    if( PyList_CheckExact(s)) {
        return PyList_GetSlice(s, i1, i2);
    }
    if( PyTuple_CheckExact(s)) {
        return PyTuple_GetSlice(s, i1, i2);
    }
    if( PyString_CheckExact(s)) {
        char * str = PyString_AS_STRING(s);
        Py_ssize_t l = PyString_GET_SIZE(s);
        if (i1 >= l) return PyString_FromStringAndSize("", 0);
        if (i2 > l) i2 = l;
        str += i1;
        i2 -= i1;
        if (i2 < 0) i2 = 0;
        return PyString_FromStringAndSize(str, i2);
    }
    return PySequence_GetSlice(s, i1, i2);
}

""")     
     
fastglob = {}

def add_fast_glob(nm):
    fastglob[nm] = True
    
def type_methfunc(co):   
    ## if co.c_name == 'getnewlines':
        ## pp(co.method_class, co.c_name 
    if ( ( co.co_flags & (0x4 + 0x8) ) == 0):    
        if co.method_class is None:
            if co.co_argcount == 1:
                return "METH_O", False
            elif co.co_argcount == 0:
                return "METH_NOARGS", False
            return "METH_VARARGS|METH_KEYWORDS", False
        if co.method_class is not None and co.co_argcount == 0:
            return "METH_NOARGS", True
        if co.method_class is not None and co.co_argcount == 1:
            return "METH_O", True
    return "METH_VARARGS|METH_KEYWORDS", co.method_class is not None

def write_as_c(cfile, nmmodule):
    global pregenerated
    global predeclared_chars
    global restart, is_code_ext
    
    if restart:
        return 

    first = Out()
    first2 = Out()
    first2_5 = Out()
    first3 = Out() 
    first.print_to(c_head0)
    if is_code_ext:
        first.print_to("""
#define Py2CCodeObject PyCodeObject
""")
    else:
        first.print_to("""
typedef struct {
    PyCodeObject _body;
    void *co_cfunc;        /* Python code compiled to C function */
} Py2CCodeObject;""")
    first.print_to(c_head1)
##    first2.print_to(c_head2)
    first3.print_to(c_head3)
    gen_dcl_calc_reftotal(first)
    if len(fastglob) > 0:
        if not separate_global:
            s = 'enum{'
            n = 0
            li = fastglob.keys()
            li.sort()
            for k in li:

                if k in detected_global_type and IsCType(detected_global_type[k]):
                    cty = Type2CType(detected_global_type[k])
                    first3.print_to('static %s Glob_%s_%s;\n' % (cty, cty, k))
                else:    
                    if k in calculated_const:               
                        continue
                    s += 'Glob_' + k + ','
                    n += 1
            s = s[:-1] + '};\n'
            if n > 0:
                first3.print_to('PyObject * fastglob[' + str(n) + '];\n')
                first3.print_to(s)   
                first3.print_to("""#define SETSTATIC(i, value)	do { PyObject *tmp = fastglob[Glob_##i]; \
                                        fastglob[Glob_##i] = value; \
                                        Py_XDECREF(tmp); } while (0)
                                     """)   
                first3.print_to("""#define SETSTATIC2(i, value)	do { Py_XDECREF(fastglob[Glob_##i]); \
                                        fastglob[Glob_##i] = value; } while (0)
                                     """)   
                                     
                first3.print_to("""#define GETSTATIC(i)	(fastglob[Glob_##i])
                                """)            
        else:
            li = fastglob.keys()
            li.sort()
            for k in li:
                if k in detected_global_type and IsCType(detected_global_type[k]):
                    cty = Type2CType(detected_global_type[k])
                    first3.print_to('static %s Glob_%s_%s;\n' % (cty, cty, k))
                else:
                    if k in calculated_const:
                        continue
                    first3.print_to('static PyObject * Glob_%s = 0;\n' % k)
            first3.print_to("""#define SETSTATIC(i, value)	do { PyObject *tmp = Glob_##i; \
                                        Glob_##i = value; \
                                        Py_XDECREF(tmp); } while (0)
                                     """)   
            first3.print_to("""#define GETSTATIC(i)	Glob_##i
                                """)                      
    di = {}
    d_methfunc = {}
    d_cfunc = {}
    d_direct = {}
    for cmds, o, co in pregenerated:
        ## if co.c_name == '_new_popvalues':  

            ## pprint(co.__dict__)
        if not co.no_codefunc:
            if co.c_name in di:
                continue
            di[co.c_name] = 0
            if co.can_be_cfunc():
                met = type_methfunc(co)[0]
                if met == "METH_O" or met == "METH_NOARGS":
                    first3.print_to('static PyObject * cfunc_' + co.c_name +'(PyObject *, PyObject *);')
                else:
                    first3.print_to('static PyObject * cfunc_' + co.c_name +'(PyObject *, PyObject *, PyObject *);')
                if co.c_name != 'Init_filename':
                    d_methfunc["methfunc_" + co.c_name] = co.c_name
                    d_cfunc["cfunc_" + co.c_name] = co.c_name
                    first3.Raw("static PyMethodDef methfunc_", co.c_name, " = {\"", co.co_name, "\", (PyCFunction)cfunc_", co.c_name, ", ", met, ", 0};")
            else:
                first3.print_to('static PyObject * codefunc_' + co.c_name +'(PyFrameObject *);')
                Used('PyEval_Eval2CCodeEx')
        if co.c_name in direct_args and co.direct_cmds is not None   : # and direct_call and subroutine_can_be_direct(nm): 
            assert co.direct_cmds is not None                
            arg = ""
            coarg = co.co_argcount
            hidden = co.hidden_arg_direct
            typed_arg = co.typed_arg_direct
            if co.co_flags & 0x4:
                assert len(hidden) == 0
                coarg += 1
            if coarg == 0:
                arg = '(void)'
            else:    
                arg = ''
                ##i = 0
                for i in range(coarg): #while coarg > 1:
                    if i not in hidden:
                        if i in typed_arg and IsCType(typed_arg[i]):
                            arg += ', ' + Type2CType(typed_arg[i])
                        else:    
                            arg += ', PyObject *'
                    coarg -= 1
                    ## i += 1
                ## if i not in hidden:
                    ## if i in typed_arg and IsCType(typed_arg[i]):
                        ## arg += ', ' + Type2CType(typed_arg[i])
                    ## else:    
                        ## arg += ', PyObject *'
                if arg == '':
                    arg = '  void'    
                arg = '(' + arg[2:] + ')'
            if co.IsRetVoid():    
                first3.print_to('static int _Direct_' + co.c_name + arg + ';') 
            elif IsCType(co.ReturnType()):       
                if IsChar(co.ReturnType()):
                    first3.print_to('static int _Direct_' + co.c_name + arg + ';')    
                else:
                    first3.print_to(('static %s _Direct_' % Type2CType(co.ReturnType())) + co.c_name + arg + ';')    
            else:
                first3.print_to('static PyObject * _Direct_' + co.c_name + arg + ';') 
            d_direct["_Direct_" + co.c_name] = co.c_name

    to_check = {'_c_BINARY_SUBSCR_Int':' ', '_PyEval_AssignSlice':' ', 'FastCall': ' ', 'FastCall0' : ' ',
                '_PyEval_ApplySlice':'  ', '_PyEval_reset_exc_info': ' ', 'c_LOAD_NAME' : ' '}
    checked = {}

    for k, v in to_check.items():
        for cmds, o, co in pregenerated:
            for s in o:
                if name_in(k, s):
                    checked[k] = True

    for cmds, o, co in pregenerated:
        assert type(o) is Out
        first3.extend(o)

    pregenerate_code_objects()

    generate_consts(first2, first3)    

    generate_calculated_consts(first2)   
    
    generate_compiled_slots(first2) 

    generate_builtin(first2, first3)
    generate_init(first3, nmmodule)    

    if build_executable:
        Used('main')

    first3.print_to(c_tail)

    for a in used_libr:
        if IsLibr(a):
            if a not in to_check or (a in checked and checked[a]):
                first2_5.print_to(LibrDcl(a))
                first3.print_to(LibrDef(a))

    strip_unused_methfunc(list(first + first2 + first2_5 + first3), first3, d_methfunc)
    strip_unused_cfunc(list(first + first2 + first2_5 + first3), first3, d_cfunc)
    strip_unused_direct_new(list(first + first2 + first2_5 + first3), first3, d_direct)

    strip_unused_methfunc(list(first + first2 + first2_5 + first3), first3, d_methfunc)
    strip_unused_cfunc(list(first + first2 + first2_5 + first3), first3, d_cfunc)
    strip_unused_direct_new(list(first + first2 + first2_5 + first3), first3, d_direct)
            
    for s in first + first2 + first2_5 + first3:
        print_to(cfile, s)
        
def find_def(nm, o):
    first = -3
    last = -3
    for i, s in enumerate(o):
        assert type(s) is str
        if s.startswith('static ') and (s.endswith('{') or s.endswith('};')):
            if first == -3 and name_in(nm, s):
                first = i
            elif first != -3:
                last = i - 1
                break
    if last != -3:
         return (first, last)
    return None
   
def find_defs(nms_, o):
    first = -3
    cur_nm = None
    ret = []
    nms = nms_.copy()
    for i, s in enumerate(o):
        assert type(s) is str
        if s.startswith('static ') and (s.endswith('{') or s.endswith('};')):
            if cur_nm is not None:
                ret.append((first, i-1, cur_nm))
                first = -3
                del nms[cur_nm]
                cur_nm = None
            for nm in nms.keys():
                if name_in(nm, s):
                    first = i
                    cur_nm = nm
                    break
    return ret
 
## def name_in___(k, s):
    ## assert type(s) is str
    ## assert type(k) is str
    ## isname = False
    ## begname = 0
    ## endname = 0
    ## beg = k[0]
    ## end = k[-1]
    ## for i,c in enumerate(s):
        ## if not isname:
            ## if (c.isalpha() or c == '_'):
                ## isname = True
                ## begname = i
            ## else:
                ## continue
        ## else:
            ## if c.isalpha() or c == '_' or c.isdigit():
                ## continue
            ## else:
                ## isname = False
                ## endname = i
                ## if (endname - begname) == len(k) and s[begname] == beg and s[endname-1] == end and s.startswith(k, begname):
                    ## return True
    ## return False

def name_in(k, s):
    assert type(s) is str
    assert type(k) is str

    cnt = s.count(k)
    if cnt == 0:
        return False
    beg = 0
    for i in range(cnt):
        pos = s.find(k, beg)
        if pos < 0:
            return False
        pos_end = pos+len(k)
##    assert type(pos_end) is int
        if pos > 0:
            cbeg = s[pos-1]
        else:
            cbeg = ' '
        if pos_end < len(s):
            cend = s[pos_end]
        else:
            cend = ' '
        if cbeg.isdigit() or cbeg.isalpha() or cbeg == '_' or cend.isdigit() or cend.isalpha() or cend == '_':
            beg = pos_end
            continue
        return True
    return False

def strip_unused_methfunc(all, first3, d_del):
    d_del = d_del.copy()
    for s in all:
       assert type(s) is str
       if not s.startswith("static PyMethodDef methfunc_") and 'methfunc_' in s:
           for k,v in d_del.items()[:]:
               if name_in(k, s):
                   del d_del[k]
    if len(d_del) == 0:
        return                   
    for i, s in enumerate(first3):
        assert type(s) is str
        if s.startswith("static PyMethodDef methfunc_"):
            for k,v in d_del.items()[:]:
                if name_in(k, s):
                    first3[i] = ''
                        
def strip_unused_cfunc(all, first3, d_del):
    d_del = d_del.copy()
    for s in all:
        assert type(s) is str
        if not s.startswith("static PyObject * cfunc_") and 'cfunc_' in s:
           for k,v in d_del.items()[:]:
               if name_in(k, s):
                   del d_del[k]  
    if len(d_del) == 0:
        return
    for i, s in enumerate(first3):
        assert type(s) is str
        if s.startswith("static PyObject * cfunc_") and s.endswith(';'):
            for k,v in d_del.items()[:]:
               if name_in(k, s):
                    first3[i] = ''
    for k,v in d_del.items()[:]:
        rng = find_def(k, first3)
        if rng is not None:
            del first3[rng[0]:rng[1]+1] 
 
def strip_unused_direct_new(all, first3, d_del):
    assert type(d_del) is dict
    assert type(all) is list
    d_de = d_del.items()
    li = [i for i, s in enumerate(all) if type(s) is str and "_Direct_" in s and not s.startswith("static ")]
    assert type(d_de) is list
    rngs = find_defs(d_del, all)
    rngs.sort()
    while len(rngs) > 0:
        rng = rngs[-1]
        del rngs[-1]
        k = rng[2]
        assert type(k) is str
        for i1 in li:
            assert type(i1) is int and i1 >= 0
            s = all[i1]
            assert type(s) is str
            if i1 >= rng[0] and i1 <= rng[1]:
                continue
            if not s.startswith("static "):
               if k in s and name_in(k, s) and k in d_del:
                   del d_del[k] 
                   break 
    if len(d_del) == 0:
        return
    for i, s in enumerate(first3):
        assert type(s) is str
        if s.startswith("static ") and "_Direct_" in s and s.endswith(';'):
            for k,v in d_del.items()[:]:
               if name_in(k, s):
                    first3[i] = ''
    for k,v in d_del.items()[:]:
        rng = find_def(k, first3)
        if rng is not None:
            del first3[rng[0]:rng[1]+1] 
 
def generate_init(first3, nmmodule):
    global labl, is_code_ext
    if not build_executable:
        if c_name is None:
            first3.print_to('PyMODINIT_FUNC init' + nmmodule+'(void);')
            first3.print_to('PyMODINIT_FUNC init' + nmmodule+'(void){')
        else:
            first3.print_to('PyMODINIT_FUNC init' + c_name+'(void);')
            first3.print_to('PyMODINIT_FUNC init' + c_name+'(void){')
    else:    
        first3.print_to('static void init_main(void);')
        first3.print_to('static void init_main(void){')
    if not is_code_ext:
        if IsUsedLibr('Py2CCodeObject'):
            first3.print_to('    patch_Py2CCode();')
        if IsUsedLibr('Py2CFunction'):
            first3.print_to('    patch_Py2CFunction();')
    if 'Py2CFunction_NewEx' in used_libr:
        first3.print_to('    Py2CFunction_init();')
    if 'Py2CFunction_NewFull' in used_libr:
        first3.print_to('    Py2CFunction_init_full();')
    first3.print_to('    b = PyImport_AddModule("__builtin__");')
    first3.print_to('    bdict = PyModule_GetDict(b);')
    if len(loaded_builtin) > 0:
        first3.print_to('    load_builtin();')
    first3.print_to('    init_consts();')
    co = _n2c['Init_filename']
    if co.can_be_cfunc():
        first3.print_to('    PyImport_Init_Module(\"' + nmmodule +'", '  +const_to(co.co_filename) +');')
        first3.print_to('    PyDict_SetItemString(glob, \"__compile_hash__\", PyInt_FromString(\"' + str(hash_compile) + '\", NULL, 0));')
        Used('PyImport_Init_Module')
    elif c_name is None:
        if build_executable:
            first3.INCREF(const_to(co))
            first3.print_to('    PyImport_Exec2CCodeModuleEx(\"__main__", '  +const_to(co) +');')
            gen_print_calc_reftotal(first3)
            
            li = fastglob.keys()
            li.sort()
            for k in li:
                if k in detected_global_type and IsCType(detected_global_type[k]):
                    continue 
                if k in calculated_const:               
                    continue
                first3.Raw('Py_CLEAR( GETSTATIC(', k, ') );')
                
            li = [(obj.no, obj.nm, obj) for k, obj in calculated_const.items()]
            li.sort()
            prev_i = -1
            for i, k, obj in li:
                if prev_i == i:
                    continue
                if obj.generate:
                    if IsCType(TypeExpr(('!LOAD_GLOBAL', k))) and not redefined_all and (build_executable and fast_globals):
                        continue

                    if type(k) is str:
                        first3.Raw('Py_CLEAR( calculated_const_', k, ' );')
                    else:
                        first3.Raw('Py_CLEAR( calculated_const_', str(i), ' );')
                prev_i = i  
            first3.Raw('PyDict_Clear(glob);')

            first3.Raw('{')
            first3.Raw('int i;')
            first3.Raw('for(i = 0; i < ', len(consts), '; i++) {')
            first3.Raw('Py_CLEAR( consts[i] );')
            first3.Raw('}')
            
            if hasattr(sys, 'gettotalrefcount'):
                first3.append('{')
                first3.Raw('FILE * _refs = fopen(\"all_final\", \"w+\");')
                first3.Raw('_Py_PrintReferences(_refs);')   
                first3.Raw('fclose(_refs);')     
                first3.append('}')                
            first3.Raw('}')
           
        else:
            if package is not None and package != '':
                first3.print_to('    package = "' + package + '";')
                nmmodule = package + '.' + nmmodule
            if absfilename is not None and absfilename != '':
                first3.print_to('    absfilename = "' + absfilename + '";')
            first3.print_to('    PyImport_Exec2CCodeModuleEx(\"' + nmmodule +'", '  +const_to(co) +');')
        first3.print_to('    PyDict_SetItemString(glob, \"__compile_hash__\", PyInt_FromString(\"' + str(hash_compile) + '\", NULL, 0));')
        Used('PyImport_Exec2CCodeModuleEx')
    else:
        _cname = c_name
        if package is not None and package != '':
            first3.print_to('    package = "' + package + '";')   
            _cname = package + '.' + _cname 
        if absfilename is not None and absfilename != '':
            first3.print_to('    absfilename = "' + absfilename + '";')            
        first3.print_to('    PyImport_Exec2CCodeModuleEx(\"' + _cname +'", '  +const_to(co) +');')
        first3.print_to('    PyDict_SetItemString(glob, \"__compile_hash__\", PyInt_FromString(\"' + str(hash_compile) + '\", NULL, 0));')
        Used('PyImport_Exec2CCodeModuleEx')
    first3.print_to('}')

predefined_c = set(('SCHAR_MIN', 'SCHAR_MAX', 'UCHAR_MAX', 'CHAR_MIN', 'CHAR_MAX', 'MB_LEN_MAX', 'SHRT_MIN', 
                    'SHRT_MAX', 'USHRT_MAX', 'INT_MIN', 'INT_MAX', 'UINT_MAX', 'LONG_MIN', 'LONG_MAX',
                    'ULONG_MAX', '_I64_MIN', '_I64_MAX', '_UI64_MAX', 'errno', 'EOF', 'SIGALRM', 'SIG_DFL', 'NULL'))
    
def nmvar_to_loc(v):
    assert type(v) is str
    if '(' in v or ')' in v or '[' in v or ']' in v or '.' in v or '-' in v or '+' in v or ' ' in v:
        v = v.replace('[', '_1_')    
        v = v.replace(']', '_9_')            
        v = v.replace('(', '_2_')    
        v = v.replace(')', '_7_')            
        v = v.replace('.', '_5_')    
        v = v.replace('-', '_6_') 
        v = v.replace('+', '_8_') 
        v = v.replace(' ', '_3_') 
    if v in predefined_c:
        v = v + '_not_define'
    return v

def generate_stand_header(l, co, typed, o, typed_local, isdirect, hidden):
    global no_fastlocals
    assert type(co) is code_extended
    orepr = no_comment_o(o)
    for i,(f,t) in enumerate(typed):
        nm = t + '_' + str(i)
        if t != 'label' and t != 'longref' and nm in orepr:
            orepr = may_be_append_to_o(l, orepr, t, nm, o)
    cnt = 0
    if not isdirect or not no_fastlocals:
        s = 'enum{' 
        if isdirect:
            names = co.co_varnames_direct
        else:
            names = co.co_varnames    
        for v in names:        
            if co.IsCVar(('FAST', v)) or v in hidden:
                if isdirect:
                    continue
                else:
                    v += '_missing_'
            if s != 'enum{':
                s += ', '
            v = nmvar_to_loc(v)
            s += 'Loc_' + v 
            cnt += 1
        s += '};'
        if s != 'enum{};':
            l.append(s)  
    for k, v in typed_local.items():
        if IsCType(v):
            ty = Type2CType(v)
            cnm = 'Loc_%s_%s' %(ty, k)
            orepr = may_be_append_to_o(l, orepr, ty, cnm, o)
    return cnt    

def no_comment_o(o):
    li = [x for x in o if type(x) is str and not x.startswith('/*')]
    return '\n'.join(li)    
   
def may_be_append_to_o(l, orepr, ty, cnm, o, debug = False):
    assert type(o) is Out
    assert type(cnm) is str
    assert type(orepr) is str
    if cnm in orepr:
        cnm2 = (cnm + ' = ' + cnm + ';')
        updated = False
        for i, oi in enumerate(o):
            assert type(oi) is str
            if oi.startswith('/*'):
                continue
            if oi == cnm2:
                o[i] = ''
                updated = True
        if updated:
            o[:] = [x for x in o if x != '']
            orepr = no_comment_o(o)
    assert type(orepr) is str
    if cnm in orepr:               
        if orepr.count(cnm) == orepr.count(cnm + ' = '):
            for i in range(len(o)):
                oi = o[i]
                assert type(oi) is str
                if oi.startswith('/*'):
                    continue                
                if (cnm + ' = ') in oi:
                    oi = oi.replace(cnm + ' = ', '')
                    o[i] = oi
                    assert type(oi) is str
                    if oi.startswith('( (') and oi.endswith(') );'):
                        o[i] = oi[2:-3] + ';'
                    if 'goto ' in oi and oi.startswith('if'):
                        pass
                    elif oi.startswith('if') and (oi.endswith(' break;') or oi.endswith(' continue;')) :
                        pass
                    elif ' = ' not in oi:
                        if oi in ('0;', '1;', '-1;', 'Py_NAN;', 'Py_HUGE_VAL;'):
                            o[i] = ''
                        elif oi.startswith('( Py_ssize_t_') and oi.endswith(' );'):
                            o[i] = ''
                        elif oi.startswith('( long_') and oi.endswith(' );'):
                            o[i] = ''
                        elif oi.startswith('( longref_') and oi.endswith(' );'):
                            o[i] = ''
                        elif oi.startswith('longref_') and oi.endswith('];'):
                            tmp_oi = oi[8:-2].split('[')
                            if len(tmp_oi) == 2 and tmp_oi[0].isdigit() and tmp_oi[1].startswith('int_') and tmp_oi[1][4:].isdigit():
                                o[i] = ''
                        elif oi.startswith('( int_') and oi.endswith(' );'):
                            o[i] = ''
                        elif oi.startswith('Loc_') and oi.endswith(';') and ' ' not in oi and '(' not in oi and ')' not in oi:
                            o[i] = ''
                        elif oi.startswith('\'') and oi.endswith('\';'):
                            o[i] = ''
                        elif oi[0].isdigit():
                            o[i] = ''
                        elif oi.startswith('(c_Py_EQ_String(') and oi.endswith(']));'):
                            o[i] = ''
                        elif oi.startswith('-') and oi.endswith(';') and oi[1:-1].replace('.', '').isdigit():
                            o[i] = ''
                        elif len(oi) > 1 and oi.endswith(';') and oi[0:-1].replace('.', '').isdigit():
                            o[i] = ''
                        elif oi.startswith('PyObject_IsTrue(temp[') and oi.endswith(']);'):
                            o[i] = ''
                        elif oi.startswith('PyInt_AsLong(temp[') and oi.endswith(']);'):
                            o[i] = ''
                        elif oi.startswith('PyInt_AS_LONG ( GETLOCAL(') and oi.endswith(';'):
                            o[i] = ''
                        elif oi.startswith('( PyInt_AS_LONG ( GETLOCAL(') and oi.endswith(' );'):
                            o[i] = ''
                        elif oi.startswith('PyFloat_AsDouble(temp[') and oi.endswith(']);'):
                            o[i] = ''      
                        elif oi.startswith('PyFloat_AS_DOUBLE ( temp[') and oi.endswith('] );'):
                            o[i] = ''      
                        elif oi.startswith('PyString_AS_STRING ( temp[') and oi.endswith('] );'):
                            o[i] = ''
                        elif oi.startswith('*PyString_AS_STRING ( temp[') and oi.endswith('] );'):
                            o[i] = ''
                        elif oi.startswith('int_') and oi.endswith(';') and oi[4:-1].isdigit():
                            o[i] = ''
                        elif oi.startswith('long_') and oi.endswith(';') and oi[5:-1].isdigit():
                            o[i] = ''
                        elif oi.startswith('Py_ssize_t_') and oi.endswith(';') and oi[11:-1].isdigit():
                            o[i] = ''
                        elif oi.startswith('-') and oi.endswith(';') and oi[1:-1].isdigit():
                            o[i] = ''
                        elif oi in ('LONG_MIN;', 'LONG_MAX;'):
                            o[i] = ''
                        elif 'PyInt_FromLong ( longref' in oi:
                            pass
                        elif oi.startswith('PyInt_AS_LONG ( ') and oi.endswith(' );'):
                            oi = oi[16:-3] + ';'
                            if oi.startswith('consts[') and oi.endswith('];'):
                                o[i] = ''
                            o[i] =oi
                        elif oi.startswith('(PyTuple_GET_SIZE(') and oi.endswith('));'):
                            oi = oi[18:-3] + ';'
                            if oi.startswith('consts[') and oi.endswith('];'):
                                oi = ''
                            elif oi.startswith('GETLOCAL'):
                                oi = ''
                            elif oi.startswith('temp['):
                                oi = ''
                            else:
                                pp(o[i], 'o[i]', '12345678')
                                Fatal(o[i])     
                                assert False
                            o[i] = oi
                        elif ( oi.startswith('(long_') or oi.startswith('(Py_ssize_t_') ) and oi.endswith(');') and \
                             (' + ' in oi or ' - ' in oi or ' > ' in oi or ' < ' in oi or ' == ' in oi or ' >= ' in oi or ' <= ' in oi) \
                             and ')' not in oi[1:-2] and '(' not in oi[1:-2]:
                            o[i] = ''
                        else:
                            pp(o[i], 'o[i]', '12345678')
                    else:
                        if 'PyInt_FromLong ( longref' in oi:
                            pass    
                        elif ' = ( longref' in oi:
                            pass  
                        elif ' = longref' in oi:
                            pass                                                  
                        else:
                            pp(oi, 'o[i]', '12345678')
            o[:] = [x for x in o if x != '']
            orepr = no_comment_o(o)

        if name_in(cnm, orepr):
            l.append(ty + ' ' + cnm + ';')
    return orepr
            
            
def call_parse_arguments(o, co, defaul):
    global labl
    assert type(co) is code_extended
    o.Raw('if ( parse_arguments (self, args, kw, ', const_to(co), ', ', defaul, ', fastlocals) == -1) goto ', labl, ';')
    UseLabl()
    Used('parse_arguments')
    
def generate_parse_cfunc_args(co, cntvar, o, cntarg, ismeth):
    global labl

    assert labl is not None
    assert type(labl) is tuple
    ismeth = False
    defa = None
    if co.c_name in default_args:
        defa = default_args[co.c_name]
    if defa == ('CONST', ()):
        defa = None
    ## attempt = attempt_direct_type_generation(('CFUNC_PARSE_ARGS', ('CONST', cntvar), ('CONST', cntarg), defa, ('CONST', co.c_name)), o, None)
    ## if attempt is not None:
        ## pprint(o)
        ## return   
    if defa is not None:
        if defa[0] == 'CONST':
            defaul = defa
            defa = tuple([('CONST', x) for x in defa[1]])
        else:
            defaul = 'GETSTATIC(' + co.default_args_nm() + ')'
            defa = defa[1]       # BUILD_TUPLE         
    else:
        defaul = 'NULL'
    assert co.co_cellvars is None or len(co.co_cellvars) == 0
    if ( ( co.co_flags & (0x4 + 0x8) ) == 0):
        o.Raw(cntarg, ' = PyTuple_GET_SIZE(args);')
        if defa is None:
            o.Raw('if (kw == 0) {')
            if not ismeth:
                o.Raw('if ( ', cntarg, ' != ', co.co_argcount, ' ) {')
            else:
                o.Raw('if ( ', cntarg, ' != ', co.co_argcount-1, ' ) {')
            if co.co_argcount != 1:
                o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes exactly ", co.co_argcount, " arguments (%d given)\", ", cntarg, ');')
            else:
                o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes exactly ", co.co_argcount, " argument (%d given)\", ", cntarg, ');')
            o.Raw('goto ', labl, ';')
            UseLabl()
            o.Raw('}')

            if not ismeth:
                for i in range(co.co_argcount):
                    o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i, ');')
                    o.Raw('Py_INCREF(fastlocals[', i, ']);')
            else:
                for i in range(co.co_argcount):
                    if i == 0:
                        o.Raw('fastlocals[', i, '] = self;')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    else:
                        o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i-1, ');')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
            o.Raw('} else {')
            if not ismeth:
                o.Raw('    static char *kwlist[] = {', ', '.join(['"' + co.co_varnames[i] + '"' for i in range(co.co_argcount)] + ['NULL']), '};')
                listargs = ' , '.join(['fastlocals+' + str(i) for i in range(co.co_argcount)])
                form = ''.join(['O' for i_0 in range(co.co_argcount)])                
            else:
                i = 0
                o.Raw('    static char *kwlist[] = {', ', '.join(['"' + co.co_varnames[i] + '"' for i in range(1, co.co_argcount)] + ['NULL']), '};')
                listargs = ' , '.join(['fastlocals+' + str(i) for i in range(1, co.co_argcount)])
                form = ''.join(['O' for i in range(1, co.co_argcount)])                
                o.Raw('fastlocals[', i, '] = self;')
                o.Raw('Py_INCREF(fastlocals[', i, ']);')
            o.Raw('if ( !PyArg_ParseTupleAndKeywords ( args , kw , \"', form, '\" , kwlist , ', listargs, ' ) ) goto ', labl, ';')
            o.Raw('}')
        else:
            minarg = co.co_argcount - len(defa)
            assert minarg >= 0
            o.Raw('if (kw == 0) {')
            if not ismeth:
                o.Raw('if ( ', cntarg, ' < ', minarg, ' ) {')
                if minarg != 1:
                    o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes at least ", minarg, " arguments (%d given)\", ", cntarg, ');')
                else:
                    o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes at least ", minarg, " argument (%d given)\", ", cntarg, ');')
            else:
                o.Raw('if ( ', cntarg, ' < ', minarg-1, ' ) {')
                if minarg != 0:
                    o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes at least ", minarg, " arguments (%d given)\", ", cntarg, ');')
                else:
                    o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes at least ", minarg, " argument (%d given)\", ", cntarg, ');')
            o.Raw('goto ', labl, ';')
            UseLabl()
            o.Raw('}')
            
            for i in range(co.co_argcount):
                if i < minarg:
                    if not ismeth:
                        o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i, ');')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    elif i == 0:
                        o.Raw('fastlocals[', i, '] = self;')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    else:
                        o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i-1, ');')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
                else:
                    if not ismeth:
                        o.Raw('if ( ', i, ' < ', cntarg, ' ) {')
                        o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i, ');')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    else:
                        if i == 0:
                            o.Raw('fastlocals[', i, '] = self;')
                            o.Raw('Py_INCREF(fastlocals[', i, ']);')
                        else:
                            o.Raw('if ( ', i, ' < ', cntarg, ' ) {')
                            o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i-1, ');')
                            o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    o.Raw('} else {')
                    if not ismeth:
                        assert (i-minarg) >= 0
                    edefa = defa[i-minarg]
                    if edefa[0] == 'CONST':
                        o.Raw('fastlocals[', i, '] = ', edefa, ';')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')
                    else:
                        o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM ( GETSTATIC(', co.default_args_nm(), ') , ', i-minarg, ');')
                        o.Raw('Py_INCREF(fastlocals[', i, ']);')                        
                    o.Raw('} ')
            o.Raw('} else {')
            call_parse_arguments(o, co, defaul)
            o.Raw('}')
        o.Cls(cntarg)
        return


    if ( ( co.co_flags & (0x4 + 0x8) ) == 0x4):
        defa = None
        if co.c_name in default_args:
            defa = default_args[co.c_name]
        if defa == ('CONST', ()):
            defa = None
        if defa is None:
            if cntarg is not None:
                o.Raw(cntarg, ' = PyTuple_GET_SIZE(args);')
            o.Raw('if (kw == 0) {')
            if co.co_argcount > 0:
                o.Raw('if ( ', cntarg, ' < ', co.co_argcount, ' ) {')
                if co.co_argcount != 1:
                    o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes at least ", co.co_argcount, " arguments (%d given)\", ", cntarg, ');')
                else:
                    o.Raw("PyErr_Format(PyExc_TypeError, \"", co.co_name, "() takes at least ", co.co_argcount, " argument (%d given)\", ", cntarg, ');')
                o.Raw('goto ', labl, ';')
                UseLabl()
                o.Raw('}')
    
            for i in range(co.co_argcount):
                o.Raw('fastlocals[', i, '] = PyTuple_GET_ITEM (args, ', i, ');')
                o.Raw('Py_INCREF(fastlocals[', i, ']);')
            o.Raw('fastlocals[', co.co_argcount, '] = PySequence_GetSlice ( args , ', co.co_argcount , ', PY_SSIZE_T_MAX );')
            o.Raw('} else {')
            call_parse_arguments(o, co, defaul)
            o.Raw('}')
            return
        else:
            call_parse_arguments(o, co, defaul)
            return            
    Fatal('Unhandeled cfunc', co)
    assert False
    
def generate_cfunc_header(nm, o, co, typed, typed_local):
    global tempgen
    assert type(o) is Out
    assert type(co) is code_extended
    l = Out()
    l.append('') 
    to_count_arg = None
    met, ismeth = type_methfunc(co)
    have_fastlocal = False
    for s in o:
       if name_in('GETLOCAL', s):
            have_fastlocal = True
            break
    if not have_fastlocal:
        for s in o:
            if name_in('SETLOCAL', s):
                    have_fastlocal = True
                    break
            ## if name_in('SETLOCAL2', s):
                    ## have_fastlocal = True
                    ## break
            if name_in('LETLOCAL', s):
                    have_fastlocal = True
                    break
    ## attempt = attempt_direct_type_generation(('CHEAD_' + met, ('CONST', nm), ('CONST', ismeth), ('CONST', have_fastlocal), ('CONST', co), ('CONST', tuple(typed)), ('CONST', tuple(typed_local.items()))), l, None)
    ## if attempt is not None:
        ## pprint(l)
        ## return       

    if met == "METH_NOARGS":
        l.append('static PyObject * cfunc_' + nm +'(PyObject * self, PyObject * UNUSED) {')
    elif met == "METH_O" or met == "METH_NOARGS":
        l.append('static PyObject * cfunc_' + nm +'(PyObject * self, PyObject * args) {')
    else:
        l.append('static PyObject * cfunc_' + nm +'(PyObject * self, PyObject * args, PyObject *kw) {')
        if have_fastlocal: # and ( ( co.co_flags & (0x4 + 0x8) ) == 0)
            if ( ( co.co_flags & (0x4 + 0x8) ) != 0x4) or co.co_argcount != 0:
                defa = None
                if co.c_name in default_args:
                    defa = default_args[co.c_name]
                if defa == ('CONST', ()):
                    defa = None   
                if defa is not None and ( ( co.co_flags & (0x4 + 0x8) ) == 0x4):
                    pass
                else:
                    l.append('int len_args = 0;')
                    to_count_arg = 'len_args'
    cntvar = generate_stand_header(l, co, typed, o, typed_local, False, {})
    if line_number:
        l.Raw('int PyLine = ', co.co_firstlineno, ';')     
        l.append('int PyAddr = 0;')           
    if len(co.co_cellvars + co.co_freevars) > 0:
        Fatal("Can\'t make cfunc with cellvars & freevars") 
        assert False
        return None

    if have_fastlocal:
        l.Raw('PyObject *fastlocals[', cntvar, '];')
    if is_current & IS_DICTIONABLE_CFUNC:
        if nm != 'Init_filename':
            l.Raw('PyObject *_f_locals;')
    is_tstate = False
    for s in o:
        assert type(s) is str
        if not s.startswith('/*') and name_in('tstate', s):
            is_tstate = True 
            break   
    if is_tstate:
        l.append('PyThreadState * tstate;')
    if is_current & IS_DICTIONABLE_CFUNC and nm != 'Init_filename':
        l.Raw('_f_locals = PyDict_New();')        
    dicts_used = co.dict_getattr_used
    assert type(dicts_used) is dict
    if not redefined_attribute:
        for k in dicts_used.iterkeys():
            l.Raw('PyObject *_', k, '_dict = 0;')
    if calc_ref_total:
        l.append('Py_ssize_t l_Py_RefTotal;')
        l.append('Py_ssize_t l_Py_RefTotal_Printed;')
    if is_tstate:
        l.append('tstate = PyThreadState_GET();')
    l_fast = Out()
    if nm == 'Init_filename':
        if False:
            l_fast.Raw('glob = PyObject_GetAttrString((PyObject *)f, "f_locals");')
        else:
            l_fast.Raw('glob = f->f_locals;')
    l_fast = Out()
    if have_fastlocal:            
        if met == "METH_NOARGS":
            for i in range(cntvar):
                l_fast.append('fastlocals[' + str(i) + '] = 0;')
        elif met == "METH_O" or met == "METH_NOARGS":
            l_fast.append('fastlocals[0] = args;')
            l_fast.append('Py_INCREF(fastlocals[0]);')
            for i in range(1, cntvar):
                l_fast.append('fastlocals[' + str(i) + '] = 0;')
        else:
            for i in range(cntvar):
                l_fast.append('fastlocals[' + str(i) + '] = 0;')
            generate_parse_cfunc_args(co, cntvar, l_fast, to_count_arg, ismeth)
    if len(tempgen) != 0:
        l.Raw('PyObject * temp[', max(1, len(tempgen)), '];')
        for i in range(len(tempgen)):
            l.append('temp[' + str(i) + '] = 0;')
    l.extend(l_fast)
    l_fast = None
    if not redefined_attribute:
        for k in dicts_used.iterkeys():
                l.append('if (PyInstance_Check(GETLOCAL(%s))) {' % k)
                l.append('_%s_dict = ((PyInstanceObject *)GETLOCAL(%s))->in_dict;' %(k,k))
                l.append('} else {')
                l.append('PyObject **refdict = _PyObject_GetDictPtr(GETLOCAL(%s));' %k)
                l.append('if (refdict && *refdict) _%s_dict = *refdict;' %k )
                l.append('}')
    if calc_ref_total:
        l.append('l_Py_RefTotal = _Py_RefTotal;')
        l.append('l_Py_RefTotal_Printed = _Py_RefTotal_Printed;')
    l.Raw('')        
    l.extend(o)
    o[:] = l[:]   
    cnt_temp = 0
    for s in o:
        if 'temp[' in s or 'CLEARTEMP(' in s:
            cnt_temp += 1
    if cnt_temp == 1:
        for i in range(len(o)):
            if o[i].startswith('PyObject * temp['): 
                del o[i]
                break
    return   

def detect_len_temp(o):
    i = -1
    assert type(o) is Out
    for s in o:
        assert type(s) is str
        if s.startswith('CLEARTEMP(') and s.endswith(');'):
            i = max(i, int(s[+10:-2]))
        if 'temp[' in s:
            l = s.split('temp[')
            for j in range(len(l)):
                if j > 0 and (len(l[j-1]) == 0 or (not l[j-1][-1].isalnum() and l[j-1][-1] != '_')):
                    if ']' in l[j]:
                        vv = l[j].split(']')[0]
                        assert type(vv) is str
                        if vv.isdigit():
                            i = max(i, int(vv))
    return i

def generate_header(nm, o, co, typed, typed_local):
    global tempgen
    assert type(o) is Out
    assert type(co) is code_extended
    l = Out()
    l.append('')        

    l.append('static PyObject * codefunc_' + nm +'(PyFrameObject *f) {')
    cntvar = generate_stand_header(l, co, typed, o, typed_local, False, {})
    
    have_temp = False
    if co.co_stacksize != 0:
        for s in o:
            assert type(s) is str
            if ('CLEARTEMP' in s or 'temp[' in s) and not s.startswith('/*'):
                have_temp = True
        for k in co.to_exception.keys():
            for s in k:
                assert type(s) is str
                if ('CLEARTEMP' in s or 'temp[' in s) and not s.startswith('/*'):
                    have_temp = True

        if False:    
            l.Raw('PyObject * temp[', co.co_stacksize, '];')
        else:
            if have_temp:
                l.append('PyObject ** temp;')

    co.have_temp = have_temp
    sfree = 'enum{' + ', '.join(['Loc2_' + nmvar_to_loc(v) for v in co.co_cellvars + co.co_freevars]) + '};'
    have_fastlocal = False
    if sfree != 'enum{};':
        l.Raw(sfree)  
        l.append('register PyObject **fastlocals, **freevars;')
        have_fastlocal = True
        assert True
    else:    
        sfree = None
        if cntvar != 0:
            for s in o:
                assert type(s) is str
                if 'LOCAL' in s and not s.startswith('/*'):
                    have_fastlocal = True
            if have_fastlocal:
                if True:
                    l.append('register PyObject **fastlocals;')
                else:
                    l.append('PyObject *fastlocals[' + str(cntvar) + '];')
    if True:
        l.append('PyThreadState * tstate = PyThreadState_GET();')
    dicts_used = co.dict_getattr_used
    assert type(dicts_used) is dict
    if not redefined_attribute:
        for k in dicts_used.iterkeys():
            l.Raw('PyObject *_', k, '_dict = 0;')
    if calc_ref_total:
        l.append('Py_ssize_t l_Py_RefTotal;')
        l.append('Py_ssize_t l_Py_RefTotal_Printed;')
    if nm == 'Init_filename':
        if False:
            l.Raw('glob = PyObject_GetAttrString((PyObject *)f, "f_locals");')
        else:
            l.Raw('glob = f->f_locals;')
    l.append('if (f == 0) return NULL;')
    if check_recursive_call:
        l.append('if (Py_EnterRecursiveCall("")) return NULL;')
    if True:
        l.append('tstate->frame = f;')
    if sfree is not None or cntvar != 0:
        if have_fastlocal:
            if False:
                pass
            else:
                l.append('fastlocals = f->f_localsplus;')
    if sfree is not None:
        l.append('freevars = fastlocals + f->f_code->co_nlocals;')
    cnt = 0
    if co.co_stacksize != 0:
        if have_temp:    
            l.append('temp = f->f_stacktop;')
            l.append('assert(temp != NULL);')

        cnt = detect_len_temp(o)
        for i in range(cnt+1):
            l.append('temp[' + str(i) + '] = 0;')
            co.co_stacksize = i+1
            co.new_stacksize = i+1
    if True:
        l.append('f->f_stacktop = NULL;')
    if not redefined_attribute:
        for k in dicts_used.iterkeys():
                l.append('if (PyInstance_Check(GETLOCAL(%s))) {' % k)
                l.append('_%s_dict = ((PyInstanceObject *)GETLOCAL(%s))->in_dict;' %(k,k))
                l.append('} else {')
                l.append('PyObject **refdict = _PyObject_GetDictPtr(GETLOCAL(%s));' %k)
                l.append('if (refdict && *refdict) _%s_dict = *refdict;' %k )
                l.append('}')
    if calc_ref_total:
        l.append('l_Py_RefTotal = _Py_RefTotal;')
        l.append('l_Py_RefTotal_Printed = _Py_RefTotal_Printed;')
    l.Raw('')  
    if co.co_flags & CO_GENERATOR:
        assert len(co.yield_labels) > 1
        l.Raw('switch(f->f_lasti) {')
        for la, tag in co.yield_labels:
            l.Raw('case ', tag, ': goto ', la, ';')
        l.Raw('default: assert(2>3);')
        l.Raw('}')

    l.extend(o)
    o[:] = l[:]         
    return cnt  

def generate_from_frame_to_direct_stube(co, o, nm, cmds):
    assert type(o) is Out
    l = Out()
    l.append('')        

    l.append('static PyObject * codefunc_' + nm +'(PyFrameObject *f) {')
    cntvar = generate_stand_header(l, co, [], o, {}, False, {})
    s = 'enum{' + ', '.join(['Loc2_' + nmvar_to_loc(v) for v in co.co_cellvars + co.co_freevars]) + '};'

    if s != 'enum{};':
        l.append(s)
        
    arg = ""
    coarg = co.co_argcount
    if co.co_flags & 0x4:
        coarg += 1
    
    if False:
            arg = '(' + ', '.join(['c_LOAD_NAME(f->f_locals, ' + CVar(const_to(('CONST', x))) + ')' for i, x in enumerate(co.co_varnames) if i < coarg]) + ')'        
            Used('c_LOAD_NAME')
    else:
        arg = '(' + ', '.join(['GETLOCAL(' + nmvar_to_loc(x) + ')' for i, x in enumerate(co.co_varnames) if i < coarg]) + ')'     
        
    if (s != 'enum{};' or cntvar != 0) and arg != '()':
        l.append('register PyObject **fastlocals;')
    if True:
        l.append('PyThreadState * tstate = PyThreadState_GET();')
    rettype = co.ReturnType()
    if not co.IsRetVoid() and not IsCType(rettype):
        l.append('PyObject * ret;')
    if IsCType(rettype):
        l.append('%s ret;' % Type2CType(rettype))
    l.append('if (f == 0) return NULL;')
    if True:
        l.append('tstate->frame = f;')
    if (s != 'enum{};' or cntvar != 0) and arg != '()':
        l.append('fastlocals = f->f_localsplus;')

    l.append('')        


    if co.IsRetVoid():
        l.append('if (_Direct_' + nm + arg + ' == -1) {')
        l.frame_back()
        l.append('return NULL;')
        l.append('} else {')
        l.frame_back()
        l.append('Py_INCREF(Py_None);')
        l.append('return Py_None;')
        l.append('}')
    elif co.IsRetBool():
        l.append('if ((ret = _Direct_' + nm + arg + ') == -1) {')
        l.frame_back()
        l.append('return NULL;')
        l.append('} else {')
        l.frame_back()
        l.append('if (ret) {')
        l.append('Py_RETURN_TRUE;')
        l.append('} else {')
        l.append('Py_RETURN_FALSE;')
        l.append('}')
        l.append('}')
    elif co.IsRetInt():
        l.append('if ((ret = _Direct_' + nm + arg + ') == -1 && PyErr_Occurred()) {')
        l.frame_back()
        l.append('return NULL;')
        l.append('} else {')
        l.frame_back()
        l.append('return PyInt_FromLong (ret);')
        l.append('}')
    elif co.IsRetChar():
        l.append('if ((ret = _Direct_' + nm + arg + ') == \'\\xff\' && PyErr_Occurred()) {')
        l.frame_back()
        l.append('return NULL;')
        l.append('} else {')
        l.frame_back()
        l.append('return PyString_FromStringAndSize (&ret, 1);')
        l.append('}')
    elif co.IsRetFloat():
        l.append('if ((ret = _Direct_' + nm + arg + ') == -1 && PyErr_Occurred()) {')
        l.frame_back()
        l.append('return NULL;')
        l.append('} else {')
        l.frame_back()
        l.append('return PyFloat_FromDouble (ret);')
        l.append('}')
    else:
        l.append('ret = _Direct_' + nm + arg + ';')
        l.frame_back()
        l.append('return ret;')
    o[:] = l[:]    
    o.append('}')    
     
    pregenerated.append((cmds, o, co))    
    
def declare_arg(i, typed_arg, co):
    global no_fastlocals
    if i in typed_arg:
        t = typed_arg[i] 
        if IsCType(t):
            cty = Type2CType(t)
            return True, '%s Loc_%s_%s' % (cty, cty, nmvar_to_loc(co.co_varnames[i]))
    if no_fastlocals:
        return False, 'PyObject * _Fast_%s' % nmvar_to_loc(co.co_varnames[i])
    return False, 'PyObject * Arg_' + str(i) 
    
    
def generate_stand_direct_header(l, co, typed, o, typed_local, hidden, cnt_arg):
    global no_fastlocals
    assert type(o) is Out
    assert type(co) is code_extended
    orepr = no_comment_o(o)
    for i,(f,t) in enumerate(typed):
        nm = t + '_' + str(i)
        if t != 'label' and t != 'longref' and nm in orepr:
            orepr = may_be_append_to_o(l, orepr, t, nm, o)
    if no_fastlocals:
        li = [(ii, nmvar_to_loc(v)) \
               for (ii, v) in enumerate(co.co_varnames_direct) \
               if not co.IsCVar(('FAST', v)) and v not in hidden]  
        lii = [v for v in co.co_varnames_direct \
               if co.IsCVar(('FAST', v)) or v in hidden]
    else:
        li = [(ii, nmvar_to_loc(v)) \
               for (ii, v) in enumerate(co.co_varnames_direct) \
               if not co.IsCVar(('FAST', v)) and v not in hidden]
        lii = [v for v in co.co_varnames_direct \
               if co.IsCVar(('FAST', v)) or v in hidden]               
    cnt = len(li) 
    if cnt > 0:
        if no_fastlocals:
            l.extend(['PyObject * _Fast_' + nmvar_to_loc(v) + ' = 0;' for ii, v in li[cnt_arg:]])
        else:
            l.append('enum{' + ', '.join(['Loc_' + nmvar_to_loc(v) for ii, v in li]) + '};')     
    for v in lii:
        if v in co.dict_getattr_used:
            del co.dict_getattr_used[v]
    for k, v in typed_local.items():
        if IsCType(v):
            ty = Type2CType(v)
            cnm = 'Loc_%s_%s' %(ty, k)
            orepr = may_be_append_to_o(l, orepr, ty, cnm, o)
    return cnt        
    

def generate_header_direct(nm, o, co, typed, typed_arg, typed_local):
    global no_fastlocals
    assert type(o) is Out
    l = Out()
    assert type(co) is code_extended
    l.Raw('')        
    arg = ""
    coarg = co.co_argcount
    if co.co_flags & 0x4:
        assert len(co.hidden_arg_direct) == 0
        coarg += 1
    cnt_arg = coarg    
    if coarg == 0:
        arg = '(void)'
        i = 0
        ii = 0
    else:    
        arg = ''
        i = 0
        ii = 0
        while coarg > 1:
            if i not in co.hidden_arg_direct:  
                cty, _arg = declare_arg(i, typed_arg, co)
                arg += ', ' + _arg
                if not cty:
                    ii += 1
            i += 1
            coarg -= 1
        if i not in co.hidden_arg_direct:
            cty, _arg = declare_arg(i, typed_arg, co)
            arg += ', ' + _arg
            if not cty:
                ii += 1
        if arg == '':
            arg = '  void'    
        arg = '(' + arg[2:] + ')'
    if co.IsRetVoid() or co.IsRetBool():     
        l.Raw('static int _Direct_', nm, arg, '{')
    elif co.IsRetInt():     
        l.Raw('static long _Direct_', nm, arg, '{')
    elif co.IsRetFloat():     
        l.Raw('static double _Direct_', nm, arg, '{')
    elif co.IsRetChar():     
        l.Raw('static int _Direct_', nm, arg, '{')
    else:    
        l.Raw('static PyObject * _Direct_', nm, arg, '{')
    hid = {}
    for i in co.hidden_arg_direct: 
        hid[co.co_varnames_direct[i]] = True   
    cntvar = generate_stand_direct_header(l, co, typed, o, typed_local, hid, ii)
    
    t_stacksize = detect_len_temp(o)
    if t_stacksize+1 > co.co_stacksize:
        co.co_stacksize  = t_stacksize+1
    if co.co_stacksize != 0:
        if no_fastlocals:
            for i_0 in range(co.co_stacksize):
                l.Raw('PyObject * temp__', i_0, ';')
        else:                
            l.Raw('PyObject * temp[', co.co_stacksize, '];')
    if len(co.co_varnames) > 0 and cntvar > 0:
        if no_fastlocals:
            pass
        else:
            l.Raw('PyObject *fastlocals[', cntvar, '];')
    if calc_ref_total:
        l.append('Py_ssize_t l_Py_RefTotal;')
        l.append('Py_ssize_t l_Py_RefTotal_Printed;')
        l.append('l_Py_RefTotal = _Py_RefTotal;')
        l.append('l_Py_RefTotal_Printed = _Py_RefTotal_Printed;')
    if line_number:
        l.Raw('int PyLine = ', co.co_firstlineno, ';')     
        l.append('int PyAddr = 0;')     
    if not redefined_attribute:
        for k in co.dict_getattr_used.iterkeys():
            l.Raw('PyObject *_', k, '_dict = 0;')
    ii = 0        
    for i in range(cnt_arg):
        if i in co.hidden_arg_direct:
            continue
        if i in typed_arg and typed_arg[i][0] is int:
            pass
        elif i in typed_arg and typed_arg[i][0] is float:
            pass
        elif i in typed_arg and typed_arg[i][0] is bool:
            pass
        elif i in typed_arg and IsChar(typed_arg[i]):
            pass
        elif ii < cntvar:
            if no_fastlocals:
                l.Raw('Py_INCREF(_Fast_%s);' % nmvar_to_loc(co.co_varnames_direct[i]))
            else:
                l.Raw('fastlocals[', ii, '] = Arg_', i, ';')  
                l.Raw('Py_INCREF(Arg_', i, ');')  
            ii += 1

    for i in range(ii, cntvar):
        if no_fastlocals:
            pass
        else:
            l.Raw('fastlocals[', i, '] = NULL;')   
    if not redefined_attribute:
        for k in co.dict_getattr_used.iterkeys():
                l.append('if (PyInstance_Check(GETLOCAL(%s))) {' % k)
                l.append('_%s_dict = ((PyInstanceObject *)GETLOCAL(%s))->in_dict;' %(k,k))
                l.append('} else {')
                l.append('PyObject **refdict = _PyObject_GetDictPtr(GETLOCAL(%s));' %k)
                l.append('if (refdict && *refdict) _%s_dict = *refdict;' %k )
                l.append('}')

    for i in range(co.co_stacksize):
        if no_fastlocals:
            l.Raw('temp__', i, ' = 0;')
        else:
            l.Raw('temp[', i, '] = 0;')
    l.Raw('')        
    l.extend(o)
    o[:] = l[:]         
    return   

    
def stub_generator(co):
    pass    
    
def generate_list(lis, o = None):
    i = 0
    if o is None:
        o = Out()
    assert type(o) is Out
    cnt_prev = None
    line_prev = None
    if recalc_refcnt:
        cnt_prev = New('Py_ssize_t')
        line_prev = New('int')
        o.Raw(cnt_prev, '= _Py_RefTotal;')
        o.Raw(line_prev, '= __LINE__;')

    while i < len(lis):        
        assert type(i) is int
        it = lis[i]
        head = it[0]
        assert type(head) is str
        assert head[0] != ')' and head[0:2] != ')(' 
        if IsBeg(head):            
            i1 = get_closed_pair(lis, i)
            o.Comment(it)            
            generate_compaund_statement(head[1:], lis[i:i1+1], o)            
            i = i1 + 1
        else:            
            o.Comment(it)  
            generate_statement(head, it, o)
            if head == 'RETURN_VALUE':
                break            
            i += 1        
        if cnt_prev is not None:
            o.Raw('if ((int)(_Py_RefTotal -', cnt_prev, ')) { printf("\\nfunc %s, line %5d:%5d, refcnt %d\\n", "', func, '", ',\
                   line_prev, ',__LINE__, (int)(_Py_RefTotal -', cnt_prev, '));} ',\
                   cnt_prev, '= _Py_RefTotal; ', line_prev, '= __LINE__;')
    if recalc_refcnt:
        o.Cls(cnt_prev, line_prev)
    return o

def get_closed_pair(lis,i):
    if type(lis) is list:
        for i1 in range(i+1, len(lis)):
            lis2 = lis[i1]
            if type(lis2) is tuple:
                lis3 = lis2[0]
                if type(lis3) is str:
                    if lis3[0] == ')' and lis3[0:2] != ')(':
                        return i1
    Fatal('Can\'t get closed pair', lis)
    assert False
   
def generate_return_statement(it, o):   
    global try_jump_context, dropped_temp
    global traced_tempgen
    assert type(o) is Out

    g_co.return_cnt += 1
    place = len(o)
    logical = 'UNDEFINED***'
    v2 = {}
    i = len(o) - 1
    while i >= 0:
        o1 = o[i]
        if (o1 == '' or o1.startswith('/*') or\
                    o1.startswith('PyLine = ') or\
                    o1.startswith('PyAddr = ') or\
                    o1.startswith('f->f_lineno = ') or\
                    o1.startswith('f->f_lasti = ')):  
            i -= 1
            continue
        break
    i -= 1
    assert type(i) is int and i >= -2
    if i >= 0 and 'PyDict_Contains'  in o[i] and TxMatch(o, i, """   
        if ((int_$1 = PyDict_Contains ( $5 , $6 )) == -1) goto label_$3;
        if ( int_$1 ) {
        """, v2): 
            retlabl = None
    else:
        retlabl = ConC('ret_label_', g_co.return_cnt)
        o.Raw(retlabl, ':;')
    if True:
        o.Raw('if (ping_threading () == -1) goto ', labl, ';')
        UseLabl()
        Used('ping_threading')
    for drop in dropped_temp:
        for t in drop[1]:
            if istempref(t):
                o.Raw('Py_CLEAR(', t, ');')
    try_jump = try_jump_context[:]
    if len(it[1]) == 1 and it[1][0] == 'f->f_locals':
        ref = New()
        if is_current & IS_ANY_CFUNC:
            if g_co.co_name == 'Init_filename':
                o.Raw(ref, ' = glob;')
            else:
                o.Raw(ref, ' = _f_locals;')
        else:    
            assert is_current & IS_CODEFUNC
            o.Raw(ref, ' = ', it[1][0], ';')
        o.INCREF(ref)
        PopClearAll(o)
        if checkmaxref != 0:
            o.Raw('if ((', ref, ')->ob_refcnt > ', checkmaxref, ') printf("line %5d, line %6d \\n", __LINE__,(', ref, ')->ob_refcnt);')
        if is_current & IS_CODEFUNC:
            if check_recursive_call:
                o.append('Py_LeaveRecursiveCall();')
            o.frame_back()
        o.Raw('return ', ref, ';')
        o.Cls(ref)
        return
    if is_current & IS_DIRECT:
        isvoid = g_co.IsRetVoid()
        isbool = g_co.IsRetBool()
        isint = g_co.IsRetInt()
        isfloat = g_co.IsRetFloat()
        ischar = g_co.IsRetChar()
    else:
        isvoid = False
        isbool = False
        isint = False
        isfloat = False
        ischar = False
    if isvoid:
        if not IsKlNone(TypeExpr(it[1])):
            pprint(it)
            pprint(TypeExpr(it[1]))
            
        assert IsKlNone(TypeExpr(it[1]))
    ref = it[1]           
    
    if isvoid:
        ref = Expr1(ref, o)
        o.Cls(ref)
        ref = None
    elif IsCVar(ref):
        logical = CVarName(ref)      
        if is_current & IS_CALLABLE_COMPILABLE:
            ref = Expr1(ref, o)
    elif ref[0] == 'CONST' and isbool:
        if ref[1]:
            logical = 1
        else:
            logical = 0  
    elif ref[0] == 'CONST' and (isint or isfloat or ischar):
        logical = ref[1]
    elif isbool:
        o1, logical = shortage(generate_logical_expr(ref))
        o.extend(o1)
        if type(logical) is str and ('temp[' in logical or 'GETLOCAL' in logical):
            _l = New('int')
            o.Raw(_l, ' = ', logical, ';')
            logical = _l
    elif isint: 
        ref = Expr1(ref, o)
        logical = New('long')
        o.Raw(logical, ' = PyInt_AsLong ( ', ref, ' );')
        o.Cls(ref)
    elif ischar: 
        ref = Expr1(ref, o)
        logical = New('char')
        o.Raw('if (PyString_AsString ( ', ref, ' ) == 0) goto ', labl, ';')
        o.Raw('if (PyString_Size ( ', ref, ' ) != 1) goto ', labl, ';')
        o.Raw(logical, ' = *PyString_AsString ( ', ref, ' );')
        UseLabl()
        o.Cls(ref)
    elif isfloat: 
        ref = Expr1(ref, o)
        logical = New('double')
        o.Raw('if ((', logical, ' = PyFloat_AsDouble ( ', ref, ' )) == -1) goto ', labl, ';')
        UseLabl()
        o.Cls(ref)
    else: 
        ref = Expr1(ref, o) 
        if not istempref(ref) and not ( is_current & (IS_DIRECT | IS_ANY_CFUNC ) and ref[0] == 'FAST'): 
            o.INCREF(ref) 
        if istempref(ref):
            remove_temporary_long_when_push_int_from_long(o)

    if is_current & IS_CODEFUNC:
        _to_fin = try_jump
        try_jump[:] = []
        while len(_to_fin) > 0:
            to_fin = _to_fin[-1]
            del _to_fin[-1]
            if to_fin:
                if type(to_fin) is list:
                    o.Comment((')(FINALLY',))
                    o.append('{')
                    generate_list(to_fin,o)
                    o.append('}')                    

    if is_current & IS_DIRECT:
        hid = {}
        for i in g_co.hidden_arg_direct: 
            hid[g_co.co_varnames[i]] = True               
        for i,v in enumerate(g_co.co_varnames_direct):
            if v in hid:
                continue
            nmvar = nmvar_to_loc(v)
            if isvoid or isbool or isint or isfloat or \
                (len(ref) != 2 or ref[0] != 'FAST' or ref[1] != nmvar): 
                if not g_co.IsCVar(('FAST', v)) and \
                   (nmvar in g_co.used_fastlocals or g_co.list_compr_in_progress == True):
                    o.CLEAR('GETLOCAL(' + nmvar + ')')

    elif is_current & IS_ANY_CFUNC:
        for i,v in enumerate(g_co.co_varnames):
            nmvar = nmvar_to_loc(v)
            if (len(ref) != 2 or ref[0] != 'FAST' or ref[1] != nmvar): 
                if not g_co.IsCVar(('FAST', v)) and \
                   (nmvar in g_co.used_fastlocals or g_co.list_compr_in_progress == True):
                     o.CLEAR('GETLOCAL(' + nmvar + ')')


    for i,v in enumerate(g_co.co_freevars):
        nmvar = nmvar_to_loc(v)
        if isvoid or isbool or (len(ref) != 2 or ref[0] != 'LOAD_CLOSURE' or ref[1] != nmvar): 
            o.CLEAR('GETFREEVAR(' + nmvar + ')')

    PopClearAll(o)
    if calc_ref_total:
        calc_reftotal_printed(o, func)
    if stat_func == func:
        o.append('{')
        o.append('FILE * _refs = fopen(\"%s_end\", \"w+\");' % func)
        o.append('_Py_PrintReferences(_refs);')  
        o.append('fclose(_refs);')     
        o.append('}')    
    if is_current & IS_CODEFUNC:
        if True:
            o.append('if (tstate->frame->f_exc_type != NULL) {')
            PyEval_reset_exc_info(o)      
            o.append('}')
        if check_recursive_call:
            o.append('Py_LeaveRecursiveCall();')
        o.frame_back()
    if isvoid:
        o.append('return 0;')
    elif isbool:
        o.Raw('return ', logical, ';')
        o.Cls(logical)
    elif isint:
        o.Raw('return ', logical, ';')
        o.Cls(logical)
    elif ischar:
        if istemptyped(logical):
            o.Raw('return ', logical, ';')
        else:
            o.Raw('return ', Char_for_C(logical), ';')
        o.Cls(logical)
    elif isfloat:
        o.Raw('return ', logical, ';')
        o.Cls(logical)
    else:  
        if IsCVar(it[1]):  
            if is_current & IS_CALLABLE_COMPILABLE:
                o.Stmt('return', ref)   
            else:
                ref3 = New()
                CType2Py(o, ref3, logical, TypeExpr(it[1]))    
                o.Stmt('return', ref3)   
                o.ClsFict(ref3)
        else:    
            o.Stmt('return', ref)   
            o.ClsFict(ref)

    if is_current & IS_DIRECT and retlabl is not None:
        if tuple(o[place+1:]) in g_co.returns_direct:
            rets = g_co.returns_direct[tuple(o[place+1:])]
            o[place:] = ['goto ' + rets[1] + ';']
            g_co.used_return_labels[rets[1]] = True
            return
        g_co.returns_direct[tuple(o[place+1:])] = (place, retlabl)   
    if is_current & IS_ANY_CFUNC and retlabl is not None:
        if tuple(o[place+1:]) in g_co.returns_cfunc:
            rets = g_co.returns_cfunc[tuple(o[place+1:])]
            o[place:] = ['goto ' + rets[1] + ';']
            g_co.used_return_labels[rets[1]] = True
            return
        g_co.returns_cfunc[tuple(o[place+1:])] = (place, retlabl)   
    return

dcl_stat_refcalc = {}

def gen_dcl_calc_reftotal(o):
    global dcl_stat_refcalc
    assert type(o) is Out
    ## if not hasattr(sys, 'gettotalrefcount'):
        ## return
    ## return
    ## li = dcl_stat_refcalc.keys()
    ## li.sort()
    ## for k in li:
        ## o.Raw('Py_ssize_t ', k, '_cnt = 0;')
        ## o.Raw('Py_ssize_t ', k, '_cntref = 0;')
        ## o.Raw('Py_ssize_t ', k, '_cntref_all = 0;')

def gen_print_calc_reftotal(o):
    global dcl_stat_refcalc
    assert type(o) is Out
    if not hasattr(sys, 'gettotalrefcount'):
        return
    return
    li = dcl_stat_refcalc.keys()
    li.sort()
    for k in li:
        o.Raw('if (', k, '_cnt && ', k, '_cntref_all)')
        o.Raw('printf ("func ', k, '\\t%d\\t%d\\t%f\\t%d\\t%f\\n", ', k + '_cnt, ', k + '_cntref, (((double)',k + '_cntref) / ((double)', k + '_cnt)), ', k + '_cntref_all, (((double)',k + '_cntref_all) / ((double)', k + '_cnt)));')

        
def calc_reftotal_printed(o, nm):
    global dcl_stat_refcalc
    assert type(o) is Out
    if not hasattr(sys, 'gettotalrefcount'):
        return
    return
    o.Raw('{')
    o.Raw('int delta_all = _Py_RefTotal - l_Py_RefTotal;')
    o.Raw('int delta_printed = _Py_RefTotal_Printed - l_Py_RefTotal_Printed;')
    o.Raw('int delta_need = delta_all - delta_printed;')
    o.Raw('_Py_RefTotal_Printed += delta_need;')
    pre = ''
    if is_current & IS_CODEFUNC:
        pre = 'cf'
    if is_current & IS_DIRECT:
        pre = 'dir'
    o.Raw(pre, '_', nm, '_cnt += 1;')
    o.Raw(pre, '_', nm, '_cntref += delta_need;')
    o.Raw(pre, '_', nm, '_cntref_all += delta_all;')
    dcl_stat_refcalc[pre + '_' + nm] = True
    
    o.Raw('}')
    
    
def del_unused_ret_label(o):
    i = 0
    assert type(o) is Out
    while i < len(o):
        assert type(i) is int
        s = o[i]
        assert type(s) is str
        if s.startswith('ret_label_') and s.endswith(':;'):
            retlabl = s[:-2]
            if retlabl not in g_co.used_return_labels:
                del o[i]
                continue
        i += 1
        
        
def set_line(o, line):
    global line_number, is_current, Line2Addr, filename
    assert type(o) is Out
    if not line_number:
        return
    if is_current & IS_DIRECT or is_current & IS_ANY_CFUNC:
        o.Raw('PyLine = ', str(line), ';')
    else:    
        o.Stmt('f->f_lineno', '=', line)
    if line in Line2Addr:
        if is_current & IS_DIRECT or is_current & IS_ANY_CFUNC:
            o.Raw('PyAddr = ', str(Line2Addr[line]), ';')
        elif True:    
            o.Raw('f->f_lasti = ', str(Line2Addr[line]), ';')
    if print_pyline:
        o.Stmt('printf', '\"Py:' + filename +':%5d\\n\"', line)
                    
def generate_statement(head, it, o):
    global g_co
    assert type(it) is tuple
    assert type(head) is str
    assert type(o) is Out
    if head == '.L':
        set_line(o, it[1])
        return

    if head == 'STORE':
        if len(it) == 3 and len(it[1]) == 1 and len(it[2]) == 1:
         
            if it[1][0][0] == 'STORE_FAST' and IsCVar(('FAST', it[1][0][1])):
                if CSetVariable(o, ('FAST', it[1][0][1]), it[2][0]):
                    return
            elif (it[1][0][0] == 'STORE_GLOBAL' or (it[1][0][0] == 'STORE_NAME' and func == 'Init_filename')) and IsCVar(('!LOAD_GLOBAL', it[1][0][1])):
                add_fast_glob(it[1][0][1])
                if CSetVariable(o, ('!LOAD_GLOBAL', it[1][0][1]), it[2][0]):
                    return
            elif it[1][0][0] == 'STORE_CALC_CONST' and (it[1][0][1][0] == 'STORE_GLOBAL'\
                                                         or (it[1][0][1][0] == 'STORE_NAME' and \
                                                             func == 'Init_filename')) \
                                                             and IsCVar(('!LOAD_GLOBAL', it[1][0][1][1])):
                                                              
                add_fast_glob(it[1][0][1][1])
                if CSetVariable(o, ('!LOAD_GLOBAL', it[1][0][1][1]), it[2][0]):
                    return
        if len(it[2]) == 1 and len(it[1]) == 1:
            if is_like_float(it[2][0]) and it[2][0][0] != 'CONST':
                acc = []
                isfloat = {}
                if parse_for_float_expr(it[2][0], acc, isfloat):
                    if len(acc) >= 2 or (len(acc) == 1 and acc[0][0] == 'CONST' and type(acc[0][1]) is float):
                       return generate_mixed_float_expr(it,acc,o, isfloat)
            acc = detect_repeated_subexpr(it[1][0], it[2][0]).keys()
            refs = Expr(o, acc) #[Expr1(x, o) for x in acc]
            PushAcc(acc, refs)
            ref = Expr1(it[2][0], o)
            if it[2][0][0] == 'FAST':
                stor = ('STORE_FAST', it[2][0][1])
                if repr(stor) in repr(it[1][0]):
                    ref2 = New()
                    o.Raw(ref2, ' = ', ref, ';')
                    o.INCREF(ref2)
                    ref = ref2
                    ref2 = None
            generate_store(it[1][0], ref, o, it[2][0])
            PopAcc(o)      
            o.Cls(*refs)              
            o.Cls(ref)
            if ref not in g_refs2:
                o.ZeroTemp(ref)
            return
        Fatal('MultyStore', it)
        assert False

    if head == 'SEQ_ASSIGN':
        ref = Expr1(it[2], o)
        PushAcc([ref], [ref])
        _refss = [ref]
        for i in range(len(it[1])-1):
            ref2 = New()
            _refss.append(ref2)
            o.Raw(ref2, ' = ', ref, ';')
            o.INCREF(ref2)
        for i, iit in enumerate(it[1]):
          generate_store(iit, _refss[i], o, it[2])
          o.Raw(_refss[i], ' = 0;')
          o.ClsFict(_refss[i])
        PopAcc(o, False)
        o.ClsFict(ref)
        return

    if head == 'SET_EXPRS_TO_VARS':
        if len(it[1]) == 2 and it[2][0] == 'CLONE':
            ref = Expr1(it[2][1],o)
            o.ClsFict(ref)
            generate_store(it[1][0], ref, o, it[2][1])
            generate_store(it[1][1], ref, o, it[2][1])
            if istempref(ref):
                o.CLEAR(ref)
            return
        assert len(it[2]) == len(it[1])
        stor = dict.fromkeys([x[0] for x in it[1]]).keys()
        srepr = it[2]
        if len(stor) == 1 and stor[0] == 'STORE_FAST':
            gets = [('FAST', x[1]) for x in it[1]]
            gets.extend([('LOAD_FAST', x[1]) for x in it[1]])
            pure = True
            for ge in gets:
                if expr_in_expr(ge, srepr):
                    pure = False
            if pure:
                for i,iit in enumerate(it[1]):
                    ref1 = Expr1(it[2][i], o)
                    generate_store(iit,ref1,o, it[2][i])
                    o.Cls(ref1)
                return
        expr = TupleFromArgs(it[2])
        ref = Expr1(expr, o)
        its = it[1]
        for i,iit in enumerate(its):
            ref1 = ConC('PyTuple_GET_ITEM( ', ref, ', ', i, ' )')
            generate_store(iit,ref1,o, ('!PyTuple_GET_ITEM',))
        o.Cls(ref)
        return

    if head == 'RETURN_VALUE':
        generate_return_statement(it, o)
        return
    if head == 'CALL_PROC':
        Fatal('Illegal', it)
        assert False
        return
    if head == 'UNPUSH':
        if like_append(it[1]):
            generate_may_be_append(it[1], o)
            return
        _v = []
        if like_append_const(it[1], _v):
            generate_may_be_append_const(it[1], o, _v)
            return
        if it[1][0] == '!COND_METH_EXPR':
            generate_cond_meth_expr_new(it[1], o, None, True)
            return
        t = TypeExpr(it[1])
        if t is not None and t != Kl_None:
            if ( IsCType(t) or IsIntUndefSize(t) ) and it[1][0] in ('!PyNumber_Subtract', '!PyNumber_Add', '!PyNumber_And',
                                                                    '!PyNumber_Or', '!PyNumber_Divide', '!_EQ_', '!_NEQ_'):
                generate_statement('UNPUSH', it[1][1], o)
                generate_statement('UNPUSH', it[1][2], o)
                return
        if it[1][0] == '!LIST_COMPR':
            generate_unpush_list_compr(it[1], o)
            return
        ref = Expr1(it[1], o)
        o.Cls(ref)
        return
    if head == 'PYAPI_CALL':
        iit = it[1]
        gen = []
        for i in range(len(iit)):
            if i > 0:
                if type(iit[i]) is tuple and len(iit[i]) > 0:
                    gen.append(Expr1(iit[i], o))
                else:
                    gen.append(iit[i])
        if iit[0] in CFuncIntCheck:        
            args = (iit[0],) + tuple(gen)       
            o.Stmt(*args)
            o.Cls(*gen)
            return    
        elif iit[0] in CFuncVoid:        
            args = (iit[0],) + tuple(gen)       
            o.Stmt(*args)
            o.Cls(*gen)
            return    
        else:
            Fatal('', it)
            assert False

    if head == 'IMPORT_FROM_AS':
        if it[3][0] == 'CONST' and len(it[3][1]) == len(it[4]):
            ref = Expr1(('!IMPORT_NAME', it[1],it[2],it[3]), o)
            for i in range(len(it[4])):
                ref1 = New()
                o.Raw('if ((', ref1, ' = PyObject_GetAttr( ', ref, ', ', ('CONST', it[3][1][i]), ')) == 0) {')
                o.Raw('if (PyErr_ExceptionMatches(PyExc_AttributeError)) {')
                o.Raw('PyErr_Format(PyExc_ImportError, ', ('"cannot import name %s"' % it[3][1][i]), ');')
                o.append('}')
                o.Raw('goto ', labl, ';')
                UseLabl()
                o.append('}')
                generate_store(it[4][i], ref1,o, it)
            o.Cls(ref)
            return
        Fatal('', it)
        assert False
        return
    if head == 'PRINT_ITEM_TO_2':
        ref1, ref2 = Expr(o, it[1:])
        o.Stmt('_PyEval_PRINT_ITEM_TO_2', ref1, ref2)
        o.Cls(ref1, ref2)
        return
    if head == 'PRINT_ITEM_AND_NEWLINE_TO_2':
        ref1, ref2 = Expr(o, it[1:])
        o.Stmt('_PyEval_PRINT_ITEM_TO_2', ref1, ref2)
        o.Stmt('_PyEval_PRINT_NEWLINE_TO_1', ref1)
        o.Cls(ref1, ref2)
        return
    if head == 'PRINT_ITEM_AND_NEWLINE_TO_3':
        ref1, ref2, ref3 = Expr(o, it[1:])
        o.Stmt('_PyEval_PRINT_ITEM_TO_2', ref1, ref2)
        o.Stmt('_PyEval_PRINT_ITEM_TO_2', ref1, ref3)
        o.Stmt('_PyEval_PRINT_NEWLINE_TO_1', ref1)
        o.Cls(ref1, ref2, ref3)
        return
    if head == 'PRINT_ITEM_1':
        ref1 = Expr1(it[1], o)
        o.Stmt('_PyEval_PRINT_ITEM_1', ref1)
        o.Cls(ref1)
        return
    if head == 'PRINT_NEWLINE_TO_1':
        ref1 = Expr1(it[1], o)
        o.Stmt('_PyEval_PRINT_NEWLINE_TO_1', ref1)
        o.Cls(ref1)
        return
    if head == 'PRINT_NEWLINE':
        o.Stmt('_PyEval_PRINT_NEWLINE_TO_1', 'NULL')
        return
    if head == 'DELETE_ATTR_2':
        ref1, ref2 = Expr(o, it[1:])
        o.Stmt('PyObject_SetAttr', ref1, ref2, 'NULL')
        o.Cls(ref1, ref2)
        return
    if head == 'DELETE_SUBSCR':
        t = TypeExpr(it[1])
        t_ind = TypeExpr(it[2])
        if IsList(t) and IsInt(t_ind):
            ref1 = Expr1(it[1],o)
                
            o2,ind1 = short_gen_size_t(it[2])
            o.extend(o2)
            if type(ind1) is int:
                if ind1 < 0:
                    ind2 = New('long')
                    o.Raw(ind2, ' = PyList_GET_SIZE(', ref1, ');')
                    _ind1 = New('long')
                    o.Stmt(_ind1, '=', ind1, '+', ind2)
                    ind1 = _ind1
                else:
                    ind2 = ind1 + 1
            elif ind1[0] == 'CONST':
                if ind1[1] < 0:
                    ind2 = New('long')
                    o.Raw(ind2, ' = PyList_GET_SIZE(', ref1, ');')
                    _ind1 = New('long')
                    o.Stmt(_ind1, '=', ind1[1], '+', ind2)
                    ind1 = _ind1
                else:
                    ind1, ind2 = ind1[1], ind1[1]+1
            else:   
                if not IsCardinal(t_ind):
                    ind2 = New('long')
                    o.Raw(ind2, ' = PyList_GET_SIZE(', ref1, ');')   
                else:
                    ind2 = None
                if not istemptyped(ind1) and not IsCardinal(t_ind):
                    ind_ = New('long')
                    o.Raw(ind_, ' = ', ind1, ';')
                    ind1 = ind_
                if not IsCardinal(t_ind):
                    o.Stmt('if (', ind1, '< 0) {')
                    o.Stmt(ind1, '=', ind1, '+', ind2)
                    o.append('}')     
            if ind2 is None:
                o.Stmt('PyList_SetSlice', ref1, ind1, ConC(ind1, ' + 1'), 'NULL')
            else:
                o.Stmt('PyList_SetSlice', ref1, ind1, ind2, 'NULL')
            o.Cls(ref1, ind1, ind2)
            return    
            
        if t is not None and t != Kl_Dict:
            Debug('Typed ' + head, t, it)
        ref1, ref2 = Expr(o, it[1:])
        if IsDict(t):
            o.Stmt('PyDict_DelItem', ref1, ref2)
        else:    
            o.Stmt('PyObject_DelItem', ref1, ref2)
        o.Cls(ref1, ref2)
        return
    if head == 'DELETE_SLICE+0':
        t = TypeExpr(it[1])
        if IsList(t):
            assign_list_slice(it, o, 'NULL')
            return    
        if t is not None:
            Debug('Typed ' + head, t, it)
        ref1 = Expr1(it[1], o)
        o.Stmt('PySequence_DelSlice', ref1, 0, 'PY_SSIZE_T_MAX')
        o.Cls(ref1)
        return    
    if head == 'DELETE_SLICE+1':
        t = TypeExpr(it[1])
        if IsList(t):
            assign_list_slice(it, o, 'NULL')
            return    
            
        if t is not None:
            Debug('Typed ' + head, t, it)
        ref1, ref2 = Expr(o, it[1:])
        if isintconst(ref2) and IsListAll(t):
            o.Stmt('PySequence_DelSlice', ref1, ref2[1], 'PY_SSIZE_T_MAX')
        else:    
            o.Stmt('_PyEval_AssignSlice', ref1, ref2, 'NULL', 'NULL')
        o.Cls(ref1, ref2)
        return    
    if head == 'DELETE_SLICE+2':
        t = TypeExpr(it[1])
        if t is not None:
            Debug('Typed ' + head, t, it)
        ref1, ref2 = Expr(o, it[1:])
        if isintconst(ref2) and IsListAll(t):
            o.Stmt('PySequence_DelSlice', ref1, 0, ref2[1])
        else:    
            o.Stmt('_PyEval_AssignSlice', ref1, 'NULL', ref2, 'NULL')
        o.Cls(ref1, ref2)
        return    
    if head == 'DELETE_SLICE+3':
        t = TypeExpr(it[1])
        if t is not None:
            Debug('Typed ' + head, t, it)
        ref1, ref2, ref3 = Expr(o, it[1:])
        if isintconst(ref2) and isintconst(ref3) and IsListAll(t):
            o.Stmt('PySequence_DelSlice', ref1, ref2[1], ref3[1])
        else:    
            o.Stmt('_PyEval_AssignSlice', ref1, ref2, ref3, 'NULL')
        o.Cls(ref1, ref2, ref3)
        return    
    if head == 'DELETE_GLOBAL':
        ref1 =  Expr1(('CONST', it[1]),o)
        o.Stmt('PyDict_DelItem', ('glob',), ref1)
        o.Cls(ref1)
        return
    if head == 'CONTINUE':
        if try_jump_context[-1]:
            if type(try_jump_context[-1]) is list:
                o.Comment((')(FINALLY',))
                o.append('{')
                generate_list(try_jump_context[-1],o)
                o.append('}')                    
        o.append('continue;')
        return
    if head == 'BREAK_LOOP':
        if try_jump_context[-1]:
            if type(try_jump_context[-1]) is list:
                o.Comment((')(FINALLY',))
                o.append('{')
                generate_list(try_jump_context[-1],o)
                o.append('}')     
        if loop_else_context[-1] is not None:
            o.Raw(loop_else_context[-1], ' = 0;')
        o.append('break;')
        return
    if head == 'EXEC_STMT_3':
        g_co.Use_all_fastlocals()
        r1, r2, r3 = Expr(o, it[1:])
        plain = False
        
        if r2 == ('CONST', None) == r3:
            if it[1][0] == '!BUILD_TUPLE' and len(it[1][1]) in (2,3):
                pass
            else:
                r2 = 'glob'
                o.append('PyFrame_FastToLocals(f);')
                r3 = 'f->f_locals'
                plain = True
        if r2 != ('CONST', None) and ('CONST', None) == r3:
            r3 = r2
        o.Stmt('_PyEval_ExecStatement', 'f', r1,r2,r3)
        if plain:
            o.append('PyFrame_LocalsToFast(f, 0);')
        o.Cls(r1, r2, r3)
        return
    if head == 'DELETE_NAME':
        if g_co.c_name == 'Init_filename':
            ref1 = Expr1(('CONST', it[1]),o)
            o.Stmt('PyObject_DelItem', 'glob', ref1)
            o.Cls(ref1)
            return
 
        ref1 = Expr1(('CONST', it[1]),o)
        if is_current & IS_DICTIONABLE_CFUNC:
            o.Stmt('PyObject_DelItem', '_f_locals', ref1)
        else:
            o.Stmt('PyObject_DelItem', 'f->f_locals', ref1)
        o.Cls(ref1)
        return
    if head == 'RAISE_VARARGS_STMT' or head == 'RAISE_VARARGS':
        assert it[1] == 0
        if len(it) < 3:
            refn = []
        else:    
            refn = Expr(o, it[2])
        while len(refn) < 3:
            refn.append('NULL')
        assert len(refn) == 3    
        if refn[0] != 'NULL':
             o.INCREF(refn[0])
        if refn[1] != 'NULL':
            o.INCREF(refn[1])
        if refn[2] != 'NULL':
            o.INCREF(refn[2])
        o.Stmt('_PyEval_DoRaise', refn[0], refn[1], refn[2])
        o.Cls(*refn)
        o.Stmt('goto', labl)
        UseLabl()
        return
    if head == 'IMPORT_STAR':
        g_co.Use_all_fastlocals()
        o.Stmt('PyFrame_FastToLocals', 'f')
        ref1 = Expr1(it[1],o)
        o.Stmt('_PyEval_ImportAllFrom', 'f->f_locals', ref1)
        o.Stmt('PyFrame_LocalsToFast', 'f', 0)
        o.Cls(ref1)
        return
    if head == 'DELETE_FAST':
        o.Stmt('SETLOCAL', nmvar_to_loc(it[1]), 'NULL')
        return
    if head == 'PASS':
        pass
        return
    if head == 'YIELD_STMT':
        Used('PY2C_GENERATOR')
        
        
        g_co.Use_all_fastlocals()
        assert len(it) == 2
        r1 = Expr1(it[1], o)
        o.Raw('return ', r1, ';') 
        assert len(g_co.yield_labels) != 0
        r2 = New('label')
        g_co.yield_labels.append((r2, len(g_co.yield_labels)-1))
        o.Raw(r2, ':;')
        return

    Fatal('HEAD', head, it)
    assert False
    
def like_append(it):
    v = []
    return TCmp(it,v,('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', 'append')),\
                    ('!BUILD_TUPLE', ('?',)), ('NULL',)))
                    
def like_append_const(it, v):
    return TCmp(it,v,('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', 'append')),\
                    ('CONST', ('?',)), ('NULL',)))          
                        

redef_append = set(['append'])

def generate_may_be_append(it, o):
    assert type(it) is tuple
    assert type(o) is Out
    ref_list = Expr1(it[1][1], o)
    ref_value = Expr1(it[2][1][0], o)
    t = TypeExpr(it[1][1])
    islist = False
    if t is None:
        pass
    elif IsListAll(t, redef_append):
        islist = True
    _generate_may_be_append(ref_list, ref_value, o, islist)
    o.Cls(ref_value, ref_list)

def generate_may_be_append_const(it, o, v):
    assert type(o) is Out    
    ref_list = Expr1(v[0], o)
    t = TypeExpr(v[0])
    islist = False
    if t is None:
        pass
    elif IsListAll(t, redef_append):
        islist = True
    _generate_may_be_append_const(ref_list, v[1], o, islist)
    o.Cls(ref_list)

def _generate_may_be_append_const(ref_list, v1, o, islist = False):
    assert type(o) is Out    
    if not islist:
        o.Stmt('if (PyList_Check(', ref_list, ')) {')
    o.Stmt('PyList_Append', ref_list, ('CONST', v1))
    if not islist:
        o.append('} else {')
        ref_attr = New()
        o.Stmt(ref_attr, '=', 'PyObject_GetAttr', ref_list, ('CONST', 'append'))    
        ref_return = New()
        o.Stmt(ref_return, '=', 'FirstCFunctionCall', ref_attr, ('CONST', (v1,)), ('NULL',))
        o.Cls(ref_return, ref_attr)
        o.append('}')


def _generate_may_be_append(ref_list, ref_value, o, islist = False):
    assert type(o) is Out    
    if not islist:
        o.Stmt('if (PyList_Check(', ref_list, ')) {')
    o.Stmt('PyList_Append', ref_list, ref_value)
    if not islist:
        o.append('} else {')
        ref_attr = New()
        o.Stmt(ref_attr, '=', 'PyObject_GetAttr', ref_list, ('CONST', 'append'))    
        ref_tuple = New()
        o.Stmt(ref_tuple, '=', 'PyTuple_New', 1)
        o.INCREF(ref_value)
        o.Stmt('PyTuple_SET_ITEM', ref_tuple, 0, ref_value)
        ref_return = New()
        o.Stmt(ref_return, '=', 'FirstCFunctionCall', ref_attr, ref_tuple, ('NULL',))
        o.Cls(ref_return, ref_tuple, ref_attr)
        o.append('}')
 
def _detect_r_subexpr(e, acc2):
    if not (type(e) is tuple) or len(e) == 0 or \
       e[0] in ('CONST', 'FAST', 'CALC_CONST', 'TYPED_TEMP', '!@PyInt_FromSsize_t'):
        return
    if type(e) is tuple and len(e) > 0 and e[0] == 'PY_TYPE':
        return _detect_r_subexpr(e[3], acc2)
   
    if e in acc2:
        acc2[e] = acc2[e] + 1
    else:    
        acc2[e] = 1    
    if type(e) is tuple and len(e) > 0:
        if e[0] == '!BUILD_MAP':
            e = e[1]    
            for i,it in enumerate(e):
                if i == 0 or not (type(it[0]) is tuple) or len(it[0]) == 0 or \
                it[0][0] in ('CONST', 'FAST', 'CALC_CONST', 'TYPED_TEMP', '!@PyInt_FromSsize_t'):
                    pass
                else:
                    _detect_r_subexpr(it[0], acc2)     
                if i == 0 or not (type(it[1]) is tuple) or len(it[1]) == 0 or \
                it[1][0] in ('CONST', 'FAST', 'CALC_CONST', 'TYPED_TEMP', '!@PyInt_FromSsize_t'):
                    pass
                else:
                    _detect_r_subexpr(it[1], acc2)     
            return        
        if e[0] in ('!BUILD_LIST', '!BUILD_TUPLE'):
            e = e[1]    
            for it in e:
                acc2[it] = -100000    
        for i,it in enumerate(e):
                if i == 0 or not (type(it) is tuple) or len(it) == 0 or \
                    it[0] in ('CONST', 'FAST', 'CALC_CONST', 'TYPED_TEMP', '!@PyInt_FromSsize_t'):
                    continue
                _detect_r_subexpr(it, acc2)     
    return
    
tags_cond = frozenset(('!AND', '!AND_JUMP', '!AND_BOOLEAN', \
                       '!AND_JUMPED_STACKED', '!OR_JUMP', '!OR_BOOLEAN', \
                       '!OR_JUMPED_STACKED', '!COND_EXPR'))
   
def cond_in_expr(e):  
    return str_tags_in_expr(tags_cond, e)   

def detect_repeated_subexpr(store, expr):
    acc2 = {}
    if cond_in_expr(expr):
        return {}
    _detect_r_subexpr(expr,acc2)    
    if len(store) > 0 and store[0] in ('PyObject_SetItem', 'PyObject_SetAttr'):
        if cond_in_expr(store[1]) or cond_in_expr(store[2]):
            return {}
        _detect_r_subexpr(store[1],acc2)
        _detect_r_subexpr(store[2],acc2)
    d = {}
    for k,v in acc2.items():
        if v > 1:
            d[k] = v
    todel = {}
    for k,v in d.items():        
        if k[0] in ('!BUILD_LIST', '!BUILD_TUPLE', '!BUILD_MAP', 'CONST', \
                    '!CLASS_CALC_CONST', '!CLASS_CALC_CONST_NEW', \
                    '!PyObject_Call', '!FirstCFunctionCall', '!FastCall') or k[0] != '!from_ceval_BINARY_SUBSCR':
            todel[k] = True
        else:
            todel[k] = True
                    
    for k in todel.keys():
        del d[k]
    todel = {}  
    for k,v in d.items():      
        for k1,v1 in d.items():        
            if k != k1 and expr_in_expr(k1, k) and v1 == v:
               todel[k1] = True
    for k in todel.keys():
        del d[k]  
    return d    

def find_common_subexpr_for_float(it,acc):
    assert type(it) is tuple

    d = detect_repeated_subexpr(it[1][0], it[2][0])
    assert type(d) is dict
    subfloat = {}
    upfloat = {}
    todel = {}
    for k in d.iterkeys():
        for x in acc:
            if k == x:
                todel[k] = True
    for k in todel.keys():
        del d[k]            
    for k in d.iterkeys():
        for x in acc:
            if expr_in_expr(k, x):
                subfloat[k] = subfloat.get(k,0) + 1
            if expr_in_expr(x, k):
                upfloat[k] = upfloat.get(k,0) + 1
# k1 and k2 is uniq => todel is uniq
#--
# I don't know... And I don't  
    for k in set(upfloat.keys()) & set(subfloat.keys()):
#        [k1 for k1 in upfloat.iterkeys() \
#                              for k2 in subfloat.iterkeys() if k1 == k2]:
        del subfloat[k]            
        del upfloat[k]  
    return subfloat.keys()
    
def generate_mixed_float_expr(it,acc,o,isfloat):
    assert type(it) is tuple
    assert type(o) is Out    
    assert (it[1] is None or len(it[1]) == 1) and len(it[2]) == 1
    acc_subfloat = find_common_subexpr_for_float(it,acc)
    refs_subfloat = Expr(o, acc_subfloat) #[Expr1(x, o) for x in acc_subfloat]
    PushAcc(acc_subfloat, refs_subfloat)
    refs = Expr(o, acc) #[Expr1(x, o) for x in acc]
    PopAcc(o)
    seq = 'if ('
    for i,x in enumerate(refs):
        if x[0] != 'CONST' and not IsFloat(TypeExpr(acc[i])) :
            seq = seq + 'PyFloat_CheckExact(' + CVar(x) + ')'
            seq = seq + ' && '
    if seq == 'if (':
       seq = 'if (1) {'
    else:    
        seq = seq[:-4] + ') {'
    o.append(seq)
    floats = []
    for x in refs:
        if x[0] == 'CONST':
            x1 = x[1]
            assert type(x1) is float
            if hasattr(math, 'isnan') and math.isnan(x1):
                floats.append(float_str(x1))
            elif hasattr(math, 'isinf') and math.isinf(x1):
                floats.append(float_str(x1))
            else:    
                floats.append(x)
        else:
            floats.append(New('double'))
    text_floats = []        
    for x in floats:
        if x[0] == 'CONST':
            text_floats.append(str(x[1]))
        else:
            text_floats.append(CVar(x))
    for i, x in enumerate(floats):
        if istemptyped(x):
            o.Stmt(x, '=', 'PyFloat_AS_DOUBLE', refs[i])        
    float_seq = generate_float_expr(it[2][0], acc, text_floats)    
    ref = New()
    o.Stmt(ref, '=', 'PyFloat_FromDouble', float_seq)
    o.Cls(*floats)
    o.append('} else {')
    PushAcc(acc_subfloat+acc, refs_subfloat+refs)
    if len(floats) <= 2:
        ref = GenExpr(it[2][0], o, ref,None,True)
    else:    
        ref = GenExpr(it[2][0], o, ref)
    PopAcc(o, False)
    o.append('}')
    o.Cls(*refs)
    PushAcc(acc_subfloat, refs_subfloat)
    if it[1] is not None:
        generate_store(it[1][0], ref, o, acc)
    PopAcc(o, False)
    o.Cls(*refs_subfloat)    
    if it[1] is not None:
        o.Cls(ref)
    else:
        return ref    
    return
    
def generate_compaund_statement(head,it,o):
    assert type(o) is Out    
    global loop_else_context
    if head == 'IF':
        generate_if(it,o)
        return
    if head == 'PREEXPR':
        generate_preexpr(it,o)
        return
    if head == 'WHILE':
        prev_compr = g_co.list_compr_in_progress
        g_co.list_compr_in_progress = True
        loop_else_context.append(None)
        generate_while(it,o)
        del loop_else_context[-1]
        g_co.list_compr_in_progress = prev_compr
        return
    if head == 'FOR':
        prev_compr = g_co.list_compr_in_progress
        g_co.list_compr_in_progress = True
        loop_else_context.append(None)
        generate_for_new(it,o)
        del loop_else_context[-1]
        g_co.list_compr_in_progress = prev_compr
        return
    if head == 'TRY': 
        g_co.Use_all_fastlocals()
        if attempt_iteration_try(it, o):
            return 
        generate_try(it,o)
        return
    if head == 'TRY_FINALLY': 
        g_co.Use_all_fastlocals()
        generate_try_finally(it,o)
        return
    if head == 'WITH':
        g_co.Use_all_fastlocals()
        generate_with(it,o)
        return
    Fatal('', it)
    assert False

def generate_with(it,o):
    global try_jump_context, dropped_temp
    global traced_tempgen
    assert type(o) is Out
    
    try_j = try_jump_context[:]
    assert len(it) == 3 and it[2] == (')ENDWITH',) and len(it[0]) == 3 and it[0][0] == '(WITH'
    r0 = Expr1(it[0][1], o)
    o.INCREF(r0)
    r1 = New()
    r2 = New()
    ref1 = New()
  
    o.Raw('if ((', r1, ' = from_ceval_2_7_special_lookup(', r0, ', "__enter__", &from_ceval_2_7_enter)) == 0) goto ', labl, ';')
    o.Raw('if ((', r2, ' = from_ceval_2_7_special_lookup(', r0, ', "__exit__", &from_ceval_2_7_exit)) == 0) goto ', labl, ';')
    Used('from_ceval_2_7_special_lookup')
    o.Raw('if ((', ref1, ' = PyObject_Call(', r1, ', ', ('CONST', ()), ', NULL)) == 0) goto ', labl, ';')
    o.Cls(r1)

    if it[0][2] == (): 
        pass
    elif len(it[0][2]) == 1 and it[0][2][0][0] in set_any:
        generate_store(it[0][2][0], ref1, o, 'Store clause at WITH statement')
    elif it[0][2][0] == 'SET_VARS':
        generate_store(it[0][2], ref1, o, 'Multy store clause at WITH statement')
    elif len(it[0][2]) == 2 and it[0][2][0] in set_any:
        generate_store(it[0][2], ref1, o, 'Store clause at WITH statement')
    elif len(it[0][2]) == 3 and it[0][2][0] in ('PyObject_SetAttr', 'PyObject_SetItem'):
        generate_store(it[0][2], ref1, o, 'Store clause at WITH statement')
    else:
        Fatal('WITH error', len(it[0][2]), it[0][2], it)
        assert False
    o.Cls(ref1) 
        
    try_jump_context.append(True)
    o.append('{')
    label_exc = New('label')  
    global traced_tempgen
    a,b,c = New(), New(), New()
    o.Stmt('PyErr_Fetch', ('&', a), ('&', b), ('&', c)) 
    set_toerr_new(o, label_exc)
    o.XINCREF(a)
    o.XINCREF(b)
    o.XINCREF(c)
    dropped_temp.append(('WITH', (ref1, r2, a,b,c)))
    traced_tempgen.append({})
    generate_list(it[1],o)
    traced_temp = traced_tempgen[-1].keys()
    del traced_tempgen[-1]
    if len(traced_tempgen) > 0:
        for k in traced_temp:
            traced_tempgen[-1][k] = True
    set_toerr_back(o)
    o.Stmt('PyErr_Restore', a,b,c)   
    ref2 = New()
    o.Raw('if ((', ref2, ' = PyObject_Call(', r2, ', ', ('CONST', (None,None,None)), ', NULL)) == 0) goto ', labl, ';')
    bool_ret = None
    UseLabl()
    raised = None
    ot = Out()
    if IsUsedLabl(label_exc):   
        raised = New('int')
        o.Raw(raised, ' = 0;')
        o.Stmt('if (0) { ', label_exc, ':')
        o.Stmt(raised, '=', 1)
        o.append('PyTraceBack_Here(f);') 
        generate_clear_temp_on_exception(o, traced_temp)
        ae,be,ce = get_exc_info(o)
        o.XINCREF(ae)
        o.XINCREF(be)
        o.XINCREF(ce)
        tupl = New()
        o.Raw(tupl, ' = PyTuple_Pack(3, ', ae, ', ', be, ', ', ce, ');')
        ref2 = New()
        o.Raw('if ((', ref2, ' = PyObject_Call(', r2, ', ', tupl, ', NULL)) == 0) goto ', labl, ';')
        o.Cls(tupl, r2)
        bool_ret = New('int')
        o.Raw('if (', ref2, ' == Py_None) ', bool_ret, ' = 0;')
        o.Raw('else {')
        o.Raw('if ((', bool_ret, ' = PyObject_IsTrue(', ref2, ')) == -1) goto ', labl, ';')
        o.append('}')
        o.Cls(ref2)
        UseLabl()

        o.Raw('if (', bool_ret, ') {')
        o.Stmt('PyErr_Restore', a,b,c)
        PyEval_reset_exc_info(o)       
        o.append('} else {')
        o.Stmt('PyErr_Restore', ae,be,ce)   
        ot.DECREF(r0)
        ot.Cls(ref2, a, b, c, r0, r2, r1)
        o.extend(ot)
        o.Raw('goto ',labl, ';')
        UseLabl()
        o.append('}')
        o.Cls(ae, be, ce)
        o.append('}')
    o.append('}')
    if len(ot) > 0:
        o.extend(ot)
    o.Cls(ref2, a, b, c, r0, r2, r1)
    UseLabl()
    o.Cls(raised, bool_ret)
    set_toerr_final(o)
    del dropped_temp[-1]
    try_jump_context[:] = try_j
    return

def attempt_iteration_try(it, o):
    assert type(o) is Out
    if len(it) != 5:
        return False
    body = it[1]
    assert type(body) is list
    exc = it[2]
    handle = it[3]
    while len(body) > 0 and body[0][0] == '.L':
        body = body[1:]
    if len(body) == 0:
        return False    
    stmt = body[0]    
    no_append = False
    iter = None
    if stmt[0] == 'STORE':
        if len(stmt[1]) != 1 or len(stmt[2]) != 1:
            return False
        action = stmt[2][0]
        iter = is_attr_next_call(action)
        if iter == False:
            return False
        no_append = True
    elif 'next' in repr(stmt):
        if stmt[0] != 'UNPUSH':
            return False
        if not like_append(stmt[1]):
            return False
        expr_value = stmt[1][2][1][0]
        iter = is_attr_next_call(expr_value)
        if iter == False:
            return False
        no_append = False
    if exc[0] != ')(EXCEPT':
        return False
    if len(exc) >= 3 and exc[2] != ():
        return False
    if len(exc) < 2:
        return False
    excarg = exc[1]
    if len(excarg) == 2:
        if type(excarg[1]) is int:
            excarg = (excarg[0],)
    if len(excarg) == 1 and type(excarg) is tuple:
        excarg = excarg[0]
    if len(excarg) != 2:
        return False
    if excarg[1] != 'StopIteration':
        return False 
    if iter is None:
        return False
    ref_iter = Expr1(iter,o)
    o.Stmt('if (PyIter_Check(', ref_iter, ')) {')
    val_iter = New()
    o.Stmt(val_iter, '=', 'PyIter_Next', ref_iter)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (', val_iter, '!= NULL ) {')
    o.Cls(ref_iter)    
    if no_append:
        generate_store(stmt[1][0], val_iter, o, stmt)
        o.ZeroTemp(val_iter)  
    else:
        ref_list = Expr1(stmt[1][1][1], o)
        _generate_may_be_append(ref_list, val_iter, o, IsList(TypeExpr(stmt[1][1][1])))
        o.Cls(ref_list)
    o.Cls(val_iter)
    generate_list(body[1:], o)   
    o.append('} else {')
    generate_list(handle, o)   
    o.append('}')
    o.append('} else {')
    generate_try(it, o)   
    o.append('}')
    return True

def is_attr_next_call(action):
    if action[0] != '!PyObject_Call':
        return False
    if len(action[2]) != 2:
        return False
    if action[2][0] != 'CONST':
        return False
    if action[2][1] != ():
        return False
    if len(action[3]) != 1:
        return False
    if action[3][0] != 'NULL':
        return False
    if len(action[1]) != 3:
        return False
    if action[1][0] != '!PyObject_GetAttr':
        return False
    if len(action[1][2]) != 2:
        return False
    if action[1][2][0] != 'CONST':
        return False
    if action[1][2][1] != 'next':
        return False
    return action[1][1]  
       
def no_to_else(it, i):
    if it[i+1] == [('PASS',)] and (i+2) == len(it):
        return True
    if isretblock(it[i+1]) and (i+2) == len(it):
        if len(it[i+1]) == 2 and it[i+1][0][0] == '.L':
            return True
        if len(it[i+1]) == 1:
            return True
    return False

def generate_try(it,o2):
    global try_jump_context, dropped_temp, line_number
    assert type(it) is list
    assert type(o2) is Out
    o = Out()
    else_cod = None
    i = 2
    while i < len(it):
        assert type(i) is int
        if it[i][0] == ')(EXCEPT':
            i += 2
            continue
        elif it[i][0] == ')(ELSE':
            else_cod = it[i+1]
            del it[i]
            del it[i]
            continue
        elif it[i][0] == ')ENDTRY':
            del it[i]    
        else:
            Fatal('', it, i, it[i])
            assert False
    try_jump_context.append(True)
    to_else = New('int')
    o.Stmt(to_else, '=', 1)
    label_exc = New('label') 

    global traced_tempgen
    a = New()
    b = New()
    c = New()
    o.Stmt('PyErr_Fetch', ('&', a), ('&', b), ('&', c))
    dropped_temp.append(('TRY', (a,b,c)))
    set_toerr_new(o, label_exc)

    traced_tempgen.append({})
    generate_list(it[1],o)
    traced_temp = traced_tempgen[-1].keys()
    del traced_tempgen[-1]
    if len(traced_tempgen) > 0:
        for k in traced_temp:
            traced_tempgen[-1][k] = True
    set_toerr_back(o)
    o.Stmt('PyErr_Restore', a,b,c)   

    a1,b1,c1 = None,None,None
    i = 2
    if not IsUsedLabl(label_exc):        
        del try_jump_context[-1]     
        if else_cod is not None:
            o.Comment((')(ELSE',))
            o.Stmt('if (', to_else, ') {')
            generate_list(else_cod,o)
            o.append('}')
        o.Cls(a, b, c)
        o.Cls(to_else)
        set_toerr_final(o)
        try_opt(o, to_else)
        o2.extend(o)
        del dropped_temp[-1]
        return None
    global tempgen
    o.Stmt('if (0) { ', label_exc, ':')
    
    if is_current & IS_CODEFUNC:
        o.append('PyTraceBack_Here(f);')
    else:    
        cod = const_to(g_co)
        Used('Direct_AddTraceback')
        if line_number:
            o.Raw('Direct_AddTraceback((PyCodeObject *)', cod, ', PyLine, PyAddr);') 
        else:
            o.Raw('Direct_AddTraceback((PyCodeObject *)', cod, ', 0, 0);') 
        
    handled = False
    generate_clear_temp_on_exception(o, traced_temp)
    while i < len(it):
        assert type(i) is int
        if it[i][0] == ')(EXCEPT' and len(it[i]) == 1:
            o.Comment(it[i])
            o.Raw('if (', to_else, ') {')
            ae,be,ce = get_exc_info(o)
            o.Cls(ae, be, ce)
            o.Stmt('PyErr_Restore', a,b,c)
            if no_to_else(it, i):
                pass
            else:
                o.Stmt(to_else, '=', 0)
            generate_list(it[i+1],o)
            PyEval_reset_exc_info(o)       
            o.append('}')
            handled = True
            i += 2
            continue
        if it[i][0] == ')(EXCEPT' and len(it[i]) > 1:
            if ((len (it[i][1]) == 2 and type(it[i][1][1]) is int) or len (it[i][1]) == 1) and \
               len(it[i][2]) == 0:
                    iti = it[i]
                    o.Comment(iti)
                    o.Raw('if (', to_else, ') {')
                    if len (iti[1]) == 2 and type(iti[1][1]) is int:
                        set_line(o, iti[1][1])

                    ref_ = Expr1(iti[1][0],o)
                    ref1 = New('int')
                    o.Stmt(ref1, '=', 'PyErr_ExceptionMatches', ref_)
                    o.Cls(ref_)
                    o.Stmt('if (', ref1, ') {')
                    ae,be,ce = get_exc_info(o)
                    o.Cls(ae, be, ce)

                    o.Stmt('PyErr_Restore', a,b,c)
                    o.Stmt(to_else, '=', 0)
                    generate_list(it[i+1],o)
                    PyEval_reset_exc_info(o)       
                    o.append('}')
                    o.Cls(ref1)
                    o.append('}')
                    i += 2
                    continue
            if ((len (it[i][1]) == 2 and type(it[i][1][1]) is int) or len (it[i][1]) == 1) and \
               len(it[i][2]) >= 1:
                    iti = it[i]
                    o.Comment(iti)
                    o.Raw('if (', to_else, ') {')
                    if len (iti[1]) == 2 and type(iti[1][1]) is int:
                        set_line(o, iti[1][1])

                    ref_ = Expr1(iti[1][0],o)
                    ref1 = New('int')
                    o.Stmt(ref1, '=', 'PyErr_ExceptionMatches', ref_)
                    o.Cls(ref_)
                    o.Stmt('if (', ref1, ') {')
                    ae,be,ce = get_exc_info(o)
                    if len(it[i][2]) == 1 and it[i][2][0][0] in set_any:
                        generate_store(it[i][2][0], be, o, 'Object Exception')
                    elif len(it[i][2]) >= 1 and it[i][2][0] == 'UNPACK_SEQ_AND_STORE':
                        generate_store(it[i][2], be, o, 'Object Exception')
                    else:
                        Fatal('TRY error', it[i])
                        assert False
                    o.Cls(ae, be, ce)

                    o.Stmt('PyErr_Restore', a,b,c)
                    o.Stmt(to_else, '=', 0)
                    generate_list(it[i+1],o)
                    PyEval_reset_exc_info(o)      
                    o.append('}')
                    o.Cls(ref1)
                    o.append('}')
                    i += 2
                    continue
            Fatal('TRY error', it[i], it[i][0], it[i][1], it[i][1][0], it[i][2], it[i][2][0])
            assert False
        else:
            Fatal('', it, i, it[i])
            assert False
    del try_jump_context[-1]        
    if not handled and else_cod is None:
        o.Stmt('if (', to_else, ') {')
        o.Stmt('goto', labl)
        UseLabl()
        o.append('}')
                
    o.append('}')
    if else_cod is not None:
        o.Comment((')(ELSE',))
        o.Stmt('if (', to_else, ') {')
        generate_list(else_cod,o)
        o.append('}')
    global tempgen
    o.Cls(a, b, c)
    o.Cls(a1, b1, c1)
    del dropped_temp[-1]
    if else_cod is not None:
        o.Cls(to_else)
    set_toerr_final(o)
    try_opt(o, to_else)
    o2.extend(o)
    
def PyEval_reset_exc_info(o):    
    assert type(o) is Out    
    if is_current & IS_DIRECT or is_current & IS_ANY_CFUNC:
        o.Stmt('_PyEval_reset_exc_info', 'PyThreadState_GET()')
    else:
        o.Stmt('_PyEval_reset_exc_info', 'f->f_tstate')
   
def PyEval_set_exc_info(o, ae, be, ce):
    assert type(o) is Out    
    if is_current & IS_DIRECT or is_current & IS_ANY_CFUNC:
        o.Stmt('_PyEval_set_exc_info', 'PyThreadState_GET()', ae, be, ce)       
    else:    
        o.Stmt('_PyEval_set_exc_info', 'f->f_tstate', ae, be, ce)    
            
def try_opt(o, to_else):
    assert type(o) is Out    
    may_be_append_to_o(Out(), no_comment_o(o), 'int', ConC(to_else), o, False)

def generate_try_finally(it,o2):
    global try_jump_context, dropped_temp
    assert type(it) is list
    assert type(o2) is Out
    o = Out() 
    finally_cod = None
    while 2 < len(it):
        if it[2][0] == ')ENDTRY_FINALLY':
            del it[2]    
        elif it[2][0] == ')(FINALLY':
            finally_cod = it[2+1]
            del it[2]
            del it[2]
            continue
        else:
            Fatal('', it, 2, it[2])
            assert False
    try_jump_context.append(finally_cod)

    label_exc = New('label') 

    global traced_tempgen
    a = New()
    b = New()
    c = New()
    o.Stmt('PyErr_Fetch', ('&', a), ('&', b), ('&', c))
    dropped_temp.append(('TRY', (a,b,c)))

    set_toerr_new(o, label_exc)

    traced_tempgen.append({})
    generate_list(it[1],o)
    traced_temp = traced_tempgen[-1].keys()
    del traced_tempgen[-1]
    if len(traced_tempgen) > 0:
        for k in traced_temp:
            traced_tempgen[-1][k] = True

    set_toerr_back(o)
    o.Stmt('PyErr_Restore', a,b,c)   

    a1,b1,c1 = None,None,None 

    if not IsUsedLabl(label_exc):        
        del try_jump_context[-1]     
        generate_list(finally_cod,o)
        o.Cls(a, b, c)
        set_toerr_final(o)
        o2.extend(o)
        del dropped_temp[-1]
        return None
    global tempgen
    raised = New('int')
    is_return = False
    if it[1][-1][0] == 'RETURN_VALUE': 
        o.Raw(label_exc, ':')
        is_return = True
    else:
        o.Stmt(raised, '=', 0)
        o.Stmt('if (0) { ', label_exc, ':')

    if False:
        if is_current & IS_CODEFUNC:
            o.append('PyTraceBack_Here(f);')
        else:    
            cod = const_to(g_co)
            Used('Direct_AddTraceback')
            if line_number:
                o.Raw('Direct_AddTraceback((PyCodeObject *)', cod, ', PyLine, PyAddr);') 
            else:
                o.Raw('Direct_AddTraceback((PyCodeObject *)', cod, ', 0, 0);') 
    
    o.Stmt(raised, '=', 1)
    generate_clear_temp_on_exception(o, traced_temp)
    if not is_return:
        o.append('}')
    if 2 < len(it):
        Fatal('', it)
        assert False
    del try_jump_context[-1]        
    o.Comment((')(FINALLY',))
    temp_finally = finally_cod
    finally_cod = []
    generate_list(temp_finally,o)
    finally_cod = temp_finally
    temp_finally = None
    global tempgen
    o.Cls(a, b, c)
    o.Cls(a1, b1, c1)
    o.Cls(raised)
    if is_return:
        o.Raw('goto ',labl, ';')
    else:
        o.Raw('if (', raised, ') { goto ',labl, '; }')
    UseLabl()
    del dropped_temp[-1]
    set_toerr_final(o)
    o2.extend(o)
  
def generate_clear_temp_on_exception(o, traced_temp):
    assert type(o) is Out    
    for k, n in traced_temp:
        o.CLEAR('temp[' + str(n) + ']')
  
def get_exc_info(o):
    assert type(o) is Out    
    ae,be,ce = New(), New(), New()
    o.Stmt('PyErr_Fetch', ('&', ae), ('&', be), ('&', ce))
    o.Stmt('if (', be, '== 0) {')
    o.Raw(be, '= Py_None;')
    o.INCREF(be)
    o.append('}')
    o.Stmt('PyErr_NormalizeException', ('&', ae), ('&', be), ('&', ce))
    PyEval_set_exc_info(o, ae, be, ce)  
    o.Stmt('if (', ce, '== 0) {')
    o.Raw(ce, '= Py_None;')
    o.INCREF(ce)
    o.append('}')
    return ae, be, ce

def set_toerr_new(o, label_err):    
    global labels, labl
    labels.append(label_err)
    labl = label_err

def set_toerr_back(o):
    global labels, labl
    del labels[-1]
    if len(labels) > 0:
        labl = labels[-1]
    else:
        labl = None  
        
def set_toerr_final(o):
    pass 

IsObject = ('!LOAD_NAME', '!LOAD_GLOBAL', 'FAST', '!PyObject_Call', '!CALL_CALC_CONST', '!CALL_CALC_CONST_INDIRECT',\
            '!PyDict_GetItem(glob,', '!BINARY_SUBSCR_Int',\
            '!PyObject_GetAttr', '!PyNumber_And', '!PyNumber_Or', \
            '!from_ceval_BINARY_SUBSCR', '!PySequence_GetSlice', '!LOAD_DEREF', 'CALC_CONST',\
            '!PyList_GetSlice', '!PyTuple_GetSlice',
            '!BUILD_MAP', '!BUILD_SET',  '!MK_FUNK', '!_PyEval_ApplySlice', \
            '!LIST_COMPR', '!BUILD_TUPLE')

IsFloatOp = {'!PyNumber_Add':'+', '!PyNumber_InPlaceAdd':'+', \
            '!PyNumber_Divide':'/', '!PyNumber_Multiply':'*', '!PyNumber_Negative':'-', \
            '!PyNumber_Subtract':'-', '!PyNumber_InPlaceSubtract':'-', '!PyNumber_Power':None}
           
def parse_for_float_expr(it, acc, isfloat): 

    if it in acc:
        return True
    t = TypeExpr(it)
    if IsInt(t) or t == Kl_IntUndefSize or IsSequence(t):
        return False
    if type(it) is float:
        acc.append(('CONST', it))
        return True
    if type(it) is tuple :
        if it[0] == 'CONST' and type(it[1]) is float:
            acc.append(it)
            return True
        if it[0] == 'CONST' and type(it[1]) is int:
            acc.append(it)
            return True
        if it[0] == '!PyNumber_Power':
            if not parse_for_float_expr(it[1], acc, isfloat):
                return False
            if it[2][0] == 'CONST' and type(it[2][1]) is int and\
            it[3] == 'Py_None' and it[2][1] >= 2 and it[2][1] <= 5:
                return True
            assert 'sqrt' not in repr(it)
            return False
    
        if it[0] in IsFloatOp:
            if it[0] in ('!PyNumber_Add', '!PyNumber_Subtract'):
                if it[1][0] == 'CONST' and type(it[1][1]) is int:
                    return parse_for_float_expr(it[2], acc, isfloat)
                if it[2][0] == 'CONST' and type(it[2][1]) is int:
                    return parse_for_float_expr(it[1], acc, isfloat)
            ret = True
            for i in it[1:]:
                ret = ret and parse_for_float_expr(i, acc, isfloat)  
            return ret    
        if it[0] == '!PyObject_Call' and it[1][0] == 'CALC_CONST':
            t = it[1][1]    
            if len(t) == 2:
                t = (ImportedM[t[0]], t[1])
                if t in CFuncFloatOfFloat:
                    if it[2][0] == 'CONST' and len(it[2][1]) == 1:
                        return parse_for_float_expr(('CONST', it[2][1][0]), acc,isfloat)
                    return parse_for_float_expr(it[2][1][0], acc,isfloat)
            if t in ImportedM:
                t = ImportedM[t]
            else:
                t = None
            if t in CFuncFloatOfFloat:
                if it[2][0] == 'CONST' and len(it[2][1]) == 1:
                    return parse_for_float_expr(('CONST', it[2][1][0]), acc,isfloat)
                return parse_for_float_expr(it[2][1][0], acc,isfloat)
                
        if it[0] in IsObject:
            acc.append(it)
            isfloat[it] = True
            return True
    return False    
    
def generate_float_expr(it, acc, refs):
 
    if type(it) is float:
        return str(it)
    assert type(it) is tuple
    if it[0] in IsFloatOp:
        op = IsFloatOp[it[0]]
        if op is None:
            if it[2] == ('CONST', 2):
                iit = generate_float_expr(it[1], acc, refs)
                return '(' + iit + ') * (' + iit + ')'
            elif it[2] == ('CONST', 3):
                iit = generate_float_expr(it[1], acc, refs)
                return '(' + iit + ') * (' + iit + ') * (' + iit + ')'
            elif it[2] == ('CONST', 4):
                iit = generate_float_expr(it[1], acc, refs)
                return '(' + iit + ') * (' + iit + ') * (' + iit + ') * (' + iit + ')'
            elif it[2] == ('CONST', 5):
                iit = generate_float_expr(it[1], acc, refs)
                return '(' + iit + ') * (' + iit + ') * (' + iit + ') * (' + iit + ') * (' + iit + ')'
            Fatal('generate float EXPR', it)
            assert False
        if len(it) == 3:     
            return '(' + generate_float_expr(it[1], acc, refs) + ') ' + op + ' (' + generate_float_expr(it[2], acc, refs) + ')'
        if len(it) == 2:     
            return op + '(' + generate_float_expr(it[1], acc, refs) + ')'
        Fatal('generate float EXPR', it)
        assert False
  
    if it[0] == '!PyObject_Call' and it[1][0] == 'CALC_CONST':
        t = it[1][1] 
        if type(t) is str and t in ImportedM:
            t = ImportedM[t]
        elif len(t) == 2 and t[0] in ImportedM:
            t = (ImportedM[t[0]], t[1])
        if t in CFuncFloatOfFloat:
            return CFuncFloatOfFloat[t] + ' ( ' + generate_float_expr(it[2][1][0], acc, refs) +' )'
    if it in acc:
        i = acc.index(it)
        return refs[i]
    if it[0] == 'CONST' and type(it[1]) is int:
        return ' ' + str(it[1]) + ' '
    Fatal('generate float EXPR', it)
    assert False
    
redef_len = set(['__len__'])
    
def generate_ssize_t_expr(it, nocheck = False): 
    if type(it) is int:
        return Out(), it
    if it[0] == 'PY_TYPE' and IsInt(TypeExpr(it)):
        return generate_ssize_t_expr(it[3], True)
    if it[0] == '!PY_SSIZE_T':
        return generate_ssize_t_expr(it[1])
    if it[0] == 'CONST' and type(it[1]) is int:
        return Out(), it[1]
    if IsCVar(it) and IsInt(TypeExpr(it)):
        return Out(), CVarName(it)    
    if it[0] in len_family:
        if it[0] != '!PyObject_Size':
            if it[1][0] == '!LIST_COMPR':
                o = Out()
                prev_compr = g_co.list_compr_in_progress
                g_co.list_compr_in_progress = True
                size_t = generate_len_list_compr(it[1][1],it[1][2],o) 
                g_co.list_compr_in_progress = prev_compr
                return o, size_t
            
            nm = it[0][1:]
        else:    
            nm = 'PyObject_Size'
            t = TypeExpr(it[1])
            if t is not None:
                if IsListAll(t, redef_len):
                    if it[1][0] == '!LIST_COMPR':
                        o = Out()
                        prev_compr = g_co.list_compr_in_progress
                        g_co.list_compr_in_progress = True
                        size_t = generate_len_list_compr(it[1][1],it[1][2],o) 
                        g_co.list_compr_in_progress = prev_compr
                        return o, size_t
                    nm  = 'PyList_GET_SIZE'
                elif IsTuple(t):
                    nm  = 'PyTuple_GET_SIZE'
                elif IsStr(t):
                    nm = 'PyString_GET_SIZE'
                elif IsDict(t):
                    nm = 'PyDict_Size'
                elif t == Kl_Set:
                    nm = 'PySet_Size'
                elif t == Kl_Unicode:
                    nm = 'PyUnicode_GetSize'
                elif t == Kl_Buffer:
                    nm = 'PyObject_Size'
                elif t == Kl_XRange:
                    nm = 'PyObject_Size'
                elif t is Kl_Generator or IsInt(t):
                    nm = 'PyObject_Size'
                elif IsKlNone(t):
                    Debug("len(None) construction detected", it)
                    nm = 'PyObject_Size'
                elif t[0] in (T_OLD_CL_INST, T_NEW_CL_INST, T_ANY_CL_INST):
                    nm = 'PyObject_Size'
                elif t is not None:
                    nm = 'PyObject_Size'
                    if not IsSequence(t):
                        Debug('len of new known type', t, it[1], func)
        size_t = New('Py_ssize_t')
        o = Out()
        ref1 = Expr1(it[1], o)
        if nm.endswith('_GET_SIZE'):
            o.Raw(size_t, ' = ', nm, '(', ref1, ');')
        else:    
            o.Stmt(size_t, '=', nm, ref1)
        o.Cls(ref1)
        return o, size_t
    plusminus = {'!PyNumber_Add':0, '!PyNumber_Subtract':1}
    if it[0] in plusminus:
        t1 = TypeExpr(it[1])
        t2 = TypeExpr(it[2])
        if IsInt(t1) and IsInt(t2):
            o1, v1 = short_gen_size_t(it[1])
            o2, v2 = short_gen_size_t(it[2])
            size_t = New('Py_ssize_t')
            o = Out()
            o.extend(o1)
            o.extend(o2)
            op = (' + ', ' - ')[plusminus[it[0]]]
            o.Raw(size_t, ' = ', v1, op, v2, ';')
            o.Cls(v1, v2)
            return o, size_t
    if it[0] == '!PyNumber_Negative':
        t1 = TypeExpr(it[1])
        if IsInt(t1) and t1[1][0] >= -MInt:
            o1, v1 = short_gen_size_t(it[1])
            size_t = New('Py_ssize_t')
            o = Out()
            o.extend(o1)
            o.Raw(size_t, ' = 0 - ', v1, ';')
            o.Cls(v1)
            return o, size_t
    if it[0] == '!@PyInt_FromSsize_t':
        return Out(), ConC(it[1]) # for prevent Cls of temp 'for' count 

    o = Out()
    ref2 = Expr1(it, o)
    ind = New('Py_ssize_t')
    if nocheck:
        o.Raw(ind, ' = PyInt_AS_LONG ( ',ref2,' );') 
    else:
        o.Stmt(ind, '=', 'PyInt_AsSsize_t', ref2)
    o.Cls(ref2)
    return o, ind
            

type_to_check = {'tuple' : 'PyTuple_CheckExact', 'list' : 'PyList_CheckExact',
                 'dict' : 'PyDict_CheckExact', 'int' : 'PyInt_CheckExact',
                 'str' : 'PyString_CheckExact',
                 'float' : 'PyFloat_CheckExact', 'complex' : 'PyComplex_CheckExact',
                 'bool' : 'PyBool_Check',
                 'frozenset' : 'PyFrozenSet_CheckExact'}  
type_to_check_t = {tuple : 'PyTuple_CheckExact', list : 'PyList_CheckExact',
                 dict : 'PyDict_CheckExact', int : 'PyInt_CheckExact',
                 str : 'PyString_CheckExact', 
                 float : 'PyFloat_CheckExact', complex : 'PyComplex_CheckExact',
                 bool : 'PyBool_Check',
                 frozenset : 'PyFrozenSet_CheckExact'}  
if py_version < 30:
    type_to_check_t[long] = 'PyLong_CheckExact'   
    type_to_check['long'] = 'PyLong_CheckExact' 
    type_to_check_t[unicode] = 'PyUnicode_CheckExact' 
    type_to_check['unicode'] = 'PyUnicode_CheckExact' 
                 
if False:
    del type_to_check['frozenset']
    del type_to_check_t[frozenset]
type_to_check_str = {tuple : 'tuple', list : 'list',
                 dict : 'dict', int : 'int',
                 str : 'str', 
                 set : 'set', frozenset : 'frozenset',
                 float : 'float', complex : 'complex',
                 bool : 'bool'} 
if py_version < 30:
    type_to_check_str[long] = 'long'
    type_to_check_str[unicode] = 'unicode'

def cmp_tuple_item(o, logic, ref1, val, op):
    assert type(o) is Out
    if type(val) is str and op == 'Py_EQ':
        o.Raw('if ( PyString_CheckExact( ', ref1, ') ) {')
        o.Raw(logic, ' = (PyString_GET_SIZE(', ref1, ') == ', len(val),') && (0 == memcmp(', Str_AS_STRING(ref1), ', ', Str_AS_STRING(('CONST', val)), ', ',len (val), '));')
        o.append('} else {')
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ('CONST', val), op)
        o.append('}')
    elif type(val) is str and op == 'Py_NE':
        o.Raw('if ( PyString_CheckExact( ', ref1, ') ) {')
        o.Raw(logic, ' = (PyString_GET_SIZE(', ref1, ') != ', len(val),') || (0 != memcmp(', Str_AS_STRING(ref1), ', ', Str_AS_STRING(('CONST', val)), ', ',len (val), '));')
        o.append('} else {')
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ('CONST', val), op)
        o.append('}')
    elif type(val) is int and op == 'Py_EQ':
        o.Raw('if ( PyInt_CheckExact( ', ref1, ') ) {')
        o.Raw(logic, ' = PyInt_AS_LONG(', ref1, ') == ', val, ';')
        o.append('} else {')
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ('CONST', val), op)
        o.append('}')
    elif type(val) is int and op == 'Py_NE':
        o.Raw('if ( PyInt_CheckExact( ', ref1, ') ) {')
        o.Raw(logic, ' = PyInt_AS_LONG(', ref1, ') != ', val, ';')
        o.append('} else {')
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ('CONST', val), op)
        o.append('}')
    elif type(val) is type(None) and op == 'Py_EQ':
        o.Raw(logic, ' = ', ref1, ' == Py_None;')
        o.Raw('if (!', logic,') {')
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ('CONST', val), op)
        o.append('}')
    elif type(val) is tuple and op == 'Py_EQ' and len(val) == 0:
        o.Raw('if ( PyTuple_CheckExact( ', ref1, ') ) {')
        o.Raw(logic, ' = PyTuple_GET_SIZE(', ref1, ') == 0;')
        o.append('} else {')
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ('CONST', val), op)
        o.append('}')
    else:
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ('CONST', val), op)

def generate_rich_compare(it,logic,o):
    assert type(it) is tuple
    assert type(o) is Out    

    it1 = it[1]
    it2 = it[2]
    t1 = TypeExpr(it1)
    t2 = TypeExpr(it2)
    op = it[3]


    if IsType(t1) and IsType(t2) and op in ('Py_EQ', 'Py_NE'):
        pp(it)
        pp(t1, t2)
        assert False

    if IsInt(t1) and IsInt(t2):
        pprint(it)
        pp(';;', t1, t2)
        assert False

    if IsBool(t1) and IsBool(t2):
        pp(t1, t2)
        pprint(it)
        assert False

    if (IsTuple(t1) or t1 is None) and IsTuple(t2):
        ref1, ref2 = Expr(o, it[1:3])
        ref0 = None
        if t1 is None:
            o.Raw('if (PyTuple_CheckExact(', ref1, ')) {')
        if ref2[0] == 'CONST':
            if op == 'Py_EQ':
                o.Raw(logic, ' = PyTuple_GET_SIZE(', ref1,') == ', len(ref2[1]), ';')
                for i, _it in enumerate(ref2[1]):
                    o.Raw('if (', logic, ') {')
                    cmp_tuple_item(o, logic, ConC('PyTuple_GET_ITEM ( ', ref1, ' , ', i,' )'), ref2[1][i], op)
                    o.append('}')                    
            elif op == 'Py_NE':
                o.Raw(logic, ' = PyTuple_GET_SIZE(', ref1,') != ', len(ref2[1]), ';')
                for i, _it in enumerate(ref2[1]):
                    o.Raw('if (!', logic, ') {')
                    cmp_tuple_item(o, logic, ConC('PyTuple_GET_ITEM ( ', ref1, ' , ', i,' )'), ref2[1][i], op)
                    o.append('}')                    
            else:   
                ref0 = New() 
                o.Raw(ref0, ' = PyTuple_Type.tp_richcompare(', ref1, ', ', ref2, ', ', op, ');')
                ToTrue(o, logic, ref0, it)
                o.Cls(ref0)
        else:
            ref0 = New()
            o.Raw(ref0, ' = PyTuple_Type.tp_richcompare(', ref1, ', ', ref2, ', ', op, ');')
            ToTrue(o, logic, ref0, it)
            o.Cls(ref0)            
        if t1 is None:
            o.Raw('} else {')
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            o.Raw('}')
        o.Cls(ref0, ref1, ref2)
        return o, logic
        
    if IsChar(t1) and IsChar(t2):   
        assert False
    if IsStr(t1) and IsStr(t2):
        ref1, ref2 = Expr(o, it[1:3])
        if op == 'Py_EQ':
            assert False
        elif op == 'Py_NE':
            assert False
        elif True:
            ref0 = New()
            o.Raw(ref0, ' = PyString_Type.tp_richcompare(', ref1, ', ', ref2, ', ', op, ');')
            ToTrue(o, logic, ref0, it)
            o.Cls(ref0)
            o.Cls(ref1, ref2)
            return o, logic
        else:
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            o.Cls(ref1, ref2)
            return o, logic
            
        
    if IsStr(t1) and t2 is None and op in ('Py_EQ', 'Py_NE'):
        ref1, ref2 = Expr(o, it[1:3])
        o.Raw('if (PyString_CheckExact(', ref2, ')) {')
        if op == 'Py_EQ':
            o.Raw(logic, ' = (PyString_GET_SIZE(', ref1,') == PyString_GET_SIZE(', ref2, ')) && ', \
                  '(PyString_AS_STRING(',ref1,')[0] == PyString_AS_STRING(',ref2, ')[0]) && ', \
                  '(memcmp(PyString_AS_STRING(',ref1,'), PyString_AS_STRING(',ref2,'), ',
                        'PyString_GET_SIZE(', ref1,')) == 0);')
        else:
            o.Raw(logic, ' = (PyString_GET_SIZE(', ref1,') != PyString_GET_SIZE(', ref2, ')) || ', \
                  '(PyString_AS_STRING(',ref1,')[0] != PyString_AS_STRING(',ref2, ')[0]) || ', \
                  '(memcmp(PyString_AS_STRING(',ref1,'), PyString_AS_STRING(',ref2,'), ',
                        'PyString_GET_SIZE(', ref1,')) != 0);')
        o.append('} else {')    
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        o.append('}')
        o.Cls(ref1, ref2)
        return o, logic

    if IsStr(t2) and t1 is None and op in ('Py_EQ', 'Py_NE'):
        ref1, ref2 = Expr(o, it[1:3])
        o.Raw('if (PyString_CheckExact(', ref1, ')) {')
        if op == 'Py_EQ':
            o.Raw(logic, ' = (PyString_GET_SIZE(', ref1,') == PyString_GET_SIZE(', ref2, ')) && ', \
                  '(PyString_AS_STRING(',ref1,')[0] == PyString_AS_STRING(',ref2, ')[0]) && ', \
                  '(memcmp(PyString_AS_STRING(',ref1,'), PyString_AS_STRING(',ref2,'), ',
                        'PyString_GET_SIZE(', ref1,')) == 0);')
        else:
            o.Raw(logic, ' = (PyString_GET_SIZE(', ref1,') != PyString_GET_SIZE(', ref2, ')) || ', \
                  '(PyString_AS_STRING(',ref1,')[0] != PyString_AS_STRING(',ref2, ')[0]) || ', \
                  '(memcmp(PyString_AS_STRING(',ref1,'), PyString_AS_STRING(',ref2,'), ',
                        'PyString_GET_SIZE(', ref1,')) != 0);')
        o.append('} else {')    
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        o.append('}')
        o.Cls(ref1, ref2)
        return o, logic

    if IsStr(t2) and IsChar(t2) and t1 is None and op in op_to_oper:
        ref1, ref2 = Expr(o, it[1:3])
        o.Raw('if (PyString_CheckExact(', ref1, ') && PyString_GET_SIZE(', ref1,') == 1) {')
        o.Raw(logic, ' = PyString_AS_STRING(',ref1,')[0] ',op_to_oper[op],' PyString_AS_STRING(',ref2, ')[0];')
        o.append('} else {')    
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        o.append('}')
        o.Cls(ref1, ref2)
        return o, logic

    if (IsIntUndefSize(t1) or t1 is None) and IsInt(t2) and it[2][0] == 'CONST' and type(it[2][1]) is int:
        if op in op_to_oper:
            ref1 = GenExpr(it[1],o, None, None, True)   
            ref2 = it[2] 
            if (op_to_oper[op] == ' < ' and it[2][1] == ((-MInt)-1)) or (op_to_oper[op] == ' > ' and it[2][1] == MInt):
                o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
                o.Cls(ref1, ref2)
                return o, logic
            elif (op_to_oper[op] == ' >= ' and it[2][1] == ((-MInt)-1)) or (op_to_oper[op] == ' <= ' and it[2][1] == MInt):
                o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
                o.Raw(logic, ' = 1;')
                o.append('} else {')
                o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
                o.append('}')
                o.Cls(ref1, ref2)
                return o, logic

    if IsIntUndefSize(t1) and IsInt(t2) and it[2][0] == 'CONST' and type(it[2][1]) is int:
        if op in op_to_oper:
            ref1 = GenExpr(it[1],o, None, None, True)   
            ref2 = it[2] 
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            int1 = ConC('PyInt_AS_LONG ( ',ref1,' )') 
            int2 = ref2[1]
            o.Raw(logic, ' = ', int1, op_to_oper[op], int2, ';')
            o.append('} else {')
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            o.append('}')
            o.Cls(ref1, ref2)
            return o, logic

    if (t1 is None or IsIntUndefSize(t1)) and IsInt(t2):
        if op in op_to_oper and not g_co.IsIntVar(it[2]):
            ref1 = GenExpr(it[1],o, None, None, True)   
            ref2 = Expr1(it[2],o)   
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            int1 = ConC('PyInt_AS_LONG ( ',ref1,' )') 
            int2 = ConC('PyInt_AS_LONG ( ',ref2,' )') 
            o.Raw(logic, ' = ', int1, op_to_oper[op], int2, ';')
            o.append('} else {')
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            o.append('}')
            o.Cls(ref1, ref2)
            return o, logic

    if (t1 is None or IsIntUndefSize(t1)) and IsInt(t2):
        if op in op_to_oper and g_co.IsIntVar(it[2]):
            ref1 = GenExpr(it[1],o, None, None, True)   
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            int1 = ConC('PyInt_AS_LONG ( ',ref1,' )') 
            int2 = CVarName(it[2])
            o.Raw(logic, ' = ', int1, op_to_oper[op], int2, ';')
            o.append('} else {')
            ref2 = Expr1(it[2], o)
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            o.Cls(ref2)
            o.append('}')
            o.Cls(ref1)
            return o, logic


    if t1 is None and IsFloat(t2):
        if op in op_to_oper:
            ref1 = Expr1(it[1],o)   
            ref2 = Expr1(it[2],o)   
            o.Raw('if (PyFloat_CheckExact(', ref1, ')) {')
            f1 = ConC('PyFloat_AsDouble(',ref1,')') 
            if it[2][0] == 'CONST' and type(it[2][1]) is float:
                f2 = float_str(it[2][1]) 
            else:    
                f2 = ConC('PyFloat_AsDouble(',ref2,')') 
            o.Raw(logic, ' = ', f1, op_to_oper[op], f2, ';')
            o.Cls(f1, f2)
            o.append('} else {')
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            o.append('}')
            o.Cls(ref1, ref2)
            return o, logic

    if IsFloat(t1) and t2 is None:
        if op in op_to_oper:
            ref1 = Expr1(it[1],o)   
            ref2 = Expr1(it[2],o)   
            o.Raw('if (PyFloat_CheckExact(', ref2, ')) {')
            if it[1][0] == 'CONST' and type(it[1][1]) is float:
                f1 = float_str(it[1][1]) 
            else:    
                f1 = ConC('PyFloat_AsDouble(',ref1,')') 
            f2 = ConC('PyFloat_AsDouble(',ref2,')') 
            o.Raw(logic, ' = ', f1, op_to_oper[op], f2, ';')
            o.Cls(f1, f2)
            o.append('} else {')
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            o.append('}')
            o.Cls(ref1, ref2)
            return o, logic
    
    if IsShort(t1) and (t2 is None or IsIntUndefSize(t2)) and op in op_to_oper:
        it1_ = it1
        if it1[0] == 'PY_TYPE':
            it1_ = it1[3]
        if g_co.IsIntVar(it1_):
            o1, size_t_1 = Out(), CVarName(it1_)
        else:    
            o1,size_t_1 = short_gen_size_t((it1))
        o.extend(o1)
        ref2 = GenExpr(it[2],o, None, None, True)   
        o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
        o.Raw(logic, ' = ', size_t_1, op_to_oper[op], 'PyInt_AS_LONG ( ', ref2, ' );')
        o.append('} else {')
        ref1 = New()
        o.PushInt(ref1, size_t_1)
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        o.Cls(ref1)
        o.append('}')
        o.Cls(ref2, size_t_1)
        return o, logic

    if IsInt(t1) and (t2 is None or IsIntUndefSize(t2)) and op in op_to_oper:
        ref1 = Expr1(it[1], o)
        int_1 = None
        ref1, int_1 = to_long(o, ref1, int_1)  
        
        ref2 = GenExpr(it[2],o, None, None, True)   
        o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
        o.Raw(logic, ' = ', int_1, op_to_oper[op], 'PyInt_AS_LONG ( ', ref2, ' );')
        o.append('} else {')
        newref = False
        if ref1 is None:
            newref = True
            ref1 = New()
            o.PushInt(ref1, int_1) 
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        if newref:
            o.Cls(ref1)
        o.append('}')
        o.Cls(ref1, ref2, int_1)
        return o, logic


    if IsShort(t2) and (t1 is None or IsIntUndefSize(t1)) and op in op_to_oper:
        ref1 = GenExpr(it[1],o, None, None, True)   
        if it[2][0] == 'PY_TYPE' and it[2][3][0] == 'FAST' and not g_co.IsIntVar(it[2][3]):
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            o2,size_t_2 = short_gen_size_t(it[2])
            o.extend(o2)
            o.Raw(logic, ' = PyInt_AS_LONG ( ', ref1, ' )', op_to_oper[op], size_t_2, ';')
            o.Cls(size_t_2)
            o.append('} else {')
            ref2 = it[2][3]
            o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
            o.Cls(ref2)
            o.append('}')
            o.Cls(ref1, size_t_2)
            return o, logic
   
        o2,size_t_2 = short_gen_size_t(it[2])
        o.extend(o2)
        o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
        o.Raw(logic, ' = PyInt_AS_LONG ( ', ref1, ' )', op_to_oper[op], size_t_2, ';')
        o.append('} else {')
        ref2 = New()
        o.PushInt(ref2, size_t_2) 
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        o.Cls(ref2)
        o.append('}')
        o.Cls(ref1, size_t_2)
        return o, logic

    if IsInt(t2) and (t1 is None or IsIntUndefSize(t1)) and op in op_to_oper:
        ref1 = GenExpr(it[1],o, None, None, True)   
        ref2 = Expr1(it[2], o)
        n = New('long')
        o.Raw(n, ' = PyInt_AS_LONG ( ', ref2, ' );')
        o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
        o.Raw(logic, ' = PyInt_AS_LONG ( ', ref1, ' )', op_to_oper[op], n, ';')
        o.append('} else {')
        o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
        o.append('}')
        o.Cls(ref1, ref2, n)
        return o, logic
    
    if IsKlNone(t2) and t1 is None and \
       op in ('Py_EQ', 'Py_NE') and it[2] == ('CONST', None):
            ref1 = Expr1(it[1],o)   
            o.Raw(logic, ' = ', ref1, op_to_oper[op], ('CONST', None), ';')
            o.Cls(ref1)
            return o, logic

    if IsBool(t2) and IsBool(t1) and op in ('Py_EQ', 'Py_NE') and it[2][0] == 'CONST':
        assert False
               
    if t1 is not None and t2 is not None:   
        if t1 == Kl_String and t2 == Kl_String:
            Fatal('Cmp String unrecognized ?', it) 
            assert False
        Debug('Typed comparison unrecognized %s %s %s' % (t1, op, t2), it[1], it[2])
    elif t1 is not None or t2 is not None:    
        Debug('Half-typed comparison unrecognized %s %s %s' % (t1, op, t2), it[1], it[2])

    ref1, ref2 = Expr(o, it[1:3])
    o.Stmt(logic, '=', 'PyObject_RichCompareBool', ref1, ref2, it[3])
    o.Cls(ref1, ref2)
    return o, logic

def Gen_Patt_TuplInt(it0, t):
    assert it0[0][0] == 'CONST'
    assert type(it0[0][1]) is tuple
    li = list(it0[0][1])
    assert len(li) > 0
    assert all([type(x) is int for x in li])

    t2 = TypeExpr(it0[1])
    o = Out()
    s = ''
    if not IsInt(t2):
        o.append('if (PyInt_CheckExact({L2})) {')
        s = 'PyInt_AS_LONG({L2})'
    else:
        s = '{L2}'

    li1 = [ '(' + s + ' == ' + str(v) + ')' for v in li]
    o.append('{LB} = ' + ' || '.join(li1) + ';')
    if not IsInt(t2):
        o.append('} else {')
        for i, v in enumerate(li):
            o.append('if (({LB} = PyObject_RichCompareBool( ' + CVar(const_to(v)) + ', {L2}, Py_EQ )) == -1) goto L0;')
            if i < (len(it0[0][1]) - 1):
                o.append('if (!{LB}) {')
        for i in range(len(it0[0][1])-1):
            o.append('}')
        o.append('}')
    o.append('{LB}')
    return list(o)

def Gen_Patt_TuplChar(it0, t):
    assert it0[0][0] == 'CONST'
    assert type(it0[0][1]) is tuple
    li = list(it0[0][1])
    assert len(li) > 0
    assert all([type(x) is str and len(x) ==  1 for x in li])

##    t2 = TypeExpr(it0[1])
    o = Out()
    li1 = [ '({L2} == ' + str(ord(v)) + ')' for v in li]
    o.append('{LB} = ' + ' || '.join(li1) + ';')
    o.append('{LB}')
    return list(o)

def Gen_Patt_GetAttr_slots(it0, t):
    if is_GETATTR_compiled(t[0][1], it0[1][1]):
        return ['{LR} = ' + GETATTR_compiled(t[0][1], '{L1}', it0[1][1]) + ';', 
            'Py_INCREF({LR});', 
            '{LR}']
    return ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
            "{LR}"]
            
def list_final_class_first(li):
    li3 = []
    for k,obj in calculated_const.iteritems():
        if obj.derived_from is not None and len(obj.derived_from) > 0:
            li3.extend(obj.derived_from)
    li3 = set(li3)
##    pprint(li3)    
    li2 = [(('!CALC_CONST', v) in li3, v) for v in li]
    li2.sort()
##    pprint(li2)
    return [v for b, v in li2]

def Gen_Patt_U_GetAttr_slots(it0, t):
    assert False
    li = []
    if it0[1][1] != '__dict__' and it0[1][1] in inverted_compiled_slots:
        li = inverted_compiled_slots[it0[1][1]]
    li = list_final_class_first(li)
    li2 = []
    for k in li: 
        if len(li2) == 0:
            li2.append(ConC('if (((PyObject *)Py_TYPE({L1})) == ', ('CALC_CONST', k), ') {'))
        else:    
            li2.append(ConC('} else if (((PyObject *)Py_TYPE({L1})) == ', ('CALC_CONST', k), ') {'))
        li2.append('{LR} = GETATTR(' + k + ', {L1}, ' + it0[1][1] + ');')
        li2.append('Py_INCREF({LR});')
        
    if it0[1][1] in ('co_cellvars', 'co_code', 'co_consts', 'co_filename', 'co_freevars', 'co_lnotab', 'co_name', 'co_names', 'co_varnames'):        
        if len(li2) == 0:
            li2.append('if (PyCode_Check({L1})) {')
        else:
            li2.append('} else if (PyCode_Check({L1})) {')
        li2.append('{LR} = (((PyCodeObject *){L1})->' + it0[1][1] + ');')
        li2.append('Py_INCREF({LR});')
        
    if len(li2) == 0:
        li2.append("if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;")
    else:
        li2.append('} else {')
        li2.append("if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;")
        li2.append('}')
    li2.append('{LR}')
    return li2

def Gen_Patt_U_GetAttr_slots_AS_LONG(it0, t):
    assert False
    li = []
    if it0[1][1] != '__dict__' and it0[1][1] in inverted_compiled_slots:
        li = inverted_compiled_slots[it0[1][1]]
    li2 = []
    for k in li: 
        if len(li2) == 0:
            li2.append(ConC('if (((PyObject *)Py_TYPE({L1})) == ', ('CALC_CONST', k), ') {'))
        else:    
            li2.append(ConC('} else if (((PyObject *)Py_TYPE({L1})) == ', ('CALC_CONST', k), ') {'))
        li2.append('{LI} = PyInt_AS_LONG(GETATTR(' + k + ', {L1}, ' + it0[1][1] + '));')
    if it0[1][1] in ('co_argcount', 'co_flags', 'co_firstlineno', 'co_nlocals','co_stacksize'):
        if len(li2) == 0:
            li2.append('if (PyCode_Check({L1})) {')
        else:
            li2.append('} else if (PyCode_Check({L1})) {')
        li2.append('{LI} = (((PyCodeObject *){L1})->' + it0[1][1] + ');')

    if len(li2) == 0:
        li2.append("if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;")
        li2.append("{LI} = PyInt_AS_LONG({LR});")
        li2.append('Py_CLEAR({LR});')
    else:
        li2.append('} else {')
        li2.append("if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;")
        li2.append('{LI} = PyInt_AS_LONG({LR});')
        li2.append('Py_CLEAR({LR});')
        li2.append('}')
    li2.append('{LI}')
    return li2
 
def Gen_Patt_U_GetAttr_slots_bool(it0, t):
    assert False
    li = []
    if it0[1][1] != '__dict__' and it0[1][1] in inverted_compiled_slots:
        li = inverted_compiled_slots[it0[1][1]]
    li2 = []
    for k in li: 
        if len(li2) == 0:
            li2.append(ConC('if (((PyObject *)Py_TYPE({L1})) == ', ('CALC_CONST', k), ') {'))
        else:    
            li2.append(ConC('} else if (((PyObject *)Py_TYPE({L1})) == ', ('CALC_CONST', k), ') {'))
        li2.append('{LB} = (GETATTR(' + k + ', {L1}, ' + it0[1][1] + ') == Py_True);')
       
    if len(li2) == 0:
        li2.append("if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;")
        li2.append('{LB} = ({LR} == Py_True);')
#        li2.append('Py_CLEAR({LR});')
    else:
        li2.append('} else {')
        li2.append("if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;")
        li2.append('{LB} = ({LR} == Py_True);')
        li2.append('Py_CLEAR({LR});')
        li2.append('}')
    li2.append('{LB}')
    return li2

## ("PyObject_GetAttr",    Kl_Undefined, None, Kl_String, None,            Kl_Boolean,["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    ## "assert({LR} == Py_True || {LR} == Py_False);",
                                                                                    ## "({LR} == Py_True)"]),
def Gen_Patt_GetAttr_slots_AS_LONG(it0, t):
    if is_GETATTR_compiled(t[0][1], it0[1][1]):
        return 'PyInt_AS_LONG(' + GETATTR_compiled(t[0][1], '{L1}', it0[1][1]) + ')'
    return ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
            "PyInt_AS_LONG({LR})"]

def Gen_Patt_GetAttr_slots_bool(it0, t):
    if is_GETATTR_compiled(t[0][1], it0[1][1]):
        return '(' + GETATTR_compiled(t[0][1], '{L1}', it0[1][1]) + ' == Py_True)' 
    return ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
            "({LR} == Py_True)"]
    
def Gen_Patt_TuplStr(it0, t):
    assert it0[0][0] == 'CONST'
    assert type(it0[0][1]) is tuple
    li = list(it0[0][1])
    assert len(li) > 0
    assert all([type(x) is str for x in li])
    d2 = dict.fromkeys([len(x) for x in li])
    for k in d2.iterkeys():
        d2[k] = []
    for x in li:
        d2[len(x)].append(x)
    for k in d2.iterkeys():
        d2[k].sort()
        
    t2 = TypeExpr(it0[1])
    o = Out()
    if not IsStr(t2):
        o.append('if (PyString_CheckExact({L2})) {')
    o.append('{LB} = 0;')
    o.append('switch(PyString_GET_SIZE({L2})) {')
    for k, v2 in d2.iteritems():
        o.append('case ' + str(k) + ':')
        if k == 0:
            o.append('{LB} = 1;')
            o.append('break;')
            continue
        if k == 1:
            o.append('switch((unsigned char)*PyString_AS_STRING({L2})) {')
            for v in v2:
                o.append('case ' + str(ord(v)) + ':')
            o.append('{LB} = 1;')
            o.append('break;')
            o.append('default:')
            o.append('break;')
            o.append('}')
            o.append('break;')
            continue
        ## list_uniqa = [i for i in range(k) if len(dict.fromkeys([v[i] for v in v2])) == k]
        ## if len(list_uniqa) == 0:
            ## list_uniqa = [(i, j) for i in range(k) for j in range(k) if len(dict.fromkeys([v[i] + v[j] for v in v2])) == k]
        ## i = None
        ## j = None
        ## if len(list_uniqa) > 0:
            ## i = list_uniqa[0]
            ## if type(i) is tuple:
                ## i,j = i
        ## if i is not None:
            ## if j is None:
                ## o.append('switch((unsigned char)PyString_AS_STRING({L2})[' + str(i) + ']) {')
            ## else:
                ## o.append('switch(((unsigned char)PyString_AS_STRING({L2})[' + str(i) + '] * 256) + (unsigned char)PyString_AS_STRING({L2})[' + str(j) + ']) {')
            ## for v in v2:
                ## if j is None:
                    ## o.append('case ' + str(ord(v[i])) + ':')
                ## else:
                    ## o.append('case ' + str(ord(v[i]) * 256 + ord(v[j])) + ':')
                ## o.Raw('{LB} = (0 == memcmp(PyString_AS_STRING({L2}), ', generate_chars_literal(v), ', ',k, '));')
                ## o.append('break;')
            ## o.append('default:')
            ## o.append('break;')
            ## o.append('}')
            ## o.append('break;')
            ## continue
        find_i = -1
        if len(v2) > 1:
            for i in range(k):
                fi = [v[i] for v in v2]
                if len(dict.fromkeys(fi)) == len(fi):
                    find_i = i
                    break
        elif len(v2) == 1:
            find_i = int(k/2)
            
        if find_i == 0 and len(v2) > 1:
            li1 = [ConC('(*PyString_AS_STRING({L2}) == ', str(ord(v[0])), ' && 0 == memcmp(PyString_AS_STRING({L2}), ', generate_chars_literal(v), ', ',k, '))') for v in v2]
        elif find_i != -1  and len(v2) > 1:
            li1 = [ConC('(PyString_AS_STRING({L2})[', find_i, '] == ', str(ord(v[find_i])), ' && 0 == memcmp(PyString_AS_STRING({L2}), ', generate_chars_literal(v), ', ',k, '))') for v in v2]
        else:
            li1 = [ConC('(0 == memcmp(PyString_AS_STRING({L2}), ', generate_chars_literal(v), ', ',k, '))') for v in v2]
        o.append('{LB} = ' + ' || '.join(li1) + ';')
        o.append('break;')
    o.append('default:')
    o.append('break;')
    o.append('}')
    if not IsStr(t2):
        o.append('} else {')
        for i, v in enumerate(it0[0][1]):
            o.append('if (({LB} = PyObject_RichCompareBool( ' + CVar(const_to(v)) + ', {L2}, Py_EQ )) == -1) goto L0;')
            if i < (len(it0[0][1]) - 1):
                o.append('if (!{LB}) {')
        for i in range(len(it0[0][1])-1):
            o.append('}')
        o.append('}')
    o.append('{LB}')
    return list(o)
        
def Gen_Patt_EqStr(it0, t):
    s = "(PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L2})))"

    assert it0[1][0] == 'CONST'
    assert type(it0[1][1]) is str
    v2 = it0[1][1]
    assert len(v2) > 1
    s = ConC('(PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && *PyString_AS_STRING({L1}) == ', str(ord(v2[0])), ' && !memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L2})))')
    return s
    
def generate_logical_expr(it, logic = None):
    assert type(it) is tuple
    assert logic is None or logic[0] == 'TYPED_TEMP'
    it0 = it[0]
    if type(it0) is str and it0[-1] == '(':
        it0 = it0[:-1]
    o = Out()    
    if IsCVar(it) and IsBool(TypeExpr(it)):
        return o, CVarName(it) 
    it = type_in_if(it, {})   
    assert type(it) is tuple
    it0 = it[0]
    if type(it0) is str and it0[-1] == '(':
        it0 = it0[:-1]    
    if true_attempt_direct(it): # or it0 in ('!CALL_CALC_CONST', 'CALC_CONST', 'FAST', 'CONST'):
        if logic is None:
            logic = New('int')
        t00 = TypeExpr(it)
        if not IsBool(t00):
            if t00 is None and (it0 == '!PyObject_RichCompare' or it0 == '!PyObject_RichCompare('):
                it_ = it
            else:
                it_ = ('!PyObject_IsTrue', it)
        else:
            it_ = it
        o2, s, ty, checktupl, checktuplerr = attempt_str_direct_type_generation(it_, Kl_Boolean, logic)
        ## if s is None:
            ## if IsInt(TypeExpr(it)):
                ## o2, s, ty, checktupl, checktuplerr = attempt_str_direct_type_generation(it, Kl_Int)
                ## if s is not None:
                    ## s = '(' + s + ' != 0)'
        assert type(ty) is set
        if s is not None:
            labl_err = add_check_message(checktupl, checktuplerr, o2)
            if len(o2) > 0:
                o.extend(o2)
            ##if type(s) is str and s.startswith('int_') and s[4:].isdigit():
            if logic is None:
                if len(ty) == 0:    
                    return o, s
            if logic is None:    
                logic = New('int')
            o.Raw(logic, ' = ', s, ';')
            for v in ty:
                o.Cls(v)
            o.Cls(s)
            return o, logic  
    if it0 == '!BOOLEAN':
        return generate_logical_expr(it[1], logic) 
    if it0 == 'CONST' and logic is None:
        if it[1]:
            return o, '1'
        if not it[1]:
            return o, '0'
        Fatal('shd', it)
        assert False


    if logic is None:    
        logic = New('int')        
    if it0 == '!PyObject_RichCompare':
        return generate_rich_compare(it,logic,o)
    if it0 == 'CONST':
        if it[1]:
            o.Stmt(logic, '=', 1)
            return o, logic
        if not it[1]:
            o.Stmt(logic, '=', 0)
            return o, logic
        Fatal('shd', it)
        assert False
    if it0 == '!1NOT':
        if das_ist_False(it[1]): 
            o.Stmt(logic, '=', 1)
            return o, logic
        if das_ist_True(it[1]): 
            o.Stmt(logic, '=', 0)
            return o, logic
        if it[1][0] in IsObject and not IsCVar(it[1]):
            ref1 = Expr1(it[1], o)
            t1 = TypeExpr(it[1])
            if IsInt(t1):
                o.Raw(logic, ' = ! PyInt_AS_LONG ( ', ref1, ' );')                
            else:
                o.Stmt(logic, '=', 'PyObject_Not', ref1)
            o.Cls(ref1)
            return o, logic
        if IsBool(TypeExpr(it[1])) and IsCVar(it[1]):
            o.Raw(logic, ' = !', CVarName(it[1]), ';')
            return o, logic
        if IsInt(TypeExpr(it[1])) and IsCVar(it[1]):
            o.Raw(logic, ' = !', CVarName(it[1]), ';')
            return o, logic
        if it[1][0] not in IsObject:
            o, logic1 = generate_logical_expr(it[1], logic)
            o.Raw(logic, ' = !(', logic1, ');')
            return o, logic
        pp(TypeExpr(it[1]))
        pp(it[1])
        pprint(it)
        pprint(o)
        pp(IsCVar(it[1]), func)
        assert False
        
    if it0 in API_cmp_2_PyObject:
        v = []
        if TCmp(it, v, ('!PyObject_IsInstance', ('FAST', '?'), ('CALC_CONST', '?'))) and\
           IsOldClass(v[1]):
               o.Raw(logic, ' = PyInstance_Check(',('FAST', v[0]),') && ((PyInstanceObject *)',('FAST', v[0]),')->in_class == (PyClassObject*)', ('CALC_CONST', v[1]), ';')
               return o, logic
        v = []   
        if TCmp(it, v, ('!PySequence_Contains(', ('CONST', '?'),  '?')):
            if type(v[0]) is tuple and all([type(x) is str for x in v[0]]):

                t2 = TypeExpr(v[1])
                d = {}
                ref2 = LikeExpr1(v[1], o)
                if istempref(ref2) and len(o) > 0 and o[-1].startswith('Py_INCREF'):
                    oi2 = o[-2]
                    assert type(oi2) is str
                    s__ = ConC(ref2, ' = ')
                    if oi2.startswith(s__) and 'GET_ITEM' in oi2:
                        o.Cls(ref2)
                        ref2 = oi2[len(s__)-1:-1]
                        del o[-1]
                        del o[-1]
                        del o[-1]
                for ref1 in v[0]:
                    nc = len(ref1)
                    const_to(ref1)   
                    if nc == 0:
                        text = '1'
                    elif nc != 1:
                        text = ConC('0 == memcmp(', Str_AS_STRING(ref2), ' , ', generate_chars_literal(ref1), ' , ',nc, ')')
                    else:    
                        text = ConC('*', Str_AS_STRING(ref2), ' == *', generate_chars_literal(ref1))
                    if nc in d:
                        d[nc] = d[nc] + ' || (' + text + ')'
                    else:
                        d[nc] = '(' + text + ')'    
                if IsStr(t2):
                    if len(d) == 0:
                        o.Cls(ref2)
                        return o, '0'
                    elif len(d) == 1:
                        k, v = d.items()[0]
                        o.Raw(logic, ' = PyString_GET_SIZE(', ref2, ') ==  ', k, ' && (', v, ');')
                        o.Cls(ref2)
                        return o, logic
                    o.Raw(logic, ' = 0;')
                    o.Raw('switch (PyString_GET_SIZE(', ref2, ')) {')
                    for k, v in d.items():
                        o.Raw('case ', k, ':')
                        o.Raw(logic, ' = ', v, ';')
                        o.append('break;')
                    o.append('default:')
                    o.append('break;')
                    o.append('}')    
                    o.Cls(ref2)
                    return o, logic
                else:
                    if len(d) == 0:
                        o.Cls(ref2)
                        return o, '0'                    
                    elif len(d) == 1:
                        o.Raw('if (PyString_CheckExact(', ref2, ')) {')
                        k, v = d.items()[0]
                        o.Raw(logic, ' = PyString_GET_SIZE(', ref2, ') ==  ', k, ' && (', v, ');')
                        o.append('} else {')
                        o.Stmt(logic, '=', it0[1:], it[1], ref2)
                        o.append('}')
                        o.Cls(ref2)
                        return o, logic
                    o.Raw('if (PyString_CheckExact(', ref2, ')) {')
                    o.Raw(logic, ' = 0;')
                    o.Raw('switch (PyString_GET_SIZE(', ref2, ')) {')
                    for k, v in d.items():
                        o.Raw('case ', k, ':')
                        o.Raw(logic, ' = ', v, ';')
                        o.append('break;')
                    o.append('default:')
                    o.append('break;')
                    o.append('}')    
                    o.append('} else {')
                    o.Stmt(logic, '=', it0[1:], it[1], ref2)
                    o.append('}')
                    o.Cls(ref2)
                    return o, logic

            if  type(v[0]) is tuple and not all([type(x) is str for x in v[0]]):
                Debug('Contains:Not string tuple in %s', it)
        elif TCmp(it, v, ('!PySequence_Contains(', ('!BUILD_TUPLE', '?'),  '?')) and \
            type(v[0]) is tuple and not all([type(x) is str for x in v[0]]):
            Debug('Contains:Not const tuple in %s', it)
         
        ref1 = LikeExpr1(it[1], o)        
        ref2 = LikeExpr1(it[2], o)
        o.Stmt(logic, '=', it0[1:], ref1, ref2)
        o.Cls(ref1, ref2)
        return o, logic

    if it0 in ('!_EQ_', '!_NEQ_'):
        t1 = TypeExpr(it[1])
        t2 = TypeExpr(it[2])
        ref1 = LikeExpr1(it[1], o)
        o2 = Out()
        ref2 = LikeExpr1(it[2], o2)
        skip1 = False
        if istempref(ref1) and o[-1] == ConC('Py_INCREF(', ref1, ');') and len(o2) == 0:
            del o[-1]
            skip1 = True
        skip2 = False
        if istempref(ref2) and o2[-1] == ConC('Py_INCREF(', ref2, ');') and len(o) == 0:
            del o2[-1]
            skip2 = True
        o.extend(o2)    
        if it0 == '!_EQ_':
            o.Stmt(logic, '=', ref1, '==', ref2)
        else:    
            o.Stmt(logic, '=', ref1, '!=', ref2)
        if skip1:    
            o.ClsFict(ref1)
        else:   
            o.Cls(ref1)
        if skip2:    
            o.ClsFict(ref2)
        else:   
            o.Cls(ref2)
        return o, logic
    if it0 in ('!OR_JUMP', '!OR_BOOLEAN', '!OR_JUMPED_STACKED'):
        o = generate_and_or_logical(it[1:], False, logic)
        return o, logic
    if it0 in ('!AND', '!AND_JUMP', '!AND_BOOLEAN', '!AND_JUMPED_STACKED'):
        o = generate_and_or_logical(it[1:], True, logic)
        return o, logic
    if it0 in ('!SSIZE_T==', '!SSIZE_T>', '!SSIZE_T>=', '!SSIZE_T!=', \
               '!SSIZE_T<', '!SSIZE_T<='):
        o1,size_t_1 = short_gen_size_t(it[1])
        o2,size_t_2 = short_gen_size_t(it[2])
        assert type(o1) is Out
        assert type(o2) is Out
        o1.extend(o2)
        o1.Raw(logic, ' = ', size_t_1, ' ', it0[8:], ' ', size_t_2, ';')
        o1.Cls(size_t_1, size_t_2)
        return o1, logic
    if it0 == '!PY_SSIZE_T':
        o1,size_t_1 = short_gen_size_t(it[1])
        assert type(o1) is Out
        o1.Raw(logic, ' = ', size_t_1, ' != ', 0, ';')
        o1.Cls(size_t_1)
        return o1,logic
    if it0 in ('!c_Py_EQ_Int', '!c_Py_NE_Int', '!c_Py_LT_Int', \
               '!c_Py_LE_Int', '!c_Py_GT_Int', '!c_Py_GE_Int'):
        op = it0[3:-4]           
        oper = op_to_oper[op]           
        t = TypeExpr(it[1])
        if t is not None and t[0] not in (int, float): 
            return generate_logical_expr(('!PyObject_RichCompare(', it[1], it[2], op), logic)
        ref = LikeExpr1(it[1], o)
        if t is not None and not IsInt(t):
            Debug('typed compare', t,it)
        o2 = Out()
        if it[2][0] in ('CONST', 'LOAD_CONST') and type(it[2][1]) is int:
            int_t = it[2][1]    
            int_2 = const_to(int_t)   
            o.extend(o2)     
            if IsInt(t):
                o.Raw(logic, ' = PyInt_AS_LONG ( ', ref, ' )', oper, int_t, ';')
                o.Cls(ref, int_t)
                return o,logic
            if IsFloat(t):
                o.Raw(logic, ' = PyFloat_AS_DOUBLE( ', ref, ' )', oper, int_t, ';')
                o.Cls(ref, int_t)
                return o,logic
            if t is not None:
                Debug('Typed %s (%s, %s)' % (it0, t, it[2]), it) 
            o.Stmt(logic,'=', it0[1:], ref, int_t, int_2)
            o.Cls(ref, int_t)
       
        else:
            pp(it)
            pp('-', it[2][0])
            pp('--', it[2][1], type(it[2][1]))
            Fatal('', it, type(it[2][1]))
            assert False
        return o,logic 

    if it0 in ('!c_Py_EQ_String', '!c_Py_NE_String'):
        if it[2][0] == 'CONST' and type(it[2][1]) is str:
            s_t = it[2][1]    
            s_2 = const_to(s_t)   
        else:
            Fatal('', it)
            return 0, logic
        t1 = TypeExpr(it[1])  
        if IsChar(TypeExpr(it[2])) and it[1][0] == '!BINARY_SUBSCR_Int' and \
            it[1][2][0] == 'CONST' and type(it[1][2][1]) is int and it[1][2][1] >= 0:
                t4 = TypeExpr(it[1][1])
                if t4 is None or t4 == (None, None):
                    ref3 = LikeExpr1(it[1][1], o)
                    o.Raw('if ( PyString_CheckExact(', ref3,') && PyString_GET_SIZE(',ref3,') > ', it[1][2][1], ') {')
                    if it0 == '!c_Py_EQ_String' :
                        o.Raw(logic,' = ', Str_AS_STRING(ref3), '[', it[1][2][1], '] == *', generate_chars_literal(s_t), ';')
                    else:    
                        o.Raw(logic,' = ', Str_AS_STRING(ref3), '[', it[1][2][1], '] != *', generate_chars_literal(s_t), ';')
                    o.append('} else {')
                    ref = New()
                    o.Stmt(ref, '=', '_c_BINARY_SUBSCR_Int', ref3, it[1][2][1], it[1][2])
                    o.Raw(logic,' = ', it0[1:], '(', ref, ', ', len(s_t), ', ', generate_chars_literal(s_t), ', ', s_2, ');')
                    o.Cls(ref)
                    o.append('}')
                    o.Cls(ref3)
                    return o,logic 
                elif IsStr(t4):
                    ref3 = LikeExpr1(it[1][1], o)
                    o.Raw('if ( PyString_GET_SIZE(',ref3,') > ', it[1][2][1], ') {')
                    if it0 == '!c_Py_EQ_String' :
                        o.Raw(logic,' = ', Str_AS_STRING(ref3), '[', it[1][2][1], '] == *', generate_chars_literal(s_t), ';')
                    else:    
                        o.Raw(logic,' = ', Str_AS_STRING(ref3), '[', it[1][2][1], '] != *', generate_chars_literal(s_t), ';')
                    o.append('} else {')
                    ref = New()
                    o.Stmt(ref, '=', '_c_BINARY_SUBSCR_Int', ref3, it[1][2][1], it[1][2])
                    o.Raw(logic,' = ', it0[1:], '(', ref, ', ', len(s_t), ', ', generate_chars_literal(s_t), ', ', s_2, ');')
                    o.Cls(ref)
                    o.append('}')
                    o.Cls(ref3)
                    return o,logic 
                if IsTuple(t4):
                    ref = LikeExpr1(it[1], o)
                    o.Raw(logic,' = ', it0[1:], '(', ref, ', ', len(s_t), ', ', generate_chars_literal(s_t), ', ', s_2, ');')
                    o.Cls(ref)
                    return o,logic 
        if TypeExpr(it[2]) == Kl_String and it[1][0] == '!PySequence_GetSlice' and \
            it[2][0] == 'CONST' and it[1][2] == 0 and it[1][3] == len (it[2][1]):
                ref3 = LikeExpr1(it[1][1], o)
                t0 = TypeExpr(it[1][1])
                endif = True
                if IsStr(t0):
                    endif = False
                else:
                    o.Raw('if ( PyString_CheckExact(', ref3,') ) {')
                if it0 == '!c_Py_EQ_String' :
                    o.Raw(logic,' = ( PyString_GET_SIZE(',ref3,') >= ', len (it[2][1]), ' ) && (0 == memcmp(', Str_AS_STRING(ref3), ', ', generate_chars_literal(s_t), ' , ',len (it[2][1]), '));')
                else:    
                    o.Raw(logic,' = ( PyString_GET_SIZE(',ref3,') < ', len (it[2][1]), ' ) || (0 != memcmp(', Str_AS_STRING(ref3), ', ', generate_chars_literal(s_t), ' , ',len (it[2][1]), '));')
                if endif:
                    o.append('} else {')
                    ref = New()
                    o.Stmt(ref, '=', 'PySequence_GetSlice', ref3, it[1][2], it[1][3])
                    o.Raw(logic,' = ', it0[1:], '(', ref, ', ', len(s_t), ', ', generate_chars_literal(s_t), ', ', s_2, ');')
                    o.Cls(ref)
                    o.append('}')
                o.Cls(ref3)
                return o,logic 
                            
        ref = LikeExpr1(it[1], o)
        if IsStr(TypeExpr(it[1])):
            if it0 == '!c_Py_EQ_String' :
                o.Raw(logic,' = ( PyString_GET_SIZE(',ref,') == ', len (it[2][1]), ' ) && (0 == memcmp(', Str_AS_STRING(ref), ', ', generate_chars_literal(s_t), ' , ',len (it[2][1]), '));')
            else:    
                o.Raw(logic,' = ( PyString_GET_SIZE(',ref,') != ', len (it[2][1]), ' ) || (0 != memcmp(', Str_AS_STRING(ref), ', ', generate_chars_literal(s_t), ' , ',len (it[2][1]), '));')
        else:    
            if t1 is not None:
                Debug('Typed %s (%s, <str>)' % ( it0, t1), it[1], it[2])          
            o.Raw(logic,' = ', it0[1:], '(', ref, ', ', len(s_t), ', ', generate_chars_literal(s_t), ', ', s_2, ');')
        o.Cls(ref)
        return o,logic
    if it0 == '!NCMP':
        ## if len(it) == 2 and len(it[1]) == 5 and IsInt(TypeExpr(it[1][0])) and IsInt(TypeExpr(it[1][2])) and IsInt(TypeExpr(it[1][4])):
            ## o1,size_t_1 = short_gen_size_t((it[1][0]))
            ## if it[1][2][0] == 'FAST':
                ## if IsInt(TypeExpr(it[1][2])) and g_co.IsCVar(it[1][2]):
                    ## size_t_2 = 'Loc_long_' + it[1][2][1]
                ## else:
                    ## size_t_2 = ConC('PyInt_AS_LONG ( ', it[1][2], ' )') 
                ## o2 = Out()
            ## elif (it[1][2][0] == 'PY_TYPE' and it[1][2][3][0] == 'FAST'):
                ## if IsInt(TypeExpr(it[1][2][3])) and g_co.IsCVar(it[1][2][3]):
                    ## size_t_2 = 'Loc_long_' + it[1][2][3][1]
                ## else:
                    ## size_t_2 = ConC('PyInt_AS_LONG ( ', it[1][2][3], ' )')
                ## o2 = Out()
            ## else:
                ## o2,size_t_2 = short_gen_size_t((it[1][2]))
            ## o3,size_t_3 = short_gen_size_t((it[1][4]))
            ## o.extend(o1)
            ## o.extend(o2)
            ## o.extend(o3)
            ## o.Raw(logic, ' = ( ', size_t_1, ' ', it[1][1], ' ', size_t_2, ' ) && ( ', size_t_2, ' ', it[1][3], ' ', size_t_3, ' );')
            ## o.Cls(size_t_1, size_t_2, size_t_3)
            ## return o, logic
            
        tu = list(it[1])
        to_cls = []
        logic2 = New('int')
        o.Raw(logic, ' = 0;')
        ref1 = Expr1(tu[0], o)
        ref2 = Expr1(tu[2], o)
        if tu[1] == 'is':
            o.Stmt(logic2, '=', ref1, '==', ref2)
        elif tu[1] == 'is not':    
            o.Stmt(logic2, '=', ref1, '!=', ref2)
        elif tu[1] == 'in':    
            o.Stmt(logic2, '=', 'PySequence_Contains', ref2, ref1)
        elif tu[1] == 'not in':    
            o.Stmt(logic2, '=', 'PySequence_Contains', ref2, ref1)
            o.Raw(logic2, ' = ! ', logic2, ';')
        else:    
            o.Stmt(logic2, '=', 'PyObject_RichCompareBool', ref1, ref2, op_2_c_op[tu[1]])
        del tu[:3]
        to_cls.append(ref1)
        ref1 = ref2 
        o.Raw('if (', logic2, ') {')
        while len(tu) > 1:
            ref2 = Expr1(tu[1], o)
            if tu[0] == 'is':
                o.Stmt(logic2, '=', ref1, '==', ref2)
            elif tu[0] == 'is not':    
                o.Stmt(logic2, '=', ref1, '!=', ref2)
            elif tu[0] == 'in':    
                o.Stmt(logic2, '=', 'PySequence_Contains', ref2, ref1)
            elif tu[0] == 'not in':    
                o.Stmt(logic2, '=', 'PySequence_Contains', ref2, ref1)
                o.Raw(logic2, ' = ! ', logic2, ';')
            else:    
                o.Stmt(logic2, '=', 'PyObject_RichCompareBool', ref1, ref2, op_2_c_op[tu[0]])
            del tu[:2]
            to_cls.append(ref1)
            ref1 = ref2 
            o.Raw('if (', logic2, ') {')
        o.Raw(logic, ' = 1;')
        o.extend(['}' for r in to_cls])
        o.Cls(logic2)
        o.Cls(*to_cls) 
        o.Cls(ref1)            
        return o, logic
    if it0 == '!COND_METH_EXPR':
        return generate_logical_cond_meth_expr(it, logic)
    if it0 == '!PyBool_Type.tp_new' and it[2][0] == '!BUILD_TUPLE' and len(it[2][1]) == 1:
        if das_ist_False(it[2][1][0]) or das_ist_True(it[2][1][0]):  
            return Out(), it[2][1][0]
        return generate_logical_expr(it[2][1][0], logic)
    if it0 == '!PyBool_Type.tp_new' and it[2][0] == 'CONST' and len(it[2][1]) == 1:
        if it[2][1][0] in (True, False):
            return Out(), it[2][1]
        return generate_logical_expr(it[2][1], logic)
    if it0.startswith('!_PyString_'):
        o2, logic2 = generate_pystring_op_logical(it, logic)
        if logic2 is not None:
            o.extend(o2)
            assert logic2 == logic            
            return o, logic
    if it0 == '!PyObject_Call' and it[1][0] == '!LOAD_BUILTIN' and it[2][0] == '!BUILD_TUPLE' and \
       len(it[2][1]) == 1 and it[2][1][0][0] == '!LIST_COMPR' and it[1][1] in ('all', 'any'):
            prev_compr = g_co.list_compr_in_progress
            g_co.list_compr_in_progress = True
            it1 = it[2][1][0]
            
            logic2 = generate_func_list_compr(it1[1],it1[2],o, it[1][1]) 
            g_co.list_compr_in_progress = prev_compr
            if logic2 != logic:
                o.Raw(logic, ' = ', logic2, ';')
                o.Cls(logic2)
            return o, logic       
    ref1 = Expr1(it, o)
    return ToTrue(o,logic,ref1, it)
 
def ToTrue(o, logic, ref1, it):
    assert type(o) is Out
    last = o[-3:]
    assert type(last) is list
    del_check = False
    if len(last) > 0:
        che = ('if ( %s == 0 ) goto %s;' % (CVar(ref1), CVar(labl)))
        UseLabl()
        if last[-1] == che:
            del_check = True
            del last[-1]
    if len(last) > 0:
        beg = CVar(ref1) + ' = PyBool_FromLong ('
        lastlast = last[-1]
        assert type(lastlast) is str
        if lastlast.startswith(beg) and lastlast.endswith(');'):
            if del_check:
                del o[-1]
            c_expr = o[-1][len(beg):-2]
            del o[-1]
            o.ClsFict(ref1)
            o.Raw(logic, ' = ', c_expr, ';')
            return o, logic      
        beg = CVar(ref1) + ' = PyInt_FromLong ('
        if lastlast.startswith(beg) and lastlast.endswith(');'):
            if del_check:
                del o[-1]
            c_expr = o[-1][len(beg):-2]
            del o[-1]
            o.ClsFict(ref1)
            o.Raw(logic, ' = ', c_expr, ';')
            return o, logic  #    Debug('generate_logical_expr', it, o[-3:]) 
    if IsInt(TypeExpr(it)):    
        o.Raw(logic, ' = PyInt_AS_LONG ( ', ref1, ' ) != 0;')
        o.Cls(ref1)
        return o, logic
    v2 = {}
    if len(o) >= 1:
        o1 = o[-1]
        assert type(o1) is str
        if o1.startswith('temp[') and o1.endswith(');'):
            o1 = o1[5:-2]
            le = 0
            if o1[1] == ']':
                le = 1
            elif o1[2] == ']':
                le = 2
            elif o1[3] == ']':
                le = 3
            if le > 0 and o1[le:].startswith('] = PyBool_FromLong('):
                v2 = o1[le+20:].strip()
                newv = CVar(logic).strip()
                if v2 == newv:
                    del o[-1] ##TxRepl(o, len(o) - 1, (), v2)
                else:    
                    del o[-1]
                    v3 = 'if ((' + v2 + ' = '
                    if v2.startswith('int_') and len(o) > 0 and o[-1].startswith(v3):
                        o[-1] = 'if ((' + newv + ' = ' + o[-1][len(v3):]
                    elif v2.startswith('int_') and len(o) > 1 and o[-1].startswith('CLEARTEMP') and o[-2].startswith(v3):
                        o[-2] = 'if ((' + newv + ' = ' + o[-2][len(v3):]
                    elif v2.startswith('int_') and len(o) > 2 and o[-1].startswith('CLEARTEMP')and o[-2].startswith('CLEARTEMP') and o[-3].startswith(v3):
                        o[-3] = 'if ((' + newv + ' = ' + o[-3][len(v3):]

                    else:
                        o.Raw(newv, ' = ', v2, ';')
                Out().Cls(ref1)
                return (o, logic)    
    o.Stmt(logic, '=', 'PyObject_IsTrue', ref1)
    o.Cls(ref1)
    return o, logic

def generate_and_or_logical(it, is_and, logic):
    assert type(it) is tuple
  
    assert logic is None or logic[0] == 'TYPED_TEMP'
    o,logic1 = generate_logical_expr(it[0], logic)
    assert type(o) is Out
    if len(it) == 1:
        if not istemptyped(logic1) and istemptyped(logic) and type(logic1) is str:
            o.Raw(logic, ' = ', logic1, ';')
            logic1 = logic    
        return o
    if type(logic1) is int:
        logic2 = New('int')
        o.Stmt(logic2, '=', logic1)
        logic1 = logic2
    if not istemptyped(logic1) and logic is None:
        logic2 = New('int')
        o.Stmt(logic2, '=', logic1)
        logic1 = logic2
    if not istemptyped(logic1) and istemptyped(logic) and type(logic1) is str:
        o.Raw(logic, ' = ', logic1, ';')
        logic1 = logic    
    if istemptyped(logic1) and istemptyped(logic):
        assert logic1 == logic    
    if is_and:    
        o.Stmt('if (', logic1, ') {')
    else:    
        o.Stmt('if (!(', logic1, ')) {')
    assert logic1 is None or logic1[0] == 'TYPED_TEMP'
    o2 = generate_and_or_logical(it[1:], is_and, logic1)
    o.extend(o2)
    o.append('}')
    return o  

def generate_preexpr(it,o):
    assert type(it) is tuple
    assert type(o) is Out     
    assert len(it) == 3
    assert it[0][0] == '(PREEXPR'
    assert it[2][0] == ')PREEXPR'
    acc = it[1]
    refs = Expr(o, acc) #[Expr1(x, o) for x in acc]
    PushAcc(acc, refs)            
    generate_list(it[1],o)
    PopAcc(o, False)     
    o.Cls(*refs)       

def name_typed_to_typed(logic):

    if type(logic) is not str:
        return logic
    assert type(logic) is str

    oldlogic = logic
    if logic.startswith('(') and logic.endswith(')') and ' ' not in logic and '(' not in logic[1:-1] and ')' not in logic[1:-1]:
        logic = logic[1:-1]
        assert type(logic) is str
        assert '(' not in logic and ')' not in logic
    if logic.startswith('(int_'):
        assert ' ' in logic
    if ' ' not in logic and '(' not in logic and ')' not in logic:
        if logic.startswith('long_') and logic[5:].isdigit():
            return _to_typed_temp('long', int(logic[5:]))
        if logic.startswith('int_') and logic[4:].isdigit():
            return _to_typed_temp('int', int(logic[4:]))
        if logic.startswith('double_') and logic[7:].isdigit():
            return _to_typed_temp('double', int(logic[7:]))
    return oldlogic

def _to_typed_temp(ty, num):
    global typed_gen
    typed_gen[num] = (False, ty)
    return ('TYPED_TEMP', num)


def cond_add_sk(v21):
    assert type(v21) is str
    v21 = v21.strip()
    if '_' in v21:
        v21_ = v21.replace('_', '')
        if v21_.isalnum():
            pass
        else:
            v21 = '(' + v21 + ')'
    elif v21.isalnum():
        pass
    else:
        v21 = '(' + v21 + ')'  
    return v21

def shortage(l, opt = True):
    o, logic = l
    assert type(o) is Out
    if len(o) == 0:
        return o, name_typed_to_typed(logic)
    if opt:
        optimize(o)
    if not istemptyped(logic):
        logic = name_typed_to_typed(logic)
    if len(o) > 0:
        o0 = o[-1]
        assert type(o0) is str         
        if len(o) == 1 and o0.startswith(ConC(logic, ' = ')) and o0.endswith(';'):
            s = o0.split(' = ')
            if len(s) != 2:
                    return o, name_typed_to_typed(logic)
            if s[0] != ConC(logic):
                    return o, name_typed_to_typed(logic)
            o2 = Out()
            o2.Cls(logic)
            if 'Exact' in s[1]:
                v2 = {}
                if TxMatch(o, 0, """$1 = Py$2_CheckExact( $3 );""", v2):
                    return o2, name_typed_to_typed(s[1][:-1])
            if 'GET_SIZE' in s[1]:
                v2 = {}
                if TxMatch(o, 0, """$1 = Py$2_GET_SIZE($5) $3 $4;""", v2):
                    if ' ' not in v2[3] and ' ' not in v2[4] and '(' not in v2[3] and '(' not in v2[4] and ')' not in v2[3] and ')' not in v2[4]:
                        return o2, name_typed_to_typed(s[1][:-1])
            return o2, name_typed_to_typed('(' + s[1][:-1] + ')')
        if len(o) > 1 and o0.startswith(ConC(logic, ' = ')) and o0.endswith(';'):
            s = o0.split(' = ')
            if len(s) != 2:
                    return o, name_typed_to_typed(logic)
            if s[0] != ConC(logic):
                    return o, name_typed_to_typed(logic)
            o2 = Out()
            o2.extend(o[:-1])
            o2.Cls(logic)
            return o2, name_typed_to_typed('(' + s[1][:-1] + ')')
        v2 = {}

    return o, name_typed_to_typed(logic)
 
tags_breaked = frozenset(('(TRY', '(TRY_FINALLY', 'RAISE_VARARGS', 'RAISE_VARARGS_STMT', 'BREAK', 'BREAK_LOOP', 'CONTINUE'))

def is_no_breaked(lis):
    if str_tags_in_expr(tags_breaked, lis):
        return False
    return True
  
def generate_simple_efficient_if(expr, stmt, o):
    assert type(o) is Out
    condlist = generate_cond_and(expr, o)
    for o1, logic in condlist:
        o.extend(o1)
        o.Stmt('if (', logic, ') {')
        o.Cls(logic)
    prev_used_fastloc = g_co.used_fastlocals.copy()
    generate_list(stmt, o)
    if stmt[-1][0] == 'RETURN_VALUE' and is_no_breaked(stmt):
        g_co.used_fastlocals = prev_used_fastloc
    for e_it in condlist:
        o.append('}')
    return         

def generate_simple_efficient_or_if(expr, stmt, o):
    assert type(o) is Out
    condlist = generate_cond_or(expr, o)
    if len(condlist) == 1:
        o1, logic = condlist[0]
        o.extend(o1)
        o.Stmt('if (', logic, ') {')
        o.Cls(logic)
        prev_used_fastloc = g_co.used_fastlocals.copy()
        generate_list(stmt, o)
        if stmt[-1][0] == 'RETURN_VALUE' and is_no_breaked(stmt):
            g_co.used_fastlocals = prev_used_fastloc
        o.append('}')
        return 
    la = New('label')
    o1, logic = condlist[0]
    o.extend(o1)
    o.Stmt('if (', logic, ') {')
    o.Raw(la, ':;')
    o.Cls(logic)
    prev_used_fastloc = g_co.used_fastlocals.copy()
    generate_list(stmt, o)
    if stmt[-1][0] == 'RETURN_VALUE' and is_no_breaked(stmt):
        g_co.used_fastlocals = prev_used_fastloc
    o.append('} else {')
    for o1, logic in condlist[1:]:
        o.extend(o1)
        o.Stmt('if (', logic, ') goto ', la, ';')
        o.Cls(logic)
    o.append('}')
    

def generate_full_efficient_if(expr, then_, else_, o):   
    assert type(o) is Out 
    condlist = generate_cond_and(expr, o)   
            
    for o1, logic in condlist:
        o.extend(o1)
        o.Stmt('if (', logic, ') {')
        o.Cls(logic)
    generate_list(then_, o)    
    
    la = None
    if len(condlist) > 1:
        la = New('label')
    i = len(condlist) - 1
    
    while i >= 0:
        if i == (len(condlist) - 1):
            if i > 0:
                o.append('} else {')
                o.Raw(la, ':;')
                
                generate_list(else_, o)
                o.append('}')
            else:
                o.append('} else {')
                generate_list(else_, o)
                
                o.append('}')
        else:
            o.Raw('} else goto ', la,';') 
        
        i -= 1
    return  

def generate_simple_efficient_if_not(expr, stmt, o):
    assert type(o) is Out
    if expr[0] == '!BOOLEAN' and expr[1][0] == '!AND_BOOLEAN':
        generate_full_efficient_if(expr[1], [('PASS',)], stmt, o)
    elif expr[0] == '!AND_JUMP':
        generate_full_efficient_if(expr, [('PASS',)], stmt, o)
    else:
        o1, logic = shortage(generate_logical_expr(expr))
        o.extend(o1)
        o.Raw('if ( !(', logic, ') ) {')
        o.Cls(logic)
        prev_used_fastloc = g_co.used_fastlocals.copy()
        generate_list(stmt, o)
        if stmt[-1][0] == 'RETURN_VALUE' and is_no_breaked(stmt):
            g_co.used_fastlocals = prev_used_fastloc
        o.append('}')
    return   

def das_ist_False(it):
    if type(it) is tuple:
        if it == ('CONST', False):
            return True
        if len(it) > 0 and type(it[0]) is str:
            t = TypeExpr(it)
            if type(t) is tuple:
                if t[0] is bool and t[1] is False:
                    return True
    return False

def das_ist_True(it):
    if type(it) is tuple:
        if it == ('CONST', True):
            return True
        if len(it) > 0 and type(it[0]) is str:
            t = TypeExpr(it)
            if type(t) is tuple:
                if t[0] is bool and t[1] is True:
                    return True
    return False


def generate_if(it,o):
    assert type(o) is Out
    ## t0 = TypeExpr(it[0][1])
    if it[0][1][0] == '!1NOT' and len(it) > 3:
       if_ = list(it[0])
       if_[1] = if_[1][1]
       it[0] = tuple(if_)
       it[1], it[3] = it[3], it[1]
    if das_ist_True(it[0][1]):
        generate_list(it[1], o)
        return
    if das_ist_False(it[0][1]): 
        if len(it) == 3:
            return
        generate_list(it[3], o)
        return
    if len(it) == 3 and it[0][1][0] == '!BOOLEAN' and it[0][1][1][0] == '!AND_BOOLEAN':
        generate_simple_efficient_if(it[0][1][1], it[1], o)
        return
    if len(it) == 3 and it[0][1][0] == '!AND_JUMP':
        generate_simple_efficient_if(it[0][1], it[1], o)
        return
    if len(it) == 5 and it[0][1][0] == '!BOOLEAN' and it[0][1][1][0] == '!AND_BOOLEAN':
        generate_full_efficient_if(it[0][1][1], it[1], it[3], o)
        return
    if len(it) == 5 and it[0][1][0] == '!AND_JUMP':
        generate_full_efficient_if(it[0][1], it[1], it[3], o)
        return
    if len(it) == 3 and it[0][1][0] == '!1NOT':
        generate_simple_efficient_if_not(it[0][1][1], it[1], o)
        return
    if len(it) == 3 and it[0][1][0] == '!OR_JUMP':
        generate_simple_efficient_or_if(it[0][1], it[1], o)
        return
    o1, logic = shortage(generate_logical_expr(it[0][1]))  
    o.extend(o1)
    
    after_condition_used_fastloc = g_co.used_fastlocals.copy()
    if type(logic) is str and logic.startswith('(') and logic.endswith(')'):
        logic = logic[1:-1]
    o.Stmt('if (', logic, ') {')
    o.Cls(logic)
    generate_list(it[1], o)
    if it[1][-1][0] == 'RETURN_VALUE' and is_no_breaked(it[1]):
        g_co.used_fastlocals = after_condition_used_fastloc.copy()
    after_then_used_fastloc = g_co.used_fastlocals.copy()
    assert type(after_then_used_fastloc) is dict
    if len(it) == 3:
        o.append('}')
        return
    assert it[2][0] == ')(ELSE'
    o.append('} else {')
    g_co.used_fastlocals = after_condition_used_fastloc.copy()
    generate_list(it[3], o)
    if it[3][-1][0] == 'RETURN_VALUE' and is_no_breaked(it[3]):
        g_co.used_fastlocals = after_condition_used_fastloc
    for k in after_then_used_fastloc.iterkeys():
        g_co.used_fastlocals[k] = True
    o.append('}')
    assert it[4][0] == ')ENDIF'

def generate_while(it,o):
    global try_jump_context, dropped_temp, loop_else_context
    assert type(o) is Out
    else_cond = None
    if it[2][0] == ')(ELSE':
        else_cond = New('int')
        o.Stmt(else_cond, '=', 1)
        loop_else_context[-1] = else_cond
    try_jump_context.append(False)    
    dropped_temp.append(('WHILE', ()))
    lo = len(o)
    o.append('for (;;) {')
    if not das_ist_True(it[0][1]): 
        generate_if([\
                    ('(IF', Not(it[0][1])), [('BREAK_LOOP',)], (')IF',)], o)
        if len(o) - lo == 6 and o[-1] == '}' and o[-2] == 'break;' and o[-3].startswith('/*') and o[-4] == '' and \
            o[-5].startswith('if ( !(') and o[-5].endswith(') ) {'):  
           cond = o[-5][7:-5].strip()
           assert type(cond) is str
           if cond.startswith('(') and cond.endswith(')'):
                if '(' not in cond[1:-1] and ')' not in cond[1:-1]:
                    cond = cond[1:-1]
                elif cond.startswith('(GETLOCAL(') and cond.count('(') == 2:
                    cond = cond[1:-1]
           o[-6] = 'while (' + cond + ') {'
           v4 = {}
           if o[-6].startswith('while ((('):
               if TxMatch(o, len(o) -6, """while (((GETLOCAL($1) == Py_None))) {""", v4): 
                   TxRepl(o, len(o)-6, """while (GETLOCAL($1) == Py_None) {""", v4)  
               elif TxMatch(o, len(o) -6, """while (((Loc_long_$1 == $2))) {""", v4) and type(v4[2]) is str and v4[2].isdigit() and ' ' not in v4[1] and ' ' not in v4[2]: 
                   TxRepl(o, len(o)-6, """while (Loc_long_$1 == $2) {""", v4)  
               elif TxMatch(o, len(o) -6, """while (((Loc_long_$1 > Loc_long_$2))) {""", v4):
                   TxRepl(o, len(o)-6, """while (Loc_long_$1 > Loc_long_$2) {""", v4)  
               elif TxMatch(o, len(o) -6, """while (((Loc_long_$1 < Loc_long_$2))) {""", v4):
                   TxRepl(o, len(o)-6, """while (Loc_long_$1 < Loc_long_$2) {""", v4)  
               elif TxMatch(o, len(o) -6, """while (((Loc_long_$1 < PyList_GET_SIZE( $2 )))) {""", v4):
                   TxRepl(o, len(o)-6, """while (Loc_long_$1 < PyList_GET_SIZE( $2 )) {""", v4)  
               else:
                   pass
           del o[-5:]
                  
    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]

    if else_cond is not None:
        o.Stmt ('if (', else_cond,') {')
        o.Cls(else_cond)
        generate_list(it[3], o)
        o.append('}')
        assert len(it) == 5
        return
    assert len(it) == 3

def generate_for_and_else_new_pre(it,o): 
    global loop_else_context
    assert type(o) is Out
    to_else = New('int')
    o.Raw(to_else, ' = 1;')
    loop_else_context[-1] = to_else
    assert len(it) in (3,5)
    return to_else

def generate_for_and_else_new_post(it,o, to_else):
    assert type(o) is Out
    o.Stmt('if (', to_else, ') {')
    generate_list(it[3], o)
    o.append('}')
    o.Cls(to_else)
    assert len(it) in (3,5)

def generate_for_and_else_new(it,o): 
    global try_jump_context, dropped_temp, loop_else_context
    assert type(o) is Out
    iter = it[0][2]
    riter = Expr1(iter, o)
    riter2 = New()
    o.Stmt(riter2, '=', 'PyObject_GetIter', riter)
    o.Cls(riter)
    try_jump_context.append(False)
    to_else = New('int')
    o.Raw(to_else, ' = 1;')
    loop_else_context[-1] = to_else
    dropped_temp.append(('FOR', (riter2,)))
    o.append('for (;;) {')
    ref = New()
    o.Stmt(ref, '=', 'PyIter_Next', riter2)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref, '){ break; }')
    if len(it[0][1]) == 1:
       generate_store(it[0][1][0], ref, o, 'PyIter_Next')
    else:  
       generate_store(('SET_VARS', it[0][1]), ref, o, 'PyIter_Next')
    o.Cls(ref)
    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter2) 
    o.Stmt('if (', to_else, ') {')
    generate_list(it[3], o)
    o.append('}')
    o.Cls(to_else)
    assert len(it) in (3,5)

def replace_for_index(body, var, typed_index):
    if IsCVar(var):
        return body
    ret = replace_subexpr(body, var, typed_index)
    return ret

def generate_for_body_range_one_arg(o, hdr, body, pos_iter):
    global g_typed_stack
    assert type(o) is Out
    if len(hdr[1]) == 1 and hdr[1][0][0] == 'STORE_FAST' and not have_subexpr(body, hdr[1][0]):
        body2 = replace_for_index(body, ('FAST', hdr[1][0][1]), ('!@PyInt_FromSsize_t', pos_iter, ('FAST', hdr[1][0][1])))
        g_typed_stack.append(pos_iter)
        generate_body_loop(body2, o)
        del g_typed_stack[-1]
    else:   
        generate_body_loop(body, o)

def generate_for_range_one_arg(it, o, range_arg):
    global try_jump_context, dropped_temp
    
    assert type(o) is Out 
    try_jump_context.append(False)
    if type(range_arg) is int:
        cnt = range_arg   
    else:
        ref_arg = Expr1(range_arg, o)
        cnt = New('Py_ssize_t')
        o.Stmt(cnt, '=', 'PyInt_AsSsize_t', ref_arg)
        o.Cls(ref_arg)
    dropped_temp.append(('FOR', ()))
 
    pos_iter = New('Py_ssize_t')
    o.Raw('for (', pos_iter, ' = 0; ', pos_iter, ' < ', cnt, '; ', pos_iter, ' ++) {')
    if len(it[0][1]) == 1:        
        generate_store_int(o, it[0][1][0], pos_iter)
    else:  
        generate_full_store_int(o, ('SET_VARS', it[0][1]), pos_iter, 'PyInt_FromSsize_t')
    generate_for_body_range_one_arg(o, it[0], it[1], pos_iter)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(pos_iter, cnt) 

def generate_for_range_two_arg(it, o, range_arg0, range_arg):
    global try_jump_context, dropped_temp

    assert type(o) is Out 
    try_jump_context.append(False)
    if type(range_arg0) is tuple and range_arg0[0] == 'CONST':
        range_arg0 = range_arg0[1]
    if type(range_arg) is tuple and range_arg[0] == 'CONST':
        range_arg = range_arg[1]
    if type(range_arg0) != int:
        ref_arg0 = Expr1(range_arg0, o)
        cnt0 = New('Py_ssize_t')
        o.Stmt(cnt0, '=', 'PyInt_AsSsize_t', ref_arg0)
        o.Cls(ref_arg0)
    else:
        cnt0 = range_arg0  
        
    if type(range_arg) != int:
        ref_arg = Expr1(range_arg, o)
        cnt = New('Py_ssize_t')
        o.Stmt(cnt, '=', 'PyInt_AsSsize_t', ref_arg)
        o.Cls(ref_arg)
    else:
        cnt = range_arg    
    dropped_temp.append(('FOR', ()))
    pos_iter = New('Py_ssize_t')
    o.Raw('for (', pos_iter, ' = ', cnt0, ';', pos_iter, ' < ', cnt, ';', pos_iter, ' ++) {')
    if len(it[0][1]) == 1:  
        generate_store_int(o, it[0][1][0], pos_iter)
    else:  
        generate_full_store_int(o, ('SET_VARS', it[0][1]), pos_iter, 'PyInt_FromSsize_t')
    generate_for_body_range_one_arg(o, it[0], it[1], pos_iter)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(pos_iter, cnt) 
    
def generate_for_list_new(it,o): 
    global try_jump_context, dropped_temp
    assert type(o) is Out 
    iter = it[0][2]
    t = TypeExpr(iter)
    assert IsListAll(t)
    v = []
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'range'), \
                      ('CONST', ('?',)), ('NULL',))) and\
                      type(v[0]) is int:
        generate_for_range_one_arg(it, o, v[0])
        return                  
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'range'), \
                      ('!BUILD_TUPLE', ('?',)), ('NULL',))):
        generate_for_range_one_arg(it, o, v[0])
        return                  
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'range'), \
                      ('CONST', ('?', '?')), ('NULL',))) and\
                      type(v[0]) is int and type(v[1]) is int:
        generate_for_range_two_arg(it, o, v[0], v[1])
        return                  
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'range'), \
                      ('!BUILD_TUPLE', ('?', '?')), ('NULL',))):
        generate_for_range_two_arg(it, o, v[0], v[1])
        return    
    riter = Expr1(iter, o)
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    pos_iter = New('int')
    if IsList(t):
        o.Raw('assert(PyList_CheckExact(', riter,'));')
    elif IsListAll(t):
        o.Raw('assert(PyList_Check(', riter,'));')
    o.Raw('for (',pos_iter,' = 0;', pos_iter, ' < PyList_GET_SIZE(', riter, ');',pos_iter, '++) {')
    ref = New()
    o.Stmt(ref, '=', 'PyList_GET_ITEM', riter, pos_iter)
    if len(it[0][1]) == 1:
        generate_store(it[0][1][0], ref, o, 'PyList_GET_ITEM')
    else:  
        ty = None
        if t[1] is not None:
            ty = t[1]
        mass_store(o, ref, it[0][1], 'PyList_GET_ITEM', ty)
    o.Cls(ref)
    generate_body_loop(it[1], o)    
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, pos_iter) 
   
def generate_body_loop(body, o):
    assert type(o) is Out
    generate_thread_switch(o)
    generate_list(body, o)
    
def generate_thread_switch(o):
    assert type(o) is Out
    if True:
        o.Raw('if (ping_threading () == -1) goto ', labl, ';')
        UseLabl()
        Used('ping_threading')        

def generate_for_universal_new(it,o): 
    global try_jump_context, dropped_temp
    assert type(o) is Out 
    iter = it[0][2]
    riter = Expr1(iter, o)
    riter2 = New()
    o.Stmt(riter2, '=', 'PyObject_GetIter', riter)
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter2,  riter)))
    o.append('for (;;) {')
    ref = New()
    o.Stmt(ref, '=', 'PyIter_Next', riter2)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref, '){ break; }')
    if len(it[0][1]) == 1:
        generate_store(it[0][1][0], ref, o, 'PyIter_Next')
    else:  
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyIter_Next')
    o.Cls(ref)
    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, riter2) 

def generate_for_file_new(it,o): 
    global try_jump_context, dropped_temp
    assert type(o) is Out 
    iter = it[0][2]
    riter = Expr1(iter, o)
    riter2 = New()
    o.Stmt(riter2, '=', 'PyObject_GetIter', riter)
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter2,  riter)))
    o.append('for (;;) {')
    ref = New()
    o.Stmt(ref, '=', 'PyIter_Next', riter2)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref, '){ break; }')
    if len(it[0][1]) == 1:
        generate_store(it[0][1][0], ref, o, 'PyIter_Next')
    else:  
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyIter_Next')
    o.Cls(ref)
    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, riter2) 

def generate_for_fuple_of_int_new(it, o, tupl_int):
    global try_jump_context, dropped_temp
  
    assert type(o) is Out     
    try_jump_context.append(False)
    cnt = len(tupl_int)
    if cnt > 1 and (tupl_int[-1] - tupl_int[0]) == (cnt - 1) and all([tupl_int[i] == x for i, x in enumerate(range(tupl_int[0], tupl_int[0] + cnt) )]):
##                                                                    tupl_int == tuple(range(tupl_int[0], tupl_int[0] + cnt)):
        pos_iter = New('long')  
        dropped_temp.append(('FOR', ()))
    # first space to prevent next global declaration detect    
        o.Raw('for (', pos_iter, ' = ', tupl_int[0], ';', pos_iter, ' < ', tupl_int[0] + cnt, ';', pos_iter, ' ++) {')
    
        if len(it[0][1]) == 1:      
            generate_store_int(o, it[0][1][0], pos_iter)   
        else:  
            ref = New()
            o.Raw(ref, ' = PyInt_FromLong ( ',pos_iter, ' );')
            generate_store(('SET_VARS', it[0][1]), ref, o, 'PyInt_FromLong')
            o.Cls(ref)
        generate_for_body_tuple_of_int(o, it[0], it[1], pos_iter)
        o.append('}')
        del try_jump_context[-1]
        del dropped_temp[-1]
        o.Cls(pos_iter) 
        return
    if len(it[0][1]) == 1:
        store = it[0][1][0]
        if store[0] == 'STORE_FAST' and \
            not have_subexpr(it[1], store) and not have_subexpr(it[1], ('FAST', store[1])) and cnt >= 1:
            pos_iter = New('long')  
            dropped_temp.append(('FOR', ()))
        # first space to prevent next global declaration detect    
            o.Raw('for (', pos_iter, ' = 0;', pos_iter, ' < ', cnt, ';', pos_iter, ' ++) {')
            generate_list(it[1], o)
            o.append('}')
            generate_store(store, ('CONST', tupl_int[-1]), o, ('CONST', tupl_int[-1]))
            del try_jump_context[-1]
            del dropped_temp[-1]
            o.Cls(pos_iter) 
            return        
        
        
    pos_iter = New('int')    
    val_iter = New('long')
    refint = New('longref')
    li = ''
    for i in tupl_int:
        li += str(i) + 'l, '
    li = li[:-2]    
    dropped_temp.append(('FOR', ()))
    o.append('{')
# first space to prevent next global declaration detect    
    o.Raw('    static long ', refint, '[] = {', li, '};')
    o.Raw('for (', pos_iter, ' = 0;', pos_iter, ' < ', cnt, ';', pos_iter, ' ++) {')

    if len(it[0][1]) == 1:       
        generate_store_int(o, it[0][1][0], ConC(val_iter, ' = ', refint, '[', pos_iter, ']')) 
    else:  
        ref = New()
        o.Raw(ref, ' = PyInt_FromLong ( ', val_iter, ' = ', refint, '[', pos_iter, ']', ' );')
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyInt_FromLong')
        o.Cls(ref)
    generate_for_body_tuple_of_int(o, it[0], it[1], val_iter)
    o.append('}')
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(pos_iter, val_iter, refint) 

def generate_for_body_tuple_of_int(o, hdr, body, pos_iter):
    global g_typed_stack
    assert type(o) is Out
    if len(hdr[1]) == 1 and hdr[1][0][0] == 'STORE_FAST' and not have_subexpr(body, hdr[1][0]):
        body2 = replace_for_index(body, ('FAST', hdr[1][0][1]), ('!@PyInt_FromSsize_t', pos_iter, ('FAST', hdr[1][0][1])))
        g_typed_stack.append(pos_iter)
        generate_body_loop(body2, o)
        del g_typed_stack[-1]
    else:            
        generate_body_loop(body, o)

def generate_for_tuple_new(it,o): 
    global try_jump_context, dropped_temp

    assert type(o) is Out 
    iter = it[0][2]
    if iter[0] == 'CONST' and all([type(x) is int for x in iter[1]]):
        generate_for_fuple_of_int_new(it, o, iter[1])
        return
    riter = Expr1(iter, o)
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    pos_iter = New('int')
    len_riter = ConC('PyTuple_GET_SIZE(', riter, ')')
    if riter[0] != 'CONST':
        o.Raw('assert(PyTuple_CheckExact(', riter,'));')
    else:
        len_riter = len(riter[1])
    o.Raw('for (',pos_iter,' = 0;', pos_iter, ' < ', len_riter, ';',pos_iter, '++) {')
    ref = New()
    o.Stmt(ref, '=', 'PyTuple_GET_ITEM', riter, pos_iter)
    if len(it[0][1]) == 1:
        generate_store(it[0][1][0], ref, o, 'PyTuple_GET_ITEM')
    else:  
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyTuple_GET_ITEM')
    o.Cls(ref)
    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, pos_iter) 

def generate_for_str_new(it,o): 
    global try_jump_context, dropped_temp

    assert type(o) is Out 
    iter = it[0][2]
    riter = Expr1(iter, o)
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    pos_iter = New('int')
    if riter[0] != 'CONST':
        o.Raw('assert(PyString_CheckExact(', riter,'));')
    o.Raw('for (',pos_iter,' = 0;', pos_iter, ' < PyString_GET_SIZE(', riter, ');',pos_iter, '++) {')
    if len(it[0][1]) == 1:
        generate_store_char(o, it[0][1][0], ConC('PyString_AS_STRING ( ', riter, ' ) + ', pos_iter), 'PyString_FromStringAndSize')
    else:  
        generate_full_store_char(o, ('SET_VARS', it[0][1]), ConC('PyString_AS_STRING ( ', riter, ' ) + ', pos_iter), 'PyString_FromStringAndSize')
    generate_list(it[1], o)    
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, pos_iter) 

def generate_store_char(o, store_ind, n_iter, _expr = None):
    assert type(o) is Out
    if _expr is None:
        _expr = 'PyString_FromStringAndSize'
    cnm = cnamevar_for_store(store_ind)
    if cnm is not None:
        o.Raw(cnm, ' = *(', n_iter, ');')
    else:
        generate_full_store_char(o, store_ind, n_iter, _expr)
    
def generate_full_store_char(o, store_ind, n_iter, tag):
    assert type(o) is Out
    ref = New()
    o.Raw(ref, ' = PyString_FromStringAndSize ( ', n_iter, ', 1 );')  
    generate_store(store_ind, ref, o, tag)
    o.Cls(ref)   

def generate_for_enumerate_new(it,o, store1, store2, iter): 
    global try_jump_context, dropped_temp

    assert type(o) is Out 
    riter = Expr1(iter, o)
    pos_iter = New('int')
    o.Raw(pos_iter, ' = 0;')
    riter2 = New()        
    if True:
        o.Stmt(riter2, '=', 'PyObject_GetIter', riter)
    else:
        o.Raw(riter2, ' = NULL;')
        o.Raw('if (!PyList_CheckExact(', riter, ') && !PyTuple_CheckExact(', riter, ')) {')
        o.Stmt(riter2, '=', 'PyObject_GetIter', riter)
        o.append('}')
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter2,  riter)))
    o.append('for (;;) {')
    ref = New()
    if True:
        o.Stmt(ref, '=', 'PyIter_Next', riter2)
        o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
        UseLabl()
        o.Stmt('if (!', ref, '){ break; }')
    else:
        o.Raw('if (PyList_CheckExact(', riter, ')) {')
        o.Stmt('if (', pos_iter, '>= PyList_GET_SIZE(', riter, ')) break;')
        o.Stmt(ref, '=', 'PyList_GET_ITEM', riter, pos_iter)
        o.Raw('} else if (PyTuple_CheckExact(', riter, ')) {')
        o.Stmt('if (', pos_iter, '>= PyTuple_GET_SIZE(', riter, ')) break;')
        o.Stmt(ref, '=', 'PyTuple_GET_ITEM', riter, pos_iter)
        o.append('} else {')
        o.Stmt(ref, '=', 'PyIter_Next', riter2)
        o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
        UseLabl()
        o.Stmt('if (!', ref, '){ break; }')
        o.append('}')
 
    if len(it[0][1]) != 2:
        Fatal('Strange enumerate', it[0])
        assert False
    generate_store_int(o, it[0][1][0], pos_iter)
    generate_store(it[0][1][1], ref, o, 'PyIter_Next')
    o.Cls(ref)
    o.Raw(pos_iter, '++;')
    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, riter2, pos_iter) 

def generate_for_enumerate_list_new(it,o, store1, store2, iter, t): 
    global try_jump_context, dropped_temp

    assert type(o) is Out 
    riter = Expr1(iter, o)
    pos_iter = New('int')
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    if IsList(t):
        o.Raw('assert(PyList_CheckExact(', riter,'));')
    else:
        o.Raw('assert(PyList_Check(', riter,'));')
    o.Raw('for (',pos_iter,' = 0;', pos_iter, ' < PyList_GET_SIZE(', riter, ');',pos_iter, '++) {')
    if len(it[0][1]) != 2:
        Fatal('Strange enumerate', it[0])
        assert False
    generate_store_int(o, it[0][1][0], pos_iter)
    ref = New()
    o.Stmt(ref, '=', 'PyList_GET_ITEM', riter, pos_iter)
    generate_store(it[0][1][1], ref, o, 'PyList_GET_ITEM')
    o.Cls(ref)
    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, pos_iter) 

def generate_for_enumerate_tuple_new(it,o, store1, store2, iter): 
    global try_jump_context, dropped_temp

    assert type(o) is Out 
    riter = Expr1(iter, o)
    pos_iter = New('int')
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    o.Raw('assert(PyTuple_CheckExact(', riter,'));')
    o.Raw('for (',pos_iter,' = 0;', pos_iter, ' < PyTuple_GET_SIZE(', riter, ');',pos_iter, '++) {')
    if len(it[0][1]) != 2:
        Fatal('Strange enumerate', it[0])
        assert False
    generate_store_int(o, it[0][1][0], pos_iter)
    ref = New()
    o.Stmt(ref, '=', 'PyTuple_GET_ITEM', riter, pos_iter)
    generate_store(it[0][1][1], ref, o, 'PyTuple_GET_ITEM')
    o.Cls(ref)
    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, pos_iter) 

def generate_for_enumerate_str_new(it,o, store1, store2, iter): 
    global try_jump_context, dropped_temp

    assert type(o) is Out 
    riter = Expr1(iter, o)
    pos_iter = New('int')
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    o.Raw('assert(PyString_CheckExact(', riter,'));')
    o.Raw('for (',pos_iter,' = 0;', pos_iter, ' < PyString_GET_SIZE(', riter, ');',pos_iter, '++) {')
    if len(it[0][1]) != 2:
        Fatal('Strange enumerate', it[0])
        assert False
    generate_store_int(o, it[0][1][0], pos_iter)
    if it[0][1][1][0] == 'STORE_FAST' and IsChar(TypeExpr(('FAST', it[0][1][1][1]))):
        o.Raw(CVarName(('FAST', it[0][1][1][1])), ' = PyString_AS_STRING(',riter, ')[', pos_iter, '];')
    else:
        ref = New()
        o.Raw(ref, ' = PyString_FromStringAndSize(PyString_AS_STRING(',riter, ')+', pos_iter, ', 1);')
        generate_store(it[0][1][1], ref, o, 'PyString_FromStringAndSize')
        o.Cls(ref)
    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter, pos_iter) 


def generate_for_iteritems_generator_standard(it,o):
    global try_jump_context, dropped_temp

    assert type(o) is Out 
    iter = it[0][2]
    riter = Expr1(iter, o)
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter,)))
    o.append('for (;;) {')
    ref = New()
    o.Stmt(ref, '=', 'PyIter_Next', riter)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref, '){ break; }')
    assert len(it[0][1]) == 2

    ref1 = New()
    GetTupleItem(o, (tuple, 2), ref1, ref, 0)
    generate_store(it[0][1][0], ref1, o, 'PyIter_Next')
    o.Cls(ref1)
    ref1 = New()
    GetTupleItem(o, (tuple, 2), ref1, ref, 1)
    generate_store(it[0][1][1], ref1, o, 'PyIter_Next')
    o.Cls(ref1)

    o.Cls(ref)
    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter)

def generate_for_iteritems_generator_new(it,o, v): 
    global try_jump_context, dropped_temp

    assert type(o) is Out 
    d = Expr1(v[2], o)
    pos = New('Py_ssize_t')
    
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (d, pos)))
    o.Raw(pos, ' = 0;')
    k, v = New(), New()
    o.Raw('while (PyDict_Next(', d, ', ', ('&', pos), ', ', ('&', k), ', ', ('&', v), ')) {')
    assert len(it[0][1]) == 2
    o.INCREF(k)       
    o.INCREF(v)       
    generate_store(it[0][1][0], k, o, 'PyDict_Next')
    generate_store(it[0][1][1], v, o, 'PyDict_Next')
    o.Cls(k,v)

    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(d,pos) 

def generate_for_iterkeys_generator_new(it,o, v): 
    global try_jump_context, dropped_temp
    assert type(it) is tuple
    assert type(o) is Out 
    d = Expr1(v[1], o)
    pos = New('Py_ssize_t')
    
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (d, pos)))
    o.Raw(pos, ' = 0;')
    k, v = New(), New()
    o.Raw('while (PyDict_Next(', d, ', ', ('&', pos), ', ', ('&', k), ', ', ('&', v), ')) {')
    assert len(it[0][1]) == 1
    o.INCREF(k)       
    o.INCREF(v)       
    generate_store(it[0][1][0], k, o, 'PyDict_Next')
    o.Cls(k,v)
    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(d,pos) 

def generate_for_itervalues_generator_new(it,o, v): 
    global try_jump_context, dropped_temp

    assert type(o) is Out 
    d = Expr1(v[1], o)
    pos = New('Py_ssize_t')
    
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (d, pos)))
    o.Raw(pos, ' = 0;')
    k, v = New(), New()
    o.Raw('while (PyDict_Next(', d, ', ', ('&', pos), ', ', ('&', k), ', ', ('&', v), ')) {')
    assert len(it[0][1]) == 1
    o.INCREF(k)       
    o.INCREF(v)       
    generate_store(it[0][1][0], v, o, 'PyDict_Next')
    o.Cls(k,v)

    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(d,pos) 

def generate_for_new(it,o): 
    global try_jump_context, dropped_temp
    assert type(o) is Out
    to_else = None
    if len(it) == 5 and it[2][0] == ')(ELSE':
        to_else = generate_for_and_else_new_pre(it,o)
    iter = it[0][2]
    type_for = TypeExpr(iter)
    if IsListAll(type_for):
        generate_for_list_new(it,o)
        if to_else is not None: 
            generate_for_and_else_new_post(it,o, to_else)
        return
    if IsStr(type_for):
        generate_for_str_new(it,o)
        if to_else is not None: 
            generate_for_and_else_new_post(it,o, to_else)        
        return    
    if IsTuple(type_for):
        generate_for_tuple_new(it,o)
        if to_else is not None: 
            generate_for_and_else_new_post(it,o, to_else)        
        return
    if type_for == Kl_File:
        generate_for_file_new(it,o)
        if to_else is not None: 
            generate_for_and_else_new_post(it,o, to_else)        
        return
    if type_for == Kl_Generator:
        v = []
        if TCmp(it[0], v,  ('(FOR', ('?', '?'), \
                             ('!PyObject_Call', ('!LOAD_BUILTIN', 'enumerate'), \
                                     ('!BUILD_TUPLE', ('?',)), ('NULL',)))):
            t = TypeExpr(v[2])
            if IsListAll(t):                             
                generate_for_enumerate_list_new(it, o, v[0], v[1], v[2], t)
            elif IsTuple(t):                             
                generate_for_enumerate_tuple_new(it, o, v[0], v[1], v[2])
            elif IsStr(t):                             
                generate_for_enumerate_str_new(it, o, v[0], v[1], v[2])
            else:
                generate_for_enumerate_new(it, o, v[0], v[1], v[2])
            if to_else is not None: 
                generate_for_and_else_new_post(it,o, to_else)                
            return
        elif TCmp(it[0], v,  ('(FOR', ('?', '?'), \
                             ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', 'iteritems')), \
                                     ('CONST', ()), ('NULL',)))):
            t = TypeExpr(v[2])
            if IsDict(t):
                if dirty_iteritems:
                    generate_for_iteritems_generator_new(it,o, v)
                else:
                    generate_for_iteritems_generator_standard(it,o)
                if to_else is not None: 
                    generate_for_and_else_new_post(it,o, to_else)                    
                return
        elif TCmp(it[0], v,  ('(FOR', ('?',), \
                             ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', 'iterkeys')), \
                                     ('CONST', ()), ('NULL',)))):
            if dirty_iteritems:
                t = TypeExpr(v[1])
                if IsDict(t):
                    generate_for_iterkeys_generator_new(it,o, v)
                    if to_else is not None: 
                        generate_for_and_else_new_post(it,o, to_else)                    
                    return
        elif TCmp(it[0], v,  ('(FOR', ('?',), \
                             ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', 'itervalues')), \
                                     ('CONST', ()), ('NULL',)))):
            if dirty_iteritems:
                t = TypeExpr(v[1])
                if IsDict(t):
                    generate_for_itervalues_generator_new(it,o, v)
                    if to_else is not None: 
                        generate_for_and_else_new_post(it,o, to_else)                    
                    return
   
    if type_for == Kl_XRange:
        generate_for_xrange_new(it,o)
        if to_else is not None: 
            generate_for_and_else_new_post(it,o, to_else)        
        return
    generate_for_universal_new(it,o)
    if to_else is not None: 
        generate_for_and_else_new_post(it,o, to_else)    

def generate_for_xrange_new(it,o): 
    global try_jump_context, dropped_temp
    assert type(o) is Out
    iter = it[0][2]

    v = []
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'xrange'), \
                      ('CONST', ('?',)), ('NULL',))) and\
                      type(v[0]) is int:
        generate_for_range_one_arg(it, o, v[0])
        return                  
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'xrange'), \
                      ('!BUILD_TUPLE', ('?',)), ('NULL',))):
        generate_for_range_one_arg(it, o, v[0])
        return                  
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'xrange'), \
                      ('CONST', ('?', '?')), ('NULL',))) and\
                      type(v[0]) is int and type(v[1]) is int:
        generate_for_range_two_arg(it, o, v[0], v[1])
        return                  
    if TCmp(iter, v, ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'xrange'), \
                      ('!BUILD_TUPLE', ('?', '?')), ('NULL',))):
        generate_for_range_two_arg(it, o, v[0], v[1])
        return  
    riter = Expr1(iter, o)
 
    riter2 = New()
    o.Stmt(riter2, '=', 'PyObject_GetIter', riter)
    o.Cls(riter)
    
    try_jump_context.append(False)
    dropped_temp.append(('FOR', (riter2,)))
    o.append('for (;;) {')
    ref = New()
    o.Stmt(ref, '=', 'PyIter_Next', riter2)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref, '){ break; }')
    if len(it[0][1]) == 1:
        generate_store(it[0][1][0], ref, o, 'PyIter_Next')
    else:  
        generate_store(('SET_VARS', it[0][1]), ref, o, 'PyIter_Next')
    o.Cls(ref)
    generate_body_loop(it[1], o)
    o.append('}')
    del try_jump_context[-1]
    del dropped_temp[-1]
    o.Cls(riter2) 

    assert len(it) in (3,5) 

def is_like_float(a):
    if detect_float and have_floatmul(a):
        return True
    return False
        
def have_floatmul(a):
    if type(a) is tuple and len(a) > 0 and a != ('NULL',) and type(a[0]) is str and IsFloat(TypeExpr(a)):
        return True
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str:
            if len(a) >= 2 and a[0] == '!PyNumber_Multiply' and not (a[1][0] in ('!BUILD_LIST', '!BUILD_TUPLE')):
                return True
            if a[0] == '!PyNumber_Divide':
                return True
            if a[0] == 'CONST':
                return False
        for i in a:
            if type(i) is tuple and len(i) > 0 and type(i[0]) is str and i[0] != 'NULL':
                if have_floatmul(i):
                    return True
        return False
    if type(a) is list:
        for i in a:
            if have_floatmul(i):
                return True
        return False
    return False    
 
def have_subexpr(a,b):
    if a is b:
        return True
    if type(a) is type(b):
        if len(a) == len(b) and type(a[0]) is type(b[0]):
            if a == b:
                return True
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return False
        for i in a:
            if have_subexpr(i,b):
                return True
        return False
    if type(a) is list:
        for i in a:
            if have_subexpr(i,b):
                return True
        return False
    return False    

def find_statement_calculate_const(a, b):
    if type(a) is tuple:
        if len(a) >= 2:
            a0 = a[0]
            if type(a0) is str:
                if a0.startswith('STORE_') and a[1] == b:
                    return a
                if a0 == 'IMPORT_FROM_AS' and b in a[3][1]:
                    return a
                if len(a) == 2:
                    if a0 == 'CONST':
                        return False
        for i in a:
            if type(i) is not tuple:
                continue
            ret = find_statement_calculate_const(i,b)
            if ret is True:    
                return 
            if type(ret) is tuple:
                ret0 = ret[0]
                if type(ret0) is str and ret0 in ('STORE', 'SEQ_ASSIGN', 'SET_EXPRS_TO_VARS'):
                    return ret
                return a
        return False
    if type(a) is list:
        for i in a:
            ret = find_statement_calculate_const(i,b)
            if type(ret) is tuple:
                return ret
    return False    

## def TCmpDebug(e,v,p, trace = None, isrec = False):
    ## assert type(v) is list
    ## assert isrec or len(v) == 0
    ## if trace is not None:
        ## pprint(( 'Parameters:', e,v,p))
    ## if type(p) is str:
        ## if p == '?':
            ## v.append(e)
            ## if trace is not None: pp('Cmp success ', e,v,p)
            ## return True
        ## if type(e) is str and e == p:
            ## if trace is not None: pp('Cmp success ', e,v,p)
            ## return True
        ## if p.startswith(':') and p.endswith(':'):
            ## s = p[1:-1]
            ## if Is3(e, s):
                ## v.append((e,s, Val3(e,s)))
                ## if trace != None: pp('Cmp success ', e,v,p)
                ## return True  
        ## del v[:]
        ## return False
    ## if type(p) is type:
        ## if type(e) is p:
            ## v.append(e)
            ## if trace is not None: pp('Cmp success ', e,v,p)
            ## return True
        ## del v[:]
        ## return False        
    ## if type(p) is tuple:
        ## if len(p) > 0 and type(p[0]) is str and p[0] == '|':
            ## if e in p[1:]:
                ## if trace is not None: pp('Cmp success ', e,v,p)
                ## return True
        ## if type(e) is tuple:
            ## if len(e) != len(p):
                ## del v[:]
                ## return False
            ## for i,p0 in enumerate(p):
                ## if trace is not None: pp('Cmp', i, p0)
                ## if p0 is None and e[i] is None:
                    ## continue
                ## if type(p0) is str:
                    ## if p0 == '*':
                        ## v.append(e[i:])
                        ## if trace is not None: pp('Cmp success ', e,v,p)
                        ## return True
                    ## if p0 == '?':
                        ## v.append(e[i])
                        ## continue

                    ## if type(e[i]) is str:
                        ## if e[i] != p0:
                            ## if p0 == ':ImportedM:':
                                ## s = p0[1:-1]
                                ## if e[i] in ImportedM:
                                    ## v.append((e[i],s, ImportedM[e[i]]))
                                    ## if trace != None: pp('Cmp success ', e[i],v,p)
                                    ## continue  
    
                            ## del v[:]
                            ## return False
                        ## else:
                            ## continue
                    ## elif not TCmp(e[i], v, p0, trace, True):
                        ## del v[:]
                        ## return False
                ## elif not TCmp(e[i], v, p0, trace, True):
                    ## del v[:]
                    ## return False
            ## if trace is not None: pp('Cmp success ', e,v,p)
            ## return True
        ## del v[:]
        ## return False        
    ## if type(p) is list:
        ## if type(e) == type(p):
            ## if len(e) != len(p):
                ## del v[:]
                ## return False
            ## for i,p0 in enumerate(p):
                ## if not TCmp(e[i], v, p0, trace, True):
                    ## del v[:]
                    ## return False
            ## if trace is not None: pp('Cmp success ', e,v,p)
            ## return True
        ## del v[:]
        ## return False        
    ## if type(p) is dict:
        ## if e in p:
            ## v.append(e)
            ## if trace is not None: pp('Cmp success ', e,v,p)
            ## return True
        ## del v[:]
        ## return False
    ## if e == p:
        ## if trace is not None: pp('Cmp success ', e,v,p)
        ## return True
    ## del v[:]
    ## return False

patt_TCmp = {}

def TCmp(e,v,p):
    if TCmpPure(e,p):
        return TCmpValues(e,v,p)
    return False

def TCmpValues(e, v, p):
    assert type(v) is list
    if type(p) is str:
        if p == '?':
            v.append(e)
            return True
        if type(e) is str and e == p:
            return True
        if p.startswith(':') and p.endswith(':'):
            s = p[1:-1]
            if Is3(e, s):
                v.append((e,s, Val3(e,s)))
                return True  
        del v[:]
        return False
    if type(p) is type:
        if type(e) is p:
            v.append(e)
            return True
        del v[:]
        return False        
    if type(p) is tuple:
        if len(p) > 0 and type(p[0]) is str and p[0] == '|':
            if e in p[1:]:
                return True
        if type(e) is tuple:
            if len(e) != len(p):
                del v[:]
                return False
            for i,p0 in enumerate(p):
                if p0 is None and e[i] is None:
                    continue
                if type(p0) is str:
                    if p0 == '*':
                        v.append(e[i:])
                        return True
                    if p0 == '?':
                        v.append(e[i])
                        continue

                    if type(e[i]) is str:
                        if e[i] != p0:
                            if p0 == ':ImportedM:':
                                s = p0[1:-1]
                                if e[i] in ImportedM:
                                    v.append((e[i],s, ImportedM[e[i]]))
                                    continue  
    
                            del v[:]
                            return False
                        else:
                            continue
                    elif not TCmpValues(e[i], v, p0):
                        del v[:]
                        return False
                elif not TCmpValues(e[i], v, p0):
                    del v[:]
                    return False
            return True
        del v[:]
        return False        
    if type(p) is list:
        if type(e) == type(p):
            if len(e) != len(p):
                del v[:]
                return False
            for i,p0 in enumerate(p):
                if not TCmpValues(e[i], v, p0):
                    del v[:]
                    return False
            return True
        del v[:]
        return False        
    if type(p) is dict:
        if e in p:
            v.append(e)
            return True
        del v[:]
        return False
    if e == p:
        return True
    del v[:]
    return False

def TCmpPure(e, p):
    if type(p) is str:
        if p == '?':
            return True
        elif type(e) is str and e == p:
            return True
        elif p == ':ImportedM:':
            if e in ImportedM:
                return True
        return False
    elif type(p) is type:
        if type(e) is p:
            return True
        return False        
    elif type(p) is tuple:
        if len(p) > 0 and type(p[0]) is str and p[0] == '|':
            if e in p[1:]:
                return True
        if type(e) is tuple:
            if len(e) != len(p):
                return False
            for i,p0 in enumerate(p):
                if p0 is None and e[i] is None:
                    continue
                if type(p0) is str:
                    if p0 == '*':
                        return True
                    if p0 == '?':
                        continue
                    ei = e[i]
                    if type(ei) is str:
                        if ei != p0:
                            if p0 == ':ImportedM:':
                                if ei in ImportedM:
                                    continue      
                            return False
                        else:
                            continue
                    elif not TCmpPure(ei, p0):
                        return False
                elif not TCmpPure(e[i], p0):
                    return False
            return True
        return False        
    elif type(p) is list:
        if type(e) is list:
            if len(e) != len(p):
                return False
            for i,p0 in enumerate(p):
                if not TCmpPure(e[i], p0):
                    return False
            return True
        return False        
    elif type(p) is dict:
        if e in p:
            return True
        return False
    if e is p or e == p:
        return True
    return False
  
def update_v_0_1(v):
    try:
        if v[0]:
            v[0] = True
        else:
            v[0] = False
    except:
        pass
     
def class_create_to_dict_create(nm):
    cmd = N2C(nm).cmds[1]
    cmd = [x for x in cmd if x[0] != '.L' and x != ('RETURN_VALUE', ('f->f_locals',))]
    dic = []
    for x in cmd:
        v = []
        if TCmp(x, v, ('STORE', (('STORE_NAME', '?'),),  (('!MK_FUNK', '?', ('CONST', '?')),))):
            dic.append((('CONST', v[0]), ('!MK_FUNK', v[1], ('CONST', v[2]))))
            continue
        v = []
        if TCmp(x, v, ('STORE', (('STORE_NAME', '?'),), (('CONST', '?'),))):
            
            dic.append((('CONST', v[0]), ('CONST', v[1])))
            continue

        return None
    return DictFromArgs(tuple(dic))
     
 
def repl_list(a, up):
    i = 0
    assert type(a) is list
    aa = a #[:]
    updated = False
    v = []
    while i < len(aa): 
        assert type(i) is int and i >= -1000 and i < (MInt / 10)
        if i < 0:
            i = 0
            continue
        assert type(i) is int and i >= 0 and i < (MInt / 10)
        s = aa[i]
        assert type(v) is list
        if len(v) > 0:
            del v[:]
        
        if i < len(aa) - 2 and type(s) is tuple and len(s) > 0 and type(s[0]) is str and \
           s[0] == '(FOR' and  type(aa[i+1]) is list and aa[i+2] == (')ENDFOR',):         
            if TCmp(s, v, ('(FOR', ('?',), \
                        ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), \
                            ('!BUILD_TUPLE', ('?',)), \
                            ('NULL',)))):
                if aa[i+1] == [('PASS',)]:
                    s1 = [('(IF', ('!PyObject_RichCompare(', v[1], ('CONST', 0), 'Py_GT')), [('STORE', (v[0],), (('!PyNumber_Subtract', v[1], ('CONST', 1)),))], (')ENDIF',)]
                    aa[i:i+3] = s1
                    updated = True
                    i -= 10
                    continue
            elif TCmp(s, v, ('(FOR', (('STORE_FAST', '?'),), \
                        ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), \
                            ('CONST', ('?', '?')), \
                            ('NULL',)))):
                if type(v[1]) is int and type(v[2]) is int and \
                    v[2] - v[1] < 10 and v[2] - v[1] >= 0 and \
                    not expr_in_expr(('STORE_FAST', v[0]), aa[i+1]) and not str_tags_in_expr(frozenset(('CONTINUE', 'BREAK_LOOP')), aa[i+1]):
                        s1 = []
                        for i_ in range(v[1], v[2]):
                            s1.extend(replace_subexpr(aa[i+1], ('FAST', v[0]), ('CONST', i_)))
                        s1.append(('STORE', (('STORE_FAST', v[0]),), (('CONST', v[2] - 1),)))
                        aa[i:i+3] = s1
                        updated = True
                        i -= 10
                        continue
    
            elif TCmp(s, v, ('(FOR', (('?', '?'),), ('CONST', ()))):
                    aa[i:i+3] = []
                    updated = True
                    i -= 10
                    continue
       
        if type(s) is tuple and len(s) == 3 and type(s[0]) is str and s[0] == 'SET_EXPRS_TO_VARS':
            if TCmp(s, v, ('SET_EXPRS_TO_VARS', (('STORE_FAST', '?'), '?'), ('CLONE', '?'))):            
                s1 = [('STORE', (('STORE_FAST', v[0]),), (v[2],)), ('STORE', (v[1],), (('FAST', v[0]),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
    
            elif TCmp(s, v, ('SET_EXPRS_TO_VARS', ('?', '?'), (('CONST', '?'), ('CONST', '?')))):
                s1 = [('STORE', (v[0],), (('CONST', v[2]),)), ('STORE', (v[1],), (('CONST', v[3]),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            elif TCmp(s, v, ('SET_EXPRS_TO_VARS', ('?', '?', '?'), (('CONST', '?'), ('CONST', '?'), ('CONST', '?')))):
                s1 = [('STORE', (v[0],), (('CONST', v[3]),)), ('STORE', (v[1],), (('CONST', v[4]),)), ('STORE', (v[2],), (('CONST', v[5]),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            elif TCmp(s, v, ('SET_EXPRS_TO_VARS', ('?', '?', '?', '?'), (('CONST', '?'), ('CONST', '?'), ('CONST', '?'), ('CONST', '?')))):
                s1 = [('STORE', (v[0],), (('CONST', v[4]),)), ('STORE', (v[1],), (('CONST', v[5]),)), \
                      ('STORE', (v[2],), (('CONST', v[6]),)), ('STORE', (v[3],), (('CONST', v[7]),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            elif TCmp(s, v, ('SET_EXPRS_TO_VARS', ('?', '?'), (('!BUILD_LIST', ()), ('!BUILD_LIST', ())))):
                s1 = [('STORE', (v[0],), (('!BUILD_LIST', ()),)), ('STORE', (v[1],), (('!BUILD_LIST', ()),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            elif TCmp(s, v, ('SET_EXPRS_TO_VARS', ('?', '?', '?'), (('!BUILD_LIST', ()), ('!BUILD_LIST', ()), ('!BUILD_LIST', ())))):
                s1 = [('STORE', (v[0],), (('!BUILD_LIST', ()),)), ('STORE', (v[1],), (('!BUILD_LIST', ()),)), ('STORE', (v[2],), (('!BUILD_LIST', ()),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            elif TCmp(s, v, (   'SET_EXPRS_TO_VARS',
                    (('STORE_FAST', '?'), ('STORE_FAST', '?')),
                    ( '?', '?'))):    
                dic = {('FAST', v[0]):1, ('FAST', v[1]):1, ('STORE_FAST', v[0]):1, ('STORE_FAST', v[1]):1}
                if not exprs_in_expr(dic, [v[2], v[3]]):
                    s1 = [('STORE', (('STORE_FAST', v[0]),), (v[2],)), 
                          ('STORE', (('STORE_FAST', v[1],),), (v[3],))]
                    aa[i:i+1] = s1
                    updated = True
                    i -= 10
                    continue
                if len(v) > 0:
                    del v[:]            

            elif TCmp(s, v, (   'SET_EXPRS_TO_VARS',
                    (('STORE_FAST', '?'), ('STORE_FAST', '?'), ('STORE_FAST', '?')),
                    (   '?', '?', '?'))):    
                dic = {('FAST', v[0]):1, ('FAST', v[1]):1, ('FAST', v[2]):1, ('STORE_FAST', v[0]):1, ('STORE_FAST', v[1]):1, ('STORE_FAST', v[2]):1}
                if not exprs_in_expr(dic, [v[3], v[4], v[5]]):
                    s1 = [('STORE', (('STORE_FAST', v[0]),), (v[3],)), 
                          ('STORE', (('STORE_FAST', v[1]),), (v[4],)), 
                          ('STORE', (('STORE_FAST', v[2]),), (v[5],))]
                    aa[i:i+1] = s1
                    updated = True
                    i -= 10
                    continue
                if len(v) > 0:
                    del v[:]            

            elif TCmp(s, v, ('SET_EXPRS_TO_VARS',
                    (('STORE_NAME', '?'), ('STORE_NAME', '?')),
                    (('CONST', '?'), ('CONST', '?')))):        
                s1 = [('STORE', (('STORE_NAME', v[0]),), (('CONST', v[2]),)), \
                    ('STORE', (('STORE_NAME', v[1]),), (('CONST', v[2]),))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
            elif TCmp(s, v, (   'SET_EXPRS_TO_VARS',
                    (('STORE_NAME', '?'), ('STORE_NAME', '?')),
                    ( '?', '?'))) and type(v[2]) is tuple and type(v[3]) is tuple:    
                dic = {('!LOAD_NAME', v[0]):1, ('!LOAD_NAME', v[1]):1, ('STORE_NAME', v[0]):1, ('STORE_NAME', v[1]):1, 
                       ('!LOAD_GLOBAL', v[0]):1, ('!LOAD_GLOBAL', v[1]):1, ('STORE_GLOBAL', v[0]):1, ('STORE_GLOBAL', v[1]):1}
                if not exprs_in_expr(dic, [v[2], v[3]]):
                    s1 = [('STORE', (('STORE_NAME', v[0]),), (v[2],)), 
                          ('STORE', (('STORE_NAME', v[1],),), (v[3],))]
                    aa[i:i+1] = s1
                    updated = True
                    i -= 10
                    continue
                if len(v) > 0:
                    del v[:]              
            if TCmp(s, v, ('SET_EXPRS_TO_VARS', '?', '?')): 
                li = [x for x in v[1] if x[0] != 'FAST']
                if len(li) == 0:       
                    li1 = [x for x in v[1]]
                    li2 = [('STORE_FAST', x[1]) for x in v[1]]
                    li0 = v[0]
                    li3 = [x for x in range(len(li1)) if expr_in_expr(li1[x], li0) or expr_in_expr(li2[x], li0)]
                    if len(li3) == 0:
                        s1 = []
                        for x in range(len(li1)):
                            s1.append(('STORE', (v[0][x],), (li1[x],)))
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                elif len(v[0]) == len(v[1]) and len([x for x in v[0] if x[0] == 'STORE_FAST']) == len(v[0]):
                    succes = True
                    for x in range(len(v[0])):
                        e1_ = ('FAST', v[0][x][1])
                        e2_ = v[1][x]
                        if count_expr_in_expr(e1_, e2_) == 1 and count_tag_in_expr('FAST', e2_) == 1:
                            continue
                        if not expr_in_expr(e1_, e2_)  and not tag_in_expr('FAST', e2_):
                            continue
                        succes = False
                        break
                    if succes:
                        s1 = []
                        for x in range(len(v[0])):
                            s1.append(('STORE', (v[0][x],), (v[1][x],)))
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue                        
        if len(v) > 0:
            del v[:]            
        if type(s) is tuple and len(s) > 0 and type(s[0]) is str and s[0] == 'STORE':
            v2 = []
            if i < len(aa) - 2 and \
            TCmp(s, v, ('STORE', (('STORE_NAME', '?'),), (('!MK_FUNK', '?', ('CONST', ())),))) and\
            i+2 < len(aa) and aa[i+1][0] == '.L' and\
            TCmp(aa[i+2], v2, ('STORE', ('?',), \
                            (('!PyObject_Call', ('!LOAD_NAME', v[0]), \
                            ('CONST', ()), ('NULL',)),))):  
                ret2 = ('!PyObject_Call', ('!LOAD_NAME', v[0]), ('CONST', ()), ('NULL',)) # unchanged
                newstor = ('STORE', (v2[0],), (call_calc_const(v[1], ('CONST', ()), ret2),))
                if aa[i+2] != newstor:
                    aa[i+2] = newstor    
                    updated = True
                    i -= 10
                    continue
            if len(v) > 0:
                del v[:]            

            if TCmp(aa[i], v, ('STORE', (('STORE_FAST', '?'),), ('?',))):
                if v[0] in g_co.unused_fast_var:
                    aa[i] = ('UNPUSH', v[1])
                    updated = True
                    i -= 10
                    continue
            if len(v) > 0:
                del v[:] 

            if TCmp(aa[i], v, ('STORE', (('STORE_GLOBAL', '?'),), ('?',))):
                t = TypeExpr(v[1])
                if (IsBool(t)) and t[1] is not None and v[1][0] != 'CONST':
                    aa[i:i+1] = [('UNPUSH', v[1]),
                                 ('STORE', (('STORE_GLOBAL', v[0]),), (('CONST', t[1]),)) ]
                    updated = True
                    i -= 10
                    continue
                elif (IsStr(t)) and type(t[1]) is str and v[1][0] != 'CONST':
                    aa[i:i+1] = [('UNPUSH', v[1]),
                                 ('STORE', (('STORE_GLOBAL', v[0]),), (('CONST', t[1]),)) ]
                    updated = True
                    i -= 10
                    continue
            if len(v) > 0:
                del v[:] 

            if TCmp(aa[i], v, ('STORE', (('STORE_FAST', '?'),), ('?',))):
                t = TypeExpr(v[1])
                if (IsBool(t) ) and t[1] is not None and v[1][0] != 'CONST':
                    aa[i:i+1] = [('UNPUSH', v[1]),
                                 ('STORE', (('STORE_FAST', v[0]),), (('CONST', t[1]),)) ]
                    updated = True
                    i -= 10
                    continue
                elif (IsStr(t)) and type(t[1]) is str and v[1][0] != 'CONST':
                    aa[i:i+1] = [('UNPUSH', v[1]),
                                 ('STORE', (('STORE_FAST', v[0]),), (('CONST', t[1]),)) ]
                    updated = True
                    i -= 10
                    continue
            if len(v) > 0:
                del v[:] 

            if TCmp(aa[i:i+3], v, [('STORE', (('STORE_FAST', '?'),), ('?',)),
                                    ('.L', '?'),
                                    ('RETURN_VALUE', ('FAST', '?'))]):
                if v[0] == v[3]:
                    aa[i:] = [('RETURN_VALUE', v[1])]
                    updated = True
                    i -= 10
                    continue
            if len(v) > 0:
                del v[:]            

            if TCmp(aa[i:i+3], v, [('STORE', (('STORE_FAST', '?'),), ('?',)),
                                    ('.L', '?'),
                                    ('RETURN_VALUE', '?')]):
                if not accurate_frame(v[3]):
                    cnt_e = count_expr_in_expr(('FAST', v[0]), v[3])
                    if cnt_e == 1:
                        repr1 = repr(v[3])    
                        repr2 = repr(v[1])
                        is1 = 'CALL' in repr1 or 'Call' in repr1                  
                        is2 = 'CALL' in repr2 or 'Call' in repr2  
                        if is1 and is2:
                            pass
                        else:
                            aa[i:] = [('RETURN_VALUE', replace_subexpr(v[3], ('FAST', v[0]), v[1]))]
                            updated = True
                            i -= 10
                            continue
                    if cnt_e == 0:
                        aa[i:] = [('UNPUSH', v[1]),
                                        ('.L', v[2]),
                                        ('RETURN_VALUE', v[3])]
                        updated = True
                        i -= 10
                        continue  
            if len(v) > 0:
                del v[:]            


            if TCmp(aa[i:i+3], v, [('STORE', (('STORE_FAST', '?'),), ('?',)),
                                    ('.L', '?'),
                                   ('STORE', (('STORE_FAST', '?'),), ('?',))]) and v[0] == v[3]:
                cnt_e = count_expr_in_expr(('FAST', v[0]), v[4])
                if cnt_e == 0  and v[1][0] != '!IMPORT_NAME':
                    del aa[i]
                    updated = True
                    i -= 10
                    continue

            if len(v) > 0:
                del v[:]  

            if TCmp(aa[i:i+3], v, [('STORE', (('STORE_NAME', '?'),), ('?',)),
                                    ('.L', '?'),
                                   ('STORE', (('STORE_NAME', '?'),), ('?',))]) and v[0] == v[3]:
                cnt_e = count_expr_in_expr(('!LOAD_NAME', v[0]), v[4])
                if cnt_e == 0 and v[1][0] != '!IMPORT_NAME':
                    del aa[i]
                    updated = True
                    i -= 10
                    continue

            if len(v) > 0:
                del v[:]  
            if TCmp(s, v, ('STORE', 
                    (('STORE_CALC_CONST', ('STORE_NAME', '?')),),
                    (   (   '!_PyEval_BuildClass',
                            ('!PyObject_Call', ('!MK_FUNK', '?', ('CONST', ())), ('CONST', ()), ('NULL',)),
                            '?',
                            ('CONST', '?')),))) and v[0] == v[1] and v[1] == v[3]:
                dic = class_create_to_dict_create(v[0])
                if dic is not None:
                    aa[i] = ('STORE',
                                (('STORE_CALC_CONST', ('STORE_NAME', v[0])),),
                                (   (   '!_PyEval_BuildClass',
                                        dic,
                                        v[2],
                                        ('CONST', v[3])),))
                    global using_slots
                    if any([x is not None for x in dic[1] if x[0] == ('CONST', '__slots__')]):
                        using_slots = True
                    updated = True
                    i -= 10
                    continue
                if len(v) > 0:
                    del v[:]            

            if TCmp(aa[i:i+3], v, [                        
                (   'STORE',
                    (('STORE_FAST', '?'),),
                    (   '?',)),
                ('.L', '?'),
                (   'STORE',
                    (('STORE_FAST', '?'),),
                    (('!CALL_CALC_CONST', '?', '?'),))]) and v[0] == v[3] and not expr_in_expr(('FAST', v[0]), v[5]):
                        aa[i:i+3] = [                        
                            (   'UNPUSH', v[1] ),
                            ('.L', v[2]),
                            (   'STORE',
                                (('STORE_FAST', v[0]),),
                                (('!CALL_CALC_CONST', v[4], v[5]),))]
                        updated = True
                        i -= 10
                        continue
            if i < len(aa) -  2 and aa[i+1][0] == '.L' and aa[i+2][0] == 'STORE':
                if len(v) > 0:
                    del v[:]            

                if TCmp(aa[i:i+3], v, [ 
                            ('STORE', (('STORE_FAST', '?'),), (('FAST', '?'),)),
                            ('.L', '?'),
                            ('STORE', (('STORE_FAST', '?'),), (('FAST', '?'),))]) and v[0] == v[4]:
                        aa[i+2] =  ('STORE', (('STORE_FAST', v[3]),), (('FAST', v[1]),))
                        updated = True
                        i -= 10
                        continue
                if len(v) > 0:
                    del v[:]            

                if TCmp(aa[i:i+3], v, [('STORE', (('PyObject_SetItem', '?', '?'),), (('FAST', '?'),)),
                             ('.L', '?'),
                             ( 'STORE', 
                               (('PyObject_SetItem', '?', '?'),), 
                               (('!from_ceval_BINARY_SUBSCR', '?', '?'),)) ]) and v[0] == v[6] and v[1] == v[7] and IsList(TypeExpr(v[0])):
                        aa[i:i+2] =  [aa[i], aa[i+1],
                             ( 'STORE', 
                               (('PyObject_SetItem', v[4], v[5]),), 
                               (('FAST', v[2]),)) ]
                        updated = True
                        i -= 10
                        continue
                if len(v) > 0:
                    del v[:]            

            if i < len(aa) -  2 and aa[i+1][0] == '.L' and aa[i+2][0] == '(IF':
                if len(v) > 0:
                    del v[:]            

                srepr = aa[i+2]
                if TCmp(aa[i:i+2], v, [ 
                            ('STORE', (('STORE_FAST', '?'),), (('FAST', '?'),)),
                            ('.L', '?')]) and expr_in_expr(('FAST', v[0]), srepr) and not tag_in_expr('STORE_FAST', srepr) and v[0] != v[1]:
                        aa[i+2] = replace_subexpr(aa[i+2], ('FAST', v[0]), ('FAST', v[1]))
                        updated = True
                        i -= 10
                        continue
         
        if i < len(aa) - 2 and type(aa[i]) is tuple and type(aa[i+1]) is tuple and aa[i][0] == '.L' == aa[i+1][0]:
                del aa[i]
                updated = True
                i -= 10
                continue

        if len(v) > 0:
            del v[:]            


        if type(s) is tuple and len(s) == 3 and type(s[0]) is str and s[0] == 'STORE' and len(s[1]) == 1 and len(s[2]) == 1:
            if s[2][0][0] == '!CALL_CALC_CONST':
                expr = subroutine_inlined(s[2][0][1], s[2][0][2], True, False)
                if expr is not None and expr[-1][0] == 'RETURN_VALUE' and 'RETURN_VALUE' not in repr(expr[:-1]):
                    aa[i:i+1] = expr[:-1] + [('STORE', s[1], (expr[-1][1],))]
                    updated = True
                    i -= 10
                    continue
                
        if type(s) is tuple and len(s) == 2 and type(s[0]) is str and s[0] == 'RETURN_VALUE':
            if s[1][0] == '!CALL_CALC_CONST':
                expr = subroutine_inlined(s[1][1], s[1][2], True, False)
                if expr is not None:
                    assert expr[-1][0] == 'RETURN_VALUE' and 'RETURN_VALUE' not in repr(expr[:-1])
                    aa[i:i+1] = expr
                    updated = True
                    i -= 10
                    continue
    
        if type(s) is tuple and len(s) == 2 and type(s[0]) is str and s[0] == 'UNPUSH':
            t = TypeExpr(s[1])
            if len(v) > 0:
                del v[:]            

            if s[1][0] == '!CALL_CALC_CONST':
                expr = subroutine_inlined(s[1][1], s[1][2], True, False)
                if expr is not None:
                    if 'RETURN_VALUE' not in repr(expr[:-1]):
                        if expr[-1] == ('RETURN_VALUE', ('CONST', None)):
                            aa[i:i+1] = expr[:-1]
                            updated = True
                            i -= 10
                            continue
                        else:
                            aa[i:i+1] = expr[:-1] + [('UNPUSH', expr[-1][1])]
                            updated = True
                            i -= 10
                            continue                            

            if TCmp(s, v, ( 'UNPUSH', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', ('PY_TYPE', 'NewClassInstance', '?', '?', None)), ('CALC_CONST', '?'))))):
                if v[0] == v[2]:
                    del aa[i]
                    updated = True
                    i -= 10
                    continue
                del v[:]
            if t is not None and t != Kl_None:
                if ( IsCType(t) or IsIntUndefSize(t) ) and s[1][0] in ('!PyNumber_Subtract', '!PyNumber_Add', '!PyNumber_And','!PyNumber_Or', '!PyNumber_Multiply'):
                    aa[i:i+1] = [('UNPUSH', s[1][1]), ('UNPUSH', s[1][2])]
                    updated = True
                    i -= 10
                    continue
            if s[1][0] in ('FAST', 'CONST'):    
                    del aa[i]
                    updated = True
                    i -= 10
                    continue
            if s[1][0] == 'PY_TYPE':    
                    aa[i:i+1] = [('UNPUSH', s[1][3])]
                    updated = True
                    i -= 10
                    continue
            if TCmp(s[1], v, ('CALC_CONST', '?')):
                del aa[i]
                if len(aa) == 0:
                    aa.append(('PASS',))
                updated = True
                i -= 10
                continue
            if TCmp(s[1], v, ('!COND_EXPR', '?', '?', '?')):
                if v[1] != v[2]:
                    s1 = [('(IF', v[0]), [('UNPUSH', v[1])], (')(ELSE',), [('UNPUSH', (v[2]))], (')ENDIF',)]
                    aa[i:i+1] = s1
                    updated = True
                    i -= 10
                    continue
            if TCmp(s[1], v, ('!PyObject_Call', 
                                    ('!LOAD_BUILTIN', 'delattr'),
                                    ('!BUILD_TUPLE', ('?', '?')), ('NULL',))):
                s1 = [('PYAPI_CALL', ('PyObject_SetAttr', v[0], v[1], 'NULL'))]
                aa[i:i+1] = s1
                updated = True
                i -= 10
                continue
                
                
            if s[1][0] == '!COND_METH_EXPR' and len(s[1]) == 4:
                cond = s[1]
                condhead = cond[0:3]
                condvars = cond[3]
                if condhead[1][0] == 'FAST':
                    if len(condvars) > 1:    
                        arg, action = condvars[0]
                        nm = arg[1]
                        isnew = arg[0] == T_NEW_CL_INST
                        if isnew:
                            aa[i:i+1] = [('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', condhead[1]), ('CALC_CONST', nm)))),
                                        [('UNPUSH', action)],
                                        (')(ELSE',),
                                        [('UNPUSH', condhead + (condvars[1:],))],
                                        (')ENDIF',)]                    
                            updated = True
                            i -= 10
                            continue
                    if len(condvars) == 1:    
                        arg, action = condvars[0]
                        nm = arg[1]
                        isnew = arg[0] == T_NEW_CL_INST
                        if isnew:
                            aa[i:i+1] = [('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', condhead[1]), ('CALC_CONST', nm)))),
                                        [('UNPUSH', action)],
                                        (')(ELSE',),
                                        [('UNPUSH', condhead[2])],
                                        (')ENDIF',)]                    
                            updated = True
                            i -= 10
                            continue
                            
            s_ = []
            if s[1][0] == '!PyObject_Call' and\
                TCmp(s[1], s_, ('!PyObject_Call', \
                                ('!PyObject_GetAttr', '?', ('CONST', '?')), '?', ('NULL',))):
                s_ = tuple(s_)                    
                if TCmp(s_, v, ('?', 'sort', ('CONST', ()))):
                    if IsList(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyList_Sort', v[0]))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                elif TCmp(s_, v, ('?', 'append', ('CONST', ('?',)))):
                    if IsList(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyList_Append', v[0], ('CONST', v[1])))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                elif TCmp(s_, v, ('?', 'append', ('!BUILD_TUPLE', ('?',)))):
                    if IsList(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyList_Append', v[0], v[1]))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                elif TCmp(s_, v, ('?', 'clear', ('CONST', ()))):
                    if IsDict(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyDict_Clear', v[0]))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                elif TCmp(s_, v, ('?', 'reverse', ('CONST', ()))):
                    if IsList(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyList_Reverse', v[0]))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                elif TCmp(s_, v, ('?', 'insert', ('CONST', ('?', '?')))):
                    if IsList(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyList_Insert', v[0], v[1], ('CONST', v[2])))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                elif TCmp(s_, v, ('?', 'insert', ('!BUILD_TUPLE', (('CONST', '?'), '?')))):
                    if IsList(TypeExpr(v[0])):
                        s1 = [('PYAPI_CALL', ('PyList_Insert', v[0], v[1], v[2]))]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
            if len(v) > 0:
                del v[:]            


            if TCmp(s[1], v, ('CONST', '?')):
                aa[i:i+1] = []
                if len(aa) == 0:
                    aa.append(('PASS',))
                updated = True
                i -= 10
                continue

        if type(s) is tuple and len(s) == 3 and type(s[0]) is str and \
           s[0] == 'STORE' and len(s[1]) == 1 and len(s[2]) == 1:
            if s[1][0][0] == 'STORE_FAST':   
                if TCmp(s, v, ('STORE', (('STORE_FAST', '?'),), \
                                (('!COND_EXPR', '?', '?', '?'),))):
                    if v[2] != v[3]:
                        s1 = [('(IF', v[1]), [('STORE', (('STORE_FAST', v[0]),),  (v[2],))], \
                            (')(ELSE',), [('STORE', (('STORE_FAST', v[0]),),  (v[3],))], (')ENDIF',)]
                        aa[i:i+1] = s1
                        updated = True
                        i -= 10
                        continue
                del v[:]
# constant expansion                
                if up is None and TCmp(s, v, ('STORE', (('STORE_FAST', '?'),), \
                                (('CONST', '?'),))) :
                    dic = { ('FAST', v[0]):1, ('STORE_FAST', v[0]):1,   ('DELETE_FAST', v[0]):1}
                    dic2 = { ('STORE_FAST', v[0]):1,   ('DELETE_FAST', v[0]):1}
                    if not exprs_in_expr(dic, aa[i+1:]) :
                        if aa[-1][0] == 'RETURN_VALUE':
                            del aa[i]
                            i-= 10
                            continue
                    if not exprs_in_expr(dic2, aa[i+1:]) :
                        if aa[-1][0] == 'RETURN_VALUE':
                            aa[i+1:] = replace_subexpr(aa[i+1:], ('FAST', v[0]), ('CONST', v[1]))
                            del aa[i]
                            i-= 10
                            continue

                del v[:]
## unused assigment
                if up is None and TCmp(s, v, ('STORE', (('STORE_FAST', '?'),), \
                                ('?',))) :
                    dic = { ('FAST', v[0]):1, ('STORE_FAST', v[0]):1,   ('DELETE_FAST', v[0]):1}
                    if not exprs_in_expr(dic, aa[i+1:]) :
                        del aa[i]
                        i-= 10
                        continue
                del v[:]

                if TCmp(s, v, \
                    ('STORE', \
                        (('STORE_FAST', '?'),), \
                        (('!PyNumber_InPlaceAdd', \
                            ('PY_TYPE', '?', None, ('FAST', '?'), None), \
                            ('!BUILD_LIST', '?')),))):
                    if v[0] == v[2] and v[1] is list:
                        new_a = []
                        for li in v[3]:
                            new_a.append(('PYAPI_CALL', ('PyList_Append', ('FAST', v[0]), li)))
                        aa[i:i+1] = new_a
                        updated = True
                        i -= 10
                        continue
                    del v[:]
            if s[1][0][0] == 'SET_VARS' and \
                TCmp(s, v, ('STORE', (('SET_VARS', '?'),), (('!BUILD_LIST', '?'),))) and \
                   len(v[0]) == len(v[1]):
                if v[0][0][0] == 'STORE_NAME' and not v[0][0][1] in repr(v[1][1:]) and not v[0][0][1] in repr(v[0][1:]):
                    s1 = [('STORE', (('STORE_NAME', v[0][0][1]),), (v[1][0],))]
                    if len(v[0]) > 1:
                        s1.append( ('STORE', (('SET_VARS', v[0][1:]),), (('!BUILD_LIST', v[1][1:]),)) )
                    aa[i:i+1] = s1
                    updated = True
                    i -= 10
                    continue
                del v[:]
            if s[1][0][0] == 'SET_VARS' and \
                TCmp(s, v, ('STORE', (('SET_VARS', '?'),), (('CONST', '?'),))) and \
                   type(v[1]) is tuple and len(v[0]) == len(v[1]):
                if v[0][0][0] == 'STORE_NAME' and not v[0][0][1] in repr(v[1][1:]) and not v[0][0][1] in repr(v[0][1:]):
                    s1 = [('STORE', (('STORE_NAME', v[0][0][1]),), (('CONST', v[1][0]),))]
                    if len(v[0]) > 1:
                        s1.append( ('STORE', (('SET_VARS', v[0][1:]),), (('CONST', v[1][1:]),)) )
                    aa[i:i+1] = s1
                    updated = True
                    i -= 10
                    continue
                if v[0][0][0] == 'STORE_FAST' and not v[0][0][1] in repr(v[1][1:]) and not v[0][0][1] in repr(v[0][1:]):
                    s1 = [('STORE', (('STORE_FAST', v[0][0][1]),), (('CONST', v[1][0]),))]
                    if len(v[0]) > 1:
                        s1.append( ('STORE', (('SET_VARS', v[0][1:]),), (('CONST', v[1][1:]),)) )
                    aa[i:i+1] = s1
                    updated = True
                    i -= 10
                    continue
        if type(s) is tuple:
            if i+1 < len(aa) and len(s) > 0 and s[0] == 'RETURN_VALUE': # and \
               ##aa[i+1][0] in ('STORE', 'UNPUSH', '.L', 'RETURN_VALUE', 'PRINT_ITEM_1', 'PRINT_NEWLINE'):
                del aa[i+1:]
                updated = True
                i -= 10
                continue
            if i+1 < len(aa) and len(s) > 0 and s[0] == 'CONTINUE': # and \
               ##aa[i+1][0] in ('STORE', 'UNPUSH', '.L', 'RETURN_VALUE', 'PRINT_ITEM_1', 'PRINT_NEWLINE', 'CONTINUE'):
                del aa[i+1:]
                updated = True
                i -= 10
                continue
            if i+1 < len(aa) and len(s) > 0 and s[0] == 'BREAK_LOOP': ## and \
               ## aa[i+1][0] in ('STORE', 'UNPUSH', '.L', 'RETURN_VALUE', 'PRINT_ITEM_1', 'PRINT_NEWLINE'):
                del aa[i+1:]
                updated = True
                i -= 10
                continue
            if i+5 <= len(aa) and s == ('(TRY',) and type(aa[i+1]) is list and \
               len(aa[i+1]) == 1 and aa[i+1][0][0] == '.L' and\
               aa[i+2][0] == ')(EXCEPT' and type(aa[i+3]) is list and\
               aa[i+4] == (')ENDTRY',):
                aa[i:i+5] = aa[i+1]
                updated = True
                i -= 10
                continue
            if len(v) > 0:
                del v[:]            

            if False and i+5 <= len(aa) and s == ('(TRY',) and type(aa[i+1]) is list and \
               len(aa[i+1]) == 2 and aa[i+1][0][0] == '.L' and\
               TCmp(aa[i+1][1], v, ('STORE', (('STORE_FAST', '?'),), (('CALC_CONST', '?'),))) and\
               aa[i+2][0] == ')(EXCEPT' and type(aa[i+3]) is list and\
               aa[i+4] == (')ENDTRY',):
                aa[i:i+5] = aa[i+1]
                updated = True
                i -= 10
                continue

            if len(v) > 0:
                del v[:]            

            if i+5 <= len(aa) and s == ('(TRY',) and type(aa[i+1]) is list and \
               len(aa[i+1]) == 1 and aa[i+1][0] == ('PASS',) and\
               aa[i+2][0] == ')(EXCEPT' and type(aa[i+3]) is list and\
               aa[i+4] == (')ENDTRY',):
                del aa[i:i+5] 
                updated = True
                i -= 10
                continue
            if i+7 <= len(aa) and s == ('(TRY',) and type(aa[i+1]) is list and \
               len(aa[i+1]) == 1 and aa[i+1][0][0] == '.L' and\
               aa[i+2][0] == ')(EXCEPT' and type(aa[i+3]) is list and\
               aa[i+4] == (')(ELSE',) and type(aa[i+5]) is list and\
               aa[i+6] == (')ENDTRY',):

                aa[i:i+7] = aa[i+5]
                updated = True
                i -= 10
                continue
            if i+7 <= len(aa) and s == ('(TRY',) and type(aa[i+1]) is list and \
               len(aa[i+1]) == 1 and aa[i+1][0] == ('PASS',) and\
               aa[i+2][0] == ')(EXCEPT' and type(aa[i+3]) is list and\
               aa[i+4] == (')(ELSE',) and type(aa[i+5]) is list and\
               aa[i+6] == (')ENDTRY',):
                aa[i:i+7] = aa[i+5]
                updated = True
                i -= 10
                continue

          
            if s == ('(TRY',):
                i1 = get_closed_pair(aa,i)
                stm = aa[i:i1+1]
                if stm[-3] == (')(FINALLY',):
                    tr = stm[1]
                    if len(stm) == 5:
                        aa[i:i1+1] = [('(TRY_FINALLY',), stm[1], (')(FINALLY',), stm[3], (')ENDTRY_FINALLY',)]
                        updated = True
                        i -= 10
                        continue
                    if tr[0] == ('(TRY',) and get_closed_pair(stm[1],0)+1 == len(stm[1]):
                        old1 = aa[i+1]
                        new1 = stm[-2]
                        aa[i:i1+1] = [('(TRY_FINALLY',), old1, (')(FINALLY',), new1, (')ENDTRY_FINALLY',)]
                        updated = True
                        i -= 10
                        continue
                    
                    new1 = aa[i1-1]
                    del aa[i1-2:i1-1]
                    old1 = aa[i:i1-2]
                    aa[i:i1-2] = [('(TRY_FINALLY',), old1, (')(FINALLY',), new1, (')ENDTRY_FINALLY',)]
                    updated = True
                    i -= 10
                    continue
                

            if len(v) > 0:
                del v[:]            
 
            if len(s) > 1 and s[0] == '(IF' and s[1][0] != 'CONST':
                to_s = None
                if das_ist_True(s[1]):
                    to_s = ('CONST', True)
                if das_ist_False(s[1]):
                    to_s = ('CONST', False)
                if to_s is not None:
                    s = list(s)
                    s[1] = to_s
                    aa[i] = tuple(s)
                    updated = True
                    i -= 10
                    continue            
                
            if len(s) > 1 and s[0] == '(IF' and s[1][0] == 'CONST':
                if TCmp(s, v, ('(IF', ('CONST', '?'), '?')):
                    if not type(v[0]) is bool: # not in (True, False):
                        update_v_0_1(v)
                        aa[i] = ('(IF', ('CONST', v[0]), v[1])
                        updated = True
                        i -= 10
                        continue            
                if len(v) > 0:
                    del v[:]            

                if TCmp(s, v, ('(IF', ('CONST', '?'))):
                    if not type(v[0]) is bool: # not in (True, False):
                        update_v_0_1(v)
                        aa[i] = ('(IF', ('CONST', v[0]))
                        updated = True
                        i -= 10
                        continue            
                if len(v) > 0:
                    del v[:]            
    
                        
                if TCmp(s, v, ('(IF', ('CONST', False), '?')):
                    if type(aa[i+1]) is list and aa[i+2] == (')ENDIF',):
                        del aa[i:i+3]
                        updated = True
                        i -= 10
                        continue
                    if type(aa[i+1]) is list and \
                            aa[i+2] == (')(ELSE',) and type(aa[i+3]) is list and \
                            aa[i+4] == (')ENDIF',):
                        aa[i:i+5] = aa[i+3]
                        updated = True
                        i -= 10
                        continue 
                    
                if TCmp(s, v, ('(IF', ('CONST', True), '?')):
                    if type(aa[i+1]) is list and aa[i+2] == (')ENDIF',):
                        aa[i:i+3] = aa[i+1]
                        updated = True
                        i -= 10
                        continue
                        
                    if type(aa[i+1]) is list and \
                            aa[i+2] == (')(ELSE',) and type(aa[i+3]) is list and \
                            aa[i+4] == (')ENDIF',):
                        aa[i:i+5] = aa[i+1]
                        updated = True
                        i -= 10
                        continue    
    
                if TCmp(s, v, ('(IF', ('CONST', False))):
                    if type(aa[i+1]) is list and aa[i+2] == (')ENDIF',):
                        del aa[i:i+3]
                        updated = True
                        i -= 10
                        continue
                    elif type(aa[i+1]) is list and \
                            aa[i+2] == (')(ELSE',) and type(aa[i+3]) is list and \
                            aa[i+4] == (')ENDIF',):
                        aa[i:i+5] = aa[i+3]
                        updated = True
                        i -= 10
                        continue            
                if TCmp(s, v, ('(IF', ('CONST', True))):
                    if type(aa[i+1]) is list and aa[i+2] == (')ENDIF',):
                        aa[i:i+3] = aa[i+1]
                        updated = True
                        i -= 10
                        continue
                    elif type(aa[i+1]) is list and \
                            aa[i+2] == (')(ELSE',) and type(aa[i+3]) is list and \
                            aa[i+4] == (')ENDIF',):
                        aa[i:i+5] = aa[i+1]
                        updated = True
                        i -= 10
                        continue 
            if len(s) > 1 and s[0] == '(IF' and s[1][0] in ('!AND_JUMPED_STACKED', '!AND_JUMP', '!AND_BOOLEAN') and das_ist_False(s[1][-1]): 
                if len(s[1]) > 3:
                    aa[i:i+1] = [('UNPUSH', s[1][:-1]), ('(IF', ('CONST', False)) + s[2:]]
                else:
                    aa[i:i+1] = [('UNPUSH', s[1][1]), ('(IF', ('CONST', False)) + s[2:]]
                updated = True
                i -= 10
                continue
            
            if len(s) > 1 and s[0] == '(IF' and i+4 < len(aa) and TCmp(s, v, ('(IF', ('!BOOLEAN', '?'))) and \
                aa[i+1] == [('RETURN_VALUE', ('CONST', True))] and \
                aa[i+2] == (')ENDIF',) and \
                aa[i+3][0] == '.L' and \
                aa[i+4] == ('RETURN_VALUE', ('CONST', False)):
                    aa[i:i+5] = [('RETURN_VALUE', ('!BOOLEAN', v[0]))]
                    updated = True
                    i -= 10
                    continue

            if i+4 < len(aa) and len(s) >= 2 and s[0] == '(IF':
                if type(aa[i+1]) is list and type(aa[i+3]) is list and \
                   aa[i+2][0] == ')(ELSE' and aa[i+4][0] == ')ENDIF' and aa[i+1] == aa[i+3]:
                    aa[i:i+5] = [('UNPUSH', s[1])] + aa[i+1] 
                    updated = True
                    i -= 10
                    continue 
                if len(v) > 0:
                    del v[:]            

                if i + 10 < len (aa) and \
                    TCmp(s, v, ('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', ('FAST', '?')), \
                                                     ('CALC_CONST', '?'))))) and \
                    aa[i+5][0] == '.L' and \
                    aa[i+6] == ('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', ('FAST', v[0])), \
                                                     ('CALC_CONST', v[1])))) and \
                    type(aa[i+1]) is list and type(aa[i+3]) is list and \
                    aa[i+2][0] == ')(ELSE' and aa[i+4][0] == ')ENDIF' and \
                    type(aa[i+7]) is list and type(aa[i+9]) is list and \
                    aa[i+8][0] == ')(ELSE' and aa[i+10][0] == ')ENDIF':
                        l1 = aa[i+1] + [aa[i+5]] + aa[i+7]
                        l2 = aa[i+3] + [aa[i+5]] + aa[i+9]
                        if not tag_in_expr('STORE_FAST', l1) and not tag_in_expr('STORE_FAST', l2):
                            aa[i:i+11] = [('(IF', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', ('FAST', v[0])), \
                                                        ('CALC_CONST', v[1])))),
                                                        l1,
                                                        (')(ELSE',),
                                                        l2,
                                                        (')ENDIF',)]
                            updated = True
                            i -= 10
                            continue 

                   
            if len(s) > 0 and s[0] == 'RETURN_VALUE':
                if TCmp(s, v, ('RETURN_VALUE', \
                                ('!PyObject_Call', \
                                    ('!LOAD_BUILTIN', 'setattr'), \
                                    ('!BUILD_TUPLE', ('?', '?', '?')), \
                                    ('NULL',)))):
                    aa[i:i+1] = [('UNPUSH', s[1]), (s[0], ('CONST', None))]
                    updated = True
                    i -= 10
                    continue
            if len(s) == 3 and s[0] ==  'SEQ_ASSIGN':
                if len(v) > 0:
                    del v[:]            

                if TCmp(s, v, ('SEQ_ASSIGN', (('STORE_FAST', '?'), '?'), '?')):
                    if not expr_in_expr(('FAST', v[0]), v[1]):
                        aa[i:i+1] = [('STORE', (s[1][0],), (s[2],)), ('STORE', (s[1][1],), (('FAST', v[0]),))]
                        updated = True
                        i -= 10
                        continue   
        assert type(i) is int and i >= 0 and i <= (MInt / 10)
        i += 1    
    if updated:
        if len(aa) == 0:
            return [('PASS',)]
        return aa
    return a           
       
is_inlined = False

def if_to_cond(test, st1, st2):
    assert type(st1) is list
    assert type(st2) is list
    e1 = None
    e2 = None
    if len(st1) > 1:
        st1 = for_inline_to_expr(st1, 1)
    if len(st2) > 1:
        st2 = for_inline_to_expr(st2, 1)
    if len(st1) == 1 and st1[0][0] == 'RETURN_VALUE':
        e1 = st1[0][1]
    if len(st1) == 2 and st1[1][0] == 'RETURN_VALUE' and st1[0][0] == '.L':
        e1 = st1[1][1]
    if len(st2) == 1 and st2[0][0] == 'RETURN_VALUE':
        e2 = st2[0][1]
    if len(st2) == 2 and st2[1][0] == 'RETURN_VALUE' and st2[0][0] == '.L':
        e2 = st2[1][1]
    if e1 is not None and e2 is not None:
        if e1 == ('CONST', True) and e2 == ('CONST', False):
            return test
        if e2 == ('CONST', True) and e1 == ('CONST', False):
            return ('!1NOT', test)
        return cond_expr_to_andor(('!COND_EXPR', test, e1, e2))
    return None

def for_inline_to_expr(cmds, lev):
    o = []
    i = 0
    while i < len(cmds):
        if cmds[i][0] == '(IF':
            if (i+4) < len(cmds) and cmds[i+2][0] == ')(ELSE' and cmds[i+4][0] == ')ENDIF': 
                expr = if_to_cond(cmds[i][1], cmds[i+1], cmds[i+3]) 
                if expr is not None: 
                    o.append(('RETURN_VALUE', expr)) 
                    i += 5
                    continue
            if (i+3) < len(cmds) and cmds[i+2][0] == ')ENDIF': 
                if cmds[i+3][0] == 'RETURN_VALUE':                
                    expr = if_to_cond(cmds[i][1], cmds[i+1], [cmds[i+3]]) 
                    if expr is not None: 
                        o.append(('RETURN_VALUE', expr)) 
                        i += 4
                        continue
            if (i+4) < len(cmds) and cmds[i+3][0] == '.L' and cmds[i+4][0] == 'RETURN_VALUE':                
                expr = if_to_cond(cmds[i][1], cmds[i+1], [cmds[i+4]]) 
                if expr is not None: 
                    o.append(('RETURN_VALUE', expr)) 
                    i += 5
                    continue
  
        if cmds[i][0] == 'RETURN_VALUE' and cmds[i][1][0] == '!PyBool_Type.tp_new' and \
           cmds[i][1][2][0] == '!BUILD_TUPLE' and len(cmds[i][1][2][1]) == 1:
                if cmds[i][1][2][1][0][0] == '!BOOLEAN':
                    o.append((cmds[i][0], cmds[i][1][2][1][0]))
                    i += 1
                    continue
                else:
                    pp('PPPPPP///',  cmds[i][1][2][1][0])
           
        o.append(cmds[i])  
        i += 1
    return o

def cond_expr_to_andor(ret):
    if ret[0] == '!COND_EXPR':
        if ret[2] == ('CONST', True) and ret[2][1] is True:
            ## 1 1 > 1
            ## 1 0 > 1
            ## 0 1 > 1
            ## 0 0 > 0
            ret1 = repl_if_expr(ret[1])
            if ret1 is None:
                ret1 = ret[1]
            ret2 = cond_expr_to_andor(ret[3])
            if ret2 is None:
                ret2 = ret[3]
                
            ret = ('!OR_JUMPED_STACKED', ret1, ret2)
        elif ret[2][0] == 'CONST' and ret[2][1] is False:
            ## 1 1 > 0
            ## 1 0 > 0
            ## 0 1 > 1
            ## 0 0 > 0
            ret1 = repl_if_expr(ret[1])
            if ret1 is None:
                ret1 = ret[1]
            ret1 = Not(ret1)
            ret2 = cond_expr_to_andor(ret[3])
            if ret2 is None:
                ret2 = ret[3]
            ret = ('!AND_JUMPED_STACKED', ret1, ret2) 
        elif ret[3][0] == 'CONST' and ret[3][1] is False:
            ## 1 1 > 1
            ## 1 0 > 0
            ## 0 1 > 0
            ## 0 0 > 0
            ret1 = repl_if_expr(ret[1])
            if ret1 is None:
                ret1 = ret[1]
            ret2 = cond_expr_to_andor(ret[2])
            if ret2 is None:
                ret2 = ret[2]
            ret = ('!AND_JUMPED_STACKED', ret1, ret2) 
        elif ret[3][0] == 'CONST' and ret[3][1] is True:
            ## 1 1 > 1
            ## 1 0 > 0
            ## 0 1 > 1
            ## 0 0 > 1
            ret1 = repl_if_expr(ret[1])
            if ret1 is None:
                ret1 = ret[1]
            ret1 = Not(ret)
            ret2 = cond_expr_to_andor(ret[2])
            if ret2 is None:
                ret2 = ret[2]
            ret = ('!OR_JUMPED_STACKED', ret1, ret2) 
        ## if ret[2][0] == '!COND_EXPR' and ret[2][2][0] == 'CONST' and ret[2][2][1] is True and ret[3][0] == 'CONST' ret[3][1] is False:
            ## ret1 = ret[1]
            ## ret2 = ret[2][1]
            ## ret3 = ret[2][3]
## 1 1 1    1
## 1 1 0    1 
## 1 0 1    1
## 1 0 0    0
## 0 1 1    0
## 0 1 0    0
## 0 0 1    0
## 0 0 0    0        
 ## ('!_EQ_',
  ## ('!PyObject_Type', ('FAST', 't')),
  ## ('!LOAD_BUILTIN', 'tuple')),
 ## ('!COND_EXPR',
  ## '<<>>',
  ## ('CONST', True),
  ## ('!PyObject_RichCompare(',
   ## ('FAST', 't'),
   ## ('CONST', ('C', None)),
   ## 'Py_EQ')),
 ## (('CONST', False),))
    return ret
    
def cond_expr_to_cond_meth(cmds):
    if type(cmds) is tuple:
        if len(cmds) > 1:
            if cmds[0] == 'CONST':
                return cmds
            if cmds[0] == '!COND_EXPR':
                return one_cond_expr_to_cond_meth(cmds[1], cmds[2], cmds[3], cmds)
        ret2 = tuple([cond_expr_to_cond_meth(x) for x in cmds])
        if ret2 != cmds:
            cmds = ret2
    if type(cmds) is list:
        ret2 = [cond_expr_to_cond_meth(x) for x in cmds]
        if ret2 != cmds:
            cmds = ret2
    return cmds

def one_cond_expr_to_cond_meth(a,b,c, ret):
    ## print a
    ## print b
    ## print c
    ## print ret
    ## print '----------'
    assert type(a) is tuple
    assert type(b) is tuple
    assert type(c) is tuple

    meths = []
    ret2 = ['!COND_METH_EXPR', None, None, None]
    
    while True:
         
        if a[0] == '!BOOLEAN':
            a = a[1]
        if a[0] != '!_EQ_':
            return ret
        if a[1][0] == '!PyObject_Type':
            if a[2][0] not in ('CALC_CONST',): # '!LOAD_BUILTIN'):
                return ret
            if ret2[1] is None:
                ret2[1] = a[1][1]
            else:
                assert ret2[1] == a[1][1]
            if a[2][0] == '!LOAD_BUILTIN':
                t0 = (d_built[a[2][1]], None)
            else:
                t0 = TypeExpr(a[2])
                if t0 is not None:
                    if t0[0] == T_NEW_CL_TYP:
                        t0 = (T_NEW_CL_INST, t0[1])
                    elif t0[0] == T_OLD_CL_TYP:
                        t0 = (T_OLD_CL_INST, t0[1])
                    else:
                        assert False
            assert t0 is not None
            if b[0] == '!COND_EXPR':
                b = cond_expr_to_andor(b)
            if b[0] == '!COND_EXPR':
                pprint(('Cond in cond', a,(b[0], b[1], b[2], b[3]) , c))
            meths.append((t0, cond_expr_to_cond_meth(b)))
            if c[0] == '!COND_EXPR':
                a,b,c = c[1:]
                continue
            else:
                if len(meths) > 0 and ret2[1] is not None and c[0] != 'CONST':
                    ret2[2] = c
                    ret2[3] = tuple(meths)
                    pprint(('Cond to CondMeth', ret, '>-::>>->', ret2))
                    return tuple(ret2)
                else:
                    return ret
        return ret
        
    assert False
 
def subroutine_inlined(nm, tupl, only_last_return = False, one_expression = False):
    global is_inlined, inline_flag
    if is_inlined or not inline_flag:
        return None
    co = N2C(nm)
    is_varargs = co.co_flags & 0x4 
    if co == g_co:
        return None
    ## t = co.ReturnType()
    ## if not IsBool(t) and not IsInt(t):
        ## return None
    if tupl[0] == '!BUILD_TUPLE':
        tupl = tupl[1]
    elif tupl[0] == 'CONST':
        tupl = [('CONST', x) for x in tupl[1]]
    else:
        pp('No inline - *args arg', nm, tupl)
        return None   
    cmds = co.cmds[1]
    ## if cmds[-1][0] != 'RETURN_VALUE':
    prev_cmds = cmds
    while True:
        ##print '/1', cmds
        cmds = for_inline_to_expr(cmds, 0)
        ##print '/2', cmds
        while len(cmds) > 0 and cmds[-1][0] == '.L':
            del cmds[-1]
        cmds = cond_expr_to_cond_meth(cmds)
        ##print '/3', cmds
        while len(cmds) > 0 and cmds[-1][0] == '.L':
            del cmds[-1]
        if cmds == prev_cmds:
            cmds = prev_cmds
            break        
        prev_cmds = cmds
        
    if not is_varargs and nm in default_args:
        is_const_default = True
        defau = default_args[nm]
        if defau[0] != 'CONST':
            is_const_default = False
        if len(tupl) < co.co_argcount:
            if is_const_default:
                _refs2 = [('CONST', x) for x in defau[1]]
            else:
                _refs2 = [x for x in defau[1]]
            while (len(tupl) + len(_refs2) ) > co.co_argcount and len(_refs2) > 0:
                del _refs2[0]
            if (len(tupl) + len(_refs2) ) == co.co_argcount:
                tupl = list(tupl) + _refs2

    if len(tupl) == co.co_argcount and len(co.co_varnames) > co.co_argcount:
        co.strip_unused_fast()
                
    if co.co_argcount == co.co_nlocals and \
       co.co_argcount == len(co.co_varnames): 
        if is_varargs:
            return None
        if len(cmds) == 0:
            pprint((co.cmds, '------------------->>>>>>>>>>>>>>>>>>>', nm, tupl))
            assert False
        if cmds[-1][0] != 'RETURN_VALUE':        
            pprint(('!! no return at last', cmds))
            return None

        srepr = repr(cmds)
        if len(tupl) == co.co_argcount:
                expr = cmds

                d = {}
                for i in range(co.co_argcount):
                    ttu = tupl[i]
                    if ttu[0] == 'PY_TYPE':
                        ttu = ttu[3]
                    if ttu[0] == 'PY_TYPE':
                        assert False
                        ttu = ttu[3]
                    if srepr.count(repr(('FAST', co.co_varnames[i]))) > 1 and ttu[0] not in ('FAST', 'CONST'):
                        ##pp('No inline - have dangerous arg', ('FAST', co.co_varnames[i]), ttu, nm)
                        d = None
                        break
                    elif repr(('STORE_FAST', co.co_varnames[i])) in srepr :
                        d = None
                        break
                    else:
                        ttu = tupl[i]
                        if ttu[0] == 'PY_TYPE' and ttu[1] == 'PSEVDO':
                            ttu = ttu[3]
                        d[co.co_varnames[i]] = ttu
                if d is None:
                    return None

                expr = replace_fastvar(expr, d)

                is_inlined = True

                
                expr1 = tree_pass_upgrade_repl(expr, None, '?') 
                expr = tree_pass_upgrade_repl(expr1,  None, '?') 
                is_inlined = False
                srepr = repr(expr)
                if 'CONTINUE' in srepr or 'BREAK_LOOP' in srepr or 'RETURN_VALUE' in repr(expr[:-1]):
                    return None
                if expr is None:
                    return None
                if only_last_return:
                    if expr[-1][0] != 'RETURN_VALUE':
                        return None
                    if 'RETURN_VALUE' in repr(expr[:-1]):
                        return None
                if one_expression:
                    srepr = repr(expr)
                    if 'STORE' in srepr:
                        return None
                    if 'DELETE' in srepr:
                        return None
                    if '(IF' in srepr:
                        return None
                    if 'PRINT_ITEM' in srepr:
                        return None   
                    if expr[-1][0] != 'RETURN_VALUE':
                        return None
                    if len(expr) > 2 or expr[0][0] != '.L':
                        return None                 
                    
                pp(g_co.c_name, '-->>', co.c_name, ':', nm, tupl, '-->>',  expr)
                return expr
    return None    
       
def to_tuple_const(v):
    try:
        return ('CONST', tuple(v[0]))
    except:
        pass
    return None

def to_const_meth_1(obj, meth, args):
    if meth == 'iter' or meth == 'format' or meth == 'vformat':
        return None
    try:
        meth = operator.methodcaller(meth, *args[1])
        v_s = meth(obj[2][1][0])
        if type(v_s) is list:
            v_s = [('CONST', x) for x in v_s]
            return ('!BUILD_LIST', tuple(v_s))
        assert 'formatteriter' not in repr(type(v_s))
        assert 'fieldnameiterator ' not in repr(v_s)
        assert type(v_s) != dict
        try:
            if len(v_s) > 5000:
                pass
            else:
                return ('CONST', v_s)
        except:
            return ('CONST', v_s)
    except:
        pass
    return None
           
def to_const_meth_2(obj, meth, args):
    if meth == 'iter' or meth == 'format' or meth == 'vformat':
        return None
    try:
        meth = operator.methodcaller(meth, *args[1])
        v_s = meth(obj[1])
        if type(v_s) is list:
            v_s = [('CONST', x) for x in v_s]
            return ('!BUILD_LIST', tuple(v_s))
        assert 'formatteriter' not in repr(type(v_s))
        assert 'fieldnameiterator ' not in repr(v_s)
        assert type(v_s) != dict
        try:
            if len(v_s) > 5000:
                pass
            else:
                return ('CONST', v_s)
        except:
            return ('CONST', v_s)
    except:
        pass
    return None       

def cond_expr_module(t, ret):
    v = []
   
    if TCmp(ret,v, ('!COND_EXPR', ('CALC_CONST', '?'), ('CALC_CONST', ('?', '?')), '?')) and t is not None and v[0] == v[1]:
        return ret[2]    
    if TCmp(ret,v, ('!COND_EXPR', ('CALC_CONST', '?'), ('!PyObject_GetAttr', ('CALC_CONST', '?'), '?'), '?')) and t is not None and v[0] == v[1]:
        return ret[2]    

    this,d2 = MyImport(t[1])
    pprint(this)
    pprint(d2)
    pprint(ret)
    pprint(t)
    Fatal('')
    return ret[2]

def if_expr_1(ret):
    try:
        if ret[0] == '(IF' and ret[1][0] == 'CONST' and ret[1][1] and ret[1][1] is not True:
            ret = list(ret)
            ret[1] = ('CONST', True)
            return tuple(ret)
        if ret[0] == '(IF' and ret[1][0] == 'CONST' and not ret[1][1] and ret[1][1] is not False:
            ret = list(ret)
            ret[1] = ('CONST', False)
            return tuple(ret)
    except:
        pass    
    return None

not_d_built = set(('xrange', 'range', 'list', 'dict', 'set', 'raw_input', 'exit',
               'AssertionError', 'TypeError', 'RuntimeError', 'open', 'file',
              'ValueError', 'UnicodeError', 'KeyError', 'map', 'iter',
              'ImportError', 'Exception', 'ZeroDivisionError', 'UserWarning', 
              'UnicodeTranslateError', 'UnicodeEncodeError', 'execfile', 'sorted',
              'UnicodeDecodeError', 'StandardError', 'eval', 'exec', 'input', 'reversed', 'enumerate', 'zip', 'frozenset', 
              'StopIteration', 'SyntaxError', 'bytearray', 'buffer', 'memoryview', '__import__', 'vars', 'print', 'CONST'))
           
def calc_expr_1(op, v):
    assert type(op) is str
    is_vo = op.startswith('!')
    try:
        if not is_vo: # and op in d_built and op not in not_d_built and 'Error' not in op and 'Exception' not in op and 'Exit' not in op:
            if op == 'ord':
                return calculed_const(ord(v))
            elif op == 'hex':
                return calculed_const(hex(v))
            elif op == 'oct':
                return calculed_const(oct(v))
            elif op == 'round':
                return calculed_const(round(v))
            elif op == 'min':
                return calculed_const(min(v))
            elif op == 'max':
                return calculed_const(max(v))
            elif op == 'chr': #in ('!CHR_BUILTIN', 'chr'):
                return calculed_const(chr(int(v)))
            elif op in ('unichr', ):
                return calculed_const(unichr(v))
            elif op in ('callable', ):
                return calculed_const(callable(v)) # hi-hi
            elif op == 'len':
                return calculed_const(len(v))
            elif op == 'sum':
                return calculed_const(sum(v))
            elif op == 'type': #in ('!PyObject_Type', 'type'):
                if v is not None:
                    if type(v) in type_to_check_str:
                        return ('!LOAD_BUILTIN', type_to_check_str[type(v)])
                    else:
                        return None
                else:
                    return None
            elif op == 'hash':
                return calculed_const(hash(v))
            elif op in d_built and op not in not_d_built and 'Error' not in op and 'Exception' not in op and 'Exit' not in op:
                return calculed_const(d_built[op](v))
        else:
            if op == '!PyObject_Repr':
                return calculed_const(repr(v))
            elif op == '!PyObject_Str':
                return calculed_const(str(v))
            elif op == '!PyNumber_Negative':
                return calculed_const(- v)
            elif op == '!PyNumber_Float':
                return calculed_const(float(v))
            elif op == '!PyNumber_Int':
                return calculed_const(int(v))
            elif op == '!PyNumber_Long':
                return calculed_const(long(v))
            elif op == '!PyNumber_Positive':
                return calculed_const(+ v)
            elif op == '!PyNumber_Absolute':
                return calculed_const(abs(v))
            elif op == '!PyNumber_Invert':
                return calculed_const(~ v)
            elif op == '!PyObject_Str':
                return calculed_const(str(v))
            elif op == '!PyObject_Hash':
                return calculed_const(hash(v))
            elif op in ('!CHR_BUILTIN', ):
                return calculed_const(chr(int(v)))
            elif op == '!1NOT':
                return calculed_const(not v)
            elif op == '!PY_SSIZE_T' and type(v) is int:
                return calculed_const(v)
            elif op in len_family:
                return calculed_const(len(v))
            elif op  == '!PyObject_Type':
                if v is not None:
                    if type(v) in type_to_check_str:
                        return ('!LOAD_BUILTIN', type_to_check_str[type(v)])
            elif op == '!PySequence_List':
                if type(v) is int:
                    return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "'int' object is not iterable")) 
                if type(v) is long:
                    return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "'long' object is not iterable")) 
                if type(v) is float:
                    return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "'float' object is not iterable")) 
                if type(v) is complex:
                    return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "'complex' object is not iterable")) 
                return ('!BUILD_LIST', tuple([calculed_const(x) for x in list(v)]))
            elif op == '!PySequence_Tuple':
                if type(v) is int:
                    return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "'int' object is not iterable")) 
                if type(v) is long:
                    return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "'long' object is not iterable")) 
                if type(v) is float:
                    return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "'float' object is not iterable")) 
                if type(v) is complex:
                    return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "'complex' object is not iterable")) 
                return calculed_const(tuple(v))
            elif op == '!PyInt_Type.tp_str' and type(v) is int:
                return calculed_const(str(v))
    except TypeError as e:
        return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', e.message))
    except:
        pp('LLL111', sys.exc_info(), op, repr(v))
    return None

def calc_pow_1(ret):
    try:
        if type(ret[1][1]) is complex and ret[1][1] == 0j and type(ret[2][1]) is complex and ret[2][1] != 0j:
            return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "0.0 to a negative or complex power"))
        return calculed_const(pow(ret[1][1],ret[2][1]))
    except:
        pp('LLL111---', sys.exc_info(), repr(ret))
    return None

def calculed_const(v):
    if type(v) is list:
        return ('!BUILD_LIST', tuple([calculed_const(x) for x in v]))
    if type(v) is dict:
        return ('!BUILD_MAP', tuple([(calculed_const(x), calculed_const(y)) for x,y in v.iteritems()]))
    if type(v) is tuple:
        v2 = [calculed_const(x) for x in v]
        if all([x[0] == 'CONST' for x in v2]):
            return ('CONST', tuple(v))
        return ('!BUILD_TUPLE', tuple(v2))
    if type(v) in (int, long, str, unicode, complex, bool, float) or v is None:
        return ('CONST', v)
    if v in d_built_inv:
        return ('!LOAD_BUILTIN', d_built_inv[v])        
    return None

if py_version < 30:
    cont_typ_plu = (float, int, long, bool, str)
else:
    cont_typ_plu = (float, int, bool, str)

## def calc_expr_2(op, v1, v2, retu):
    ## r = _calc_expr_2(op, v1, v2, retu)

    ## return r
           
def calc_expr_2(op, v1, v2, retu):
    assert type(op) is str
    if op == '!PyNumber_Remainder' or op == '!PyNumber_InPlaceRemainder':
        try:
            if type(v1) is int and v2 != 0:
                return calculed_const(v1 % v2)
            if type(v1) is long and v2 != 0:
                return calculed_const(v1 % v2)
            if type(v1) is float and v2 != 0:
                return calculed_const(v1 % v2)
            if type(v1) is complex and v2 != 0:
                return calculed_const(v1 % v2)
            if type(v1) is int and v2 == 0:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
            if type(v1) is long and v2 == 0:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
            if type(v1) is float and v2 == 0:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
            if type(v1) is complex and v2 == 0:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
            if type(v1) is str or type(v1) is unicode:
                if len (v1 % v2) <= 255:
                    return calculed_const(v1 % v2)
                return None
            return calculed_const(v1 % v2)  
        except:
            pp('LLL11122212345', sys.exc_info(), op, repr(v1), repr(v2))
            pass  
    if type(v1) in cont_typ_plu and type(v2) in cont_typ_plu:
        if op == '!_PyString_RIndex':
            if v2 in v1:
                return calculed_const(v1.rindex(v2))
            else:
                return ('!?Raise', ('BUILTIN', 'ValueError'), ('CONST', "substring not found"))
        elif op == '!_PyString_Index':
            if v2 in v1:
                return calculed_const(v1.index(v2))
            else:
                return ('!?Raise', ('BUILTIN', 'ValueError'), ('CONST', "substring not found"))
                
        elif op == '!PyNumber_Multiply' or op == '!PyNumber_InPlaceMultiply':
            if type(v1) is str and type(v2) is int and (len(v1) * v2) > 4096:
                return None
            if type(v2) is str and type(v1) is int and (len(v2) * v1) > 4096:
                return None
            ret = calculed_const(v1 * v2)
            if type(ret[0]) is str and len(ret) > 4096:
                return None
            return ret
        elif op == '!PyNumber_Divide' or op == '!PyNumber_InPlaceDivide':
            if v2 != 0:
                return calculed_const(v1 / v2)
            else:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
        elif op == '!PyNumber_FloorDivide' or op == '!PyNumber_InPlaceFloorDivide':
            if v2 != 0:
                return calculed_const(v1 // v2)
            else:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))

        elif op == '!PyNumber_Add':
            return calculed_const(v1 + v2)
        elif op == '!PyNumber_InPlaceAdd':
            return calculed_const(v1 + v2)
        elif op == '!PyNumber_Subtract':
            return calculed_const(v1 - v2)
        elif op == '!PyNumber_InPlaceSubtract':
            return calculed_const(v1 - v2)
        elif op == '!PyNumber_Lshift' and v2 >= 0:
            try:
                return calculed_const(v1 << v2)
            except OverflowError as e:
                return ('!?Raise', ('BUILTIN', 'OverflowError'), ('CONST', e.message))
            except:
                pp('LLL111222', sys.exc_info(), op, repr(v1), repr(v2))
                return None
        elif op == '!PyNumber_Rshift' and v2 >= 0:
            return calculed_const(v1 >> v2)
        elif op == '!PyNumber_InPlaceLshift' and v2 >= 0:
            return calculed_const(v1 << v2)
        elif op == '!PyNumber_InPlaceRshift' and v2 >= 0:
            return calculed_const(v1 >> v2)
        elif op == '!PyNumber_Or':
            return calculed_const(v1 | v2)
        elif op == '!PyNumber_Xor':
            return calculed_const(v1 ^ v2)
        elif op == '!PyNumber_And':
            return calculed_const(v1 & v2)
        elif op == '!PyNumber_InPlaceOr':
            return calculed_const(v1 | v2)
        elif op == '!PyNumber_InPlaceXor':
            return calculed_const(v1 ^ v2)
        elif op == '!PyNumber_InPlaceAnd':
            return calculed_const(v1 & v2)        
        elif op == '!OR_JUMP':
            return calculed_const(v1 or v2)
        elif op == '!AND_JUMP':
            return calculed_const(v1 and v2)
        elif op in ('!CHR_BUILTIN', ):
            return calculed_const(chr(int(v1)))
        elif op == '!_EQ_':
            return calculed_const(v1 == v2)
        elif op == '!_NEQ_':
            return calculed_const(v1 != v2)
        elif op == '!c_Py_GT_Int' or op == 'Py_GT':
            return calculed_const(v1 > v2)
        elif op == '!c_Py_GE_Int' or op == 'Py_GE':
            return calculed_const(v1 >= v2)
        elif op == '!c_Py_LT_Int' or op == 'Py_LT':
            return calculed_const(v1 < v2)
        elif op == '!c_Py_LE_Int' or op == 'Py_LE':
            return calculed_const(v1 <= v2)
        elif op == '!c_Py_EQ_Int' or op == 'Py_EQ' or op == '!c_Py_EQ_String':
            return calculed_const(v1 == v2)
        elif op == '!c_Py_NE_Int' or op == 'Py_NE' or op == '!c_Py_NE_String':
            return calculed_const(v1 != v2)
        else:
            pass #Debug('rre Constant op2 unhandled', ret)

    try:
 
        if op == '!PyNumber_Multiply':
            if type(v1) is str and type(v2) is int and (len(v1) * v2) > 4096:
                return None
            if type(v2) is str and type(v1) is int and (len(v2) * v1) > 4096:
                return None            
            v_2 = calculed_const(v1 * v2)
            try:
                if len(v_2[1]) > 4096:
                    pass
                else:
                    return v_2
            except:
                return v_2               
        elif op == '!PyNumber_Divide':
            if v2 != 0:
                return calculed_const(v1 / v2)
            else:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
        elif op == '!PyNumber_FloorDivide':
            if v2 != 0:
                return calculed_const(v1 // v2)
            else:
                return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"))
        elif op == '!PyNumber_TrueDivide':
            v2_2 = calculed_const(operator.truediv(v1,v2))
            return v2_2
        elif op == '!STR_CONCAT':
            if type(v1) is int and type(v2) is str:
                return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "unsupported operand type(s) for +: 'int' and 'str'"))
            if type(v2) is int and type(v1) is str:
                return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "unsupported operand type(s) for +: 'str' and 'int'"))
            ret = ('!STR_CONCAT', calculed_const(v1 + v2)) + retu[3:]
            if len(ret) == 2:
                return ret[1]
            else:
                return None
        elif op == '!PyNumber_Add':
            return calculed_const(v1 + v2)
        elif op == '!PyNumber_InPlaceAdd':
            return calculed_const(v1 + v2)
        elif op == '!PyNumber_Subtract':
            return calculed_const(v1 - v2)
        elif op == '!PyNumber_Lshift' or op == '!PyNumber_InPlaceLshift':
            if v2 >= 0:
                return calculed_const(v1 << v2)
            return ('!?Raise', ('BUILTIN', 'ValueError'), ('CONST', "negative shift count"))
        elif op == '!PyNumber_Rshift' or op == '!PyNumber_InPlaceRshift':
            if v2 >= 0:
                return calculed_const(v1 >> v2)
            return ('!?Raise', ('BUILTIN', 'ValueError'), ('CONST', "negative shift count"))
        elif op == '!PyNumber_Or':
            return calculed_const(v1 | v2)
        elif op == '!PyNumber_Xor':
            return calculed_const(v1 ^ v2)
        elif op == '!PyNumber_And':
            return calculed_const(v1 & v2)
        elif op == '!OR_JUMP':
            return calculed_const(v1 or v2)
        elif op == '!AND_JUMP':
            return calculed_const(v1 and v2)
        elif op == '!PySequence_Repeat':
            if type(v1) is str and type(v2) is int and (len(v1) * v2) > 4096:
                return None
            if type(v2) is str and type(v1) is int and (len(v2) * v1) > 4096:
                return None
            ret2 = calculed_const(v2 * v1)
            if len(ret2[1]) > 5000:
                return None 
            return ret2
        elif op == '!PyString_Format':
            return calculed_const(v1 % v2)
        elif op in ('!PySequence_Contains(', '!PySequence_Contains', '!PyDict_Contains'):
            if type(v1) is int:
                return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "argument of type 'int' is not iterable")) 
            if type(v1) is long:
                return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "argument of type 'long' is not iterable")) 
            if type(v1) is str and v2 is None:
                return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "'in <string>' requires string as left operand, not NoneType")) 
            return calculed_const(v2 in v1)
        elif op == '!PyObject_GetAttr' and v2 == 'join' and type(v1) is str:
            pass # _PyString_Join    
##            return '!_PyString_Join'
        elif op in ('!BINARY_SUBSCR_Int', '!from_ceval_BINARY_SUBSCR'):
            if (type (v1) is str or type(v1) is unicode) and type(v2) is int and v2 >= len(v1):
                return ('!?Raise', ('BUILTIN', 'IndexError'), ('CONST', 'string index out of range')) 
            return calculed_const(v1[v2])
        ## elif op in ('!ORD_BUILTIN', ):
            ## return ('CONST', ord(v1))
        elif op in ('!CHR_BUILTIN', ):
            return calculed_const(chr(int(v1)))
        elif op == '!_EQ_':
            return calculed_const(v1 == v2)
        elif op == '!_NEQ_':
            return calculed_const(v1 != v2)
        elif op == '!c_Py_GT_Int' or op == 'Py_GT':
            return calculed_const(v1 > v2)
        elif op == '!c_Py_GE_Int' or op == 'Py_GE':
            return calculed_const(v1 >= v2)
        elif op == '!c_Py_LT_Int' or op == 'Py_LT':
            return calculed_const(v1 < v2)
        elif op == '!c_Py_LE_Int' or op == 'Py_LE':
            return calculed_const(v1 <= v2)
        elif op == '!c_Py_EQ_Int' or op == 'Py_EQ':
            return calculed_const(v1 == v2)
        elif op == '!c_Py_NE_Int' or op == 'Py_NE':
            return calculed_const(v1 != v2)
        elif op == 'in':
            return calculed_const(v1 in v2)
        elif op == 'not in':
            return calculed_const(v1 not in v2)
        elif op == '!_PyString_Find':
            return calculed_const(v1.find(v2))
        elif op == '!_PyString_RFind':
            return calculed_const(v1.rfind(v2))
        elif op == '!_PyString_Index':
            return calculed_const(v1.index(v2))
        elif op == '!_PyString_RIndex':
            return calculed_const(v1.rindex(v2))
        elif op == '!_PyString_Count':
            return calculed_const(v1.count(v2))
        elif op == '!_PyString_StartSwith':
            return calculed_const(v1.startswith(v2))
        elif op == '!_PyString_EndSwith':
            return calculed_const(v1.endswith(v2))
        elif op == 'min':
            return calculed_const(min(v1, v2))
        elif op == 'max':
            return calculed_const(max(v1, v2))
        elif op == 'cmp':
            return calculed_const(cmp(v1, v2))
        elif op == 'sum':
            return calculed_const(sum(v1, v2))
        elif op == 'divmod':
            return calculed_const(divmod(v1, v2))
        elif op == 'coerce':
            return calculed_const(coerce(v1, v2))
        elif op == 'filter':
            return calculed_const(filter(v1, v2))       
        elif op == 'reduce':
            return calculed_const(reduce(v1, v2))
        elif op == 'round':
            return calculed_const(round(v1, v2))
        elif op == 'unicode':
            return calculed_const(unicode(v1, v2))
        elif op == 'ord':
            return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', 'ord() takes exactly one argument (2 given)'))
            
        elif op == '!PyObject_HasAttr':
            if hasattr(v1,v2):
                return ('CONST', True)
        elif op == '!$PyDict_SymmetricUpdate':
            if type(v1) is dict and type(v2) is dict:
                ret_d = {}
                ret_d.update(v1)
                ret_d.update(v2)
                return calculed_const(ret_d)
        elif op == '!PyObject_IsSubclass':
            return calculed_const(issubclass(v1, v2))
        else:
            pass #Debug('rre Constant op2 unhandled', ret)
    except TypeError as e:
        return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', e.message))
    except ZeroDivisionError as e:
        return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', e.message))
    except ValueError as e:
        return ('!?Raise', ('BUILTIN', 'ValueError'), ('CONST', e.message))
    except LookupError as e:
        if op == 'unicode':
            return None
    except NameError as e:
        if op == 'unicode':
            return None
    except:
        pp(';LLL555', sys.exc_info(), op, repr(v1), repr(v2))
        pass

    try:
        if op in d_built and op not in not_d_built and 'Error' not in op and 'Exception' not in op and 'Exit' not in op and op != 'type':
            pp('--<<', op, '===', repr(v1), repr(v2),'===', repr(d_built[op](v1, v2)))
            return calculed_const(d_built[op](v1, v2))
    except LookupError as e:
        if op == 'unicode':
            return None
        pp('ZZZLLL111666', sys.exc_info(), op, repr(v1), repr(v2))
    except:
        pp('LLL111666', sys.exc_info(), op, repr(v1), repr(v2))


    return None

def calc_expr_and(op, v1, ret):
    try:
        if v1:
            if len(ret) == 3:
                return ret[2]
            else:
                lret = list(ret)
                del lret[1]
                return tuple(lret)
        else:
            return ('CONST', False)
    except:
        return None
    
def calc_expr_or(op, v1, ret):
    try:
        if not v1:
            if len(ret) == 3:
                return ret[2]
            else:
                lret = list(ret)
                del lret[1]
                return tuple(lret)
        else: 
            return ('CONST', True)
    except:
        return None
    

def function_inlined(nm, tupl):
    expr = subroutine_inlined(nm, tupl, True, True)
    if expr is None:
        return None 
    
    ## srepr = repr(expr)            
    ## if 'STORE' in srepr:
        ## return None
    ## if 'DELETE' in srepr:
        ## return None
    ## if '(IF' in srepr:
        ## return None
    ## if 'PRINT_ITEM' in srepr:
        ## return None
    ## if expr[-1] == ('RETURN_VALUE', ('CONST', None)):
        ## return None
    if expr[-1][0] == 'RETURN_VALUE' and all([x[0] == '.L' for x in expr[:-1] ]):
        return expr[-1][1]
    if len(expr) == 1 and expr[0][0] == 'RETURN_VALUE':
        return expr[0][1]
    pprint(('!! undefined unsuccess inline func', nm, tupl, expr))
    return None

def call_calc_const(func, tupl, ret):
    assert type(func) is str
    co = N2C(func)
    
    if subroutine_can_be_direct(func, len(tupl[1])):
        add_direct_arg(func, tupl)
        inlined = function_inlined(func, tupl)
        if inlined is not None:
            return inlined
        else:
            if co.co_flags & 0x4:
                if co.co_argcount > 1 and tupl[0] not in('BUILD_TUPLE', 'CONST'):
                    return ret
            return ('!CALL_CALC_CONST', func, tupl)
    elif co.co_flags & 0x28 == 0 and co.co_flags == 0x43 and \
         len(co.co_cellvars) == 0 and len(co.co_freevars) == 0 and co.co_argcount == len(tupl[1]):
        return ('!CALL_CALC_CONST_INDIRECT', func, tupl)
    elif co.co_flags & CO_GENERATOR:        
        return ret
    else:
        Debug('Unfortunelly ', ret, hex(co.co_flags))
        return ret
       
def repl_if_expr(ret):
    ret_ = ret
    updated = False
    li = []
    if ret[0] == '!1NOT':
        ret1 = repl_if_expr(ret[1])
        if ret1 is not None:
            ret = Not(ret1)
    if ret[0] == '!COND_EXPR':
        if ret[2] == ('CONST', True):
            ## 1 1 > 1
            ## 1 0 > 1
            ## 0 1 > 1
            ## 0 0 > 0
            ret1 = repl_if_expr(ret[1])
            if ret1 is None:
                ret1 = ret[1]
            ret2 = repl_if_expr(ret[3])
            if ret2 is None:
                ret2 = ret[3]
            ret = ('!OR_JUMP', ret1, ret2)
        elif ret[2] == ('CONST', False) or ret[2] == ('CONST', None):
            ## 1 1 > 0
            ## 1 0 > 0
            ## 0 1 > 1
            ## 0 0 > 0
            ret1 = repl_if_expr(ret[1])
            if ret1 is None:
                ret1 = ret[1]
            ret1 = Not(ret1)
            ret2 = repl_if_expr(ret[3])
            if ret2 is None:
                ret2 = ret[3]
            ret = ('!AND_JUMP', ret1, ret2) 
        elif ret[3] == ('CONST', None) or ret[3] == ('CONST', False):
            ## 1 1 > 1
            ## 1 0 > 0
            ## 0 1 > 0
            ## 0 0 > 0
            ret1 = repl_if_expr(ret[1])
            if ret1 is None:
                ret1 = ret[1]
            ret2 = repl_if_expr(ret[2])
            if ret2 is None:
                ret2 = ret[2]
            ret = ('!AND_JUMP', ret1, ret2) 
        elif ret[3] == ('CONST', True):
            ## 1 1 > 1
            ## 1 0 > 0
            ## 0 1 > 1
            ## 0 0 > 1
            ret1 = repl_if_expr(ret[1])
            if ret1 is None:
                ret1 = ret[1]
            ret1 = Not(ret)
            ret2 = repl_if_expr(ret[2])
            if ret2 is None:
                ret2 = ret[2]
            ret = ('!OR_JUMP', ret1, ret2) 

    if ret[0] == '!COND_EXPR':
        ret1 = None
        ret2 = None
        ret3 = None
        ret1 = repl_if_expr(ret[1])
        ret2 = repl_if_expr(ret[2])
        ret3 = repl_if_expr(ret[3])
        if ret1 is not None or ret2 is not None or ret3 is not None:
            if ret1 is None:
                ret1 = ret[1]
            if ret2 is None:
                ret2 = ret[2]
            if ret3 is None:
                ret3 = ret[3]
            ret = (ret[0], ret1, ret2, ret3)

    if ret[0] == '!BOOLEAN' and ret[1][0] == '!AND_BOOLEAN':
        ret = ('!AND_JUMP',) + tuple(ret[1][1:])
    if ret[0] == '!BOOLEAN' and ret[1][0] == '!OR_BOOLEAN':
        ret = ('!OR_JUMP',) + tuple(ret[1][1:])
    if ret[0] == '!AND_JUMP':
        for v in ret[1:]:
            if v[0] == '!BOOLEAN' and v[1][0] == '!AND_BOOLEAN':
                li.extend(v[1][1:])
                updated = True
            elif v[0] == '!AND_JUMP':
                li.extend(v[1:])
                updated = True
            else:
                li.append(v)
        if updated:
            ret = ('!AND_JUMP',) + tuple(li)
    if ret[0] == '!OR_JUMP':
        for v in ret[1:]:
            if v[0] == '!BOOLEAN' and v[1][0] == '!OR_BOOLEAN':
                li.extend(v[1][1:])
                updated = True
            elif v[0] == '!OR_JUMP':
                li.extend(v[1:])
                updated = True
            else:
                li.append(v)
        if updated:
            ret = ('!OR_JUMP',) + tuple(li)
    if ret[0] in ('!OR_JUMP', '!AND_JUMP'):
        li = []
        for ret1 in ret[1:]:
            ret2 = repl_if_expr(ret1)
            if ret2 is None:
                ret2 = ret1
            li.append(ret2)
        ret = (ret[0],) + tuple(li)
    if ret != ret_:
        return ret
    return None

def get_cond_meth(a):
    if type(a) is tuple and len(a) > 1:
        a0 = a[0]
        if type(a0) is str:
            if a0 == '!1NOT' or a0 == '!BOOLEAN':
                return get_cond_meth(a[1])
        if a0 == '!COND_METH_EXPR':
            return a[1], [x[0] for x in a[3]]
    return None, None


def cond_meth_eq(a,b):
    if type(a) is tuple and type(b) is tuple and len(a) > 0 and len(b) > 0 \
       and a[0] == b[0] == '!COND_METH_EXPR' and \
       a[1] == b[1] and len(a[3]) == len(b[3]) and\
       all([ a[3][i][0] == b[3][i][0] for i in range(len(a[3]))]):
           return True
    return False
 
repl_v = []
refcnt_last_repl = 0
refcnt_prev_repl = 0
_r_repl = ()

## def repl(ret):
    ## r = ret[:]
    ## if len(ret) >= 4:
        ## if ret[0] == '!COND_METH_EXPR' and ret[2][0] == '!COND_METH_EXPR' and ret[1] == ret[2][1]:
            ## pprint(ret)
            ## assert False
    ## ret = _repl(ret)
    ## if len(ret) >= 4:
        ## if ret[0] == '!COND_METH_EXPR' and ret[2][0] == '!COND_METH_EXPR' and ret[1] == ret[2][1]:
            ## pprint(ret)

            ## pprint(r)
            ## assert False
    ## return ret
        
def repl(ret): ## can_be_codefunc
    global repl_v
    global _n2c
    
    if not (type(ret) is tuple):
        return ret
    if len(ret) <= 1:
        return ret
    r0 = ret[0]
    if not (type(r0) is str):
        return ret
    v = repl_v
    if len(v) > 0:
        del v[:]

    if len(ret) == 2:
        if r0.startswith('!'):
            if r0 in ('!LOAD_GLOBAL', '!LOAD_NAME'):
                t0 = TypeExpr(ret)
                if IsInt(t0) and t0[1][1] == t0[1][0]:
                    return ('CONST', t0[1][0])
                if IsBool(t0) and t0[1] is not None:
                    return ('CONST', t0[1])
                if IsChar(t0) and type(t0[1]) is str and len(t0[1]) == 1: 
                    return ('CONST', t0[1])
                if build_executable and type(ret[1]) is str and ret[1].startswith('_'):
                    if ret[1] == '__debug__':
                        return ('CONST', True)            
                    if ret[1] == '__name__':
                        return ('CONST', '__main__')
                    if ret[1] == '__file__':
                        return ('CONST', g_co.co_filename)  
            elif r0 == '!PySequence_Tuple':
                t = TypeExpr(ret[1])
                if IsTuple(t):
                    return ret[1]
                if IsList(t):
                    if ret[1][0] == '!BUILD_LIST':
                        return TupleFromArgs(ret[1][1])                    
                    return ('!PyList_AsTuple', ret[1])
            elif r0 == '!PyObject_Str':
                t = TypeExpr(ret[1])
                if IsInt(t):
                    return ('!PyInt_Type.tp_str', ret[1])   
                if t is not None and t[0] in (T_NEW_CL_INST, T_OLD_CL_INST, T_ANY_CL_INST) and \
                    IsMethod(t[1], '__str__') and '__coerce__' not in _n2c:
                    codemethnm = ValMethod(t[1], '__str__')
                    tupl = ('!BUILD_TUPLE', (ret[1],))
                    return call_calc_const(codemethnm, tupl, ret)
            elif r0 == '!PyObject_Repr':
                if IsInt(TypeExpr(ret[1])):
                    return ('!_PyInt_Format', ret[1], ('CONST', 10), ('CONST', 0))            
            elif r0 == '!BUILD_TUPLE':
                if len(ret[1]) > 1 and ret[1][0][0] == '!COND_METH_EXPR' and \
                   all([x[0] == '!COND_METH_EXPR' for x in ret[1]]) and \
                   all([cond_meth_eq(ret[1][0], x) for x in ret[1][1:]]):
                    methods = []
                    for i in range(len(ret[1][0][3])):
                        tutupl = []
                        for iit in ret[1]:
                            tutupl.append(iit[3][i][1])
                            
                        methods.append((ret[1][0][3][i][0], (r0, tuple(tutupl)))  )
                    tutupl = []
                    for iit in ret[1]:
                        tutupl.append(iit[2])
                    return CondMethExpr(ret[1][0][1], (r0, tuple(tutupl)), tuple(methods))

                li = []
                for x in ret[1]:
                    if x[0] == 'PY_TYPE' and x[1] is str and type(x[2]) is str and x[3][0] == 'FAST':
                        li.append(('CONST', x[2]))
                    elif x[0] == 'PY_TYPE' and x[1] is int and type(x[2]) is tuple and x[2][0] == x[2][1] and x[3][0] == 'FAST':
                        li.append(('CONST', x[2][0]))
                    else:
                        li.append(x)
                li = tuple(li)
                if li != ret[1]:
                    return ('!BUILD_TUPLE', li)
                if all([x[0] == 'CONST' for x in ret[1]]):
                    return ('CONST', tuple([x[1] for x in ret[1]]))
            elif r0 == '!BOOLEAN':
                if das_ist_True(ret[1]):
                    return ('CONST', True)
                elif das_ist_False(ret[1]): 
                    return ('CONST', False)
                ret_n = repl_if_expr(ret[1])
                if ret_n is not None and ret_n != ret[1]:
                    ## assert ret_n != ret[1]
                    return ('!BOOLEAN', ret_n)
                
            elif r0 == '!PyObject_Type':
                t = TypeExpr(ret[1])
                if t is not None:
                    v1 = to_load_builtin(t)
                    if v1 is not None:
                        return v1
            elif r0 == '!PyInt_Type.tp_str' and ret[1][0] == '!PyNumber_Int' and \
                ret[1][1][0] == 'PY_TYPE' and ret[1][1][1] == bool:
                    return ('!COND_EXPR', ret[1][1], ('CONST', '1'), ('CONST', '0'))
            elif r0 == '!1NOT':
                if ret[1][0] == '!COND_METH_EXPR':
                    methods = []
                    for i in range(len(ret[1][3])):
                        methods.append((ret[1][3][i][0], (r0, ret[1][3][i][1])  ))
                    ## re = CondMethExpr(ret[1][1], (r0, ret[1][2]), tuple(methods))
                    ## pprint(re)
                    return CondMethExpr(ret[1][1], (r0, ret[1][2]), tuple(methods))
                ret_n = repl_if_expr(ret[1])
                if ret_n is not None and ret_n != ret[1]:
                    ## assert ret_n != ret[1]
                    return ('!1NOT', ret_n)
            elif r0 == '!PY_SSIZE_T':
                if ret[1][0] == '!?Raise':
                    return ret[1]
        
        elif r0.startswith('.'):
            pass
        elif r0.startswith('('):
            if r0 == '(IF':
                if ret[1][0] == '!COND_METH_EXPR':
                    ret_ = list(ret[1])
                    ret_[3] = tuple([(a, ('!AND_JUMP',) + b[1:] if b[0] == '!AND_JUMPED_STACKED' else b) for a,b in ret_[3]])
                    ret_[3] = tuple([(a, ('!OR_JUMP',) + b[1:] if b[0] == '!OR_JUMPED_STACKED' else b) for a,b in ret_[3]])
                    ret_[3] = tuple([(a, ('!BOOLEAN', b) if b[0] != '!BOOLEAN' else b) for a,b in ret_[3]])
                    if ret_[2][0] != '!BOOLEAN' and ret_[2] != ('CONST', True) and ret_[2] != ('CONST', False):
                        ret_[2] = ('!BOOLEAN', ret_[2])
                    ret_ = tuple(ret_)
                    if ret[1] != ret_:
                        return ('(IF', ret_)
                ret_n = repl_if_expr(ret[1])
                if ret_n is not None and ret_n != ret[1]:
                    ## assert ret_n != ret[1]
                    return ('(IF', ret_n)
                ret_n = if_expr_1(ret)
                if ret_n is not None  and ret_n != ret:
                    ## assert ret_n != ret
                    return ret_n
        else:
            if r0 in ('FAST', 'CALC_CONST'):
                t0 = TypeExpr(ret)
                if IsInt(t0) and t0[1][1] == t0[1][0]:
                    return ('CONST', t0[1][0])
                if IsBool(t0) and t0[1] is not None:
                    return ('CONST', t0[1])
                if IsChar(t0) and type(t0[1]) is str and len(t0[1]) == 1: 
                    return ('CONST', t0[1])
            elif r0 == 'UNPUSH':
                if TCmp(ret, v, ('UNPUSH', ('!PyObject_Call', 
                                    ('?', 'setattr'),
                                    ('!BUILD_TUPLE', ('?', '?', '?')), ('NULL',)))):
                    if v[0] == '!LOAD_BUILTIN':
                        return ('STORE', (('PyObject_SetAttr', v[1], v[2]),), (v[3],))
                    elif v[0] in ('!LOAD_GLOBAL', '!LOAD_NAME', '!PyDict_GetItem(glob,'):
                        return ('STORE', (('?PyObject_SetAttr', v[1], v[2], (v[0], 'setattr')),), (v[3],))
                    else:
                        return ret 
                if TCmp(ret, v, ('UNPUSH', ('!_PyList_Pop', '?'))): 
                    return ('DELETE_SUBSCR', v[0], ('CONST', -1))    
            elif r0 == 'CONST':
                if type(ret[1]) == type:
                    if ret[1] in d_built_inv:
                        return ('!LOAD_BUILTIN', d_built_inv[ret[1]])
                    else:
                        Fatal ('???', ret, type(ret[1]))
                        assert False
                        return ret    
            if len(v) > 0:
                del v[:] 
        if type(ret[1]) is tuple and len(ret[1]) >= 1:
                flag1, v1 = is_calc_arg(ret[1])
                if flag1:
                    ret_ret = calc_expr_1(r0, v1)
                    if ret_ret is not None:
                        return ret_ret

    if len(ret) == 3:
        if r0.startswith('!'):
            if r0 == '!PyObject_GetAttr':
                t = TypeExpr(ret)
                if IsInt(t) and t[1][1] == t[1][0]:
                    return ('CONST', t[1][1])
                if IsStr(t) and type(t[1]) is str:
                    return ('CONST', t[1])        
            elif r0 == '!PySequence_Contains(':
                if TCmp(ret, v, ('!PySequence_Contains(', '?', '?')):
                    ## if IsStr(TypeExpr(v[1])) and IsStr(TypeExpr(v[0])):
                        ## return ('!_PyString_Contains', v[0], v[1])
                    t =  TypeExpr(ret[1])
                    if IsDict(t):
                        return ('!PyDict_Contains', ret[1], ret[2])
                    elif t == Kl_Set:
                        return ('!PySet_Contains', ret[1], ret[2])
                    if v[0][0] == '!BUILD_TUPLE' and type(v[0][1]) is tuple:
                            if len(v[0][1]) == 1:
                                return ('!PyObject_RichCompare(', v[0][1][0],  v[1], 'Py_EQ')
                            return ('!OR_BOOLEAN',) + \
                                tuple([('!PyObject_RichCompare(', x,  v[1], 'Py_EQ') for x in v[0][1]])    
                    if v[0][0] == 'CONST' and type(v[0][1]) is tuple:
                            if len(v[0][1]) == 0:
                                return ('CONST', False)
                            elif len(v[0][1]) == 1:
                                return ('!PyObject_RichCompare(', ('CONST', v[0][1][0]),  v[1], 'Py_EQ')
                            if False:
                                typ = tuple(set([type(x) for x in v[0][1]]))
                                if len(typ) == 1:
                                    if typ[0] is str:
                                        if IsStr(TypeExpr(v[1])):
                                            return ('!OR_BOOLEAN',) + \
                                                tuple([('!PyObject_RichCompare(', ('CONST', x),  v[1], 'Py_EQ') for x in v[0][1]]) 
                    del v[:]
                assert len(ret) == 3
                if ret[1][0] == '!BUILD_LIST' and all([x[0] == 'CONST' for x in ret[1][1]]):
                    return (r0, ('CONST', tuple([x[1] for x in ret[1][1]])), ret[2])
            elif r0 == '!CALL_CALC_CONST':      
                if ret[2][0] == '!COND_METH_EXPR':
                    methods = []
                    ## pprint(ret)
                    for i in range(len(ret[2][3])):
                        methods.append((ret[2][3][i][0], (r0, ret[1], ret[2][3][i][1]))  )
                    ## pprint(CondMethExpr(ret[2][1], (r0, ret[1], ret[2][2]), tuple(methods)) )
                    ## assert False
                    return CondMethExpr(ret[2][1], (r0, ret[1], ret[2][2]), tuple(methods))             

                inlined = function_inlined(ret[1], ret[2])
                if inlined is not None:
                    return inlined
            elif r0 == '!CLASS_CALC_CONST_NEW':
                if ret[2][0] == '!COND_METH_EXPR':
                    methods = []
                    ## pprint(ret)
                    for i in range(len(ret[2][3])):
                        methods.append((ret[2][3][i][0], (r0, ret[1], ret[2][3][i][1]))  )
                    ## pprint(CondMethExpr(ret[2][1], (r0, ret[1], ret[2][2]), tuple(methods)) )
                    ## assert False
                    return CondMethExpr(ret[2][1], (r0, ret[1], ret[2][2]), tuple(methods))             
            elif r0 == '!LIST_COMPR' and len(ret[2]) == 3 and len(ret[2][1]) == 1 and \
                 ret[2][1][0][0] == '!BUILD_LIST' and all([x[0] == 'CONST' for x in ret[2][1][0][1]]):
                return (r0, ret[1], (ret[2][0], (('CONST', tuple([x[1] for x in ret[2][1][0][1]])),), ret[2][2]))
            elif r0 == '!PyNumber_Remainder':
                t = TypeExpr(ret[1])
                if IsStr(t):
                    return ('!PyString_Format', ret[1], ret[2])
            elif r0 == '!BINARY_SUBSCR_Int':
                if ret[1][0] == '!BUILD_LIST':
                    if TCmp(ret, v, ('!BINARY_SUBSCR_Int', ('!BUILD_LIST', '?'), ('CONST', int))):
                        pos = v[1]
                        if pos < 0:
                            pos = pos + len(v[0])
                        if pos < len(v[0]):    
                            return v[0][v[1]]
            elif r0 == '!c_Py_EQ_String':
                if TCmp(ret, v, ('!c_Py_EQ_String', ('CONST', '?'), ('CONST', '?'))):
                    return ('CONST', v[0] == v[1])    
            elif r0 == '!c_Py_NE_String':
                if TCmp(ret, v, ('!c_Py_NE_String', ('CONST', '?'), ('CONST', '?'))):
                    return ('CONST', v[0] != v[1])    
            elif r0 == '!_EQ_':
                if ret[1][0] == '!COND_METH_EXPR' and ret[2][0] == 'CONST':
                    methods = []
                    for i in range(len(ret[1][3])):
                        methods.append((ret[1][3][i][0], (r0, ret[1][3][i][1], ret[2])  ))
                    ## re = CondMethExpr(ret[1][1], (r0, ret[1][2]), tuple(methods))
                    ## pprint(re)
                    return CondMethExpr(ret[1][1], (r0, ret[1][2], ret[2]), tuple(methods))
         
                if len(ret) == 3 and \
                    type(ret[1]) is tuple and len(ret[1]) >= 1 and ret[1][0] == '!LOAD_BUILTIN' and \
                    type(ret[2]) is tuple and len(ret[2]) >= 1 and ret[2][0] == '!LOAD_BUILTIN':
                        return ('CONST', d_built[ret[1][1]] == d_built[ret[2][1]])
          
                elif len(ret) == 3 and \
                    type(ret[1]) is tuple and len(ret[1]) >= 2 and ret[1][0] == '!PyObject_Type' and \
                    len(ret[1][1]) == 5 and type(ret[1][1][0]) is str and ret[1][1][0] == 'PY_TYPE' and \
                    ret[1][1][1] in type_to_check_str and \
                    type(ret[2]) is tuple and len(ret[2]) >= 1 and ret[2][0] == '!LOAD_BUILTIN':
                        return ('CONST', type_to_check_str[ret[1][1][1]] == ret[2][1])
            elif r0 == '!_NEQ_':
                if ret[1][0] == '!COND_METH_EXPR' and ret[2][0] == 'CONST':
                    methods = []
                    for i in range(len(ret[1][3])):
                        methods.append((ret[1][3][i][0], (r0, ret[1][3][i][1], ret[2])  ))
                    ## re = CondMethExpr(ret[1][1], (r0, ret[1][2]), tuple(methods))
                    ## pprint(re)
                    return CondMethExpr(ret[1][1], (r0, ret[1][2], ret[2]), tuple(methods))
                if len(ret) == 3 and \
                    type(ret[1]) is tuple and len(ret[1]) >= 1 and ret[1][0] == '!LOAD_BUILTIN' and \
                    type(ret[2]) is tuple and len(ret[2]) >= 1 and ret[2][0] == '!LOAD_BUILTIN':
                        return ('CONST', ret[1][1] != ret[2][1])
                elif len(ret) == 3 and \
                    type(ret[1]) is tuple and len(ret[1]) >= 2 and ret[1][0] == '!PyObject_Type' and \
                    len(ret[1][1]) == 5 and type(ret[1][1][0]) is str and ret[1][1][0] == 'PY_TYPE' and \
                    ret[1][1][1] in type_to_check_str and \
                    type(ret[2]) is tuple and len(ret[2]) >= 1 and ret[2][0] == '!LOAD_BUILTIN':
                        return ('CONST', type_to_check_str[ret[1][1][1]] != ret[2][1])   

            elif r0.startswith('!c_Py_') and r0.endswith('_Int') and ret[1][0] == '!COND_METH_EXPR' and not IsInt(TypeExpr(ret[1])):
                meth0 = ret[1][3]
                methods = []
                for i in range(len(meth0)):
                    methods.append((meth0[i][0], (r0, meth0[i][1], ret[2])  ))
                ## re = CondMethExpr(ret[1][1], (r0, ret[1][2]), tuple(methods))
                ## pprint(re)
                return CondMethExpr(ret[1][1], (r0, ret[1][2], ret[2]), tuple(methods))
                    
            elif r0 == '!PyNumber_Divide':
                if TCmp(ret, v, ('!PyNumber_Divide', '?', ('CONST', 0))):
                    return ('!?Raise', ('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"), v[0])    
            elif r0 == '!PySequence_Repeat':
                if TCmp(ret, v, ('!PySequence_Repeat', \
                                    ('!BUILD_LIST', (('CONST', '?'),)), \
                                    ('CONST', int))) and v[1] >= 0 and v[1] < 256:
                    return ('!BUILD_LIST', (('CONST', v[0]),) * v[1]) 
            elif r0 == '!PyNumber_InPlaceAdd':
                if TCmp(ret, v, ('!PyNumber_InPlaceAdd', '?', '?')):
                    t1 = TypeExpr(v[0])
                    t2 = TypeExpr(v[1])        
                    if IsStr(t1) and IsStr(t2):
                        if v[0][0] == v[1][0] == 'CONST':
                            return ('CONST', v[0][1] + v[1][1])
                        return ('!STR_CONCAT', v[0], v[1])
                    if len(v) > 0:
                        del v[:]
            elif r0 == '!PyNumber_Add':
                     
                if TCmp(ret, v, ('!PyNumber_Add', ('CONST', str), ('!STR_CONCAT', '*'))):
                    return ('!STR_CONCAT', ('CONST', v[0])) + v[1]
                if TCmp(ret, v, ('!PyNumber_Add', ('CONST', str), '?')):
                    return ('!STR_CONCAT', ('CONST', v[0]), v[1])
                if TCmp(ret, v, ('!PyNumber_Add', ('!STR_CONCAT', '*'), ('CONST', str))):
                    return ('!STR_CONCAT',) + v[0] + (('CONST', v[1]),)
                if TCmp(ret, v, ('!PyNumber_Add', '?', ('CONST', str))):
                    return ('!STR_CONCAT', v[0], ('CONST', v[1]))
                if TCmp(ret, v, ('!PyNumber_Add', ('!STR_CONCAT', '*'), ('!STR_CONCAT', '*'))):
                    return ('!STR_CONCAT',) +  v[0] + v[1]
                if TCmp(ret, v, ('!PyNumber_Add', ('!STR_CONCAT', '*'), '?')):
                    return ('!STR_CONCAT',) +  v[0] + (v[1],)
                if TCmp(ret, v, ('!PyNumber_Add', '?', ('!STR_CONCAT', '*'))):
                    return ('!STR_CONCAT', v[0]) + v[1]
                if IsStr(TypeExpr(ret[1])):
                    return ('!STR_CONCAT',) + ret[1:]
                if IsStr(TypeExpr(ret[2])):
                    return ('!STR_CONCAT',) + ret[1:]
                if ret[1][0] == '!BUILD_TUPLE' and ret[2][0] == '!BUILD_TUPLE':
                    return ('!BUILD_TUPLE', ret[1][1] + ret[2][1])
            elif r0 == '!PyNumber_Multiply':                
                if TCmp(ret, v, ('!PyNumber_Multiply', ('CONST', str), '?')):
                    return ('!PySequence_Repeat', ('CONST', v[0]), v[1])
                if py_version < 30 and TCmp(ret, v, ('!PyNumber_Multiply', ('CONST', unicode), '?')):
                    return ('!PySequence_Repeat', ('CONST', v[0]), v[1])
                if TCmp(ret, v, ('!PyNumber_Multiply', ('CONST', list), '?')):
                    return ('!PySequence_Repeat', ('CONST', v[0]), v[1])
                if TCmp(ret, v, ('!PyNumber_Multiply', ('CONST', tuple), '?')):
                    return ('!PySequence_Repeat', ('CONST', v[0]), v[1])
                if TCmp(ret, v, ('!PyNumber_Multiply', ('!STR_CONCAT', '*'), '?')):
                    return ('!PySequence_Repeat', ('!STR_CONCAT',) + v[0], v[1])
                if TCmp(ret, v, ('!PyNumber_Multiply', ('!UNICODE_CONCAT', '*'), '?')):
                    return ('!PySequence_Repeat', ('!UNICODE_CONCAT',) + v[0], v[1])
                if TCmp(ret, v, ('!PyNumber_Multiply', ('!BUILD_LIST', '*'), '?')):
                    return ('!PySequence_Repeat', ('!BUILD_LIST',) + v[0], v[1])
                if TCmp(ret, v, ('!PyNumber_Multiply', ('!BUILD_LIST', '*'), '?')):
                    return ('!PySequence_Repeat', ('!BUILD_TUPLE',) + v[0], v[1])
                if TCmp(ret, v, ('!PyNumber_Multiply', (('CONST', int), ('!BUILD_LIST', '*')))):
                    return ('!PySequence_Repeat', ('!BUILD_LIST',) + v[1], ('CONST', v[1]))
            elif r0 == '!SSIZE_T!=' and type(ret[1]) is tuple and len(ret[1]) >= 1 and type(ret[2]) is int:
                if  ret[1][0] == 'CONST':
                    op, v1, v2 = '!c_Py_NE_Int', ret[1][1], ret[2]
                    ret_ret = calc_expr_2(op, v1, v2, ret)
                    if ret_ret is not None:
                        return ret_ret                     
            elif r0 == '!SSIZE_T==' and type(ret[1]) is tuple and len(ret[1]) >= 1 and type(ret[2]) is int:
                if  ret[1][0] == 'CONST':
                    op, v1, v2 = '!c_Py_EQ_Int', ret[1][1], ret[2]
                    ret_ret = calc_expr_2(op, v1, v2, ret)
                    if ret_ret is not None:
                        return ret_ret   
            elif r0 == '!PyObject_IsInstance' and ret[1][0] == 'CONST' and ret[2][0] == '!LOAD_BUILTIN' and ret[2][1] in d_built:
                return ('CONST', isinstance(ret[1][1], d_built[ret[2][1]]))
            elif r0 == '!PyObject_IsSubclass' and ret[1][0] == '!LOAD_BUILTIN' and ret[2][0] == '!LOAD_BUILTIN' and \
               ret[2][1] in d_built and ret[1][1] in d_built:
                return ('CONST', issubclass(d_built[ret[1][1]], d_built[ret[2][1]]))
            if type(ret[1]) is tuple and len(ret[1]) >= 1 and type(ret[2]) is tuple and len(ret[2]) >= 1:
                flag1, v1 = is_calc_arg(ret[1])
                flag2, v2 = is_calc_arg(ret[2])
                if not flag1 and flag2 and r0 == '!PyObject_HasAttr' and v2 == 'gettotalrefcount':
                    t1 = TypeExpr(ret[1])
                    if IsModule(t1) and t1[1] == 'sys':
                        return ('CONST', hasattr(sys, v2))
                if flag1 and flag2:
                    ret_ret = calc_expr_2(r0, v1, v2, ret)
                    if ret_ret is not None:
                        return ret_ret 

                                     
                if is_eq_arg(ret[1], ret[2]):
                    if r0 in ('!_PyString_StartSwith', '!_PyString_EndSwith', '!_EQ_'):
                        return ('CONST', True)
                    elif r0 in ('!_NEQ_',):
                        return ('CONST', False)

        elif r0.startswith('('):
            if r0 == '(FOR':
                if ret[2][0] == '!BUILD_LIST' and all([x[0] == 'CONST' for x in ret[2][1]]):
                    return (r0, ret[1], ('CONST', tuple([x[1] for x in ret[2][1]])))
        else:
            if r0 == 'STORE':
                v0 = [] 
                if TCmp(ret, v0, ('STORE', (('STORE_CALC_CONST', ('?', '?')),), ('?',))) and \
                        v0[0] in ('STORE_NAME', 'STORE_GLOBAL') and found_all_calc_const(v0[1]):
                    v = [(v0[1], '', get_all_calc_const(v0[1])), v0[2]]
                    if v[1] == ('!MK_FUNK', v[0][0], ('CONST', ())):
                        val_direct_code[v[0][0]] = v[1]
                        direct_code[v[0][0]] = v[1][1]
                    elif v[0][2][0] == '!MK_FUNK' and v[0][2][2] != v[0][0] and v[0][2][2] == ('CONST', ()):
                        val_direct_code[v[0][0]] = v[0][2]
                        direct_code[v[0][0]] = v[0][2][1]
                    elif v[1][0] == '!MK_FUNK' and v[1][1] == v[0][0] and \
                        v[1][2][0] == 'CONST' and len(v[1][2][1]) > 0:
                        val_direct_code[v[0][0]] = v[1]
                        direct_code[v[0][0]] = v[1][1]
                        default_args[v[0][0]] = v[1][2]
                    elif v[1][0] == '!_PyEval_BuildClass':
                        v1 = v[1]
                        v1_1 = []
                        v1_2 = []
                        if TCmp(v1, v1_1, ('!_PyEval_BuildClass',\
                                            ('!PyObject_Call',\
                                                ('!MK_FUNK', v[0][0], ('CONST', ())),\
                                                ('CONST', ()), ('NULL',)),\
                                            '?', ('CONST', v[0][0]))):
                            if v1_1[0] == ('CONST', ()):     
                                RegisterOldClass(v[0][0], None)
                        elif TCmp(v1, v1_2, ('!_PyEval_BuildClass',\
                                                ('!BUILD_MAP', '?'),\
                                            '?', ('CONST', v[0][0]))):
                            if v1_2[1] == ('CONST', ()):     
                                RegisterOldClass(v[0][0], None)
                        else:
                            pprint(v1)
                            Fatal('calcConst???Class', v1)   
                            assert False
                v0 = []
                if len(ret[1]) == 1 and len(ret[1][0]) == 2 and \
                        ret[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL', 'STORE_DEREF') and \
                        found_all_calc_const(ret[1][0][1]) and TCmp(ret, v0, ('STORE', (('?', '?'),), ('?',))):
                    v = [(v0[1], '', get_all_calc_const(v0[1])), v0[2]]
                    if v[1] == ('!MK_FUNK', v[0][0], ('CONST', ())):
                        val_direct_code[v[0][0]] = v[1]
                        direct_code[v[0][0]] = v[1][1]
                    elif v[0][2][0] == '!MK_FUNK' and v[0][2][2] != v[0][0] and v[0][2][2] == ('CONST', ()):
                        val_direct_code[v[0][0]] = v[0][2]
                        direct_code[v[0][0]] = v[0][2][1]
                    elif v[1][0] == '!MK_FUNK' and v[1][1] == v[0][0] and \
                        v[1][2][0] == 'CONST' and len(v[1][2][1]) > 0:
                        val_direct_code[v[0][0]] = v[1]
                        direct_code[v[0][0]] = v[1][1]
                        default_args[v[0][0]] = v[1][2]
                    elif v[1][0] == '!_PyEval_BuildClass':
                        v1 = v[1]
                        vvv_11 = []
                        if TCmp(v1, vvv_11, ('!_PyEval_BuildClass',\
                                            ('!PyObject_Call',\
                                                ('!MK_FUNK', '?', ('CONST', ())),\
                                                ('CONST', ()), ('NULL',)),\
                                            '?', ('CONST', v[0][0]))):  
                            DoRegClass(v[0][0], v1, vvv_11[1:])              
                        elif TCmp(v1, vvv_11, ('!_PyEval_BuildClass', ('!PyObject_Call', ('!MK_CLOSURE', '?', '?', ('CONST', ())), ('CONST', ()), ('NULL',)), '?', ('CONST', v[0][0]))):  
                            DoRegClass(v[0][0], v1, vvv_11[2:])  
                        else:
                            pprint(v1)
                            pp(v[0][0])
                            Fatal('?k', v1)
                            assert False
            ## if len(v) > 0:
                ## del v[:]                     
    if len(v) > 0:
        del v[:]

    if len(ret) == 4:
        if r0.startswith('!'):
            if r0 == '!PyObject_Call':
                if is_can_be_codefunc:
                    return repl_PyObject_Call(ret)
            elif r0 == '!PyBool_Type.tp_new':
                if ret[1] == '&PyBool_Type' and ret[2][0] == '!BUILD_TUPLE' and len(ret[2][1]) == 1:
                    if ret[2][1][0][0] == '!OR_JUMPED_STACKED':
                        return ('!BOOLEAN', ('!OR_BOOLEAN',) + ret[2][1][0][1:])
                    elif ret[2][1][0][0] == '!AND_JUMPED_STACKED':
                        return ('!BOOLEAN', ('!AND_BOOLEAN',) + ret[2][1][0][1:])
            elif r0 == '!COND_EXPR':
                if type(ret[1]) is tuple and len(ret[1]) == 2 and ret[1][0] == 'CONST':
                    assert len(ret) == 4
                    if ret[1][1]:
                        return ret[2]
                    else:
                        return ret[3]
                t1,t2,t3 = TypeExpr(ret[1]), TypeExpr(ret[2]), TypeExpr(ret[3])
                if IsBool(t1):
                    if IsBool(t2) and IsBool(t3):
                        if das_ist_False(ret[3]): 
                            return ('!BOOLEAN', ('!AND_BOOLEAN', ret[1], ret[2]))
                        if das_ist_True(ret[2]): 
                            return ('!BOOLEAN', ('!OR_BOOLEAN', ret[1], ret[3]))
                if direct_call and is_can_be_codefunc:
                    if ret[2] == ret[3] and\
                        ret[2][0] == '!CALL_CALC_CONST' and \
                        TCmp(ret[1], v, ('!_EQ_', ('!PyObject_Type', ('PY_TYPE', '?', '?', '?', None)), \
                                        ('CALC_CONST', '?'))) and\
                        v[1] == v[3]:
                            return ret[2]
                    elif ret[2] == ret[3] and\
                        ret[2][0] == '!CALL_CALC_CONST' and \
                        TCmp(ret[1], v, ('!BOOLEAN', ('!PyObject_IsInstance', \
                                                        ('PY_TYPE', '?', '?', '?', None), \
                                                        ('CALC_CONST', '?')))) and\
                        v[1] == v[3]:
                            return ret[2]    
                    del v[:]
                if TCmp(ret,v, ('!COND_EXPR', ('CALC_CONST', '?'), '?', '?')):
                    del v[:]
                    t = TypeExpr(ret[1])
                    if t is not None and t[0] is types.ModuleType and t[1] is not None:
                        ret_modl = cond_expr_module(t, ret)
                        if ret_modl is not None:
                            return ret_modl   

            elif r0 == '!_PyEval_ApplySlice':
                if ret[2][0] == 'CONST' and ret[3][0] == 'CONST' and \
                    type(ret[2][1]) is int and type(ret[3][1]) is int:
                            return ('!PySequence_GetSlice', ret[1], ret[2][1], ret[3][1])
               
            elif r0 == '!PySequence_GetSlice':
                if TCmp(ret, v, ('!PySequence_GetSlice', ('CONST', '?'), \
                                    int, 'PY_SSIZE_T_MAX')):
                    return ('CONST', v[0][v[1]:])
                t = TypeExpr(ret[1])
                if IsList(t):
                    ret3 = ret[3]
                    ret2 = ret[2]
                    if (type(ret2) is not int or type(ret3) is not int) and \
                        ret2 != 'PY_SSIZE_T_MAX' and ret3 != 'PY_SSIZE_T_MAX':
                        Fatal('Strange slice arg', ret)
                        assert False
                    return ('!PyList_GetSlice', ret[1], ret2, ret3)
                if IsTuple(t):
                    return ('!PyTuple_GetSlice', ret[1], ret[2], ret[3])
            elif r0 == '!PyObject_RichCompare':
                if TCmp(ret, v, ('!PyObject_RichCompare', '?', '?', c_2_op_op)):
                    n = _process_compare_op(c_2_op_op[v[2]], v[0],v[1])
                    if n is not None:
                        return n     
            elif r0 == '!COND_METH_EXPR':
                t = TypeExpr(ret[1])
                if t is not None:
                    for _arg, _ret in ret[3]: ###isnew, cl, bas, _ret in ret[3]: 
                        if _arg == t:
                            return _ret
                    pp( '()()()', _arg, t, ':::::', ret, '-->>', ret[2])
                    return ret[2]

                if direct_call and is_can_be_codefunc:
                    if len(v) > 0:
                        del v[:]
                    if ret[2][0] == '!CALL_CALC_CONST':
                        return ret[2]
                    if ret[2][0] == '!CALL_CALC_CONST_INDIRECT':
                        return ret[2]
                    _isnew = None
                    if ret[1][0] == 'PY_TYPE':
                        assigned = False
                        if ret[1][1] == 'OldClassInstance':
                            _isnew = False
                            assigned = True
                        elif ret[1][1] == 'NewClassInstance':
                            _isnew = True
                            assigned = True
           
                        if not assigned:
                            return ret[2]
                        for _arg, _ret in ret[3]: ###isnew, cl, bas, _ret in ret[3]: 
                            cl = _arg[1]
                            isnew = _arg[0] == T_NEW_CL_INST
                            if assigned and isnew == _isnew and cl == ret[1][2]:
                                return _ret
                        return ret[2]
            elif r0 == '!PyNumber_Power':
                if ret[3] == 'Py_None':
                    if len(ret) == 4 and  \
                        type(ret[1]) is tuple and len(ret[1]) >= 1 and ret[1][0] == 'CONST' and \
                        type(ret[2]) is tuple and len(ret[2]) >= 1 and ret[2][0] == 'CONST':
                            ret_ret = calc_pow_1(ret)
                            if ret_ret is not None:
                                return ret_ret   
                    if len(ret) == 4 and IsFloat(TypeExpr(ret[1])) and ret[2] == ('CONST', -1):
                        return ('!PyNumber_Divide', ('CONST', 1.0), ret[1])
                    if len(ret) == 4 and IsFloat(TypeExpr(ret[1])) and ret[2] == ('CONST', 1):
                        return ret[1]        
                    if len(ret) == 4 and IsFloat(TypeExpr(ret[1])) and ret[2] == ('CONST', 0):
                        return ('CONST', 1)  
                    if len(ret) == 4 and ret[1][0] == 'FAST' and ret[2] == ('CONST', 2):
                        return ('!PyNumber_Multiply', ret[1], ret[1])    
                else:
                    if IsInt(TypeExpr(ret[1])) and IsInt(TypeExpr(ret[2])) and IsInt(TypeExpr(ret[3])):
                        return ('!PyNumber_Remainder', (r0, ret[1], ret[2], 'Py_None'), ret[3])
            elif r0 == '!PyObject_RichCompare(':
                if ret[1][0] == '!COND_METH_EXPR' :
                    methods = []
                    for i in range(len(ret[1][3])):
                        methods.append((ret[1][3][i][0], (r0, ret[1][3][i][1], ret[2], ret[3])  ))
                    ## re = CondMethExpr(ret[1][1], (r0, ret[1][2]), tuple(methods))
                    ## pprint(re)
                    return CondMethExpr(ret[1][1], (r0, ret[1][2], ret[2], ret[3]), tuple(methods))

                if ret[2][0] == '!COND_METH_EXPR' :
                    methods = []
                    for i in range(len(ret[2][3])):
                        methods.append((ret[2][3][i][0], (r0, ret[1], ret[2][3][i][1], ret[3])  ))
                    ## re = CondMethExpr(ret[1][1], (r0, ret[1][2]), tuple(methods))
                    ## pprint(re)
                    return CondMethExpr(ret[2][1], (r0, ret[1], ret[2][2], ret[3]), tuple(methods))
                
                if TCmp(ret,v, ('!PyObject_RichCompare(', \
                            ('!COND_EXPR', '?', '?', '?'), \
                            ('CONST', '?'), '?')):
                    if v[1] != v[2]:
                        return ('!COND_EXPR', v[0], ('!PyObject_RichCompare(', v[1], ('CONST', v[3]), v[4]),\
                                                    ('!PyObject_RichCompare(', v[2], ('CONST', v[3]), v[4]))
                del v[:]
                if TCmp(ret, v, ('!PyObject_RichCompare(', '?', '?', c_2_op_op)):
                    n = _process_compare_op(c_2_op_op[v[2]], v[0],v[1])
                    if n is not None:
                        return n
            elif r0 == '!_PyEval_BuildClass':
                if len(v) > 0:
                    del v[:]
                if TCmp(ret, v, ('!_PyEval_BuildClass', \
                        ('!PyObject_Call', \
                            ('!MK_CLOSURE', '?', '?', '?'), \
                            '?', '?'), '?', ('CONST', '?'))): 
                    N2C(v[0]).is_class_creator = v[6]
                elif TCmp(ret, v, ('!_PyEval_BuildClass', \
                        ('!PyObject_Call', \
                            ('!MK_FUNK', '?', '?'), '?', '?'), \
                        '?', ('CONST', '?'))): 
                    N2C(v[0]).is_class_creator = v[5]
                        
            elif r0 == '!PyBool_Type.tp_new':
                if ret[2] == ('CONST', (True,)):
                    return ('CONST', True)
                if ret[2] == ('CONST', (False,)):
                    return ('CONST', False)
                if ret[2] == ('CONST', (None,)):
                    return ('CONST', False)
                if ret[2][0] == 'CONST' and len(ret[2][1]) == 1:
                    t = TypeExpr(('CONST', ret[2][1][0]))
                    if IsTuple(t) or IsStr(t):
                        return ('CONST', len(ret[2][1][0]) != 0) 
                    if IsInt(t) or IsFloat(t):
                        return ('CONST', ret[2][1][0] != 0) 
                    if IsComplex(t):
                        return ('CONST', ret[2][1][0] != complex(0,0)) 
                    pp(t, ret)
                    assert False
    if len(ret) == 5:
        if r0 == 'PY_TYPE':
            assert len(v) == 0
            if ret[3][0] == 'PY_TYPE':
                pp(ret)
                assert False
            if ret[3][0] == 'CONST':
                return ret[3]
            if ret[1] == bool and ret[2] is None:
                t = TypeExpr(ret[3])
                if IsBool(t):
                    return ret[3]
            if ret[1] == int and ret[2] is None:
                t = TypeExpr(ret[3])
                if IsInt(t):
                    return ret[3]

            ret30 = ret[3][0]
            assert type(ret30) is str
            if ret30 == 'PY_TYPE' and TCmp(ret, v, ( 'PY_TYPE', '?', '?', ('PY_TYPE', '?', '?', '?', None), None)):
                if v[0] == v[2] and v[1] == v[3]:
                    return ('PY_TYPE', v[0], v[1], v[4], None)
            elif ret30.startswith('!PyNumber_') and IsInt((ret[1], ret[2])):
                if TCmp(ret, v, ('PY_TYPE', '?', '?', ('!PyNumber_Add', '?', '?'), '?')):
                        n1 = v[2]
                        n2 = v[3]
                        t = v[4]
                        if n1[0] not in ('PY_TYPE', 'CONST'):
                            n1 = ('PY_TYPE', int, Kl_Int[1], n1, t)
                        if n2[0] not in ('PY_TYPE', 'CONST'):
                            n2 = ('PY_TYPE', int, Kl_Int[1], n2, t)
                        ret2 = ('PY_TYPE', ret[1], ret[2], ('!PyNumber_Add', n1, n2), t)
                        if ret2 != ret:
                            return ret2
                elif TCmp(ret, v, ('PY_TYPE', '?', '?', ('!PyNumber_Subtract', '?', '?'), '?')):
                        n1 = v[2]
                        n2 = v[3]
                        t = v[4]
                        if n1[0] not in ('PY_TYPE', 'CONST'):
                            n1 = ('PY_TYPE', int, Kl_Int[1], n1, t)
                        if n2[0] not in ('PY_TYPE', 'CONST'):
                            n2 = ('PY_TYPE', int, Kl_Int[1], n2, t)
                        ret2 = ('PY_TYPE', ret[1], ret[2], ('!PyNumber_Subtract', n1, n2), t)
                        if ret2 != ret:
                            return ret2
                elif TCmp(ret, v, ('PY_TYPE', '?', '?', ('!PyNumber_Negative', '?'), '?')):
                        n1 = v[2]
                        t = v[3]
                        if n1[0] not in ('PY_TYPE', 'CONST'):
                            n1 = ('PY_TYPE', int, Kl_Int[1], n1, t)
                        ret2 = ('PY_TYPE', ret[1], ret[2], ('!PyNumber_Negative', n1), t)
                        if ret2 != ret:
                            return ret2
                else:
                    pprint(ret)
                    pp(' *** 39154 ***')
            del v[:]
        
    if r0.startswith('!AND_') or r0.startswith('!OR_'):
        if r0 in ('!AND_JUMP', '!OR_JUMP', '!AND_JUMPED_STACKED', '!OR_JUMPED_STACKED'):
            if cond_meth_eq(ret[1], ret[2]):
                methods = []
                if len(ret) == 3:
                    for i in range(len(ret[1][3])):
                        methods.append((ret[2][3][i][0], (r0, ret[1][3][i][1], ret[2][3][i][1])  ))
                    return CondMethExpr(ret[1][1], (r0, ret[1][2], ret[2][2]), tuple(methods))
                elif len(ret) == 4 and cond_meth_eq(ret[1], ret[3]):
                    for i in range(len(ret[1][3])):
                        methods.append((ret[2][3][i][0], (r0, ret[1][3][i][1], ret[2][3][i][1], ret[3][3][i][1])  ))
                    return CondMethExpr(ret[1][1], (r0, ret[1][2], ret[2][2], ret[3][2]), tuple(methods))
                elif len(ret) == 5 and cond_meth_eq(ret[1], ret[3]) and cond_meth_eq(ret[1], ret[4]):
                    for i in range(len(ret[1][3])):
                        methods.append((ret[2][3][i][0], (r0, ret[1][3][i][1], ret[2][3][i][1], ret[3][3][i][1], ret[4][3][i][1])   ))
                    return CondMethExpr(ret[1][1], (r0, ret[1][2], ret[2][2], ret[3][2], ret[4][2]), tuple(methods))
            elif len(ret) == 4 and cond_meth_eq(ret[2], ret[3]) and ret[1][0] != '!COND_METH_EXPR':
                methods = []
                for i in range(len(ret[2][3])):
                    methods.append((ret[2][3][i][0], (r0, ret[1], ret[2][3][i][1], ret[3][3][i][1])  ))
                return CondMethExpr(ret[2][1], (r0, ret[1], ret[2][2], ret[3][2]), tuple(methods))
            if r0 == '!AND_JUMP':
                li = []
                _updated = False
                for x in ret[1:]:
                    if x[0] == '!BOOLEAN' and x[1][0] == '!AND_BOOLEAN':
                        y = x[1][1:]
                        if all([ _x[0] == '!BOOLEAN' for _x in y]):
                            for _x in y:
                                li.append(_x[1])
                            _updated = True
                            continue
                    li.append(x)
                if _updated:
                    return (r0,) + tuple(li)
            elif r0 == '!AND_JUMPED_STACKED':
                typ = [TypeExpr(tupl_7) for tupl_7 in ret[1:]]
                if all([IsBool(x) for x in typ]):
                    ret1 = ('!AND_BOOLEAN',) + ret[1:]
                    return ('!BOOLEAN', ret1)
                elif len(typ) > 2 and all([IsBool(x) for x in typ[1:]]):
                    ret1 = ('!AND_BOOLEAN',) + ret[2:]
                    return (r0, ret[1], ('!BOOLEAN', ret1))
                elif len(typ) > 2 and all([IsBool(x) for x in typ[:-1]]):
                    ret1 = ('!AND_BOOLEAN',) + ret[1:-1]
                    return (r0, ('!BOOLEAN', ret1), ret[-1])
                elif len(typ) > 2 and all([IsBool(x) for x in typ[-2:]]):
                    ret1 = ('!AND_BOOLEAN',) + ret[-2:]
                    return (r0,) + ret[1:-2] +  (('!BOOLEAN', ret1),)
                else:
                    for tupl in ret[1:]:
                        if not IsBool(TypeExpr(tupl)):
                            Debug('Not Is bool', TypeExpr(tupl), tupl, g_co.c_name)
                if len(v) > 0:
                    del v[:]
                if TCmp(ret, v, ('!AND_JUMPED_STACKED', ('!BOOLEAN', '?' ), '?' )):
                    return ('!COND_EXPR', ('!BOOLEAN', v[0]), v[1], ('CONST', False))
            elif r0 == '!OR_JUMPED_STACKED':
                typ = [TypeExpr(tupl) for tupl in ret[1:]]
                if all([IsBool(x) for x in typ]):
                    ret1 = ('!OR_BOOLEAN',) + ret[1:]
                    return ('!BOOLEAN', ret1)
                elif len(typ) > 2 and all([IsBool(x) for x in typ[1:]]):
                    ret1 = ('!OR_BOOLEAN',) + ret[2:]
                    return (r0, ret[1], ('!BOOLEAN', ret1))
                elif len(typ) > 2 and all([IsBool(x) for x in typ[:-1]]):
                    ret1 = ('!OR_BOOLEAN',) + ret[1:-1]
                    return (r0, ('!BOOLEAN', ret1), ret[-1])
                elif len(typ) > 2 and all([IsBool(x) for x in typ[-2:]]):
                    ret1 = ('!OR_BOOLEAN',) + ret[-2:]
                    return (r0,) + ret[1:-2] +  (('!BOOLEAN', ret1),)
                else:
                    for tupl in ret[1:]:
                        if not IsBool(TypeExpr(tupl)):
                            Debug('Not Is bool', TypeExpr(tupl), tupl, g_co.c_name)
                if len(v) > 0:
                    del v[:]
                if TCmp(ret, v, ('!OR_JUMPED_STACKED', ('!BOOLEAN', '?' ), '?' )):
                    return ('!COND_EXPR', ('!BOOLEAN', v[0]), ('CONST', True), v[1])
        if r0 == '!AND_BOOLEAN' or r0  == '!AND_JUMP':
            if len(ret) >= 3 and \
                type(ret[1]) is tuple and len(ret[1]) >= 1 and ret[1][0] == 'CONST':
                op, v1 = r0, ret[1][1]
                ret_ret = calc_expr_and(op, v1, ret)
                if ret_ret is not None:
                    return ret_ret
        elif r0 == '!OR_BOOLEAN' or r0  == '!OR_JUMP':
            if len(ret) >= 3 and \
                type(ret[1]) is tuple and len(ret[1]) >= 1 and ret[1][0] == 'CONST':
                op, v1 = r0, ret[1][1]
                ret_ret = calc_expr_or(op, v1, ret)
                if ret_ret is not None:
                    return ret_ret

        if r0 in ('!AND_BOOLEAN', '!AND_JUMP', '!OR_BOOLEAN', '!OR_JUMP'):
            if any([x[0] in ('!AND_JUMPED_STACKED', '!OR_JUMPED_STACKED') for x in ret[1:]]):
                ret = (r0,) + tuple([('!AND_JUMP',) + x[1:] if x[0] == '!AND_JUMPED_STACKED' else x for x in ret[1:]])
                ret = (r0,) + tuple([('!OR_JUMP',) + x[1:] if x[0] == '!OR_JUMPED_STACKED' else x for x in ret[1:]])
                return ret

        if r0 in ('!OR_JUMPED_STACKED', '!OR_JUMP', '!OR_BOOLEAN'):
            if ret[-1][0] == 'CONST' and not ret[-1][1]:
                if len(ret) > 3:
                    return ret[:-1]
                else:
                    return ret[1]
            if ret[1][0] == 'CONST':
                if not ret[1][1]:
                    if len(ret) > 3:
                        return ret[:1] + ret[2:]
                    else:
                        return ret[2]
                else:
                    return ('CONST', True)
        elif r0 in ('!AND_JUMPED_STACKED', '!AND_JUMP', '!AND_BOOLEAN'):
            if ret[-1][0] == 'CONST' and ret[-1][1]:
                if len(ret) > 3:
                    return ret[:-1]
                else:
                    return ret[1]
            if ret[1][0] == 'CONST':
                if ret[1][1]:
                    if len(ret) > 3:
                        return ret[:1] + ret[2:]
                    else:
                        return ret[2]
                else:
                    return ('CONST', False)
                    

    if r0 == '!IMPORT_NAME':
        CheckExistListImport(dotted_name_to_first_name(ret[1]))   
    elif r0 == 'IMPORT_FROM_AS':
        CheckExistListImport(ret[1], ret[3][1], ret[2][1])   
                               
    elif r0 == '!CLASS_CALC_CONST':
        if direct_call and is_can_be_codefunc and 2 > 3:
            if TCmp(ret, v, ('!CLASS_CALC_CONST', '?', ('!BUILD_TUPLE', '?'))):
                if IsMethod(v[0], '__init__'):
                    if subroutine_can_be_direct(CodeInit(v[0]),\
                                            len(v[1]) +1):
                        slf = ('PY_TYPE', T_OLD_CL_INST, v[0], ('PSEVDO', 'self'), None)
                        add_direct_arg(CodeInit(v[0]), ('!BUILD_TUPLE', (slf,) +v[1]))
                        return ('!CLASS_CALC_CONST_DIRECT', v[0], \
                            CodeInit(v[0]), ('!BUILD_TUPLE', v[1]))
            elif TCmp(ret, v, ('!CLASS_CALC_CONST', '?', ('CONST', '?'))):
                if IsMethod(v[0], '__init__'):
                    if subroutine_can_be_direct(CodeInit(v[0]), len(v[1])+1):
                        slf = ('PY_TYPE', T_OLD_CL_INST, v[0], ('PSEVDO', 'self'), None)
                        add_direct_arg(CodeInit(v[0]), ('!BUILD_TUPLE', (slf,) + tuple([('CONST', x) for x in v[1]])))
                        return ('!CLASS_CALC_CONST_DIRECT', v[0], \
                            CodeInit(v[0]), ('CONST', v[1]))
    
                        
    elif r0 == '!STR_CONCAT':
        li = list(ret[1:])
        upd = False
        for i, v2 in enumerate(li):
            if v2[0] == '!STR_CONCAT':
                li[i:i+1] = list(v2[1:])
                upd = True
        i = 0
        while i+1 < len(li):
            assert type(i) is int and i >= 0 and i <= (MInt / 10 )
            if li[i][0] == 'CONST' and li[i+1][0] == 'CONST' and type(li[i][1]) is str and type(li[i+1][1]) is str:
                li[i] = ('CONST', li[i][1] + li[i+1][1])
                del li[i+1]
                upd = True
                continue
            i += 1
        if len(li) == 1 and li[0][0] == 'CONST':
            return li[0]    
        if upd:
            return ('!STR_CONCAT',) + tuple(li)    
        if ret[1][0] == '!STR_CONCAT':
            return ('!STR_CONCAT',) + ret[1][1:] + ret[2:]
        if len(ret) >= 3 and ret[1][0] == 'CONST' and type(ret[1][1]) is str and ret[2][0] == '!STR_CONCAT':
            return ('!STR_CONCAT', ret[1]) + ret[2][1:] + ret[3:]
        


    return ret

def to_load_builtin(t):
    if IsFloat(t):
        return ('!LOAD_BUILTIN', 'float')
    if IsInt(t):
        return ('!LOAD_BUILTIN', 'int')
    if IsStr(t):
        return ('!LOAD_BUILTIN', 'str')
    if IsLong(t):
        return ('!LOAD_BUILTIN', 'long')
    if IsBool(t):
        return ('!LOAD_BUILTIN', 'bool')
    if IsComplex(t):
        return ('!LOAD_BUILTIN', 'complex')
    if IsList(t):
        return ('!LOAD_BUILTIN', 'list')
    if IsTuple(t):
        return ('!LOAD_BUILTIN', 'tuple')
    if IsDict(t):
        return ('!LOAD_BUILTIN', 'dict')
    if IsSet(t):
        return ('!LOAD_BUILTIN', 'set')
    return None
    

constanted_modules = {'math' : math, 'cmath' : cmath, 'operator' : operator, 'types':types}

## def is_calc_arg(a):
    ## r = _is_calc_arg(a)

    ## return r

def is_calc_arg(a):
    if type(a) is tuple and len(a) > 0:
        a0 = a[0]
        if len(a) >= 2:
            if type(a0) is str:
                if a0 == '!LOAD_BUILTIN':
                    if a[1] in d_built:
                        return True, d_built[a[1]]
                    return False, None
                if a0 == '!BUILD_TUPLE':
                    li = []
                    alist = a[1]
                    assert type(alist) is tuple
                    for x in alist:
                        lo, va = is_calc_arg(x)
                        if not lo:
                            return False, None
                        li.append(va)
                    return True, tuple(li)
                if a0 == '!BUILD_LIST':
                    li = []
                    alist = a[1]
                    assert type(alist) is tuple
                    for x in alist:
                        lo, va = is_calc_arg(x)
                        if not lo:
                            return False, None
                        li.append(va)
                    return True, tuple(li)
                if a0 == '!BUILD_MAP':
                    li = []
                    alist = a[1]
                    assert type(alist) is tuple
                    for x, y in alist:
                        lo, va = is_calc_arg(x)
                        if not lo:
                            return False, None
                        lo, va2 = is_calc_arg(y)
                        if not lo:
                            return False, None
                        li.append((va, va2))
                    return True, tuple(li)
                if a0 == 'CONST' or a0 == 'LOAD_CONST':
                    return True, a[1]
                a1, a2 = None, None
                if a0 == 'PY_TYPE':
                    a1 = a[1]
                    a2 = a[2]
                elif a0 in('FAST', 'CALC_CONST', '!PY_SSIZE_T', '!BINARY_SUBSCR_Int'):
                    t = TypeExpr(a)
                    if t is not None:
                        a1, a2 = t
                if a1 is not None:
                    if a1 is str:
                        if type(a2) is str:
                            return True, a2
                        return False, None
                    if a1 is bool:
                        if type(a2) is bool:
                            return True, a2
                        return False, None            
                    if a1 is float:
                        if type(a2) is float:
                            return True, a2            
                        return False, None
                    if a1 is complex:
                        if type(a2) is complex:
                            return True, a2            
                        return False, None
                    if a1 is int:
                        if type(a2) is tuple and a2[0] == a2[1]:
                            return True, a2[1]
                        return False, None
                    if a1 is type(None):
                        return True, None
                    if IsModule((a1, a2)):
                        if a2 in constanted_modules:
                            return True, constanted_modules[a2]
                        return False, None
                    ## if a2 is not None:


    return False, None

def _is_calc_arg(a):
    if type(a) is tuple and len(a) > 0:
        a0 = a[0]
        if len(a) >= 2:
            if type(a0) is str:
                if a0 == 'CONST' or a0 == 'LOAD_CONST':
                    return True, a[1]
                if a0 == 'PY_TYPE':
                    a1 = a[1]
                    a2 = a[2]
                    if a1 is str and type(a2) is str:
                        return True, a2
                    if a1 is bool and type(a2) is bool:
                        return True, a2            
                    if a1 is float and type(a2) is float:
                        return True, a2            
                    if a1 is complex and type(a2) is complex:
                        return True, a2            
                    if a1 is int and type(a2) is tuple and a2[0] == a2[1]:
                        return True, a2[1]
                    if IsModule(a[1:3]) and a2 in constanted_modules:
                        return True, constanted_modules[a2]
                if a0 == '!LOAD_BUILTIN' and a[1] in d_built:
                    return True, d_built[a[1]]
                if a0 == '!BUILD_TUPLE':
                    _args = [is_calc_arg(x) for x in a[1]]
                    if all([x[0] for x in _args]):
                        return True, tuple([x[1] for x in _args])
                if a0 == '!BUILD_LIST':
                    _args = [is_calc_arg(x) for x in a[1]]
                    if all([x[0] for x in _args]):
                        return True, [x[1] for x in _args]
                if a0 == '!BUILD_MAP':
                    _args = [(is_calc_arg(x), is_calc_arg(y)) for x,y in a[1]]
                    if all([x[0] and y[0] for x, y in _args]):
                        d = {}
                        for x, y in _args:
                            d[x[1]] = y[1]
                        return True, d
        t = TypeExpr(a)
        if type(t) is tuple and len(t) == 2:
            t1 = t[1]
            if a0 != '!PyObject_Call':
                if IsModule(t) and t1 in constanted_modules:
                    return True, constanted_modules[t1]
            if IsBool(t) and (t1 is False or t1 is True):
                return True, t1
            if IsInt(t) and (t1[0] == t1[1]):
                return True, t1[0]
            if IsChar(t) and type(t1) is str:
                return True, t1
            if IsStr(t) and type(t1) is str:
                return True, t1
    return False, None
 
def is_eq_arg(v1,v2):
    if v1 != v2:
        return False
    if v1[0] == 'PY_TYPE':
        v1 = v1[3]
    if v1[0] in ('FAST', '!LOAD_NAME', '!LOAD_GLOBAL', 'CONST'):
        return True
    return False

def DoRegClass(v0, v1, v1_1):
    if v1_1[0] == ('CONST', ()):                    
        RegisterOldClass(v0, None)
        exit
    elif v1_1[0][0] ==  '!BUILD_TUPLE':
        old = False
        new = False
        li  = {}
        l_1 = len(v1_1[0][1])
        for der in v1_1[0][1]:
            if der[0] == '!LOAD_BUILTIN':
                new = True
                li[der] = True
            elif der[0] in ('!LOAD_NAME', '!LOAD_GLOBAL'):    
                if IsOldClass(der[1]):
                    old = True
                    li[('!CALC_CONST', der[1])] = True
                if IsNewClass(der[1]):
                    new = True
                    li[('!CALC_CONST', der[1])] = True
                if not IsNewClass(der[1]) and not IsOldClass(der[1]):
                    old, new = True, True
                    Debug('Not name CalcConst???Class', v1)
            elif der[0] == '!PyObject_GetAttr':        
                old, new = True, True
            elif der[0] == '!PyObject_Type':        
                Debug('Not name CalcConst???Class', v1)
                old, new = True, True
            elif der[0] == '!PyObject_Call':        
                Debug('Not name CalcConst???Class', v1)
                old, new = True, True
            else:
                Debug('Not name CalcConst???Class', v1, der)
                old, new = True, True
        RegClass(v0, old, new, li.keys(), l_1, l_1 == len(li.keys()))
    else:    
        pp(v1_1[0], v1_1[0][0], v1_1)
        Fatal('?k', v1)
        assert False    
        
def repl_PyObject_Call(ret):
    v = []
    if TCmp(ret[1:-1], v, (('CALC_CONST', '?'), ('CONST', '?'))) :
        t = None
        if type(v[0]) is tuple and len(v[0]) == 2 and v[0][0] in ImportedM:
            t = (ImportedM[v[0][0]], v[0][1])
        elif v[0] in ImportedM:
            t = ImportedM[v[0]]
        if type(t) is tuple and len(t) == 2 and t[0] in constanted_modules:
            ret2 = attempt_calc_constant_math(t[1], ret, v[1], constanted_modules[t[0]]) #sqrt
            if ret2 is not None:
                return ret2
    elif direct_call:
        if TCmp(ret, v, ('!PyObject_Call', ('!MK_FUNK', '?', ('CONST', ())), \
            ('!BUILD_TUPLE', '?'), ('NULL',))):
            return call_calc_const(v[0], ('!BUILD_TUPLE', v[1]), ret)   
        t_ = None
        if ret[1][0] == '!PyObject_GetAttr':
            t_0 = TypeExpr(ret[1])
            if IsFunction(t_0) and t_0[1] is not None and ret[3] == ('NULL',):
                lis = [(cl, slot, nmcode, isstaticmeth, isclassmeth, isderived) for cl, slot, nmcode, isstaticmeth, isclassmeth, isderived in all_meth if nmcode == t_0[1]]
                if len(lis) == 1:
                    cl, slot, nmcode, isstaticmeth, isclassmeth, isderived = lis[0]
                    if IsOldClass(cl):
                        t_ = (T_OLD_CL_INST, cl)
                    if IsNewClass(cl):
                        t_ = (T_NEW_CL_INST, cl)                
            _v = []
            if ret[2][0] == '!BUILD_TUPLE' and TCmp(ret, v, \
                ('!PyObject_Call',  
                    ('!PyObject_GetAttr', '?', ('CONST', '?')), ('!BUILD_TUPLE', '?'), ('NULL',))):
                t = TypeExpr(v[0])
                if t is None:
                    t = t_
                if t is not None and type(t[1]) is str and IsMethod(t[1], v[1])  and '__coerce__' not in _n2c:
                    staticmeth, classmeth, codemethnm = ValMethod3(t[1], v[1])
                    isoldclass = IsOldClass(t[1])
                    isnewclass = IsNewClass(t[1])
                    if IsOldInst(t) and isoldclass and not isnewclass:
                        if classmeth:
                            Debug('No direct call of class method', ret)
                        elif staticmeth:
                            tupl = ('!BUILD_TUPLE', v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                        else:                        
                            tupl = ('!BUILD_TUPLE', (v[0],) + v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                    elif IsOldType(t) and isoldclass and not isnewclass:
                        if classmeth:
                            tupl = ('!BUILD_TUPLE', (v[0],) + v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                        elif staticmeth:
                            tupl = ('!BUILD_TUPLE', v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                        else:                        
                            tupl = ('!BUILD_TUPLE', v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                
                    elif IsNewInst(t) and isnewclass and not isoldclass:
                        if classmeth:
                            Debug('No direct call of class method', ret)
                        elif staticmeth:
                            tupl = ('!BUILD_TUPLE', v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                        else:                        
                            tupl = ('!BUILD_TUPLE', (v[0],) + v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                    elif IsNewType(t) and isnewclass and not isoldclass:
                        if classmeth:
                            tupl = ('!BUILD_TUPLE', (v[0],) + v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                        elif staticmeth:
                            tupl = ('!BUILD_TUPLE', v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                        else:                        
                            tupl = ('!BUILD_TUPLE', v[2])
                            return call_calc_const(codemethnm, tupl, ret)
        
            elif ret[2][0] == 'CONST' and TCmp(ret, v, \
                ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', '?')), ('CONST', '?'), ('NULL',))):
                t = TypeExpr(v[0])
                if t is None:
                    t = t_
                if t is not None and type(t[1]) is str and IsMethod(t[1], v[1])  and '__coerce__' not in _n2c:
                    staticmeth, classmeth, codemethnm = ValMethod3(t[1], v[1])
                    isoldclass = IsOldClass(t[1])
                    isnewclass = IsNewClass(t[1])
                    if IsOldInst(t) and isoldclass and not isnewclass:
                        if classmeth:
                            Debug('No direct call of class method', ret)
                        elif staticmeth:
                            tupl = ('CONST', v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                        else:    
                            v2 = tuple([('CONST', x) for x in v[2]])
                            tupl = ('!BUILD_TUPLE', (v[0],) + v2)
                            return call_calc_const(codemethnm, tupl, ret)
            
                    elif IsOldType(t) and isoldclass and not isnewclass:
                        if classmeth:
                            Debug('No direct call of class method', ret)
                        elif staticmeth:
                            tupl = ('CONST', v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                        else:    
                            v2 = tuple([('CONST', x) for x in v[2]])
                            tupl = ('CONST', v2)
                            return call_calc_const(codemethnm, tupl, ret)
                            
                    elif IsNewInst(t) and isnewclass and not isoldclass:
                        if classmeth:
                            Debug('No direct call of class method', ret)
                        elif staticmeth:
                            tupl = ('CONST', v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                        else:    
                            v2 = tuple([('CONST', x) for x in v[2]])
                            tupl = ('!BUILD_TUPLE', (v[0],) + v2)
                            return call_calc_const(codemethnm, tupl, ret)
            
                    elif IsNewType(t) and isnewclass and not isoldclass:
                        if classmeth:
                            tupl = ('!BUILD_TUPLE', (v[0],) + v[2])
                            return call_calc_const(codemethnm, tupl, ret) 
                        elif staticmeth:
                            tupl = ('CONST', v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                        else:    
                            v2 = tuple([('CONST', x) for x in v[2]])
                            tupl = ('CONST', v2)
                            return call_calc_const(codemethnm, tupl, ret)
                
            elif IsTuple(TypeExpr(ret[2])) and TCmp(ret, v, \
                ('!PyObject_Call',  
                    ('!PyObject_GetAttr', '?', ('CONST', '?')), '?', ('NULL',))):
                t = TypeExpr(v[0])
                if t is None:
                    t = t_
                if t is not None and type(t[1]) is str and IsMethod(t[1], v[1])  and '__coerce__' not in _n2c:
                    staticmeth, classmeth, codemethnm = ValMethod3(t[1], v[1])
                    isoldclass = IsOldClass(t[1])
                    isnewclass = IsNewClass(t[1])

                    if IsOldInst(t) and isoldclass and not isnewclass:
                        if classmeth:
                            Debug('No direct call of class method', ret)
                        elif staticmeth:
                            tupl = v[2]
                            return call_calc_const(codemethnm, tupl, ret)
                        else:                        
                            tupl = ('!PyNumber_Add', ('!BUILD_TUPLE', (v[0],)), v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                    elif IsOldType(t) and isoldclass and not isnewclass:
                        if classmeth:
                            tupl = ('!PyNumber_Add', ('!BUILD_TUPLE', (v[0],)), v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                        elif staticmeth:
                            tupl = v[2]
                            return call_calc_const(codemethnm, tupl, ret)
                        else:                        
                            tupl = v[2]
                            return call_calc_const(codemethnm, tupl, ret)
                
                    elif IsNewInst(t) and isnewclass and not isoldclass:
                        if classmeth:
                            Debug('No direct call of class method', ret)
                        elif staticmeth:
                            tupl = v[2]
                            return call_calc_const(codemethnm, tupl, ret)
                        else:                        
                            tupl = ('!PyNumber_Add', ('!BUILD_TUPLE', (v[0],)), v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                    elif IsNewType(t) and isnewclass and not isoldclass:
                        if classmeth:
                            tupl = ('!PyNumber_Add', ('!BUILD_TUPLE', (v[0],)), v[2])
                            return call_calc_const(codemethnm, tupl, ret)
                        elif staticmeth:
                            tupl = v[2]
                            return call_calc_const(codemethnm, tupl, ret)
                        else:                        
                            tupl = v[2]
                            return call_calc_const(codemethnm, tupl, ret)
        
                        

    v = []
    if TCmp(ret, v, ('!PyObject_Call', ('!PyObject_GetAttr', ('CONST', '?'), ('CONST', 'join')), \
                        ('!BUILD_TUPLE',  ('?',)), ('NULL',))) and type(v[0]) is str and IsListStr(v[1]):
        return ('!_PyString_Join', ('CONST', v[0]), v[1])
    if ret[1][0] == '!LOAD_BUILTIN' and ret[3] != ('NULL',): 
        flag1, v1 = is_calc_arg(ret[1])
        flag2, v2 = is_calc_arg(ret[2])
        flag3, v3 = is_calc_arg(ret[3])
        if flag1 and flag2 and flag3 and ret[1][1] in ('str', 'int', 'long', 'dict', 'float', 'complex', 'round', 'unicode'):
            ret2 = call_str_builtin(v1, v2, v3)
            if ret2 is not None:
                return ret2
    if ret[1][0] == '!LOAD_BUILTIN' and ret[3] == ('NULL',): 
        flag1, v1 = is_calc_arg(ret[1])
        flag2, v2 = is_calc_arg(ret[2])
        if flag1 and flag2 and ret[1][1] in ('str', 'int', 'long', 'dict', 'float', 'complex', 'round', 'unicode'):
            ret2 = call_str_builtin(v1, v2)
            if ret2 is not None:
                return ret2
    if ret[1][0] == '!LOAD_BUILTIN' and ret[3] == ('NULL',): #:== TCmp(ret, _v, ('!PyObject_Call', ('!LOAD_BUILTIN', '?'), '?', ('NULL',))):
        tag,args = ret[1][1], ret[2]
        v = [] 
        if args[0] == '!BUILD_TUPLE':   
            if tag == 'apply' and TCmp(args, v, ('!BUILD_TUPLE', ('?', '?'))):
                return ('!PyObject_Call', v[0] , v[1], ('NULL',))
            elif tag == 'apply' and TCmp(args, v, ('!BUILD_TUPLE', ('?', '?', '?'))):
                return ('!PyObject_Call', v[0] , v[1], v[2])
            elif tag == 'getattr' and TCmp(args, v, ('!BUILD_TUPLE', ('?', '?'))):
                return ('!PyObject_GetAttr', v[0], v[1])
            elif tag == 'getattr' and TCmp(args, v, ('!BUILD_TUPLE', ('?', '?', '?'))):
                return ('!PyObject_GetAttr3', v[0], v[1], v[2])
            elif tag == 'slice' and TCmp(args, v, ('!BUILD_TUPLE', '?')):
                if len(v[0]) == 3:                  
                    return ('!PySlice_New', v[0][0], v[0][1], v[0][2])
                elif len(v[0]) == 2:                  
                    return ('!PySlice_New', v[0][0], v[0][1], 'NULL')
                elif len(v[0]) == 1:                  
                    return ('!PySlice_New', 'NULL', v[0][0], 'NULL')
                else:
                    Fatal('Strange arg Slice', ret)
                    assert False
            elif tag == 'callable':
                if len(args[1]) == 1 and args[1][0][0] == '!LOAD_BUILTIN' and \
                   args[1][0][1] in d_built: 
                    return ('CONST', callable(d_built[args[1][0][1]]))
            if len(args[1]) == 2:
                flag1, v1 = is_calc_arg(args[1][0])
                flag2, v2 = is_calc_arg(args[1][1])
                if flag1 and flag2:
                    ret_ret = calc_expr_2(tag, v1, v2, ret)
                    if ret_ret is not None:
                        return ret_ret                 
            if len(args[1]) == 1:
                flag1, v1 = is_calc_arg(args[1][0])
                if flag1:
                    ret_ret = calc_expr_1(tag, v1)
                    if ret_ret is not None:
                        return ret_ret 
                    
        if args[0] == 'CONST':   
            if tag == 'dict' and args == ('CONST', ()):
                return ('!PyDict_New', )
            elif tag == 'slice' and TCmp(args, v, ('CONST', '?')):
                if len(v[0]) == 3:                  
                    return ('!PySlice_New', ('CONST', v[0][0]), ('CONST', v[0][1]), ('CONST', v[0][2]))
                elif len(v[0]) == 2:                  
                    return ('!PySlice_New', ('CONST', v[0][0]), ('CONST', v[0][1]), 'NULL')
                elif len(v[0]) == 1:                  
                    return ('!PySlice_New', 'NULL', ('CONST', v[0][0]), 'NULL')
                else:
                    Fatal('Strange arg Slice', ret)
                    assert False
            elif tag == 'tuple' and TCmp(args, v, ('CONST', '?')):
                ret_tupl = to_tuple_const(v)
                if ret_tupl is not None:
                    return ret_tupl
            elif tag == 'list' and args == ('CONST', ()):  
                return ('!BUILD_LIST', ())   
            if len(args[1]) == 1:
                ret_ret = calc_expr_1(tag, args[1][0])
                if ret_ret is not None:
                    return ret_ret
            elif len(args[1]) == 2:
                ret_ret = calc_expr_2(tag, args[1][0], args[1][1], ret)
                if ret_ret is not None:
                    return ret_ret  
            elif tag in ('min', 'max') and len(args[1]) > 2:
                ret_ret = calc_expr_1(tag, args[1])
                if ret_ret is not None:
                    return ret_ret
            elif tag == 'bool'  and type(args[1]) is tuple and len(args[1]) == 0:
                return ('CONST', False)
            elif tag == 'chr'  and type(args[1]) is tuple and len(args[1]) == 0:
                return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', "chr() takes exactly 1 argument (0 given)"))

    _v = []
    v = []
    if ret[1][0] == '!PyObject_GetAttr' and ret[1][2][0] == 'CONST':
        if TCmp(ret, _v, ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', '?')), '?', '?')):
            obj, meth, args, kargs = _v
            t = TypeExpr(obj)
            if meth == 'strip' and obj[0] == 'CONST' and type(obj[1]) is str and args == ('CONST', ()) and kargs == ('NULL',):
                return ('CONST', obj[1].strip())
            flag1, v1 = is_calc_arg(obj)
            flag2 = True
            v2 = None
            if kargs != ('NULL',):
                flag2, v2 = is_calc_arg(kargs)
            if flag1 and hasattr(v1, meth) and flag2:
                _args = None
                if args[0] == 'CONST':
                    _args = args[1]
                elif args[0] == '!BUILD_TUPLE':
                    _args = [is_calc_arg(x) for x in args[1]]
                    if all([x for x,y in _args]):
                        _args = tuple([y for x,y in _args])
                    else:
                        _args = None
                if _args is not None:
                    if meth in ('__eq__', '__floordiv__', '__ne__', 'fromhex', '__lt__', '__gt__', '__truediv__'):
                        ret2 = call_str_method(v1, meth, _args, v2)
                        if ret2 is not None:
                            return ret2
                    if type(v1) is type(math) :
                        ret2 = call_str_method(v1, meth, _args, v2)
                        if ret2 is not None:
                            return ret2
                    if meth in ('is_inf', 'is_nan', 'isinf', 'isnan', 'sqrt', 'sin', 'cos', 'split', 'capitalize', 'replace', 'capitalize', \
                                'expandtabs', 'lower', 'upper', 'lstrip', 'rstrip', 'splitlines', 'exp', 'trunc', 'tan', 'tanh', 'sinh', 'cosh',\
                                'split', 'strip', 'swapcase', 'translate', 'count', 'join', 'ldexp', 'copysign', 'pow', 'log', 'log10', 'atan',\
                                'modf', 'hypot', 'log1p', 'radians', 'fmod', 'frexp', 'atan2', 'floor', 'ceil', 'fabs', 'acos', 'asin', \
                                'acosh', 'asinh', 'atanh'):
                        ret2 = call_str_method(v1, meth, _args, v2)
                        if ret2 is not None:
                            return ret2
            if IsListAll(t):
                if meth == 'pop':
                    if TCmp(args, v, ('CONST', ('?',))):
                        return ('!_PyList_Pop', obj, ('CONST', v[0]))
                    elif TCmp(args, v, ('CONST', ())):
                        return ('!_PyList_Pop', obj)
                    elif TCmp(args, v, ('!BUILD_TUPLE', ('?',))):
                        return ('!_PyList_Pop', obj, v[0])
                elif meth == 'len' and args == ('CONST', ()) :
                    return ('!PY_SSIZE_T', ('!PyList_GET_SIZE', obj))
                elif meth == 'extend':
                    v2 = []
                    if TCmp(args, v2, ('!BUILD_TUPLE', ('?',))):
                        return ('!_PyList_Extend', obj, v2[0])
            elif IsStr(t):
                if meth == 'startswith' and TCmp(args, v, ('CONST', ('?',))) and\
                    type(v[0]) is str:
                    return ('!_PyString_StartSwith', obj, ('CONST', v[0]))
                if meth == 'endswith' and TCmp(args, v, ('CONST', ('?',))) and\
                    type(v[0]) is str:
                    return ('!_PyString_EndSwith', obj, ('CONST', v[0]))
                if meth == 'startswith' and TCmp(args, v, ('!BUILD_TUPLE', ('?',))) and\
                    IsStr(TypeExpr(v[0])):
                    return ('!_PyString_StartSwith', obj, v[0])
                if meth == 'endswith' and TCmp(args, v, ('!BUILD_TUPLE', ('?',))) and\
                    IsStr(TypeExpr(v[0])):
                    return ('!_PyString_EndSwith', obj, v[0])
                if meth == 'find':
                    if TCmp(args, v, ('CONST', ('?',))) and type(v[0]) is str:
                        return ('!_PyString_Find', obj, ('CONST', v[0]))
                    if TCmp(args, v, ('!BUILD_TUPLE', ('?',))) and IsStr(TypeExpr(v[0])):
                        return ('!_PyString_Find', obj,  v[0])
                    if TCmp(args, v, ('CONST', ('?', '?'))) and type(v[0]) is str and type(v[1]) is int:
                        return ('!_PyString_Find', obj, ('CONST', v[0]), ('CONST', v[1]))
                    if TCmp(args, v, ('!BUILD_TUPLE', ('?', '?'))) and IsStr(TypeExpr(v[0]))and IsInt(TypeExpr(v[1])):
                        return ('!_PyString_Find', obj,  v[0], v[1])
                if meth == 'rfind':
                    if TCmp(args, v, ('CONST', ('?',))) and type(v[0]) is str:
                        return ('!_PyString_RFind', obj, ('CONST', v[0]))
                    if TCmp(args, v, ('!BUILD_TUPLE', ('?',))) and IsStr(TypeExpr(v[0])):
                        return ('!_PyString_RFind', obj,  v[0])
                    if TCmp(args, v, ('CONST', ('?', '?'))) and type(v[0]) is str and type(v[1]) is int:
                        return ('!_PyString_RFind', obj, ('CONST', v[0]), ('CONST', v[1]))
                    if TCmp(args, v, ('!BUILD_TUPLE', ('?', '?'))) and IsStr(TypeExpr(v[0]))and IsInt(TypeExpr(v[1])):
                        return ('!_PyString_RFind', obj,  v[0], v[1])
                if meth == 'count':
                    if TCmp(args, v, ('CONST', ('?',))) and type(v[0]) is str:
                        return ('!_PyString_Count', obj, ('CONST', v[0]))
                    if TCmp(args, v, ('!BUILD_TUPLE', ('?',))) and IsStr(TypeExpr(v[0])):
                        return ('!_PyString_Count', obj,  v[0])
                    if TCmp(args, v, ('CONST', ('?', '?'))) and type(v[0]) is str and type(v[1]) is int:
                        return ('!_PyString_Count', obj, ('CONST', v[0]), ('CONST', v[1]))
                    if TCmp(args, v, ('!BUILD_TUPLE', ('?', '?'))) and IsStr(TypeExpr(v[0])) and IsInt(TypeExpr(v[1])):
                        return ('!_PyString_Count', obj,  v[0], v[1])


                if meth == 'index':
                    if TCmp(args, v, ('CONST', ('?',))):
                        if type(v[0]) is str:
                            return ('!_PyString_Index', obj, ('CONST', v[0]))
                        del v[:]
                    elif TCmp(args, v, ('CONST', ('?', '?'))):
                        if type(v[0]) is str and type(v[1]) is int:
                            return ('!_PyString_Index', obj, ('CONST', v[0]), ('CONST', v[1]))   
                        del v[:]   
                    elif TCmp(args, v, ('!BUILD_TUPLE', ('?',))):
                        if  IsStr(TypeExpr(v[0])):
                            return ('!_PyString_Index', obj, v[0])
                        del v[:]
                    elif  TCmp(args, v, ('!BUILD_TUPLE', ('?', '?'))):
                        if IsStr(TypeExpr(v[0])) and IsInt(TypeExpr(v[1])):
                            return ('!_PyString_Index', obj, v[0], v[1])
                        del v[:]
                if meth == 'rindex':
                    if TCmp(args, v, ('CONST', ('?',))):
                        if type(v[0]) is str:
                            return ('!_PyString_RIndex', obj, ('CONST', v[0]))  
                        del v[:] 
                    elif TCmp(args, v, ('CONST', ('?', '?'))):
                        if type(v[0]) is str and type(v[1]) is int:
                            return ('!_PyString_RIndex', obj, ('CONST', v[0]), ('CONST', v[1])) 
                        del v[:]
                    elif TCmp(args, v, ('!BUILD_TUPLE', ('?',))):
                        if IsStr(TypeExpr(v[0])):
                            return ('!_PyString_RIndex', obj, v[0])
                        del v[:]
                    elif TCmp(args, v, ('!BUILD_TUPLE', ('?', '?'))):
                        if IsStr(TypeExpr(v[0])) and IsInt(TypeExpr(v[1])):
                            return ('!_PyString_RIndex', obj,  v[0], v[1])  
                        del v[:]
                        
                if meth in ('isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'isupper'):
                    if TCmp(args, v, ('CONST', ())):
                        if obj[0] == 'CONST' and type(obj[1]) is str and len([x for x in obj[1] if ord(x) > 127]) == 0:
                            return ('CONST', getattr(obj[1], meth)())
                        return ('!_PyString_ctype', obj, meth)

            elif t == New_Kl_Module('string'):
                if meth == 'atoi':
                    retl = list(ret)
                    retl[1] = ('!LOAD_BUILTIN', 'int')
                    return tuple(retl)
                if meth == 'atol':
                    retl = list(ret)
                    retl[1] = ('!LOAD_BUILTIN', 'long')
                    return tuple(retl)
                if meth == 'atof':
                    retl = list(ret)
                    retl[1] = ('!LOAD_BUILTIN', 'float')
                    return tuple(retl)
            elif IsDict(t):
                if meth == 'copy':
                    if TCmp(args, v, ('CONST', ())):
                        return ('!PyDict_Copy', obj)
                elif meth == 'get':
                    if TCmp(args, v, ('!BUILD_TUPLE', ('?','?'))):
                        return ('!_PyDict_Get', obj, v[0], v[1])
                    elif TCmp(args, v, ('!BUILD_TUPLE', ('?',))):
                        return ('!_PyDict_Get', obj, v[0], ('CONST', None))
                    elif TCmp(args, v, ('CONST', ('?','?'))):
                        return ('!_PyDict_Get', obj, ('CONST',v[0]), ('CONST', v[1]))
                    elif TCmp(args, v, ('CONST', ('?',))):
                        return ('!_PyDict_Get', obj, ('CONST',v[0]), ('CONST', None))
                elif meth == 'has_key':
                    if TCmp(args, v, ('!BUILD_TUPLE', ('?',))):
                        return ('!BOOLEAN', ('!PyDict_Contains', obj, v[0]))
                    elif TCmp(args, v, ('CONST', ('?',))):
                        return ('!BOOLEAN', ('!PyDict_Contains', obj, ('CONST', v[0])))
                elif meth == 'keys' and args == ('CONST', ()) :
                    return ('!PyDict_Keys', obj)
                elif meth == 'values' and args == ('CONST', ()) :
                    return ('!PyDict_Values', obj)
                elif meth == 'items' and args == ('CONST', ()) :
                    return ('!PyDict_Items', obj)
                elif meth == 'len' and args == ('CONST', ()) :
                    return ('!PY_SSIZE_T', ('!PyDict_Size', obj))
# TypeError: 'int' object is not iterable !!!!!!!!
            if len(obj) == 4 and obj[-1] == 'NULL' and obj[1][0] == '&' and \
                    obj[0].endswith('.tp_new') and obj[0][0] == '!' and \
                    obj[0][1:-7] == obj[1][1:] and obj[2][0] == 'CONST' and\
                    len(obj[2][1]) == 1:
                t1 = TypeExpr(obj)
                t2 = TypeExpr(('CONST', obj[2][1][0]))
                if t1 == t2 and t1 is not None:
                        if args[0] == 'CONST':
                            ret_co = to_const_meth_1(obj, meth, args)
                            if ret_co is not None:
                                return ret_co
            if obj[0] == 'CONST':
                if args[0] == 'CONST':
                    ret_co = to_const_meth_2(obj, meth, args)
                    if ret_co is not None:
                        return ret_co
                else:
                    Debug('Call const meth', obj, meth, args)
    return ret    

def call_str_method(obj, meth, args, d):
    try:
        me = getattr(obj, meth)
        if d is None:
            ret = me(*args)
        else:
            assert type(d) is dict
            ret = me(*args, **d)
        return calculed_const(ret)
    except OverflowError as e:
        return ('!?Raise', ('BUILTIN', 'OverflowError'), ('CONST', e.message))
    except ValueError as e:
        return ('!?Raise', ('BUILTIN', 'ValueError'), ('CONST', e.message))
    except TypeError as e:
        return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', e.message))
    except:
        pp('CallMethConstErr', repr((obj, meth, args, d)), sys.exc_info())
    return None

def call_str_builtin(me, args, d = None):
    try:
        if d is None:
            ret = me(*args)
        else:
            assert type(d) is dict
            ret = me(*args, **d)
        return calculed_const(ret)
    except TypeError as e:
        return ('!?Raise', ('BUILTIN', 'TypeError'), ('CONST', e.message))    
    except LookupError as e:
        if me is unicode:
            return None
        pp('CallBuiltConstErrLookUp', repr((me, args, d)), sys.exc_info())
    except NameError as e:
        if me is unicode:
            pp('Namaerr', repr((me, args, d)), sys.exc_info())
            return None
        pp('CallBuiltConstErrName', repr((me, args, d)), sys.exc_info())
    except:
        pp('CallBuiltConstErr', repr((me, args, d)), sys.exc_info())
    return None

def IsListStr(it):
    if it[0] == '!LIST_COMPR':
        if IsStr(TypeExpr(it[1][0])):
            return True
        else:
            return False
    if it[0] == '!PyNumber_Add':
        return IsListStr(it[1]) and IsListStr(it[2])
    if it[0] == '!BUILD_LIST':
        return all([IsStr(TypeExpr(x)) for x in it[1]])
    if it[0] == '!PyObject_Call':
        v = []
        if TCmp(it[1], v, ('!PyObject_GetAttr', '?', ('CONST', 'split'))):
            if IsStr(TypeExpr(v[0])):
                return True
            return False
                    
    return False

def IsListUnicode(it):
    if it[0] == '!LIST_COMPR':
        if IsUnicode(TypeExpr(it[1][0])):
            return True
        else:
            return False
    if it[0] == '!PyNumber_Add':
        return IsListUnicode(it[1]) or IsListUnicode(it[2])
    if it[0] == '!BUILD_LIST':
        return any([IsUnicode(TypeExpr(x)) for x in it[1]])
    if it[0] == '!PyObject_Call':
        v = []
        if TCmp(it[1], v, ('!PyObject_GetAttr', '?', ('CONST', 'split'))):
            if IsUnicode(TypeExpr(v[0])):
                return True
            return False
                    
    return False
    

def module_attr_persistent(mod):
    global variable_module_attr
    if mod in variable_module_attr:
        return False
    if mod in constanted_modules:
        return True
    return False

def collect_modules_attr(ret):
    v = []
    if type(ret) is tuple and len(ret) > 1 and ret[0] == '!PyObject_GetAttr' and\
      TCmp(ret, v, ('!PyObject_GetAttr', \
                     (('|', 'CALC_CONST', \
                            '!LOAD_NAME', \
                            '!LOAD_GLOBAL', \
                            '!PyDict_GetItem(glob,'), \
                        ':ImportedM:'), ('CONST', '?'))) and \
                        ModuleHaveAttr(v[0][0], v[1]):
        if type(v[0][2]) is str and v[0][2].startswith('__buil') and v[0][2][6:] == 'tin__':
           pass
        elif is_sys_const(v[0][2], v[1]):
            return get_sys_const(v[0][2], v[1])
        else:
            if v[0][2] != 'sys' and module_attr_persistent(v[0][2]):
                v2 = IfConstImp(v[0][0], v[1])
                if v2 is not None:
                    return v2
            if ModuleHaveAttr(v[0][0], v[1]) and module_attr_persistent(v[0][2]):
                _3(v[0][0], 'ModuleAttr', v[1])  


variable_module_attr = ('time', 'strptime', '_strptime', 'textwrap', 'test', 'test_support', 'test.test_support')

sys_const = ('byteorder', 'subversion', 'builtin_module_names', 
             'copyright', 'hexversion', 'maxint', 'maxsize', 'maxunicode',
             'platform', 'version', 'api_version')
             
def is_sys_const(a,b):    
    return ( a == 'sys' and b in sys_const ) or ( a == 'os' and b == 'name' )

def get_sys_const(a,b):
    if a == 'sys':
        return ('CONST', getattr(sys, b))  
    if a == 'os':
        return ('CONST', os.name)
    pp(a, b)
    assert False

def is_right_const_value(v2):
    if type(v2) in (int,long,bool,complex,float) or (type(v2) is str and len(v2) == 1):
        return True
    return False

def IfConstImp(imp,nm):
    assert imp is not None
    v2 = val_imp(imp, nm)
    if is_right_const_value(v2):
        return ('CONST', v2)
    return None

def ModuleHaveAttr(imp,nm):
    assert type(imp) is str
    if imp.startswith('__buil') and imp[6:] == 'tin__':
        return nm in d_built
    if imp == 'sys' or (not module_attr_persistent(imp)) or (imp.startswith('__buil') and imp[6:] == 'tin__'):
        return False
    if imp in  ImportedM:
        v = ImportedM[imp]
        if type(v) is tuple and len(v) == 2:
            imp = v[0] + '.' + v[1]
            if v[0] in list_import and v[1] in list_import[v[0]] and not IsModule(list_import[v[0]][v[1]]):
                return False
        elif type(v) is str and v != imp:
            imp = v
        elif v != imp:
            Fatal(imp, v, nm)
            assert False
    if imp == 'sys' or (not module_attr_persistent(imp)):
        return False
    v2 = val_imp(imp, nm)
    if v2 is None:
        return False
    return True

def repl_collected_module_attr(ret):
    assert ret != ('PY_TYPE', 'NewClassInstance', 'MovedAttribute', ('CALC_CONST', '_importer'), None)
    assert ret != (('NewClassInstance', 'MovedAttribute'), ('!PyObject_GetAttr', ('PY_TYPE', 'NewClassInstance', 'MovedAttribute', ('CALC_CONST', '_importer'), None), ('CONST', 'name')))

    if len(ret) == 4 and ret[0] == '!COND_METH_EXPR':
        t = TypeExpr(ret[1])
        if t is not None or True:
            for _arg, _ret in ret[3]: 
                if _arg == t:
                    return repl_collected_module_attr(_ret)
            if t is not None:
                return repl_collected_module_attr(ret[2])
    
    if type(ret) is tuple and len(ret) >= 1 and type(ret[0]) is str and ret[0] == '!PyObject_GetAttr':
        v = []
        if TCmp(ret, v, ('!PyObject_GetAttr', '?', ('CONST', '?'))):
            assert v[0] != ('PY_TYPE', 'NewClassInstance', 'MovedAttribute', ('CALC_CONST', '_importer'), None)
            t = TypeExpr(v[0])
            if t is not None and t[0] is types.ModuleType and is_sys_const(t[1], v[1]):
                return get_sys_const(t[1], v[1])
            elif t is not None and t[0] is types.ModuleType and t[1] != 'sys' and\
                t[1] is not None and module_attr_persistent(t[1]):
                v2 = IfConstImp(t[1], v[1])
                if v2 is not None:
                    return v2
        v = []
        if TCmp(ret, v, ('!PyObject_GetAttr', 
                        (('|', 'CALC_CONST',
                                '!LOAD_NAME', 
                                '!LOAD_GLOBAL', 
                                '!PyDict_GetItem(glob,'),
                            ':ImportedM:'), ('CONST', '?'))):
            if is_sys_const(v[0][2], v[1]):
                return get_sys_const(v[0][2], v[1])
            elif v[0][2] != 'sys' and module_attr_persistent(v[0][2]):
                v2 = IfConstImp(v[0][0], v[1])
                if v2 is not None:
                    return v2
            if v[0][2] != 'sys' and ModuleHaveAttr(v[0][0], v[1]) and module_attr_persistent(v[0][2]):
                _3(v[0][0], 'ModuleAttr', v[1])                    
                ret = calc_const_to((v[0][0], v[1]))
            v = []
    
        if TCmp(ret, v, ('!PyObject_GetAttr', ('CALC_CONST', '?'), ('CONST', '?'))):
            t = TypeExpr(('CALC_CONST', v[0]))
            if not redefined_attribute and t != None and \
            t[0] in (T_NEW_CL_INST, T_OLD_CL_INST) and\
            IsAttrInstance(t[1], v[1]) and not auto_slots: 
                _3(v[0], 'ModuleAttr', '.__dict__') 
                calc_const_to((v[0], '.__dict__'))                  
        v = []

    if type(ret) is tuple and len(ret) == 2 and type(ret[0]) is str and \
       ret[0] in ('!LOAD_NAME', '!LOAD_GLOBAL', '!PyDict_GetItem(glob,') and \
       ret[1] in calculated_const:
        ret = calc_const_to(ret[1])    
    return ret

def upgrade_op(ret, nm = None):   
    if type(ret) is tuple and len(ret) == 2 and \
       ( ret[0] in ('!LOAD_GLOBAL', '!PyDict_GetItem(glob,', 'CALC_CONST') or (ret[0] == '!LOAD_NAME' and g_co.c_name == 'Init_filename') ) and \
       is_mnemonic_const(ret[1]):
           return calculated_const[ret[1]].mnemonic_constant_value
    collect_modules_attr(ret)    
    return repl(ret)

methods_type = {(Kl_String, 'find'): Kl_FromMinusOne,
                (Kl_String, 'index'): Kl_Cardinal,
                (Kl_String, 'rfind'): Kl_FromMinusOne,
                (Kl_String, 'rindex'): Kl_Cardinal,
                (Kl_String, 'split'): Kl_List,
                (Kl_String, 'splitlines'): Kl_List,
                (Kl_String, 'ljust'): Kl_String,
                (Kl_String, 'rjust'): Kl_String,
                (Kl_String, 'zfill'): Kl_String,
                (Kl_Char, 'lower'): Kl_Char,
                (Kl_Char, 'upper'): Kl_Char,
                (Kl_String, 'lower'): Kl_String,
                (Kl_String, 'upper'): Kl_String,
                (Kl_String, 'encode'): None,
                (Kl_String, 'replace'): Kl_String,
                (Kl_String, 'strip'): Kl_String,
                (Kl_String, 'rstrip'): Kl_String,
                (Kl_String, 'lstrip'): Kl_String,
                (Kl_String, 'center'): Kl_String,
                ##(Kl_String, 'join'): Kl_String,
                (Kl_String, 'startswith'): Kl_Boolean,
                (Kl_Tuple,  'startswith'): Kl_None,
                (Kl_List,   'startswith'): Kl_None,
                (Kl_String, 'endswith'): Kl_Boolean,
                (Kl_String, 'isalnum'): Kl_Boolean,
                (Kl_String, 'isalpha'): Kl_Boolean,
                (Kl_String, 'isdigit'): Kl_Boolean,
                (Kl_String, 'islower'): Kl_Boolean,
                (Kl_String, 'isspace'): Kl_Boolean,
                (Kl_String, 'istitle'): Kl_Boolean,
                (Kl_String, 'isupper'): Kl_Boolean,
                (Kl_String, 'count'): Kl_Cardinal,
                ## (Kl_File, 'close'): Kl_None,
                ## (Kl_File, 'write'): Kl_None,
                ## (Kl_File, 'seek'): Kl_None,
                ## (Kl_File, 'fileno'): Kl_Int,
                ## (Kl_File, 'tell'): Kl_Long,
                ## (Kl_File, 'read'): Kl_String,
                ## (Kl_File, 'getvalue'): Kl_String,
                ## (Kl_File, 'readline'): Kl_String,
                ## (Kl_File, 'readlines'): Kl_List,
                
                (Kl_Dict, 'iteritems'): Kl_Generator,
                (Kl_Dict, 'iterkeys'): Kl_Generator,
                (Kl_Dict, 'fromkeys'): Kl_Dict,
                (Kl_Dict, 'copy'): Kl_Dict,
                (Kl_Dict, 'keys'): Kl_List,
                (Kl_Dict, 'has_key'): Kl_Boolean,
                (Kl_Dict, 'values'): Kl_List,
                (Kl_Dict, 'clear'): Kl_None,
                (Kl_Dict, 'update'): Kl_None,
                (Kl_Dict, 'items'): (list, (tuple,(None,None))),
                (Kl_Dict, 'itervalues'): Kl_Generator,
                (Kl_Dict, 'setdefault'): None,
                (Kl_Dict, 'get'): None,
                (Kl_Dict, 'count'): Kl_Int,
                (Kl_Dict, 'popitem'): Kl_Tuple,
                (Kl_List, 'reverse'): Kl_None,
                (Kl_List, 'pop'): None,
                (Kl_List, 'append'): Kl_None,
                (Kl_List, 'extend'): Kl_None,
                (Kl_List, 'insert'): Kl_None,
                (Kl_List, 'sort'): Kl_None,
                (Kl_List, 'remove'): Kl_None,
                (Kl_List, 'index'): Kl_Cardinal,
                (Kl_List, 'count'): Kl_Cardinal,
                (Kl_List, 'pop'): None,
                (Kl_File, 'isatty'): Kl_Boolean,
                (Kl_File, 'write'): Kl_None,
                (Kl_File, 'flush'): Kl_None,
                (Kl_Set,  'clear'): Kl_None,
                (Kl_Set,  'discard'): Kl_None,
                (Kl_Set,  'remove'): Kl_None,
                (Kl_Set,  'add'): Kl_None,
                (Kl_Set,  'difference'): Kl_Set,
                (Kl_Set,  'intersection'): Kl_Set,
                (Kl_Set,  'union'): Kl_Set,
                (Kl_Set,  'copy'): Kl_Set,
                (Kl_Set,  'pop'): None,
                (Kl_Set,  'isdisjoint'): Kl_Boolean,
                (Kl_Set,  'issubset'): Kl_Boolean,
                (Kl_Set,  'issuperset'): Kl_Boolean,
                ((T_NEW_CL_INST, 'StringIO'), 'getvalue') : Kl_String,
                ((T_OLD_CL_INST, 'ZipFile'), 'getinfo') : (T_OLD_CL_INST, 'ZipInfo'),
                ((T_OLD_CL_INST, 'ZipFile'), 'infolist') : Kl_List,
                ((T_OLD_CL_INST, 'ZipFile'), 'namelist') : Kl_List,
                (Kl_MatchObject, 'group'): None,
                (Kl_MatchObject, 'groups'): Kl_Tuple,
                (Kl_MatchObject, 'span'): Kl_Tuple,
                (Kl_RegexObject, 'subn'): Kl_Tuple,
                (Kl_RegexObject, 'search'): None,
                (Kl_RegexObject, 'finditer'): Kl_Generator,
                (Kl_RegexObject, 'findall'): Kl_List,
                (Kl_RegexObject, 'split'): Kl_List,
                (Kl_RegexObject, 'match'): None,
                (Kl_RegexObject, 'sub'): Kl_String
                }
if py_version < 30:
    methods_type[(Kl_File, 'close')] = Kl_None
    methods_type[(Kl_File, 'write')] = Kl_None
    methods_type[(Kl_File, 'seek')] = Kl_None
    methods_type[(Kl_File, 'fileno')] = Kl_Int
    methods_type[(Kl_File, 'tell')] = Kl_Long
    methods_type[(Kl_File, 'read')] = Kl_String
    methods_type[(Kl_File, 'getvalue')] = Kl_String
    methods_type[(Kl_File, 'readline')] = Kl_String
    methods_type[(Kl_File, 'readlines')] = Kl_List
    

attrs_type = {
              (Kl_Code, 'co_flags') : Kl_ShortCardinal,
              (Kl_Code, 'co_argcount') : Kl_ShortCardinal,
              (Kl_Code, 'co_nlocals') : Kl_ShortCardinal,
              (Kl_Code, 'co_varnames') : Kl_Tuple,
              (Kl_Code, 'co_cellvars') : Kl_Tuple,
              (Kl_Code, 'co_freevars') : Kl_Tuple,
              (Kl_Code, 'co_consts') : Kl_Tuple,
              (Kl_Code, 'co_names') : Kl_Tuple,
              (Kl_Code, 'co_lnotab') : Kl_String,
              
              (Kl_Code, 'co_stacksize') : Kl_ShortCardinal,
              (Kl_Code, 'co_filename') : Kl_String,
              (Kl_Code, 'co_firstlineno') : Kl_ShortCardinal,
              (Kl_Code, 'co_name') : Kl_String,
              (Kl_Code, 'co_code') : Kl_String,
              (Kl_Complex, 'imag') : Kl_Float,
              (Kl_Complex, 'real') : Kl_Float,
              (Kl_Function, 'func_code') : Kl_Code} 

tag_builtin = {}

def TypeBuilt(kl, *words):
    for w in words:
        tag_builtin[w] = kl
        
TypeBuilt(Kl_Tuple, 'divmod', 'tuple')
TypeBuilt(Kl_List, 'map', 'range', 'zip', 'list', 'dir', 'sorted')
TypeBuilt(Kl_Boolean, 'all', 'any', 'callable', 'isinstance', 'issubclass', 'bool')
TypeBuilt(Kl_Int, 'hash')
TypeBuilt(Kl_IntUndefSize, 'int')
TypeBuilt(Int(-1, 1), 'cmp')
TypeBuilt(Kl_None, 'exit')
TypeBuilt(Kl_Cardinal, 'len')
TypeBuilt((int, (0, sys.maxunicode)), 'ord')
TypeBuilt(Kl_Dict, 'dict', 'globals', 'locals', 'vars')
TypeBuilt(Kl_Float, 'float', 'round')
TypeBuilt(Kl_String, 'hex', 'oct', 'str', 'repr', 'raw_input', 'bin', 'bytes')
TypeBuilt(Kl_Char, 'chr')
if py_version < 30: 
    TypeBuilt(Kl_Unicode, 'unicode', 'unichr')
    TypeBuilt(Kl_File, 'file', 'open')
    TypeBuilt(Kl_Slice, 'slice')
    TypeBuilt(Kl_Buffer, 'buffer')
    TypeBuilt(Kl_XRange, 'xrange')
TypeBuilt(Kl_Complex, 'complex')
TypeBuilt(Kl_Set, 'set')
TypeBuilt(Kl_Long, 'long')
TypeBuilt(Kl_FrozenSet, 'frozenset')
TypeBuilt(Kl_StaticMethod, 'staticmethod')
TypeBuilt(New_Kl_Module(None), '__import__')
TypeBuilt(Kl_ClassMethod, 'classmethod')
TypeBuilt(Kl_Reversed, 'reversed')
TypeBuilt(Kl_Generator, 'enumerate', 'iter')
TypeBuilt(None, 'min', 'max', 'property', 'reduce', 'eval', 'super', \
                          'sum', 'compile', 'ValueError', 'IOError', \
                          'SyntaxError', 'input', 'bytearray', \
                          'filter')

_min_max_div_rem = {}
def MinMaxDivRem(op, a,b,c,d):
    if (op,a,b,c,d) in _min_max_div_rem:
        return _min_max_div_rem[(op,a,b,c,d)]
    if op == '/' or op == '//':
        if a == b and c == d and d != 0:
            return (a / c, a / c)
        if (1 >= c and 1 <= d) and (-1 >= c and -1 <= d):
            return (min(a,b,-a, -b), max(a,b, -a, -b))
        elif (1 >= c and 1 <= d):
            return (a, b)
        elif (-1 >= c and -1 <= d):
            return (min(-a, -b), max(-a, -b))
        elif d < -1:
            return (min(a/d, b/d), max(a/d, b/d))
        elif c > 1:
            return (min(a/c, b/c), max(a/c, b/c))
        pp('UNDEF divrem', (op,a,b,c,d))
        assert False
    if op == '/':    
        pp('UNDEF divrem', (op,a,b,c,d))
        assert False
    if op == '//':
        pp('UNDEF divrem', (op,a,b,c,d))
        assert False
    if op == '%':
        if a == b and c == d and d != 0:
            return (a % c, a % c)
        li = []
        if d < 0:
            li.append(d+1)
            li.append(0)
        if c < 0:
            li.append(c+1)
            li.append(0)
        if d > 0:
            li.append(d-1)
            li.append(0)
        if c > 0:
            li.append(c-1)
            li.append(0)
        li.sort()
        return (li[0], li[-1])
    assert False
    
def IsArgStr(t):
    assert type(t) is tuple
    return IsStr(t) or (IsMayBe(t) and IsStr(t[1]))

def combine_type(t0, t1):
    _t0 = t0
    _t1 = t1
    if t1 is None or t1[0] == 'PSEVDO':
        return t0
    if t1 == t0:
        return t0
    if t0[0] == t1[0]:
        if IsCType(t1) and not IsCType(t0):
            return t1
        if t1[0] is str and t0[0] is str:
            if t0[1] == 1 and t1[1] is None:
                return t0
            if type(t0[1]) is str and t1[1] is None:
                return t0
            if type(t1[1]) is str and t0[1] is None:
                return t1
        if t0[0] is int:
            return (int, (max(t0[1][0], t1[1][0]), min(t0[1][1], t1[1][1])))
        if t0[0] is bool:
            if t0[1] is None:
                return t1
            else:
                return t0
        if t0[0] is list:
            if t0[1] is None and t1[1] is not None:
                return t1
        if t0[0] == 'MayBe':
            return ('MayBe', combine_type(t0[1], t1[1]))
        if t0[0] is tuple:
            if t0[1] is None:
                return t1
            if type(t0[1]) is tuple:
                if type(t1[1]) is int and len(t0[1]) >= t1[1]:
                    return t0
                if t1[1] is None:
                    return t0
                if type(t1[1]) is tuple:
                    li = []
                    for i in range(max(len(t0[1]), len(t1[1]))):
                        if i >= len(t0[1]):
                            li.append(t1[1][i])
                            continue
                        if i >= len(t1[1]):
                            li.append(t0[1][i])
                            continue
                        if t0[1][i] == t1[1][i]:
                            li.append(t1[1][i])
                            continue
                        if t0[1][i] is None:
                            li.append(t1[1][i])
                            continue
                        if t1[1][i] is None:
                            li.append(t0[1][i])
                            continue
                        li.append(combine_type(t0[1][i], t1[1][i]))
                        continue
                    return (tuple, tuple(li))
            elif type(t0[1]) is int:
                if t1[1] is None:
                    return t0
                if type(t1[1]) is tuple and len(t1[1]) < t0[1]:
                    return (tuple, t1[1] + tuple([ None for i in range( t0[1]-len(t1[1]) ) ]))
                if type(t1[1]) is tuple and len(t1[1]) >= t0[1]:
                    return t1
                if type(t1[1]) is int:
                    return (tuple, max(t0[1], t1[1]))                    
    else:
        if IsInt(t0) and IsIntUndefSize(t1):
            return t0
        if IsIntUndefSize(t0) and IsInt(t1):
            return t1
        if IsMayBe(t1):
            if t1[1] == t0:
                return t0
            if t1[1][0] == t0[0]:
                if t0[0] is int:
                    t1 = t1[1]
                    return (int, (max(t0[1][0], t1[1][0]), min(t0[1][1], t1[1][1])))
                if IsStr(t0) and IsStr(t1[1]):
                    if t0[1] is None:
                        return t1[1]
                    elif t1[1][1]  is None:
                        return t0
                    pp(t0, t1)
                    assert False
                if t0[0] is tuple:
                    if t0[1] is None:
                        return t1[1]
                    t1 = t1[1]
                    if type(t0[1]) is tuple:
                        if type(t1[1]) is int and len(t0[1]) >= t1[1]:
                            return t0
                        if t1[1] is None:
                            return t0
                        if type(t1[1]) is tuple and len(t1[1]) == len(t0[1]):
                            li = []
                            for i, v in enumerate(t0[1]):
                                if v == t1[1][i]:
                                    li.append(v)
                                    continue
                                if v is None:
                                    li.append(t1[1][i])
                                    continue
                                if t1[1][i] is None:
                                    li.append(v)
                                    continue
                                li.append(combine_type(v, t1[1][i]))
                                continue
                            return (tuple, tuple(li))
                    elif type(t0[1]) is int and t1[1] is None:
                        return t0
            else:
                if IsInt(t0) and IsIntUndefSize(t1[1]):
                    return t0
                if IsIntUndefSize(t0) and IsInt(t1[1]):
                    return t1[1]
    pp('PY_TYPE', _t0, _t1, g_co.c_name)
    pprint(_t0)
    pprint(_t1)
    assert False
    
   
def TypeFast(nm):
    l_co = g_co
    assert type(l_co) is code_extended
    ind = l_co.d_varnames[nm]
    detec = l_co.detected_type
    if nm in detec and detec[nm] is not None:
        ##print ind, (l_co.co_argcount + bool(l_co.co_flags & 0x4)), nm, detec, l_co.c_name
        if ind >= (l_co.co_argcount + bool(l_co.co_flags & 0x4)):
            return detec[nm]
        else:
            pp('TypeFast 2/ ', nm,  l_co.co_varnames, ' at ', l_co.c_name)
            assert False
    if ( bool(l_co.can_be_codefunc() ) and l_co.no_codefunc ) or ( is_current & IS_DIRECT ):        
        ## assert is_current & IS_DIRECT
        if ind in l_co.typed_arg_direct:
            return l_co.typed_arg_direct[ind]
        return type_fast_changed_arg_type_detect(l_co, nm, ind)
    return None        

def TypeExpr(ret):
    global to_call_1, to_call_2
    global _n2c    
    if type(ret) is str:
        if ret == 'Py_None':
            return Kl_None
        if ret == 'bdict':
            return Kl_Dict
    if type(ret) != tuple:
        return None
    assert type(ret) is tuple
    if len(ret) < 1:
        return None
    ret0 = ret[0]  
    if type(ret0) is str:
        assert len(ret0) > 0
        c0 = ret0[0]
        if c0 == 'P':
            if ret0 == 'PY_TYPE':
                if ret[3][0] == 'PY_TYPE':
                    pp(ret)
                    assert False
                return combine_type(ret[1:3], TypeExpr(ret[3]))
        if c0 == 'T':
            if ret0 == 'TYPED_TEMP':
                ct = typed_to_ctype(ret[1])
                if ct == 'long':
                    return Kl_Int
                if ct == 'Py_ssize_t':
                    return Kl_Cardinal
                if ct == 'char':
                    return Kl_Char
                if ct == 'double':
                    return Kl_Float
                if ct == 'int':
                    return Kl_Boolean
        elif c0 == 'C':
            if ret0 == 'CONST':
                if type(ret[1]) is int:
                    return Int(ret[1], ret[1])
                if type(ret[1]) is tuple:
                    return (tuple, tuple([TypeExpr(('CONST', x)) for x in ret[1]]))
                if type(ret[1]) is str:
                    return (type(ret[1]), ret[1])
                if type(ret[1]) is bool:
                    return (type(ret[1]), ret[1])
                return (type(ret[1]), None)
            if ret0 == 'CALC_CONST':
                nm = ret[1]    
                if type(nm) is tuple and len(nm) == 2:
                    tupl = (ImportedM[nm[0]], nm[1], 'val')
                    if tupl in t_imp:
                        return t_imp[tupl]
                elif type(nm) is str and nm in ImportedM:
                    tuplcall = ImportedM[nm]
                    if type(tuplcall) is tuple:
                        tuplcall +=  ('val',)
                        if tuplcall in t_imp:
                            return t_imp[tuplcall]            
                if IsOldClass(ret[1]) and not IsNewClass(ret[1]):
                    return (T_OLD_CL_TYP, ret[1])
                if IsNewClass(ret[1]) and not IsOldClass(ret[1]):
                    return (T_NEW_CL_TYP, ret[1])
                if IsAnyClass(ret[1]):
                    return (T_ANY_CL_TYP, ret[1])        
                if found_value_calc_const(ret[1]):
                    fo = get_value_calc_const(ret[1])
                    if fo == ret:
                        return None
                    return TypeExpr(fo) #Klass(ret)
                return None

        elif c0 == 'F':
            if ret0 == 'FAST':
                return TypeFast(ret[1])
        elif c0 == '!':
            c1 = ret0[1]
            if c1 == 'R':
                if ret0 == '!?Raise':
                    return ('Raise', ret[1])
            elif c1 == 'O':
                if ret0 == '!ORD_BUILTIN':
                    assert False
            elif c1 == 'P':
                if ret0 == '!PyObject_Type':
                    t = TypeExpr(ret[1])
                    return (Kl_Type[0], t)
                
                if ret0 == '!PyUnicode_Type.tp_new':
                    return Kl_Unicode
                if ret0 in ('!PyObject_IsInstance', '!PyObject_IsSubclass', \
                          '!PySequence_Contains(', \
                          '!PySet_Contains', '!PyDict_Contains', '!PySequence_Contains', '!PyBool_Type.tp_new',\
                          '!PyObject_HasAttr'):
                    return Kl_Boolean
                if ret0 == '!PyInt_Type.tp_new':
                    return Kl_Int
                if ret0 == '!PyLong_Type.tp_new':
                    return Kl_Long
                if ret0 == '!PyComplex_Type.tp_new':
                    return Kl_Complex
                if ret0 in ('!PyFloat_Type.tp_new', '!PyNumber_Float'):
                    return Kl_Float
                if ret0 == '!PyBaseObject_Type.tp_new':
                    return Kl_BaseObject        
                if ret0.endswith('.tp_new'):
                    pp('!!!tp_new', ret)
                if len(ret) == 3 and type(ret0) is str and ret0 in frozenset_to_call_2 and \
                   len(to_call_2[ret0]) == 1 and '__coerce__' not in _n2c: 
                    t1 = TypeExpr(ret[1])
                    ##t2 = TypeExpr(ret[2])
                    nm_meth = to_call_2[ret0][0]
                    if t1 is not None and t1[0] in(T_OLD_CL_INST, T_NEW_CL_INST): 
                        codemethnm, staticmeth, classmeth = body_meth_by_class_and_meth(t1[1], nm_meth)
                        if codemethnm is not None:
                            if classmeth or staticmeth:
                                pass   
                            elif codemethnm in detected_return_type:
                                t0 = detected_return_type[codemethnm]
                                if t0 == ('PSEVDO', 'self'):
                                    t0 = t1
                                return t0
                if ret0.startswith('!PyNumber_'):
                    if len(ret) == 2:
                        t1 = TypeExpr(ret[1])
                        if ret0 == '!PyNumber_Int':
                            if IsBool(t1):
                                return Int(0, 1)
                            if IsInt(t1):
                                return t1
                            return Kl_IntUndefSize   
                        if ret0 == '!PyNumber_Invert':
                            if type(t1) is tuple:
                                if IsInt(t1) and t1[1] is not None and type(t1[1][0]) is int and type(t1[1][1]) is int:
                                    return Int(~t1[1][1], ~t1[1][0])
                                if IsInt(t1):
                                    return t1    
                                if IsLong(t1):
                                    return Kl_Long
                                if IsIntUndefSize(t1):
                                    return Kl_IntUndefSize
                                if IsBool(t1):
                                    return (int, (-2, -1))    
                        if ret0 == '!PyNumber_Positive':
                            if type(t1) is tuple:
                                if IsInt(t1):
                                    return t1
                                if IsFloat(t1):
                                    return t1
                                if IsComplex(t1):
                                    return t1
                                if IsBool(t1):
                                    return t1
                                if t1 == Kl_Long or IsFloat(t1) or IsIntUndefSize(t1) or (type(t1) is tuple and t1[0] == 'MayBe'):
                                    return t1
                        if ret0 == '!PyNumber_Negative':
                            if type(t1) is tuple:
                                if IsInt(t1):
                                    return detect_long_subint(Int(-t1[1][1], -t1[1][0]))
                                if IsIntOrFloat(t1):
                                    return t1
                                if t1 == Kl_Long or IsFloat(t1) or IsIntUndefSize(t1) or (type(t1) is tuple and t1[0] == 'MayBe'):
                                    return t1
                                if IsBool(t1):
                                    return (int, (-1, -0))    
                            return None        
                        if ret0 == '!PyNumber_Absolute':
                            if IsInt(t1):
                                li = [abs(t1[1][0]), abs(t1[1][1])]
                                if 0 >= t1[1][0] and 0 <= t1[1][1]:
                                    li.append(0)
                                li.sort()
                                return detect_long_subint(Int(li[0], li[-1]))
                            return t1 

                    if len(ret) == 3:
                        t1 = TypeExpr(ret[1])
                        t2 = TypeExpr(ret[2])
                        if ret0 in ('!PyNumber_Lshift', '!PyNumber_Rshift', '!PyNumber_InPlaceLshift', '!PyNumber_InPlaceRshift'):
                            if t1 == Kl_Long:
                                return t1
                            if IsInt(t1) and IsInt(t2):
                                if t2[1][0] == t2[1][1]:
                                    if t2[1][0] >= 0: 
                                        if ret0 in ('!PyNumber_Rshift', '!PyNumber_InPlaceRshift'):
                                            return Int(t1[1][0] >> t2[1][0], t1[1][1] >> t2[1][0])
                                        if ret0 in ('!PyNumber_Lshift', '!PyNumber_InPlaceLshift'):
                                            return detect_long_subint(Int(t1[1][0] << t2[1][0], t1[1][1] << t2[1][0]))
                                    else:
                                        return None
                                if (ret0 == '!PyNumber_Lshift' or ret0 == '!PyNumber_InPlaceLshift'):
                                    t2 = Int(max(0, t2[1][0]), max(0, t2[1][1]))
                                    if t2[1][0] > 256 or t2[1][1] > 256 or t2[1][0] > 256 or t2[1][1] >256:
                                        return Kl_IntUndefSize
                                    
                                    k1 = t1[1][0] << t2[1][0]
                                    k2 = t1[1][0] << t2[1][1]
                                    k3 = t1[1][1] << t2[1][0]
                                    k4 = t1[1][1] << t2[1][1]
                                    li = [k1,k2,k3,k4]                
                                    li.sort()
                                    return detect_long_subint(Int(li[0], li[-1]))
                                if (ret0 == '!PyNumber_Rshift' or ret0 == '!PyNumber_InPlaceRshift'):
                                    t2 = Int(max(0, t2[1][0]), max(0, t2[1][1]))
                                    k1 = t1[1][0] >> t2[1][0]
                                    k2 = t1[1][0] >> t2[1][1]
                                    k3 = t1[1][1] >> t2[1][0]
                                    k4 = t1[1][1] >> t2[1][1]
                                    li = [k1,k2,k3,k4]
                                    li.sort()
                                    return detect_long_subint(Int(li[0], li[-1])) 
                                            
                            if IsInt(t2):
                                if t2[1][1] is not None and t2[1][1] == t2[1][0] and t2[1][1] < 0:
                                    return None
                            if IsInt(t1) and ret0 == '!PyNumber_Rshift' :
                                if ret[2][0] == 'CONST' and type(ret[2][1]) is int and ret[2][1] >= 16:
                                    return Kl_Short
                                if t2 is None:
                                    return None
                                pp('RShift', t1, t2, ret)
                                return t1
                            if IsInt(t1) and ret0 == '!PyNumber_Lshift':
                                if IsInt(t2) and (t2[1][1] is None or t2[1][1] >= 32):
                                    if t2[1][1] is None or t2[1][1] >= 32:
                                        return Kl_Long
                                    return Kl_IntUndefSize
                                if IsInt(t2) and type(t1[1]) is tuple and type(t2[1]) is tuple and \
                                   t2[1][0] == t2[1][1] and type(t2[1][1]) is int and type(t1[1][0]) is int and type(t1[1][1]) is int and t2[1][0] >= 0:
                                       t3 = Int(t1[1][0] << t2[1][0], t1[1][1] << t2[1][0])
                                       if t3[1][1] < MInt and t3[1][0] > -MInt:
                                           return t3
                            if ret0 in ('!PyNumber_InPlaceLshift', '!PyNumber_InPlaceRshift'):
                                if t1 == Kl_Long:
                                    return t1
                                if IsInt(t1) and ret0 == '!PyNumber_InPlaceRshift' :
                                    if ret[2][0] == 'CONST' and type(ret[2][1]) is int and ret[2][1] >= 16:
                                        return Kl_Short
                                    return t1
                            if ret0 in ('!PyNumber_InPlaceRshift', '!PyNumber_Rshift'):
                                if IsIntUndefSize(t1):
                                    return Kl_IntUndefSize
                            if (ret0 == '!PyNumber_Lshift' or ret0 == '!PyNumber_InPlaceLshift'):
                                if IsInt(t1) and IsInt(t2):
                                    t2 = Int(max(0, t2[1][0]), max(0, t2[1][1]))
                                    li = [t1[1][0] << t2[1][0], t1[1][0] << t2[1][1], t1[1][1] << t2[1][0], t1[1][1] << t2[1][1]]
                                    li.sort()
                                    return detect_long_subint(Int(li[0], li[-1]))
                                if IsIntUndefSize(t1) and IsInt(t2):
                                    return Kl_IntUndefSize

                                if IsIntUndefSize(t2):
                                    return Kl_IntUndefSize

                        if ret0 in ('!PyNumber_Xor', '!PyNumber_InPlaceXor'):
                            if IsBool(t1) and IsInt(t2):
                                t1 = (int, (0, 1))
                            if IsInt(t1) and IsInt(t2):
                                if t1[1][0] < 0 or t2[1][0] < 0:
                                    return Kl_Int
                                if t1[1][0] >= 0 and t1[1][1] >= 0 and t2[1][0] >= 0 and t2[1][1] >= 0:
                                    le = max(len(bin(t1[1][0])), len(bin(t1[1][1])), len(bin(t2[1][0])), len(bin(t2[1][0]))) - 2
                                    ir = 1
                                    while le > 1:
                                        le -= 1
                                        ir = ir << 1
                                        ir += 1
                                    assert ir <= MInt
                                    return (int, (0, ir))
                                if t1 == t2:
                                    return t1
                                if t2[1][0] == t2[1][1] == -1:
                                    return Int(-(t1[1][1]+1), -(t1[1][0]+1))
                                if t1[1][1] == t1[1][0] and t2[1][1] == t2[1][0]:
                                    return Int(t1[1][1] ^ t2[1][1], t1[1][1] ^ t2[1][1])
                                pp(ret)
                                pp('??', '=', t1, '^', t2)
                                if IsShort(t1) and IsShort(t2):
                                    return Kl_Short
                                if IsInt(t1) and IsInt(t2):
                                    return Kl_Int   

                            if IsInt(t1) and IsIntUndefSize(t2):
                                return Kl_IntUndefSize
                            if IsIntUndefSize(t1) and IsIntUndefSize(t2):
                                return Kl_IntUndefSize
                            if IsInt(t2) and IsIntUndefSize(t1):
                                return Kl_IntUndefSize        
                            if IsShort(t1) and IsShort(t2):
                                return Kl_Short 
                            if IsInt(t1) and IsInt(t2):
                                return Kl_Int
                            if IsBool(t1) and IsBool(t2):
                                return Kl_Boolean      
                            if IsLong(t1) and IsLong(t2):
                                return Kl_Long   
                            if IsSet(t1) and IsSet(t2):
                                return Kl_Set 
                            if IsFrozenSet(t1) and IsFrozenSet(t2):
                                return Kl_FrozenSet           
                            if IsSet(t1) and IsFrozenSet(t2):
                                return Kl_Set 
                            if IsFrozenSet(t1) and IsSet(t2):
                                return Kl_FrozenSet           
                        if ret0 in ('!PyNumber_And', '!PyNumber_Or', '!PyNumber_InPlaceAnd', '!PyNumber_InPlaceOr'):
                            if IsBool(t1) and IsInt(t2):
                                t1 = (int, (0, 1))        
                            if IsSet(t1) and IsSet(t2):
                                return Kl_Set 
                            if IsFrozenSet(t1) and IsFrozenSet(t2):
                                return Kl_FrozenSet           
                            if IsSet(t1) and IsFrozenSet(t2):
                                return Kl_Set 
                            if IsFrozenSet(t1) and IsSet(t2):
                                return Kl_FrozenSet   
                            if ret0 in ('!PyNumber_Or', '!PyNumber_InPlaceOr'):
                                if IsLong(t1) and IsInt(t2):
                                    return Kl_Long
                                if IsInt(t1) and IsLong(t2):
                                    return Kl_Long
                                if IsLong(t1) and IsLong(t2):
                                    return Kl_Long
                                if IsInt(t1) and IsInt(t2):
                                    if t1[1][0] < 0 or t2[1][0] < 0:
                                        return Kl_Int
                                    assert type(t1) is tuple
                                    assert len(t1) == 2
                                    assert type(t1[1]) is tuple
                                    assert len(t1[1]) == 2
                                    assert type(t1[1][0]) is int
                                    assert type(t1[1][1]) is int
                                    assert type(t2) is tuple
                                    assert len(t2) == 2
                                    assert type(t2[1]) is tuple
                                    assert len(t2[1]) == 2
                                    assert type(t2[1][0]) is int
                                    assert type(t2[1][1]) is int
                                    if t1[1][0] >= 0 and t1[1][1] >= 0 and t2[1][0] >= 0 and t2[1][1] >= 0:
                                        le = max(len(bin(t1[1][0])), len(bin(t1[1][1])), len(bin(t2[1][0])), len(bin(t2[1][0]))) - 2
                                        ir = 1
                                        while le > 1:
                                            le -= 1
                                            ir = ir << 1
                                            ir += 1
                                        assert ir <= MInt
                                        return (int, (0, ir))
                                    if t1 == t2:
                                        return t1
                                    if t1[1][1] == t1[1][0] == 0:
                                        return t2
                                    if t2[1][1] == t2[1][0] == 0:
                                        return t1   
                                    if t1[1][1] == t1[1][0] and t2[1][1] == t2[1][0]:
                                        return Int(t1[1][1] | t2[1][1], t1[1][1] | t2[1][1])
                                    if t1[1][1] == t1[1][0] == (-MInt)-1:
                                        return Int((-MInt)-1, -1)
                                    if t2[1][1] == t2[1][0] == (-MInt)-1:
                                        return Int((-MInt)-1, -1)
                                    if t2[1][1] == t2[1][0] and t1[1][0] != t1[1][1]:
                                        t1, t2 = t2, t1
                                    if t1[1][1] == t1[1][0] and t2[1][0] != t2[1][1]:
                                        _min = None
                                        _max = None
                                        rng1, rng2 = t2[1][0], t2[1][1]
                                        assert type(rng1) is int
                                        assert type(rng2) is int
                                        pp('range(', hex(rng1), ', ', hex(rng2), ')')
                                        for i3 in range(rng1, rng2):
                                            val3 = t1[1][0] | i3
                                            if _min is None or _min > val3:
                                                _min = val3
                                            if _max is None or _max < val3:
                                                _max = val3
                                        if type(_min) is int and type(_max) is int:
                                            return Int(_min, _max)
                                    if t1[1][0] < 0 and t2[1][0] < 0 and t1[1][1] > 0 and t2[1][1] > 0:
                                        le = max(len(bin(t1[1][1])), len(bin(t2[1][1]))) - 2
                                        ir = 1
                                        while le > 1:
                                            le -= 1
                                            ir = ir << 1
                                            ir += 1
                                        assert ir <= MInt
                                        le = max(len(bin(t1[1][0])), len(bin(t2[1][0]))) - 3
                                        ir2 = -1
                                        while le > 1:
                                            le -= 1
                                            ir2 = ir2 << 1
                                        assert ir2 >= ((-MInt) - 1)
                                        return (int, (ir2, ir))
                                    pp(ret)
                                    pp('??', '=', t1, '|', t2)
                                if IsShort(t1) and IsShort(t2):
                                    return Kl_Short
                                if IsInt(t1) and IsInt(t2):
                                    return Kl_Int
                                if IsBool(t1) and IsBool(t2):
                                    return Kl_Boolean
                                if IsIntUndefSize(t1) or IsIntUndefSize(t2):
                                    return Kl_IntUndefSize

                            if ret0 in ('!PyNumber_And', '!PyNumber_InPlaceAnd'):
                                if IsInt(t1) and IsInt(t2):
                                    if t1[1][0] < 0 or t2[1][0] < 0:
                                        return Kl_Int

                                    if t1[1][0] >= 0 and t1[1][1] >= 0 and t2[1][0] >= 0 and t2[1][1] >= 0:
                                        le = min(len(bin(t1[1][1])), len(bin(t2[1][1]))) - 2
                                        ir = 1
                                        while le > 1:
                                            le -= 1
                                            ir = ir << 1
                                            ir += 1
                                        assert ir <= MInt
                                        return (int, (0, ir))
                                    if t1[1][0] < 0 and t1[1][1] > 0 and t2[1][0] >= 0 and t2[1][1] >= 0 and t2[1][1] == t2[1][0]:
                                        le = min(len(bin(t2[1][1])), len(bin(t1[1][1]))) - 2
                                        ir = 1
                                        while le > 1:
                                            le -= 1
                                            ir = ir << 1
                                            ir += 1
                                        assert ir <= MInt
                                        return (int, (0, ir))
                                    if t1[1][0] < 0 and t2[1][1] == t2[1][0] >= 0:
                                        return Int(0, t2[1][1])
                                    if t2[1][0] < 0 and t1[1][1] == t1[1][0] >= 0:
                                        return Int(0, t1[1][1])   
                                    if t1[1][1] == t1[1][0] and t2[1][1] == t2[1][0]:
                                        return Int(t1[1][1] & t2[1][1], t1[1][1] & t2[1][1])                             
                                    pp(ret)
                                    pp('??', '=', t1, '&', t2)
                                if IsIntUndefSize(t1) and IsIntUndefSize(t2):
                                    return Kl_IntUndefSize
                                if IsLong(t1) and IsLong(t2):
                                    return Kl_Long
                                if IsShort(t1) and IsInt(t2):
                                    return Kl_Short
                                if IsShort(t2) and IsInt(t1):
                                    return Kl_Short
                                if IsLong(t1) and IsInt(t2):
                                    return Kl_Long
                                if IsLong(t2) and IsInt(t1):
                                    return Kl_Long
                                
                                if IsBool(t1) and IsBool(t2):
                                    return Kl_Boolean
                                if IsIntUndefSize(t1) and IsLong(t2):
                                    return Kl_IntUndefSize
                                if IsIntUndefSize(t2) and IsLong(t1):
                                    return Kl_IntUndefSize
                                if (t1 is None or IsIntUndefSize(t1) or IsLong(t1)) and IsInt(t2):
                                    return t1
                                if (t2 is None or IsIntUndefSize(t2) or IsLong(t2)) and IsInt(t1):
                                    return t2
                                if t1 is not None and t1[0] == 'Raise':
                                    return t1
                                ##global _n2c
                                if '__and__' not in _n2c and '__rand__' not in _n2c and '__coerce__' not in _n2c:
                                    if t1 is None and IsInt(t2) and ret[2][0] == 'CONST' and t2[1][1] >= 0:
                                        return Int(0, t2[1][1])
                                    if t2 is None and IsInt(t1) and ret[1][0] == 'CONST' and t1[1][1] >= 0:
                                        return Int(0, t1[1][1])
                                    if IsIntUndefSize(t1) and IsInt(t2) and ret[2][0] == 'CONST' and t2[1][1] >= 0:
                                        return Int(0, t2[1][1])
                                    if IsIntUndefSize(t1) and IsInt(t1) and ret[1][0] == 'CONST' and t1[1][1] >= 0:
                                        return Int(0, t1[1][1])

                                    if ret[2][0] == 'CONST' and (type(ret[2][1]) is int or type(ret[2][1]) is long) and ret[2][1] >= 0 and ret[2][1] <= 0xffff:
                                        if t1 is not None:
                                            pprint(ret)
                                            pp('TypeExpr And', t1)
                                            return Kl_Short
                                    if ret[2][0] == 'CONST' and (type(ret[2][1]) is int or type(ret[2][1]) is long) and ret[2][1] >= 0 and ret[2][1] <= 0x7fffffff:
                                        if t1 is not None:
                                            pprint(ret)
                                            pp('TypeExpr And', t1)
                                            return Kl_Int
                                    if ret[1][0] == 'CONST' and (type(ret[1][1]) is int or type(ret[1][1]) is long) and ret[1][1] >= 0 and ret[1][1] <= 0xffff:
                                        if t2 is not None:
                                            pprint(ret)
                                            pp('TypeExpr And', t1)
                                            return Kl_Short
                                    if ret[1][0] == 'CONST' and (type(ret[1][1]) is int or type(ret[1][1]) is long) and ret[1][1] >= 0 and ret[1][1] <= 0x7fffffff:
                                        if t2 is not None:
                                            pprint(ret)
                                            pp('TypeExpr And', t1)
                                            return Kl_Int
                        if ret0 in ('!PyNumber_Add', '!PyNumber_InPlaceAdd'):
                            t1 = TypeExpr(ret[1])
                            t2 = TypeExpr(ret[2])
                            if IsLong(t1) and IsInt(t2):
                                return Kl_Long
                            if IsInt(t1) and IsLong(t2):
                                return Kl_Long
                            if IsLong(t1) and IsLong(t2):
                                return Kl_Long
                            if IsInt(t1) and IsIntUndefSize(t2):
                                return Kl_IntUndefSize
                            if IsIntUndefSize(t1) and IsInt(t2):
                                return Kl_IntUndefSize
                            if IsInt(t1) and IsInt(t2):
                                _t0 = t1[1][0] + t2[1][0]
                                _t1 = t1[1][1] + t2[1][1]  
                                return detect_long_subint(Int(_t0, _t1))
                            if IsInt(t1) and IsMayBe(t2) and IsInt(t2[1]):
                                _t0 = t1[1][0] + t2[1][1][0]
                                _t1 = t1[1][1] + t2[1][1][1]  
                                return detect_long_subint(Int(_t0, _t1))
                            if IsInt(t2) and IsMayBe(t1) and IsInt(t1[1]):
                                _t0 = t1[1][1][0] + t2[1][0]
                                _t1 = t1[1][1][1] + t2[1][1]  
                                return detect_long_subint(Int(_t0, _t1))
                                
                            if Kl_Float == t1 and IsMayBeFloat(t2):
                                return Kl_Float
                            if Kl_Float == t2 and IsMayBeFloat(t1):
                                return Kl_Float        
                            if IsInt(t1) and IsMayBeFloat(t2):
                                return Kl_Float
                            if IsInt(t2) and IsMayBeFloat(t1):
                                return Kl_Float 
                            if IsBool(t1) and IsInt(t2):
                                return detect_long_subint(Int(t2[1][0], t2[1][1]+1))
                            if IsBool(t2) and IsInt(t1):
                                return detect_long_subint(Int(t1[1][0], t1[1][1]+1))
                            if IsBool(t1) and IsBool(t2):
                                return Int(0,2)

                            if IsFloat(t1) and IsFloat(t2):
                                return Kl_Float
                            if IsInt(t1) and IsFloat(t2):
                                return Kl_Float
                            if IsInt(t2) and IsFloat(t1):
                                return Kl_Float
                            if IsIntUndefSize(t1) and IsFloat(t2):
                                return Kl_Float
                            if IsIntUndefSize(t2) and IsFloat(t1):
                                return Kl_Float

                            if IsIntUndefSize(t1) and IsInt(t2):
                                return Kl_IntUndefSize
                            if IsIntUndefSize(t2) and IsInt(t1):
                                return Kl_IntUndefSize
                            if IsIntUndefSize(t2) and IsLong(t1):
                                return Kl_Long
                            if IsIntUndefSize(t1) and IsLong(t2):
                                return Kl_Long
                            if IsIntUndefSize(t1) and IsIntUndefSize(t2):
                                return Kl_IntUndefSize
                            if IsTuple(t1) and IsTuple(t2):
                                t1_1 = t1[1]
                                t2_1 = t2[1]
                                if t1_1 is not None and t2_1 is not None:
                                    if type(t1_1) is int and type(t2_1) is int:
                                        return (tuple, t1_1 + t2_1)
                                    if type(t1_1) is int and type(t2_1) is tuple:
                                        return (tuple, t1_1 + len(t2_1))
                                    if type(t1_1) is tuple and type(t2_1) is int:
                                        return (tuple, len(t1_1) + t2_1)
                                    if type(t1_1) is tuple and type(t2_1) is tuple:
                                        return (tuple, t1_1 + t2_1)
                                if t1_1 is None and type(t2_1) is tuple:
                                    return (tuple, len(t2_1))
                                if t1_1 is None and type(t2_1) is int:
                                    return (tuple, t2_1)
                                if type(t1_1) is int and t2_1 is None:
                                    return (tuple, t1_1)
                                if type(t1_1) is tuple and t2_1 is None:
                                    return (tuple, len(t1_1))
                                return Kl_Tuple
                            if IsTuple(t1) and ret[2][0] == '!PySequence_GetSlice':
                                return t1
                            if IsTuple(t2) and ret[1][0] == '!PySequence_GetSlice':
                                return Kl_Tuple        

                            if IsList(t1) and IsList(t2):
                                return Kl_List
                            if IsMayBe(t1) and IsList(t1[1]) and IsList(t2):
                                return Kl_List
                            if IsMayBe(t1) and IsList(t1[1]) and IsMayBe(t2) and IsList(t2[1]):
                                return Kl_List
                            if IsList(t1) and IsMayBe(t2) and IsList(t2[1]):
                                return Kl_List
                            ## if IsList(t1) and t2 is None:
                                ## return Kl_Sequence
                            ## if IsList(t2) and t1 is None:
                                ## return Kl_Sequence
                            if IsStr(t1) and IsStr(t2):
                                return Kl_String
                            if IsMayBe(t1) and IsStr(t2) and IsStr(t1[1]):
                                return Kl_String
                            if IsStr(t1) and IsMayBe(t2) and IsStr(t2[1]):
                                return Kl_String
                            if IsMayBe(t1) and IsStr(t1[1]) and IsStr(t1[1]) and IsMayBe(t2) and IsStr(t2[1]):
                                return Kl_String
                            if IsUnicode(t1) and IsUnicode(t2):
                                return Kl_Unicode
                            if IsStr(t1) and IsUnicode(t2):
                                return Kl_Unicode
                            if IsUnicode(t1) and IsStr(t2):
                                return Kl_Unicode
                            if IsArray(t1) and IsArray(t2):
                                if t1[1] == t2[1]:
                                    return t1
                                return Kl_Array
                            if IsBuffer(t1) and IsBuffer(t2):
                                return Kl_Buffer        
                            ## if ret[2][0] == '!PySequence_GetSlice' or ret[1][0] == '!PySequence_GetSlice':
                                ## return Kl_Sequence
                            ## ## if t1 is None and t2 is not None and t2[0] == 'Not':
                                ## ## return t2
                            ## ## if t2 is None and t1 is not None and t1[0] == 'Not':
                                ## ## return t1
                            ## if IsTuple(t1) or IsTuple(t2):
                                ## return Kl_Sequence
                            ## if IsStr(t1) or IsStr(t2):
                                ## return Kl_Sequence
                            ## if IsSequence(t1) or IsSequence(t2):
                                ## return Kl_Sequence        
                            return None
                        if (ret0 == '!PyNumber_Multiply' or ret0 == '!PyNumber_InPlaceMultiply'):
                            t1 = TypeExpr(ret[1])
                            t2 = TypeExpr(ret[2])
                            if IsBool(t1):
                                if IsInt(t2):
                                    li = [0 * t2[1][0], 0 * t2[1][1], 1 * t2[1][0], 1 * t2[1][1]]
                                    if (0 >= 0 and 0 <= 1) or (0 >= t2[1][0] and 0 <= t2[1][1]):
                                        li.append(0)
                                    li.sort()
                                    return detect_long_subint(Int(li[0], li[-1]))                
                                if IsFloat(t2) or IsIntUndefSize(t2):
                                    return t2
                            if IsBool(t2):
                                if IsInt(t1):
                                    li = [t1[1][0] * 0, t1[1][0] * 1, t1[1][1] * 0, t1[1][0] * 1]
                                    if (0 >= t1[1][0] and 0 <= t1[1][1]) or (0 >= 0 and 0 <= 1):
                                        li.append(0)
                                    li.sort()
                                    return detect_long_subint(Int(li[0], li[-1]))
                                    
                                    return Kl_Int
                                if IsFloat(t1) or IsIntUndefSize(t1):
                                    return t1

                            if IsIntUndefSize(t1) and IsLong(t2):
                                return Kl_Long
                            if IsIntUndefSize(t2) and IsLong(t1):
                                return Kl_Long
                            if IsInt(t1) and IsInt(t2):
                                li = [t1[1][0] * t2[1][0], t1[1][0] * t2[1][1], t1[1][1] * t2[1][0], t1[1][1] * t2[1][1]]
                                if (0 >= t1[1][0] and 0 <= t1[1][1]) or (0 >= t2[1][0] and 0 <= t2[1][1]):
                                    li.append(0)
                                li.sort()
                                return detect_long_subint(Int(li[0], li[-1]))
                            if IsInt(t1) and IsFloat(t2):
                                return Kl_Float
                            if IsInt(t2) and IsFloat(t1):
                                return Kl_Float    
                            if IsLong(t1) and IsFloat(t2):
                                return Kl_Float
                            if IsLong(t2) and IsFloat(t1):
                                return Kl_Float    
                            if IsIntUndefSize(t1) and IsFloat(t2):
                                return Kl_Float
                            if IsIntUndefSize(t2) and IsFloat(t1):
                                return Kl_Float    
                            
                        if ret0 in ('!PyNumber_InPlaceDivide', '!PyNumber_InPlaceFloorDivide', '!PyNumber_InPlaceRemainder',\
                                      '!PyNumber_Divide', '!PyNumber_FloorDivide', '!PyNumber_Remainder'):
                            t1 = TypeExpr(ret[1])
                            t2 = TypeExpr(ret[2])
                            if IsLong(t1) and IsLong(t2):
                                return Kl_Long
                            if IsComplex(t1) and IsComplex(t2):
                                return Kl_Complex
                            if IsInt(t1) and IsInt(t2):
                                if t2[1][1] == t2[1][0] and type(t1[1][1]) is int and type(t1[1][0]) is int and t2[1][0] != 0:
                                    if ret0 in ('!PyNumber_InPlaceDivide', '!PyNumber_Divide'):
                                        if t1[1][1] == t1[1][0]:
                                            return detect_long_subint((int, MinMaxDivRem('/', t1[1][0], t1[1][1], t2[1][0], t2[1][1])))
                                        te = [t1[1][0] / t2[1][0], t1[1][1] / t2[1][0]]
                                        te.sort()
                                        return detect_long_subint((int, tuple(te)))
                                    if ret0 in ('!PyNumber_InPlaceFloorDivide', '!PyNumber_FloorDivide'):
                                        if t1[1][1] == t1[1][0]:
                                            return detect_long_subint((int, MinMaxDivRem('//', t1[1][0], t1[1][1], t2[1][0], t2[1][1])))
                                        te = [t1[1][0] // t2[1][0], t1[1][1] // t2[1][0]]
                                        te.sort()
                                        return detect_long_subint((int, tuple(te)))
                                if type(t2[1][1]) is int and type(t2[1][0]) is int and ret0 in ('!PyNumber_InPlaceRemainder', '!PyNumber_Remainder'):
                                    return detect_long_subint((int, MinMaxDivRem('%', t1[1][0], t1[1][1], t2[1][0], t2[1][1])))
                                if t1[1][1] != t1[1][0] and t2[1][1] != t2[1][0] and type(t1[1][1]) is int and type(t1[1][0]) is int and type(t2[1][1]) is int and type(t2[1][0]) is int:
                                    if ret0 in ('!PyNumber_InPlaceDivide', '!PyNumber_Divide'):
                                        return detect_long_subint((int, MinMaxDivRem('/', t1[1][0], t1[1][1], t2[1][0], t2[1][1])))
                                    if ret0 in ('!PyNumber_InPlaceFloorDivide', '!PyNumber_FloorDivide'):
                                        return detect_long_subint((int, MinMaxDivRem('//', t1[1][0], t1[1][1], t2[1][0], t2[1][1])))
                                    if ret0 in ('!PyNumber_InPlaceRemainder', '!PyNumber_Remainder'):
                                        return detect_long_subint((int, MinMaxDivRem('%', t1[1][0], t1[1][1], t2[1][0], t2[1][1])))
                                if t1[1][1] == t1[1][0] and t2[1][1] != t2[1][0] and type(t1[1][1]) is int and type(t1[1][0]) is int and type(t2[1][1]) is int and type(t2[1][0]) is int:
                                    if ret0 in ('!PyNumber_InPlaceDivide', '!PyNumber_Divide'):
                                        return detect_long_subint((int, MinMaxDivRem('/', t1[1][0], t1[1][1], t2[1][0], t2[1][1])))
                                    if ret0 in ('!PyNumber_InPlaceFloorDivide', '!PyNumber_FloorDivide'):
                                        return detect_long_subint((int, MinMaxDivRem('//', t1[1][0], t1[1][1], t2[1][0], t2[1][1])))
                                    if ret0 in ('!PyNumber_InPlaceRemainder', '!PyNumber_Remainder'):
                                        return detect_long_subint((int, MinMaxDivRem('%', t1[1][0], t1[1][1], t2[1][0], t2[1][1])))

                                if t2[1][1] == t2[1][0] and t1[1][1] is None and type(t1[1][0]) is int and t2[1][0] != 0:
                                    if t2[1][0] > 0 and t2[1][0] <= 255:
                                        if ret0 in ('!PyNumber_InPlaceDivide', '!PyNumber_Divide'):
                                            return t1
                                        if ret0 in ('!PyNumber_InPlaceFloorDivide', '!PyNumber_FloorDivide'):
                                            return t1
                                if t2[1][0] == t2[1][1] and t2[1][1] == 0:
                                    return None
                                pp('IntDivRem', t1, t2, ret)
                                return Kl_Int
                            if ret0 == '!PyNumber_TrueDivide':
                                if IsFloat(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsInt(t1) and IsLong(t2):
                                    return Kl_Long
                                if IsLong(t1) and IsInt(t2):
                                    return Kl_Long
                                if IsLong(t2) and IsLong(t2):
                                    return Kl_Long
                            if ret0 == '!PyNumber_Remainder':
                                if IsStr(t1):
                                    return Kl_String  
                                if IsFloat(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsFloat(t1) and IsInt(t2):
                                    return Kl_Float
                                if IsIntUndefSize(t1) and IsInt(t2):
                                    return Kl_IntUndefSize          
                                if IsLong(t1) and IsInt(t2):
                                    return Kl_Long    
                                if IsInt(t1) and IsLong(t2):
                                    return Kl_Long    
                                if IsUnicode(t1) and IsStr(t2):
                                    return Kl_Unicode
                                if IsUnicode(t1) and IsInt(t2):
                                    return Kl_Unicode
                                if IsUnicode(t1) and IsTuple(t2):
                                    return Kl_Unicode                        
                                if IsUnicode(t1) and IsUnicode(t2):
                                    return Kl_Unicode                        
                                if IsUnicode(t1) and IsDict(t2):
                                    return Kl_Unicode                        
                                if IsUnicode(t1) and IsIntUndefSize(t2):
                                    return Kl_Unicode                        

                        if ret0 in ('!PyNumber_Multiply', '!PyNumber_Divide', '!PyNumber_FloorDivide', \
                                    '!PyNumber_InPlaceFloorDivide', '!PyNumber_InPlaceDivide', \
                                    '!PyNumber_Subtract', '!PyNumber_InPlaceSubtract', '!PyNumber_InPlaceMultiply'):
                            t1 = TypeExpr(ret[1])
                            t2 = TypeExpr(ret[2])
                            if IsBool(t1) and (ret0 == '!PyNumber_Multiply' or ret0 == '!PyNumber_InPlaceMultiply'):
                                return t2
                            if Kl_Float == t1 and IsMayBeFloat(t2):
                                return Kl_Float
                            if Kl_Float == t2 and IsMayBeFloat(t1):
                                return Kl_Float        
                            if IsInt(t1) and IsMayBeFloat(t2):
                                return Kl_Float
                            if IsInt(t2) and IsMayBeFloat(t1):
                                return Kl_Float          
                            if IsFloat(t1) and IsFloat(t2):    
                                    return Kl_Float
                            if IsInt(t1) and IsFloat(t2):
                                return Kl_Float
                            if IsInt(t2) and IsFloat(t1):
                                return Kl_Float    
                            if IsIntUndefSize(t1) and IsFloat(t2):
                                return Kl_Float
                            if IsIntUndefSize(t2) and IsFloat(t1):
                                return Kl_Float    

                            if IsLong(t1) and IsIntUndefSize(t2):
                                return Kl_Long

                            if ret0 in ('!PyNumber_InPlaceSubtract', '!PyNumber_Subtract'):
                                if IsFloat(t1) and IsLong(t2):
                                    return  Kl_Float
                                if IsLong(t1) and IsFloat(t2):
                                    return  Kl_Float
                                if IsBool(t1) and IsBool(t2):
                                    return (int, (-1, 1))
                                if IsIntUndefSize(t1) and IsLong(t2):
                                    return Kl_Long
                                if IsLong(t1) and IsIntUndefSize(t2):
                                    return Kl_Long
                                if IsLong(t1) and IsInt(t2):
                                    return Kl_Long
                                if IsInt(t1) and IsLong(t2):
                                    return Kl_Long
                                if IsLong(t1) and IsLong(t2):
                                    return Kl_Long
                                if IsSet(t1) and IsSet(t2):
                                    return Kl_Set 
                                if IsFrozenSet(t1) and IsFrozenSet(t2):
                                    return Kl_FrozenSet           
                                if IsSet(t1) and IsFrozenSet(t2):
                                    return Kl_Set 
                                if IsFrozenSet(t1) and IsSet(t2):
                                    return Kl_FrozenSet   
                                if IsInt(t1) and IsIntUndefSize(t2):
                                    return Kl_IntUndefSize
                                if IsIntUndefSize(t1) and IsInt(t2):
                                    return Kl_IntUndefSize

                                if IsInt(t1) and IsBool(t2):
                                    if type(t1[1][0]) is int and type(t1[1][1]) is int:
                                        return detect_long_subint(Int(int(t1[1][0]-1), int(t1[1][1])))
                                if IsInt(t1) and IsInt(t2) :
                                    li = [int(t1[1][0] - t2[1][1]), int(t1[1][1] - t2[1][0]), int(t1[1][0] - t2[1][1]), int(t1[1][1] - t2[1][1])]
                                    li.sort()     
                                    return detect_long_subint(Int(li[0], li[-1]))
                                if IsInt(t1) and IsMayBe(t2) and IsInt(t2[1]) :
                                    t2 = t2[1]
                                    li = [int(t1[1][0] - t2[1][1]), int(t1[1][1] - t2[1][0]), int(t1[1][0] - t2[1][1]), int(t1[1][1] - t2[1][1])]
                                    li.sort()     
                                    return detect_long_subint(Int(li[0], li[-1]))
                                if IsInt(t2) and IsMayBe(t1) and IsInt(t1[1]) :
                                    t1 = t1[1]
                                    li = [int(t1[1][0] - t2[1][1]), int(t1[1][1] - t2[1][0]), int(t1[1][0] - t2[1][1]), int(t1[1][1] - t2[1][1])]
                                    li.sort()     
                                    return detect_long_subint(Int(li[0], li[-1]))

                                if IsFloat(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsInt(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsIntUndefSize(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsInt(t2) and IsFloat(t1):
                                    return Kl_Float
                                if IsIntUndefSize(t2) and IsFloat(t1):
                                    return Kl_Float

                                if IsIntUndefSize(t1) and IsInt(t2):
                                    return Kl_IntUndefSize
                                if IsIntUndefSize(t2) and IsInt(t1):
                                    return Kl_IntUndefSize
                                if IsIntUndefSize(t1) and IsIntUndefSize(t2):
                                    return Kl_IntUndefSize
                                
                                return None
                            
                            if ret0 == '!PyNumber_Multiply' or ret0 == '!PyNumber_InPlaceMultiply':
                                assert not IsInt(t1) or not IsInt(t2)
                                if IsInt(t1) and IsArray(t2):
                                    return t2
                                if IsArray(t1) and IsInt(t2):
                                    return t1
                                if IsTuple(t1) and IsIntUndefSize(t2):
                                    return Kl_Tuple
                                if IsTuple(t2) and IsIntUndefSize(t1):
                                    return Kl_Tuple
                                if IsList(t1) and IsIntUndefSize(t2):
                                    return t1
                                if IsList(t2) and IsIntUndefSize(t1):
                                    return t2
                                if IsTuple(t1) and IsInt(t2):
                                    return Kl_Tuple
                                if IsTuple(t2) and IsInt(t1):
                                    return Kl_Tuple
                                if IsList(t1) and IsInt(t2):
                                    return t1
                                if IsList(t2) and IsInt(t1):
                                    return t2
                                if IsInt(t1) and IsLong(t2):
                                    return Kl_Long
                                if IsLong(t1) and IsInt(t2):
                                    return Kl_Long
                                if IsFloat(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsInt(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsInt(t2) and IsFloat(t1):
                                    return Kl_Float
                                if IsIntUndefSize(t2) and IsFloat(t1):
                                    return Kl_Float
                                if IsIntUndefSize(t1) and IsFloat(t2):
                                    return Kl_Float

                                if IsIntUndefSize(t1) and IsInt(t2):
                                    return Kl_IntUndefSize
                                if IsIntUndefSize(t2) and IsInt(t1):
                                    return Kl_IntUndefSize
                                if IsIntUndefSize(t1) and IsIntUndefSize(t2):
                                    return Kl_IntUndefSize
                                if IsIntUndefSize(t1) and IsStr(t2):
                                    return Kl_String
                                if IsIntUndefSize(t2) and IsStr(t1):
                                    return Kl_String
                                if IsInt(t1) and IsStr(t2):
                                    return Kl_String
                                if IsInt(t2) and IsStr(t1):
                                    return Kl_String
                                ## if IsInt(t1) and IsSequence(t2):
                                    ## return Kl_Sequence
                                ## if IsInt(t2) and IsSequence(t1):
                                    ## return Kl_Sequence      
                            

                                    
                            if ret0 == '!PyNumber_FloorDivide':
                                if IsInt(t1) and IsInt(t2) and t2[1][0] == t2[1][1] and type(t1[1][0]) is int and type(t1[1][1]) is int:
                                    return detect_long_subint(Int(t1[1][0]//t2[1][1], t1[1][1]//t2[1][1]))
                                if IsShort(t1) and IsShort(t2):
                                    return Kl_Short

                                if IsFloat(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsInt(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsInt(t2) and IsFloat(t1):
                                    return Kl_Float
                                if IsIntUndefSize(t2) and IsFloat(t1):
                                    return Kl_Float
                                if IsIntUndefSize(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsIntUndefSize(t1) and IsInt(t2):
                                    return Kl_IntUndefSize
                                if IsIntUndefSize(t2) and IsInt(t1):
                                    return Kl_Int
                                if IsIntUndefSize(t1) and IsIntUndefSize(t2):
                                    return Kl_IntUndefSize

                            if ret0 == '!PyNumber_Divide':
                                if IsInt(t1) and IsInt(t2) and t2[1][0] == t2[1][1] and type(t2[1][1]) is int and t2[1][1] != 0:
                                    _t3 = list(t1[1])
                                    if _t3[0] is None:
                                        _t3[0] = int(-MInt / t2[1][1])
                                    else:
                                        _t3[0] = int(_t3[0] / t2[1][1])
                                    if _t3[1] is None:
                                        _t3[1] = int(MInt / t2[1][1])
                                    else:
                                        _t3[1] = int(_t3[1] / t2[1][1])
                                    return detect_long_subint((int, tuple(_t3)))
                                if IsShort(t1) and IsShort(t2):
                                    return Kl_Short
                                if IsShort(t1) and IsInt(t2):
                                    return Kl_Short
                                if IsFloat(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsInt(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsInt(t2) and IsFloat(t1):
                                    return Kl_Float
                                if IsIntUndefSize(t2) and IsFloat(t1):
                                    return Kl_Float
                                if IsIntUndefSize(t1) and IsFloat(t2):
                                    return Kl_Float
                                if IsIntUndefSize(t1) and IsInt(t2):
                                    return Kl_IntUndefSize
                                if IsIntUndefSize(t2) and IsInt(t1):
                                    return Kl_Int
                                if IsIntUndefSize(t1) and IsIntUndefSize(t2):
                                    return Kl_IntUndefSize
                                
                            ## if IsIntUndefSize(t1) and IsShort(t2):
                                ## return Kl_IntUndefSize
                            ## if IsIntUndefSize(t2) and IsShort(t1):
                                ## return Kl_IntUndefSize
                            if IsIntUndefSize(t1) and IsInt(t2):
                                return Kl_IntUndefSize
                            if IsIntUndefSize(t2) and IsInt(t1):
                                return Kl_IntUndefSize
                            if IsIntUndefSize(t1) and IsIntUndefSize(t2):
                                return Kl_IntUndefSize

                    if ret0 in \
                        ('!PyNumber_InPlaceMultiply', '!PyNumber_InPlaceSubtract', '!PyNumber_Subtract', '!PyNumber_Multiply'):
                        t1 = TypeExpr(ret[1])
                        t2 = TypeExpr(ret[2])
                        if IsInt(t1) and IsInt(t2) :
                            assert False  
                        if IsLong(t1) and IsLong(t2):
                            return Kl_Long  

                    if ret0 == '!PyNumber_Power':
                # ??? complex number ???
                        t1 = TypeExpr(ret[1])
                        t2 = TypeExpr(ret[2])
                        t3 = TypeExpr(ret[3])
                        ## if Kl_Float == t1:
                           ## return Kl_Float
                        ## if ret[2][0] == 'CONST' and type(ret[2][1]) is not complex and ret[2][1] < 0:
                            ## return Kl_Float
                        if Kl_None == t3:
                            if IsFloat(t1) and IsFloat(t2):
                                return Kl_Float
                            if IsInt(t1) and IsInt(t2):
                                assert type(t1) is tuple
                                assert type(t2) is tuple
                                assert len(t1) == 2
                                assert len(t2) == 2
                                if t1[1][0] == t1[1][1] and t2[1][0] == t2[1][1]:
                                    tmp = pow(t1[1][0], t2[1][0]) 
                                    if type(tmp) is int:
                                        return (int, (tmp, tmp))
                                    elif type(tmp) is long:
                                        return Kl_Long
                                    elif type(tmp) is float:
                                        return Kl_Float
                                if t2[1][0] == t2[1][1] and t2[1][1] >= 0:
                                    li = [pow(t1[1][0], t2[1][1]), pow(t1[1][1], t2[1][1])]
                                    if type(li[1]) is int and type(li[0]) is int:
                                        li.sort()
                                        return (int, (li[0], li[1]))
                                    if (type(li[1]) is int and type(li[0]) is long) or (type(li[1]) is long and type(li[0]) is int) or (type(li[1]) is long and type(li[0]) is long):
                                        return Kl_IntUndefSize
                                    pp('0000-0', li)
                                if t1[1][0] == t1[1][1] and t2[1][0] >= 0 and t1[1][0] > 0:
                                    max_exp = math.log(MInt, t1[1][0])
                                    if max_exp < t2[1][0] or max_exp < t2[1][1]:
                                        return Kl_IntUndefSize
                                    li = [pow(t1[1][0], t2[1][0]), pow(t1[1][1], t2[1][1])]
                                    if type(li[1]) is int and type(li[0]) is int:
                                        li.sort()
                                        return (int, (li[0], li[1]))
                                    if (type(li[0]) is int and type(li[1]) is long) or (type(li[1]) is int and type(li[0]) is long) or (type(li[1]) is long and type(li[0]) is long):
                                        return Kl_IntUndefSize
                                if t1[1][0] != t1[1][1] and t2[1][0] != t2[1][1]:
                                    if t2[1][0] >= 0 and t1[1][0] < 0:
                                        rng1, rng2 = t2[1][0], t2[1][1]+1
                                        assert type(rng1) is int
                                        assert type(rng2) is int                                        
                                        tu = (min([pow(t1[1][0], x) for x in range(rng1, rng2)]), max([pow(t1[1][1], x) for x in range(rng1, rng2)]))
                                        if type(tu[0]) is int and type(tu[1]) is int:
                                            return (int, tu)
                                        elif (type(tu[0]) is long and type(tu[1]) is int) or (type(tu[0]) is int and type(tu[1]) is long) or (type(tu[0]) is long and type(tu[1]) is long):
                                            return Kl_IntUndefSize
                                if t2[1][0] < 0:
                                    if t2[1][1] < 0:
                                        return Kl_Float
                                    else:
                                        return None
                            if IsInt(t1) and IsLong(t2):
                                return Kl_Long
                            if IsLong(t1) and IsInt(t2):
                                return Kl_Long
                            if IsIntUndefSize(t1) and IsLong(t2):
                                return Kl_Long
                            if IsLong(t1) and IsIntUndefSize(t2):
                                return Kl_Long
                            if IsLong(t1) and IsLong(t2):
                                return Kl_Long
                            if IsInt(t1) and IsIntUndefSize(t2):
                                return Kl_IntUndefSize
                            if IsIntUndefSize(t1) and IsInt(t2):
                                return Kl_IntUndefSize
                            if IsIntUndefSize(t1) and IsIntUndefSize(t2):
                                return Kl_IntUndefSize
                            if IsInt(t1) and IsComplex(t2):
                                return Kl_Complex
                            if IsComplex(t1) and IsInt(t2):
                                return Kl_Complex
                            if IsComplex(t1) and IsComplex(t2):
                                return Kl_Complex
                            if IsFloat(t1) and IsInt(t2):
                                return Kl_Float
                            if IsOldInst(t1) and IsInt(t2):
                                return None
                            if IsOldInst(t2) and IsInt(t1):
                                return None
                        else:
                            if IsInt(t3) or IsLong(t3):
                                if IsInt(t1) and IsLong(t2):
                                    return Kl_Long
                                if IsLong(t1) and IsInt(t2):
                                    return Kl_Long
                                if IsLong(t1) and IsLong(t2):
                                    return Kl_Long
                            if t3 is None:
                                return None
                        if t1 is not None and t2 is not None and ret[3] != 'Py_None':
                            pp('?Power', t1,t2,t3, ret[3])
                        if t1 is not None and t2 is not None and ret[3] == 'Py_None':
                            pp('+Power', t1,t2, ret)
                                
                        return None

                if ret0 in ('!PyObject_Hash', '!PyInt_FromLong'):
                    return Kl_Int
                if ret0 == '!PY_SSIZE_T':
                    t1 = Kl_Cardinal
                    assert len(ret) > 1
                    if ret[1][0] == '!PyObject_Size':
                        t2 = TypeExpr(ret[1][1])
                        if t2 is None:
                            return Int(0, MInt / 20)
                        if t2 in (Kl_BuiltFunc, Kl_Function, Kl_StaticMethod, Kl_ClassMethod, Kl_Method, Kl_Long, Kl_Boolean, Kl_IntUndefSize, Kl_Float, Kl_None) or IsInt(t2):
                            Debug('%s:Attempt len() of strange type: %s' % (g_co.co_name, t2), ret)
                        if t2[0] == Kl_BuiltFunc[0]:
                            Debug('%s:Attempt len() of strange type: %s' % (g_co.co_name, t2), ret)
                        if t2 is not None:
                            if IsListAll(t2) or IsDict(t2) or t2[0] == 'Sequence' or IsUnicode(t2):
                                return Int(0, MInt / 20)
                            if IsStr(t2):
                                if t2[1] is not None:
                                    if type(t2[1]) is int:
                                        return Int(t2[1], t2[1])
                                    if type(t2[1]) is str:
                                        return Int(len(t2[1]), len(t2[1]))
                                return Int(0, MInt / 20)
                            if IsTuple(t2):
                                if t2[1] is not None:
                                    if type(t2[1]) is tuple:
                                        return Int(len(t2[1]), len(t2[1]))
                                    if type(t2[1]) is int:
                                        return Int(t2[1], MInt / 20)
                                    assert False
                                return Int(0, MInt / 20)
                            if IsSet(t2):
                                return Int(0, MInt / 20)
                            if IsFrozenSet(t2):
                                return Int(0, MInt / 20)
                            if IsMayBe(t2) and IsSequence(t2[1]):
                                return Int(0, MInt / 20)
                            if t2 == Kl_XRange:
                                return Kl_IntUndefSize
                            if t2 == Kl_None:
                                return None
                            if IsDict(t2):
                                return Int(0, MInt / 20)
                                
                        li = [c for a, b, c, isstaticmeth, isclassmeth, isderived in all_meth if a == t2[1] and b == '__len__']
                        if len(li) == 1:
                            if li[0] in detected_return_type:
                                t0 = detected_return_type[li[0]] 
                                if t0 == ('PSEVDO', 'self'):
                                    return t2
                                return t0
                                    
                                
                        if t2 is not None:
                            '/// size of ', t2, 'undefined'
                        return Int(0, MInt / 20)
                    if ret[1][0] =='!PyList_GET_SIZE':
                        return Int(0, MInt / 20)     
                    if ret[1][0] == '!PyTuple_GET_SIZE':
                        t2 = TypeExpr(ret[1][1])
                        assert IsTuple(t2)
                        if t2[1] is not None:
                            if type(t2[1]) is tuple:
                                return Int(len(t2[1]), len(t2[1]))
                            if type(t2[1]) is int:
                                return Int(t2[1], MInt / 20)
                            assert False
                        return Int(0, MInt / 20)
                    if ret[1][0] == '!PySet_Size':
                        return Int(0, MInt / 20)
                    if ret[1][0] == '!PyDict_Size':
                        return Int(0, MInt / 20)
                    if ret[1][0] == '!PyString_GET_SIZE':  
                        t2 = TypeExpr(ret[1][1])
                        assert IsStr(t2) 
                        if t2[1] is not None:
                            if type(t2[1]) is int:
                                return Int(t2[1], t2[1])
                            if type(t2[1]) is str:
                                return Int(len(t2[1]), len(t2[1]))
                            assert False
                        return Int(0, MInt / 10)  
                    if ret[1] == ('!LOAD_BUILTIN', 'False'):
                        return (int, (0,0))              
                    if ret[1] == ('!LOAD_BUILTIN', 'True'):
                        return (int, (1,1))              
            
                    t2 = TypeExpr(ret[1])
                    pp('len2->', t2, '---', ret)
                    if IsInt(t2):
                        return t2
                if ret0 in ('!PyObject_Size', '!PyString_GET_SIZE', '!PyString_Size', 
                      '!PySet_GET_SIZE', '!PySet_Size', '!PyList_GET_SIZE',
                      '!PyList_Size', '!PyTuple_GET_SIZE', '!PyTuple_Size', 
                      '!PyDict_Size', '!PyUnicode_GET_SIZE', '!PyUnicode_GetSize',
                      '!PyByteArray_GET_SIZE', '!PyByteArray_Size'):
                    return Int(0, MInt / 20)
                if ret0 in ('!PyDict_New', '!PyDict_Copy'):
                    return Kl_Dict
                if ret0 in ('!PyObject_Repr', '!PyString_Format', '!PyObject_Str', '!PyNumber_ToBase', '!PyInt_Type.tp_str'):
                    return Kl_String
                if ret0 in ('!PyDict_Keys', '!PyDict_Values', '!PyList_GetSlice', \
                        '!PySequence_List', '!PyObject_Dir'):
                    return Kl_List
                if ret0 in ('!PyList_AsTuple', '!PySequence_Tuple', '!PyTuple_GetSlice'):
                    return Kl_Tuple
                if ret0 == '!PyDict_Items':
                    return (list, (tuple,(None,None))) 
                if ret0 in ('!PyLong_Type.tp_new', '!PyNumber_Long'):
                    return Kl_Long
                if ret0 == '!PyInt_FromSsize_t':
                    return Kl_Short   
                if ret0 == '!PySet_New':
                    return Kl_Set
                if ret0 == '!PyFrozenSet_New':
                    return Kl_FrozenSet
                if ret0 == '!PySlice_New':
                    return Kl_Slice                                     
                if ret0 == '!PyObject_GetAttr' and ret[2][0] == 'CONST':
                    t1 = TypeExpr(ret[1])
                    if type(t1) is tuple:
                        if (t1, ret[2][1]) in attrs_type:
                            if attrs_type[(t1, ret[2][1])] is not None:
                                return attrs_type[(t1, ret[2][1])]
                        if (t1, ret[2][1]) in methods_type:
                            return (types.MethodType, (t1,ret[2][1]))
                        if t1[0] == 'MayBe':
                            t1 = t1[1]
                        if (t1, ret[2][1]) in attrs_type:
                            if attrs_type[(t1, ret[2][1])] is not None:
                                return attrs_type[(t1, ret[2][1])]
                        if (t1, ret[2][1]) in methods_type:
                            return (types.MethodType, (t1,ret[2][1]))

                        if IsAnyClass(t1[1]):
                            if ret[2][1] == '__dict__':
                                return Kl_Dict
                            if ret[2][1] == '__name__':
                                return Kl_String
                        elif t1[0] is types.ModuleType:
                            if ret[2][1] == '__dict__':
                                return Kl_Dict
                            if ret[2][1] == '__name__':
                                return Kl_String
                            tupl = (t1[1], ret[2][1], 'val')
                            if tupl in t_imp:
                                return t_imp[tupl]

                            if t1[1] in list_import:
                                d2 = list_import[t1[1]]
                                if ret[2][1] not in d2 and len(d2) != 0:
                                    Debug('Module attrib is not valid: %s -> %s ()' % (t1, ret[2][1]), ret)
                                if ret[2][1] in d2:
                                    t2 = d2[ret[2][1]]
                                    if t2[0] is types.ModuleType and t2[1] is None:
                                        nm2 = t1[1] + '.' + ret[2][1]
                                        CheckExistListImport(nm2)
                                        return (types.ModuleType, nm2)
                                    return t2
                                if len(d2) == 0:
                                    return None
                            Debug('Undefined type attrib: %s -> %s ()' % (t1, ret[2][1]), ret)
                            if IsKlNone(t1):
                                Fatal('')
                                assert False
                        elif t1[0] is type:
                            if ret[2][1] == '__name__':
                                return Kl_String
                        else:
                            Debug('Undefined type attrib: %s -> %s ()' % (t1, ret[2][1]), ret)
                            if IsKlNone(t1):
                                return None
                    if type(t1) is None:
                            if ret[2][1] == '__dict__':
                                return ('MayBe', Kl_Dict)
                            if ret[2][1] == '__name__':
                                return ('MayBe', Kl_String)
                    if detect_attr_type and ret[2][1] in detected_attr_type and not redefined_all:
                        r = detected_attr_type[ret[2][1]] 

                        if IsBuiltFunc(r) and (not IsModule(t1) or 'self' in repr(ret)):
                            if (IsList(t1) or IsTuple(t1) or IsDict(t1) or t1 == Kl_Set) and ret[2][1][:2] != '__':
                                return r
                            if t1 is not None:
                                Debug('May by CFunction attribute of %s ?' % repr(t1), ret)
                            return None
                        return r
                    return None
                if ret0 == '!PySequence_Repeat':
                        t1 = TypeExpr(ret[1])
                        if type(t1) is tuple:
                            if IsChar(t1):
                                    return Kl_String
                            if IsUnicodeChar(t1):
                                    return Kl_Unicode
                            if t1 is not None and t1[0] is tuple:
                                    return Kl_Tuple
                        return t1       
                if ret0 == '!PyObject_Call':
                    if ret[1][0] == '!LOAD_BUILTIN':
                        d2 = ret[1][1]
                        if d2 in ('max', 'min'):
                            if ret[2][0] == '!BUILD_TUPLE':
                                if len (ret[2][1]) == 2:
                                    t1 = TypeExpr(ret[2][1][0])
                                    t2 = TypeExpr(ret[2][1][1])
                                    if t1 == t2:
                                        return t1
                                    if IsInt(t1) and IsInt(t2):
                                        if d2 == 'max':
                                            return Int(max(t1[1][0], t2[1][0]), max(t1[1][1], t2[1][1]))
                                        else:
                                            return Int(min(t1[1][0], t2[1][0]), min(t1[1][1], t2[1][1]))
                                lis_t = uniq_list_type([TypeExpr(x) for x in ret[2][1]])
                                if len(lis_t) == 1:
                                    if len (ret[2][1]) == 1:
                                        return None
                                    return lis_t[0]
                            elif ret[2][0] == 'CONST':
                                if d2 == 'max':
                                    return TypeExpr(('CONST', max(ret[2][1])))
                                else:
                                    return TypeExpr(('CONST', min(ret[2][1])))
                        if d2 == 'sorted':
                            if ret[2][0] == '!BUILD_TUPLE' and len(ret[2][1]) == 1 and \
                               ret[3] == ('NULL',):
                                   t2 = TypeExpr(ret[2][1][0])
                                   if IsList(t2):
                                       return t2
                        if d2 == 'type' and ret[2][0] == '!BUILD_TUPLE' and len (ret[2][1]) == 1:
                            t1 = TypeExpr(ret[2][1][0])
                            return (Kl_Type[0], t1)
                        if d2 == 'super':
                            t1 = None
                            t2 = None
                            if ret[2][0] == '!BUILD_TUPLE' and len (ret[2][1]) == 2:
                                t1 = TypeExpr(ret[2][1][0])
                                t2 = TypeExpr(ret[2][1][1])
                                if t1 is not None and t2 is not None and t1[1] ==  t2[1]:
                                    if t2[0] == T_NEW_CL_INST and t2[1] in calculated_const and \
                                       len(calculated_const[t2[1]].derived_from.keys()) == 1 and \
                                       calculated_const[t2[1]].know_all_fathers:
                                        t1 = TypeExpr(calculated_const[t2[1]].derived_from.keys()[0])
                                        if t1 is not None and t1[0] == T_NEW_CL_TYP:
                                            assert False
                                            return (T_NEW_CL_INST, t1[1])
                                    if t2[0] == T_OLD_CL_INST and t2[1] in calculated_const and \
                                       len(calculated_const[t2[1]].derived_from.keys()) == 1 and \
                                       calculated_const[t2[1]].know_all_fathers:
                                        t1 = TypeExpr(calculated_const[t2[1]].derived_from.keys()[0])
                                        if t1 is not None and t1[0] == T_OLD_CL_TYP:
                                            assert False
                                            return (T_OLD_CL_INST, t1[1])
                        if d2 == 'compile':
                            if ret[2][0] == '!BUILD_TUPLE' and len (ret[2][1]) == 3:
                                return Kl_Code
                            if ret[2][0] == 'CONST' and len (ret[2][1]) == 3:
                                return Kl_Code
                        if d2 == 'ord':
                            if ret[2][0] == '!BUILD_TUPLE' and len(ret[2][1]) == 1 and IsStr(TypeExpr(ret[2][1][0])):
                                return (int, (0, 255))
                                            
                        if d2 in tag_builtin:
                            return tag_builtin[d2]
                        else:
                            Debug('Undefined type builtin: %s' % (d2,), ret)
                            return None
                    if ret[1][0] == 'CALC_CONST':    
                        nm = ret[1][1] 
                        if type(nm) is tuple and len(nm) == 2 and nm[0] in ImportedM:
                            tuplcall = (ImportedM[nm[0]], nm[1], '()')
                            if tuplcall in t_imp:
                                return t_imp[tuplcall]
                        elif type(nm) is str and nm in ImportedM:
                            tuplcall = ImportedM[nm]
                            if type(tuplcall) is tuple:
                                tuplcall +=  ('()',)
                                if tuplcall in t_imp:
                                    return t_imp[tuplcall]
                    t2 = TypeExpr(ret[1])
                        
                    if IsNewType(t2):
                        return (T_NEW_CL_INST, t2[1])
                    elif IsOldType(t2):
                        return (T_OLD_CL_INST, t2[1])
                    t1 = TypeExpr(ret[1])
                    if IsFunction(t1) and t1[1] is not None and t1[1] in detected_return_type:
                       return detected_return_type[t1[1]] 
                    _v = [] 
                    if TCmp(ret[1], _v, ('!PyObject_GetAttr', '?', ('CONST', '?'))):
                        if _v[1] == 'fromkeys' and TCmp(_v[0], [], ('!LOAD_BUILTIN', 'dict')):
                            return Kl_Dict
                        t1 = TypeExpr(_v[0])
                        if IsMayBe(t1) and type(_v[1]) is str and len(_v[1]) > 0 and _v[1][0].isalpha():
                            t1 = t1[1] 
                        if _v[1] == 'array' and IsModule(t1) and t1[1] == 'array':
                            if ret[2][0] == 'CONST' and len(ret[2][1]) == 1:
                                return ('array', ret[2][1][0])
                        if _v[1] in ('copy', 'deepcopy')  and IsModule(t1) and t1[1] == 'copy':
                            if ret[2][0] == '!BUILD_TUPLE' and len(ret[2][1]) == 1:
                                return TypeExpr(ret[2][1][0])
                            if ret[2][0] == 'CONST' and len(ret[2][1]) == 1:
                                return TypeExpr(('XONST', ret[2][1][0]))
                        if t1 is not None and (t1, _v[1]) in methods_type:
                            return methods_type[(t1, _v[1])]
                        elif IsChar(t1) and (Kl_String, _v[1]) in methods_type:
                            return methods_type[(Kl_String, _v[1])]
                        if IsStr(t1) and _v[1] == 'join':
                            _v2 = []
                            if TCmp(ret, _v2, ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', 'join')), \
                                            ('!BUILD_TUPLE',  ('?',)), ('NULL',))):
                                    if IsListStr(_v2[1]):
                                        return Kl_String
                                    ## return Kl_Sequence
                        if IsUnicode(t1) and _v[1] == 'join':
                            _v2 = []
                            if TCmp(ret, _v2, ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', 'join')), \
                                            ('!BUILD_TUPLE',  ('?',)), ('NULL',))):
                                    if IsListStr(_v2[1]):
                                        return Kl_Unicode
                                    if IsListUnicode(_v2[1]):
                                        return Kl_Unicode
                                    return Kl_Unicode
                        if t1 is not None:
                            if type(t1[1]) is str and IsAnyClass(t1[1]):
                                pass
                            elif t1[0] is types.ModuleType:
                                tupl = (t1[1], _v[1], '()')
                                if tupl in t_imp:
                                    return t_imp[tupl]
                                tupl = (t1[1], _v[1], 'val')
                                if tupl in t_imp:
                                    t2 = t_imp[tupl]
                                    if t2[0] == T_OLD_CL_TYP:
                                        return (T_OLD_CL_INST, _v[1])
                                    elif t2[0] == T_NEW_CL_TYP:
                                        return (T_NEW_CL_INST, _v[1])
                                    elif t2[0] == T_ANY_CL_TYP:
                                        return (T_ANY_CL_INST, _v[1])                        
                                Debug('Undefined type method: %s -> %s ()' % (t1, _v[1]), ret)
                            else:
                                Debug('Undefined type method: %s -> %s ()' % (t1, _v[1]), ret)
                    return None     
                if ret0 == '!PySequence_GetSlice':
                    t2 = TypeExpr(ret[1])
                    if IsList(t2):
                        return Kl_List 
                    if IsStr(t2):
                        return Kl_String 
                    if IsTuple(t2):
                        return Kl_Tuple 
            ##        return Kl_Sequence
                    
                if ret0 == '!PyObject_RichCompare(' or ret0 == '!PyObject_RichCompare':
                    t1 = TypeExpr(ret[1])
                    t2 = TypeExpr(ret[2])
                    if type(t1) is tuple:
                        if (t1 is t2 or t1 == t2) and t1 in _Kl_Simples:
                            return Kl_Boolean
                        if IsInt(t1) or IsInt(t2):
                            return Kl_Boolean
                        if IsType(t1) and IsType(t2):
                            return Kl_Boolean
                        if IsStr(t1) and IsStr(t2):
                            return Kl_Boolean
                        if IsTuple(t1) and IsTuple(t2):
                            return Kl_Boolean
                        if IsListAll(t1) and IsListAll(t2):
                            return Kl_Boolean  
                        if IsMayBe(t2) and t2[1] == t1 and t1 in _Kl_Simples:   
                            return Kl_Boolean 
                        if IsBool(t1) and IsBool(t2):
                            return Kl_Boolean
                        if t2 is None and (IsListAll(t1) or IsBool(t1) or IsTuple(t1) or IsStr(t1) or IsType(t1) or IsInt(t1) or IsLong(t1) or IsDict(t1) or t1 == Kl_None):
                            return Kl_Boolean
                if ret0 == '!PyLong_FromVoidPtr':
                    return Kl_IntUndefSize



            elif c1 == 'L':
                if ret0 == '!LOAD_BUILTIN':
                    if ret[1] == 'False':
                        return (bool, False)
                    if ret[1] == 'True':
                        return (bool, True)
                    if ret[1] in d_built and type(d_built[ret[1]]) == type(len):
                        return (Kl_BuiltFunc[0], ret[1])
                    elif ret[1] in d_built and type(d_built[ret[1]]) == type(int):
                        if ret[1] in tag_builtin:
                            return (type, tag_builtin[ret[1]])
                        return Kl_Type
                if ret0 == '!LOAD_NAME' and ret[1] == '__name__':
                    return Kl_String
                if ret0 == '!LOAD_GLOBAL' and ret[1] in detected_global_type:
                    return detected_global_type[ret[1]]
                if ret0 == '!LOAD_NAME' and ret[1] in detected_global_type and func == 'Init_filename':
                    return detected_global_type[ret[1]]
                if ret0 == '!LIST_COMPR':
                    return Kl_List
            if c1 == 'C':
                if ret0 == '!COND_EXPR':
                    t1 = TypeExpr(ret[2])
                    t2 = TypeExpr(ret[3])
                    _v = [t1,t2]
                    _v = uniq_list_type(_v)
                    if len(_v) == 1:
                        return _v[0]        
                    if t1 == t2:
                        return t1
                    return None
                if ret0 == '!COND_METH_EXPR':
                    return TypeExpr(ret[2])
                if ret0 == '!CHR_BUILTIN':
                    return Kl_Char
                if ret0 == '!CLASS_CALC_CONST':
                    return (T_OLD_CL_INST, ret[1])
                if ret0 == '!CLASS_CALC_CONST_DIRECT':
                    return (T_OLD_CL_INST, ret[1])
                if ret0 == '!CLASS_CALC_CONST_NEW':
                    return (T_NEW_CL_INST, ret[1])
                if ret0 == '!CLASS_CALC_CONST_NEW_DIRECT':
                    return (T_NEW_CL_INST, ret[1])
                if ret0 == '!CALL_CALC_CONST':
                    if ret[1] in detected_return_type:
                        t0 = detected_return_type[ret[1]] 
                        if t0 == ('PSEVDO', 'self') and ret[2][0] == '!BUILD_TUPLE' and len(ret[2][1]) > 0:
                            return TypeExpr(ret[2][1][0])
                        return t0            
                    ## _co = N2C(ret[1])
                    ## pprint((_co.c_name, len(_co.cmds[1])))
                    return None
                if ret0 == '!CALL_CALC_CONST_INDIRECT':
                    if ret[1] in detected_return_type:
                        t0 = detected_return_type[ret[1]] 
                        if t0 == ('PSEVDO', 'self') and ret[2][0] == '!BUILD_TUPLE' and len(ret[2][1]) > 0:
                            return TypeExpr(ret[2][1][0])
                        return t0            
                    return None

            if c1 == 'M':
                if ret0 == '!MK_FUNK':
                    return (types.FunctionType, ret[1])
            if c1 == 'B':    
                if ret0 == '!BUILD_TUPLE':
                    return (tuple, tuple([TypeExpr(x) for x in ret[1]]))
                if ret0 == '!BUILD_LIST':
                    return Kl_List
                if ret0 == '!BUILD_MAP':
                    return Kl_Dict
                if ret0 == '!BUILD_SET':
                    return Kl_Set
                if ret0 == '!BINARY_SUBSCR_Int':
                    t1 = TypeExpr(ret[1])
                    if type(t1) is tuple:
                        if IsStr(t1) and IsInt(TypeExpr(ret[2])):
                           return Kl_Char
                        if IsUnicode(t1) and IsInt(TypeExpr(ret[2])):
                           return Kl_UnicodeChar
                        elif IsTuple(t1) and t1[1] is not None and ret[2][0] == 'CONST' and type(t1[1]) is tuple:
                            ind = ret[2][1]
                            if ind >= 0 and ind < len(t1[1]):
                                return t1[1][ind] 
                if ret0 == '!BINARY_SUBSCR_Int' and IsStr(TypeExpr(ret[1])) and IsInt(TypeExpr(ret[2])):
                       return Kl_Char   
                if ret0 == '!BINARY_SUBSCR_Int' and IsUnicode(TypeExpr(ret[1])) and IsInt(TypeExpr(ret[2])):
                       return Kl_UnicodeChar   
                if ret0 == '!BOOLEAN': # and IsBool(TypeExpr(ret[1])):
                    t0 = TypeExpr(ret[1])
                    if IsBool(t0):
                        return t0
                    elif IsKlNone(t0):
                        return (bool, False)
                    elif IsListAll(t0) or IsTuple(t0) or IsDict(t0):
                        return Kl_Boolean
                    elif IsInt(t0):
                        if t0[1][0] <= 0 <= t0[1][1]:
                            if t0[1][0] != 0 or t0[1][1] != 0:
                                return Kl_Boolean
                            else:
                                return (bool, False)
                        else:
                            return (bool, True)
                    elif t0 is not None:
                        pp(t0, ret)
                        assert False
                    return Kl_Boolean

            if c1 == '1':
                if ret0 == '!1NOT':
                    t1 = TypeExpr(ret[1])
                    if type(t1) is tuple:
                        if IsBool(t1) and t1[1] is not None:
                            return (bool, not t1[1])
                        if IsInt(t1) and t1[1][0] == t1[1][1]:
                            return (bool, not t1[1][0])
                        if IsStr(t1) and type(t1[1]) is str:
                            return (bool, not t1[1])
                        if t1[0] is type(None):
                            return (bool, True)
                        if IsFunction(t1):
                            return (bool, False)
                        if t1[0] == 'MayBe':
                            if IsBool(t1[1]):
                                if t1[1][1] is False:
                                    return (bool, True)
                                if IsInt(t1[1]):
                                    if t1[1][1][0] == t1[1][1][1] and t1[1][1][0] == 0:
                                        return (bool, True)
                                ##if IsCType(t1[1]):
                            return Kl_Boolean
                        if IsUnicode(t1) or IsInt(t1) or IsTuple(t1) or IsBool(t1) or IsLong(t1) or \
                           IsFloat(t1) or IsList(t1) or IsSet(t1) or IsStr(t1) or IsDict(t1) or \
                           (IsMayBe(t1) and (IsList(t1[1]) or IsSet(t1[1]) or IsTuple(t1[1]) or IsStr(t1[1]))):
                            return Kl_Boolean
                        pp(t1, ret)
                    assert t1 is None
                    return Kl_Boolean
            if c1 == '@':
                if ret0 == '!@PyInt_FromSsize_t':
                    return Kl_Short
            if c1 == 'G':
                if ret0 == '!GET_ITER':
                    return Kl_Generator
            if c1 == 'O' or c1 == 'A':
                if ret0 in ('!OR_BOOLEAN', '!AND_BOOLEAN', '!AND_JUMP', '!OR_JUMP'):
                    return Kl_Boolean
                if ret0 in ('!OR_JUMPED_STACKED', '!AND_JUMPED_STACKED'):
                    d2 = list(dict.fromkeys([TypeExpr(x) for x in ret[1:]]).keys())
                    if len(d2) > 1:
                        d2 = uniq_list_type(d2)
                    if len(d2) == 1:
                        return d2[0]
                    return None
            if c1 == 'c':
                if ret0 in ('!c_Py_EQ_Int', '!c_Py_NE_Int', '!c_Py_LT_Int', \
                          '!c_Py_LE_Int', '!c_Py_GT_Int', '!c_Py_GE_Int', \
                          '!c_Py_EQ_String', '!c_Py_NE_String'):
                    return Kl_Boolean
            if c1 == 'S':
                if ret0 in ('!SSIZE_T==', '!SSIZE_T!=',\
                      '!SSIZE_T>', '!SSIZE_T<', '!SSIZE_T>=', '!SSIZE_T<='):
                    return Kl_Boolean
                if ret0 == '!STR_CONCAT_N':
                    li = [TypeExpr(x) for x in ret[2:]]
                    if None in li:
                        return None
                    if all([IsArgStr(x) for x in li]):
                        return Kl_String
                    if all([IsArgStr(x) or IsUnicode(x) for x in li]):
                        return Kl_Unicode
                    ## if all([IsStr(x) or IsUnicode(x) or IsSequence(x) for x in li]):
                        ## return Kl_Sequence
                    return None
                if ret0 in ('!STR_CONCAT2', '!STR_CONCAT3', '!STR_CONCAT'):
                    li = [TypeExpr(x) for x in ret[1:]]
                    if None in li:
                        return None
                    if all([IsArgStr(x) for x in li]):
                        return Kl_String
                    if all([IsArgStr(x) or IsUnicode(x) for x in li]):
                        return Kl_Unicode
                    ## if all([IsStr(x) or IsUnicode(x) or IsSequence(x) for x in li]):
                        ## return Kl_Sequence
                    return None
            if c1 == '_':
                if ret0 == '!_PyObject_GetAttrRaw':
                    return TypeExpr(('!PyObject_GetAttr', ret[1], ret[2]))
                
                if ret0 in ('!_PyString_StartSwith',  '!_PyString_EndSwith',\
                      '!_NEQ_', '!_EQ_', '!_PyString_ctype'):
                    return Kl_Boolean
                if ret0 in ('!_PyString_Find', '!_PyString_RFind'):
                    return Kl_FromMinusOne
                if ret0 in ('!_PyString_Index', '!_PyString_RIndex', '!_PyString_Count'):
                    return Kl_Cardinal   
                if ret0 in('!_PyDict_New', '!_PyDict_NewPresized'):
                    return Kl_Dict
                if ret0 == '!_PyInt_Format':
                    return Kl_String
                if ret0 == '!_PyEval_BuildClass':
                    if ret[2] == ('CONST', ()) and ret[3][0] == 'CONST':
                        return (T_OLD_CL_TYP, ret[3][1])
                    if ret[2][0] == '!BUILD_TUPLE' and len(ret[2][1]) == 1 and ret[2][1][0][0] == '!LOAD_BUILTIN' and ret[3][0] == 'CONST':
                        return (T_NEW_CL_TYP, ret[3][1])
                    return (T_ANY_CL_TYP, ret[3][1])
                if ret0 == '!_PyList_Extend':
                    return Kl_None
                if ret0 == '!_PyString_Join':
                    if IsStr(TypeExpr(ret[1])) and IsListStr(ret[2]):
                        return Kl_String
                    ## return Kl_Sequence
                if ret0 == '!_PyEval_ApplySlice':
                    t2 = TypeExpr(ret[1])
                    if IsList(t2):
                        return Kl_List 
                    if IsStr(t2):
                        return Kl_String 
                    if IsTuple(t2):
                        return Kl_Tuple 
            if c1 == 'f':
                if ret0 == '!from_ceval_BINARY_SUBSCR':
                    t1 = TypeExpr(ret[1])
                    t2 = TypeExpr(ret[2])
                    if IsStr(t1) and (IsInt(t2) or IsIntUndefSize(t2)):
                       return Kl_Char
                    if IsUnicode(t1) and (IsInt(t2) or IsIntUndefSize(t2)):
                       return Kl_UnicodeChar
                    if IsStr(t1):
                        return Kl_String
                    elif IsTuple(t1) and t1[1] is not None and ret[2][0] == 'CONST':
                        ind = ret[2][1]
                        if ind >= 0 and ind < len(t1[1]):
                            return t1[1][ind]   
            if c1 == 'I':
                if ret0 == '!IMPORT_NAME':
                    return (types.ModuleType, dotted_name_to_first_name(ret[1]))

    return None
  
def detect_long_subint(t):
    assert type(t) is tuple and len(t) == 2
    if type(t[1][1]) is long:
        t = Int(t[1][0], int(t[1][1]))
    if type(t[1][0]) is long:
        t = Int(int(t[1][0]), t[1][1])
    if type(t[1][1]) is long or type(t[1][0]) is long:
        return Kl_IntUndefSize
    return t



def attempt_calc_constant_math(t, ret, v1, m):
    try:
        ret = getattr(m, t)(*v1)
        return calculed_const(ret)
    except:
        return ret
    
__v_opgrade_op2 = []
def upgrade_op2(ret, nm = None):    
    ret2 = ret
    assert ret != ('PY_TYPE', 'NewClassInstance', 'MovedAttribute', ('CALC_CONST', '_importer'), None)
    if type(ret) is tuple and len(ret) > 0:
        r0 = ret[0]
        if type(r0) is str:
            v = __v_opgrade_op2
            if len(v) > 0:
                del v[:]
            if len(ret) == 4 and r0 == '!PyObject_Call' and ret[3] == ('NULL',): 
                subret = ret[1:-1]
                if direct_call and is_can_be_codefunc:
                    if TCmp(subret, v, (('!MK_FUNK', '?', ('CONST', ())), \
                            ('!BUILD_TUPLE', '?'))):
                        return call_calc_const(v[0], ('!BUILD_TUPLE', v[1]), ret)                    
                    if TCmp(subret, v, (('!MK_FUNK', '?', ('CONST', ())), \
                            ('CONST', '?'))):
                        return call_calc_const(v[0], ('CONST', v[1]), ret)  
                    elif TCmp(subret, v, (('CALC_CONST', '?'),\
                                ('!BUILD_TUPLE', '?'))):
                        if v[0] in val_direct_code: ## and \
                            return call_calc_const(direct_code[v[0]], ('!BUILD_TUPLE', v[1]), ret)
                    elif TCmp(subret, v, (('CALC_CONST', '?'),\
                                ('CONST', '?'))) :
                        if v[0] in val_direct_code:
                            return call_calc_const(direct_code[v[0]], ('CONST', v[1]), ret)
                        t = None
                        if type(v[0]) is tuple and len(v[0]) == 2 and v[0][0] in ImportedM:
                            t = (ImportedM[v[0][0]], v[0][1])
                        elif v[0] in ImportedM:
                            t = ImportedM[v[0]]
                        if type(t) is tuple and len(t) == 2 and t[0] in constanted_modules:
                            ret2 = attempt_calc_constant_math(t[1], ret, v[1], constanted_modules[t[0]]) #sqrt
                            if ret2 is not None:
                                return ret2
                    if len(v) > 0:
                        del v[:]

                if TCmp(subret, v, (('CALC_CONST', '?'),\
                            ('!BUILD_TUPLE', '?'))):
                    if IsOldClass(v[0]):
                        if not Is3(v[0], 'HaveMetaClass') and not Is3('Init_filename', 'HaveMetaClass') and not IsNewClass(v[0]): #have_metaclass(v[0][0]):
                            return ('!CLASS_CALC_CONST', v[0], ('!BUILD_TUPLE', v[1]))
                    elif IsNewClass(v[0]):
                        if not IsOldClass(v[0]):       
                            return ('!CLASS_CALC_CONST_NEW', v[0], ('!BUILD_TUPLE', v[1]))    
                    if len(v) > 0:
                        del v[:]
                elif TCmp(subret, v, (('CALC_CONST', '?'),\
                            ('CONST', '?'))):
                    if IsOldClass(v[0]):
                        if not Is3(v[0], 'HaveMetaClass') and not Is3('Init_filename', 'HaveMetaClass') and not IsNewClass(v[0]):  ## and not have_metaclass(v[0][0]):
                            return ('!CLASS_CALC_CONST', v[0], ('CONST', v[1]))
                    elif IsNewClass(v[0]):
                        if not IsOldClass(v[0]):
                            return ('!CLASS_CALC_CONST_NEW', v[0], ('CONST', v[1]))                            
                    if len(v) > 0:
                        del v[:]

            if r0 == 'IMPORT_FROM_AS' and g_co.c_name == 'Init_filename':
                if TCmp(ret, v, ('IMPORT_FROM_AS', '?', ('CONST', '?'), ('CONST', '?'), '?')):
                    sreti = []
                    stores = v[3]
                    for reti in stores:
                        v = []
                        if type(reti) is tuple and len(reti) == 2 and \
                        reti[0] in ('STORE_NAME', 'STORE_GLOBAL') and \
                        reti[1] in calculated_const:
                            reti = ('STORE_CALC_CONST', reti)
                        sreti.append(reti)   
                    sreti = tuple(sreti)
                    if sreti != stores:
                        return ret[:4] + (sreti,)    
            if len(v) > 0:
                del v[:]
            if len(ret) == 3 and r0 == 'SEQ_ASSIGN' and g_co.c_name == 'Init_filename':
                    sreti = []
                    for reti in ret[1]:
                        v = []
                        if type(reti) is tuple and len(reti) == 2 and \
                        reti[0] in ('STORE_NAME', 'STORE_GLOBAL') and \
                        reti[1] in calculated_const:
                            set_all_calc_const(reti[1], ret[2])
                            reti = ('STORE_CALC_CONST', reti)
                        elif reti[0] == 'SET_VARS':    
                            sretii = []
                            for retii in reti[1]:
                                if type(retii) is tuple and len(retii) == 2 and \
                                retii[0] in ('STORE_NAME', 'STORE_GLOBAL') and \
                                retii[1] in calculated_const:
                                    retii = ('STORE_CALC_CONST', retii)
                                sretii.append(retii)
                            reti = ('SET_VARS', tuple(sretii))        
                        sreti.append(reti)  
                    sreti = tuple(sreti)
                    if sreti != ret[1]:                    
                        return (r0, tuple(sreti), ret[2])    
            elif len(ret) == 3 and r0 == 'SET_EXPRS_TO_VARS' and g_co.c_name == 'Init_filename':    
                    sretii = []
                    for retii in ret[1]:
                        if type(retii) is tuple and len(retii) == 2 and \
                            retii[0] in ('STORE_NAME', 'STORE_GLOBAL') and \
                            retii[1] in calculated_const:
                            retii = ('STORE_CALC_CONST', retii)
                        sretii.append(retii)
                    sretii = tuple(sretii)
                    if sretii != ret[1]:
                        return ('SET_EXPRS_TO_VARS', sretii, ret[2])        
            
            elif len(ret) == 3 and \
                    r0 == 'STORE' and len(ret[1]) == 1 and len(ret[1][0]) == 2 and \
                    ret[1][0][0] in ('STORE_NAME', 'STORE_GLOBAL') and g_co.c_name == 'Init_filename' and \
                    found_all_calc_const(ret[1][0][1]) and\
                            TCmp(ret, v, ('STORE', (('?', '?'),), ('?',))):
                    v = [(v[1], '', get_all_calc_const(v[1])), v[2]]
                    set_all_calc_const(v[0][0], v[1])
                    if len(ret[2]) == 1 and ret[2][0][0] == 'CONST' and is_right_const_value(ret[2][0][1]):
                        set_mnemonic_const(ret[1][0][1], ret[2][0])
                    return ('STORE', (('STORE_CALC_CONST', ret[1][0]),), ret[2])    
            if len(ret) == 2 and r0 in ('!LOAD_GLOBAL', '!PyDict_GetItem(glob,') and ret[1] in calculated_const:
                ret = calc_const_to(ret[1])    
            elif len(ret) == 2 and r0 == '!LOAD_NAME' and ret[1] in calculated_const and g_co.c_name == 'Init_filename':
                ret = calc_const_to(ret[1])           
    if ret2 is not ret:
        assert ret2 != ret
    ret2 = ret
    ret = repl_collected_module_attr(ret)   
    if ret2 is not ret:
        assert ret2 != ret
    ret2 = ret
    ret = repl(ret) 
    if ret2 is not ret:
        assert ret2 != ret
    return ret      
  
def class_and_body_meth_by_meth(nm_meth):
    li = [] 
    if nm_meth == '__init__':
        return {}
    for a, b, c, isstaticmeth, isclassmeth, isderived in all_meth:
        if b == nm_meth:
            li.append( (a,b,c, isstaticmeth, isclassmeth))
        elif nm_meth[0] == '_' and b == '_' + a + c:
            li.append((a,b,c, isstaticmeth, isclassmeth))    
    if len(li) == 0:
        return {}
    di = dict([(a,(c, isstaticmeth, isclassmeth)) for a,b,c, isstaticmeth, isclassmeth in li])
    while True:
        le = len(di)
        for k in di.keys():
            for a1, c1 in all_derived.keys(): #Iter3(None, 'Derived', ('!CALC_CONST', k)):
                if c1 != ('!CALC_CONST', k):
                    continue
                if a1 not in di:
                    di[a1] = di[k]
        if len(di) == le:
            break
    return di

def body_meth_by_class_and_meth(nm_class, nm_meth):
    li = [] 
    if nm_meth == '__init__':
        return None, None, None
    for a, b, c, isstaticmeth, isclassmeth, isderived in all_meth:
        if b == nm_meth and a == nm_class:
            li.append( (c, isstaticmeth, isclassmeth))
        elif nm_meth[0] == '_' and b == '_' + a + c and a == nm_class:
            li.append((c, isstaticmeth, isclassmeth)) 
    if len(li) == 1:
        return li[0]
    return None, None, None
    

def tree_pass__(a, upgrade_op, up, nm):
    ## assert not check_cond_meth_2(a)
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return a
        r = tuple([tree_pass__(i1, upgrade_op,a, nm) for i1 in a])
        ## assert not check_cond_meth_2(r)
        notchanged = all([r[i] is a[i] for i in range(len(r))])
        if notchanged:
            r = a
        r = upgrade_op(r,nm)
        ## assert not check_cond_meth_2(r)
        return r
    if type(a) is list:
        assert len(a) > 0 
        r = [tree_pass__(i1, upgrade_op, a, nm) for i1 in a]
        ## assert not check_cond_meth_2(r)
        notchanged = all([r[i] is a[i] for i in range(len(r))])
        if notchanged:
            r = a
        assert len(r) > 0
        return r
    return a

to_call_1 = {'!PyObject_Hash':('__hash__',), 
             '!PyObject_Str':('__str__',), 
             '!PyObject_Repr':('__repr__',), 
             '!PyNumber_Negative':('__neg__',),
             '!PyNumber_Positive':('__pos__',),
             '!PyNumber_Absolute':('__abs__',),
             '!PyNumber_Inver':('__invert__',),
             '!PyObject_GetIter':('__iter__',), 
             '!PyObject_Length':('__len__',), 
             '!PyNumber_Float':('__float__',)}

frozenset_to_call_1 = frozenset(to_call_1.keys())                        

def add_2_redef(*a):
    d = {}
    for (a, b) in a:
        d['!PyNumber_' + a] = ('__' + b + '__',)
        d['!PyNumber_InPlace' + a] = ('__i' + b + '__',) # '__' + b + '__')
    return d

to_call_2 = add_2_redef(('Subtract', 'sub'), ('Add', 'add'), ('Divide', 'div'),
                        ('And', 'and'), ('Or', 'or'), ('Rshift', 'rshift'),
                        ('Lshift', 'lshift'), ('Multiply', 'mul'), ('Xor', 'xor'),
                        ('Power', 'pow'), ('FloorDivide', 'floordiv'),
                        ('TrueDivede', 'truediv'), ('Remainder', 'mod'))

frozenset_to_call_2 = frozenset(to_call_2.keys())                        
                         
def check_cond_meth_2(ret):
    if type(ret) is tuple:
        if len(ret) >= 4:
            if ret[0] == '!COND_METH_EXPR' and ret[2][0] == '!COND_METH_EXPR' and ret[1] == ret[2][1]:
                return True
        return any([check_cond_meth_2(x) for x in ret])
    if type(ret) is list:
        return any([check_cond_meth_2(x) for x in ret])
    return False

## def upgrade_repl_if_type_direct_call(ret, nm = None): 
    ## ## pprint(ret)
    ## ## assert not check_cond_meth_2(ret)
    ## r = _upgrade_repl_if_type_direct_call(ret, nm)
    ## ## assert not check_cond_meth_2(r)
    ## return r

def upgrade_repl_if_type_direct_call(ret, nm = None):  
    v = []
    if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str:
        if ret[0] == '!COND_METH_EXPR':
            return ret
        if len(ret) == 3:
            if type(ret[0]) is str and ret[0] in frozenset_to_call_2:
                v = ret
                t1 = TypeExpr(v[1])
                t2 = TypeExpr(v[2])
                _self1 = v[1]
                if t1 is None and t2 is None  and '__coerce__' not in _n2c : 
                    nms = to_call_2[v[0]]
                    for nm_meth in nms:
                        di = class_and_body_meth_by_meth(nm_meth)
                        if len(di) == 0:
                            continue
                        li = []
                        for t, (codemethnm, staticmeth, classmeth) in di.items():
                            isoldclass = IsOldClass(t)
                            isnewclass = IsNewClass(t)
                            if classmeth or staticmeth:
                                continue
                            if ((isoldclass and not isnewclass) or (isnewclass and not isoldclass)):
                                pass
                            else:
                                continue
                            assert v[1][0] != 'PY_TYPE'
                            if isoldclass:
                                _self2 = ('PY_TYPE', T_OLD_CL_INST, t, v[1], None)
                                if False:
                                    continue
                            else:    
                                _self2 = ('PY_TYPE', T_NEW_CL_INST, t, v[1], None)
                            tupl = ('!BUILD_TUPLE', (_self2, replace_subexpr(v[2], v[1], _self2)))
                            ret2 = call_calc_const(codemethnm, tupl, ret)
                            if ret2 == ret:
                                continue    
                            li.append((_self2[1:3], ret2))
                        if len(li) > 0:         
                            return CondMethExpr(_self1, ret, tuple(li))
            elif type(ret[0]) is str and ret[0] == '!PyObject_GetAttr' and ret[2][0] == 'CONST':
                v = ret
                t1 = TypeExpr(v[1])
                _self1 = v[1]
                li = []
                if ret[2][1] != '__dict__' and ret[2][1] in inverted_compiled_slots:
                    li = inverted_compiled_slots[ret[2][1]]
                li2 = list_final_class_first(li)
                assert '__coerce__' not in _n2c 
                if t1 is None and '__coerce__' not in _n2c : 
                    li = []
                    for nm in li2:
                        t = TypeExpr(('CALC_CONST', nm))
                        if t is None:
                            continue
                        isoldclass = t[0] == T_OLD_CL_TYP
                        isnewclass = t[0] == T_NEW_CL_TYP
                        if ((isoldclass and not isnewclass) or (isnewclass and not isoldclass)):
                            pass
                        else:
                            continue
                        assert v[1][0] != 'PY_TYPE'
                        if isoldclass:
                            _self2 = ('PY_TYPE', T_OLD_CL_INST, t[1], v[1], None)
                            if False:
                                continue
                        else:    
                            _self2 = ('PY_TYPE', T_NEW_CL_INST, t[1], v[1], None)
                        li.append((_self2[1:3], ret[:1] + (_self2,) + ret[2:]))
                    if len(li) > 0:         
                        return CondMethExpr(_self1, ret, tuple(li))

        elif len(ret) == 2 and ret[0] in frozenset_to_call_1:
            v = ret
            t1 = TypeExpr(v[1])
            if t1 is None  and '__coerce__' not in _n2c : 
                nms = to_call_1[v[0]]
                for nm_meth in nms:
                    di = class_and_body_meth_by_meth(nm_meth)
                    if len(di) == 0:
                        continue
                    li = []
                    _self1 = None
                    for t, (codemethnm, staticmeth, classmeth) in di.items():
                        isoldclass = IsOldClass(t)
                        isnewclass = IsNewClass(t)
                        _self1 = v[1]
                        if classmeth or staticmeth:
                            continue
                        if ((isoldclass and not isnewclass) or (isnewclass and not isoldclass)):
                            pass
                        else:
                            continue
                        assert v[1][0] != 'PY_TYPE'
                        if isoldclass:
                            _self2 = ('PY_TYPE', T_OLD_CL_INST, t, v[1], None)
                            if False:
                                continue
                        else:    
                            _self2 = ('PY_TYPE', T_NEW_CL_INST, t, v[1], None)
                        tupl = ('!BUILD_TUPLE', (_self2, ))
                        ret2 = call_calc_const(codemethnm, tupl, ret)
                        if ret2 == ret:
                            continue    
                        li.append((_self2[1:3], ret2))
                    if len(li) > 0:      
                        return CondMethExpr(_self1, ret, tuple(li))
 
        elif ret[0] == '!PyObject_Call' and ret[1][0] == '!PyObject_GetAttr':
            if TCmp(ret, v, \
                ('!PyObject_Call',  
                    ('!PyObject_GetAttr', '?', ('CONST', '?')), ('!BUILD_TUPLE', '?'), ('NULL',))):
                typ1 = TypeExpr(v[0])
                if IsStr(typ1):
                    if v[1] == 'startswith' and len(v[2]) == 1 and IsStr(TypeExpr(v[2][0])):
                        return ('!_PyString_StartSwith', v[0], v[2][0])
                    if v[1] == 'endswith' and len(v[2]) == 1 and IsStr(TypeExpr(v[2][0])):
                        return ('!_PyString_EndSwith', v[0], v[2][0])
                li = []
                if typ1 is None  and '__coerce__' not in _n2c:
                    di = class_and_body_meth_by_meth(v[1])
                    for t, (codemethnm, staticmeth, classmeth) in di.items():
                        isoldclass = IsOldClass(t)
                        isnewclass = IsNewClass(t)
                        _self1 = v[0]
                        if classmeth or staticmeth:
                            continue
                        if ((isoldclass and not isnewclass) or (isnewclass and not isoldclass)):
                            pass
                        else:
                            continue
                        assert _self1[0] != 'PY_TYPE'
                        if isoldclass:
                            _self2 = ('PY_TYPE', T_OLD_CL_INST, t, _self1, None)
                            if False:
                                continue
                        else:    
                            _self2 = ('PY_TYPE', T_NEW_CL_INST, t, _self1, None)
                        tupl = ('!BUILD_TUPLE', (_self2,) + replace_subexpr(v[2], _self1, _self2))
                        ret2 = call_calc_const(codemethnm, tupl, ret)
                        if ret2 == ret:
                            continue
            
                        li.append((_self2[1:3], ret2))
                        
                if typ1 is None:
                    if len(li) == 0 and v[1] == 'startswith' and len(v[2]) == 1 and IsStr(TypeExpr(v[2][0])):
                        li.append(((str, None), ('!_PyString_StartSwith', ('PY_TYPE', str, None, v[0], None), v[2][0])))
                    if len(li) == 0 and v[1] == 'startswith' and len(v[2]) == 1 and TypeExpr(v[2][0]) is None:
                        li.append(((str, None), ('!COND_EXPR', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', v[2][0]), ('!LOAD_BUILTIN', 'str'))), 
                                ('!_PyString_StartSwith', ('PY_TYPE', str, None, v[0], None), ('PY_TYPE', str, None, v[2][0], None)), ret)))
                    if len(li) == 0 and v[1] == 'endswith' and len(v[2]) == 1 and IsStr(TypeExpr(v[2][0])):
                        li.append(((str, None), ('!_PyString_EndSwith', ('PY_TYPE', str, None, v[0], None), v[2][0])))
                    if len(li) == 0 and v[1] == 'endswith' and len(v[2]) == 1 and TypeExpr(v[2][0]) is None:
                        li.append(((str, None), ('!COND_EXPR', ('!BOOLEAN', ('!_EQ_', ('!PyObject_Type', v[2][0]), ('!LOAD_BUILTIN', 'str'))), 
                                ('!_PyString_EndSwith', ('PY_TYPE', str, None, v[0], None), ('PY_TYPE', str, None, v[2][0], None)), ret)))                                
                if len(li) > 0:         
                    ret = CondMethExpr(v[0], ret, tuple(li))
                return ret        
            v = []
            if TCmp(ret, v, \
                ('!PyObject_Call',  
                    ('!PyObject_GetAttr', '?', ('CONST', '?')), ('CONST', '?'), ('NULL',))):
                typ1 = TypeExpr(v[0])
                if IsStr(typ1) and type(v[2]) is tuple:
                    if len(v[2]) == 1 and type(v[2][0]) is str:
                        if v[1] == 'startswith':
                            return  ('!_PyString_StartSwith', ('PY_TYPE', str, None, v[0], None), ('CONST', v[2][0]))
                        if v[1] == 'endswith':
                            return ('!_PyString_EndSwith', ('PY_TYPE', str, None, v[0], None), ('CONST', v[2][0]))
                    if len(v[2]) == 0:
                        if v[1] in ('isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'isupper'):
                            return ('!_PyString_ctype', v[0], v[1])                        
                di = class_and_body_meth_by_meth(v[1])
                li = []
                if typ1 is None  and '__coerce__' not in _n2c:
                    for t, (codemethnm, staticmeth, classmeth) in di.items():
                        isoldclass = IsOldClass(t)
                        isnewclass = IsNewClass(t)
                        _self1 = v[0]
                        if classmeth or staticmeth:
                            continue
                        if ((isoldclass and not isnewclass) or (isnewclass and not isoldclass)):
                            pass
                        else:
                            continue            
            
                        v2 = tuple([('CONST', x) for x in v[2]])
                        if _self1[0] == 'PY_TYPE':
                            pp(_self1)
                            pp(ret)
                        assert _self1[0] != 'PY_TYPE'
                        if isoldclass:
                            _self2 = ('PY_TYPE', T_OLD_CL_INST, t, _self1, None)
                            if False:
                                continue
                        else:    
                            _self2 = ('PY_TYPE', T_NEW_CL_INST, t, _self1, None)
                        tupl = ('!BUILD_TUPLE', (_self2,) + replace_subexpr(v2, _self1, _self2))
                        ret2 = call_calc_const(codemethnm, tupl, ret)
                        if ret2 == ret:
                            continue
            
                        li.append((_self2[1:3], ret2))
                if typ1 is None:
                    if len(li) == 0 and v[1] == 'startswith' and type(v[2]) is tuple and len(v[2]) == 1 and type(v[2][0]) is str:
                        li.append(((str, None), ('!_PyString_StartSwith', ('PY_TYPE', str, None, v[0], None), ('CONST', v[2][0]))))
                    if len(li) == 0 and v[1] == 'endswith' and type(v[2]) is tuple and len(v[2]) == 1 and type(v[2][0]) is str:
                        li.append(((str, None), ('!_PyString_EndSwith', ('PY_TYPE', str, None, v[0], None), ('CONST', v[2][0]))))
                    if len(li) == 0 and v[1] in ('isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'isupper') and type(v[2]) is tuple and len(v[2]) == 0:
                        li.append(((str, None), ('!_PyString_ctype', ('PY_TYPE', str, None, v[0], None), v[1])))

                if len(li) > 0:         
                    ret = CondMethExpr(v[0], ret, tuple(li))
    return ret            
           
def generate_logical_cond_meth_expr(it, logic):
    assert type(it) is tuple

    t0 = TypeExpr(it[1])
    if t0 is not None:
        for _self2, it2 in it[3]:
            if _self2 == t0:
                return generate_logical_expr(it2, logic)
    o = Out()            
    ref_self = LikeExpr1(it[1], o)
    PushAcc([it[1]], [ref_self])
    v = []
    it2 = it[2]
    assert type(it2) is tuple
    if len(it2) == 4 and it2[0] == '!PyObject_Call':
        if TCmp(it2, v, ('!PyObject_Call', \
                ('!PyObject_GetAttr', '?', ('CONST', '?')), ('!BUILD_TUPLE', '?'), ('NULL',))): 
            exprs = [x for x in v[2]]
            refs = [Expr1(x, o) for x in exprs]
            PushAcc(exprs, refs)
            add_seq_cond_math(it[3], ref_self, o, logic)
            it_ = ('!PyObject_Call', ('!PyObject_GetAttr', ref_self, ('CONST', v[1])), ('!BUILD_TUPLE', tuple(refs)), ('NULL',))
            ref1 = Expr1(it_, o)
            o, logic2 = ToTrue(o,logic,ref1, it_)
            assert logic2 == logic
            o.append('}')
            PopAcc(o)
            PopAcc(o)
            return o, logic

        if TCmp(it2, v, ('!PyObject_Call', \
                ('!PyObject_GetAttr', '?', ('CONST', '?')), ('CONST', '?'), ('NULL',))): 
            exprs = [('CONST', x) for x in v[2]]
            refs = [Expr1(x, o) for x in exprs]
            PushAcc(exprs, refs)
            add_seq_cond_math(it[3], ref_self, o, logic)
            it_ = ('!PyObject_Call', ('!PyObject_GetAttr', ref_self, ('CONST', v[1])), \
                    ('CONST', v[2]), ('NULL',))
            ref1 = Expr1(it_, o)
            o, logic2 = ToTrue(o,logic,ref1, it_)
            assert logic2 == logic
            o.append('}')
            PopAcc(o)
            PopAcc(o)
            return o, logic                

    if len(it2) == 3 and type(it2[0]) is str and it2[0] in frozenset_to_call_2: # and v[0] in to_call_2:
        exprs = [it2[2]]
        refs = [Expr1(x, o) if x[0] != 'FAST' and not g_co.IsCVar(x) else x for x in exprs]
        PushAcc(exprs, refs)
        add_seq_cond_math(it[3], ref_self, o, logic)
        it_ = (it2[0], ref_self, refs[0])
        if IsBool(TypeExpr(it_)):
            o2, logic2 = generate_logical_expr(it_, logic)
            o.extend(o2)
        else:
            ref1 = Expr1(it_, o)
            o, logic2 = ToTrue(o,logic,ref1, it_)
        assert logic2 == logic        
        o.append('}')
        PopAcc(o)
        PopAcc(o)
        return o, logic

    if len(it2) == 2 and type(it2[0]) is str and it2[0] in frozenset_to_call_1:
        add_seq_cond_math(it[3], ref_self, o, logic)        
        it_ = (it2[0], ref_self)
        if IsBool(TypeExpr(it_)):
            o2, logic2 = generate_logical_expr(it_, logic)
            o.extend(o2)
        else:
            ref1 = Expr1(it_, o)
            o, logic2 = ToTrue(o,logic,ref1, it_)
        assert logic2 == logic   
        o.append('}')
        PopAcc(o)
        return o, logic

    if it2[0] in ('!OR_JUMP', '!AND_JUMP', '!OR_JUMPED_STACKED', '!AND_JUMPED_STACKED', '!OR_BOOLEAN', '!AND_BOOLEAN'):
        add_seq_cond_math(it[3], ref_self, o, logic)        

        o1 = generate_and_or_logical(it2[1:], False, logic)
        o.extend(o1)
  
        o.append('}')
        PopAcc(o)
        return o, logic
    if True:
        ## pp('JJJ=',)
        ## pprint(it)
        ## pp('---')
        add_seq_cond_math(it[3], ref_self, o, logic)       
        
        if IsBool(TypeExpr(it2)):
            o2, logic2 = generate_logical_expr(GetAttr_to_GetAttrRaw(it2, it[1]), logic)
            o.extend(o2)
        else:
            ref1 = Expr1(GetAttr_to_GetAttrRaw(it2, it[1]), o)
            o, logic2 = ToTrue(o,logic,ref1, it2)
            
        o.append('}')
        PopAcc(o)
        return o, logic

    pprint(it)
    assert False 
    return o, logic

def GetAttr_to_GetAttrRaw(it, it1):
    if type(it) is not tuple:
        return it
    if len(it) == 0:
        return it
    if it[0] == 'CONST':
        return it
    if it[0] == '!PyObject_GetAttr' and it[1] == it1 and it[2][0] == 'CONST':
        return ('!_PyObject_GetAttrRaw', it[1], it[2])
    tupl = tuple([GetAttr_to_GetAttrRaw(x, it1) for x in it])
    if tupl == it:
        return it
    return tupl    

def add_seq_cond_math(it3, ref_self, o, logic):
    for i in range(len(it3)):
        add_one_cond_math(it3[i], ref_self, o, logic)
    o.append('{')

def add_one_cond_math(it3i, ref_self, o, logic):
    assert type(o) is Out
    _self2, it2 = it3i
    t2, nmclass = _self2
    if type(t2) is str:
        isnewclass = t2 == T_NEW_CL_INST
        isoldclass = t2 == T_OLD_CL_INST
        if isnewclass:
            o.Raw('if (((PyObject *)Py_TYPE(',ref_self,')) == ', ('CALC_CONST', nmclass), ') {')
        elif isoldclass:    
            o.Raw('if (PyInstance_Check(', ref_self,') && ((PyInstanceObject *)', ref_self,\
                ')->in_class == (PyClassObject*)', ('CALC_CONST', nmclass), ') {')
        else:
            Fatal('Not instance', _self2)
            assert False
    elif t2 in type_to_check_t:
        o.Raw('if (',type_to_check_t[t2],'(', ref_self,')) {')
    else:    
        Fatal('Strange COND_METH', _self2)
        assert False
    o2, logic2 = generate_logical_expr(it2, logic)
    o.extend(o2)
    assert logic2 == logic
    o.Raw('} else') 

def generate_cond_meth_expr_new(it, o, forcenewg, no_return): 
    assert type(it) is tuple
    assert type(o) is Out     
    t0 = TypeExpr(it[1])
    if t0 is not None:
        if type(t0[0]) is type:
            cond_meth = False
            for _self2, it2 in it[3]:
                t2, nmclass = _self2
                if type(t2) is str and 'Class' in t2:
                    continue
                cond_meth = True
                break
            if not cond_meth:
                 return GenExpr(it[2], o, forcenewg)
            for _self2, it2 in it[3]:
                if _self2 == t0:
                    return GenExpr(it2, o, forcenewg)
    
    ref_self = LikeExpr1(it[1], o)
    PushAcc([it[1]], [ref_self])
    v = []
    it2 = it[2]
    assert type(it2) is tuple
    if len(it2) == 4 and it2[0] == '!PyObject_Call':
        if TCmp(it2, v, ('!PyObject_Call', \
                ('!PyObject_GetAttr', '?', ('CONST', '?')), ('!BUILD_TUPLE', '?'), ('NULL',))): 
            ret = New(None, forcenewg)
            exprs = [x for x in v[2]]
            refs = v[2] 
            li = gen_for_all_known(it, ret, ref_self)  
            old_o = o
            o = Out()
            ret2 = GenExpr(('!PyObject_Call', ('!PyObject_GetAttr', ref_self, ('CONST', v[1])), \
                            ('!BUILD_TUPLE', tuple(refs)), ('NULL',)), o, ret)
            assert ret2 == ret
            join_cond_meth_call(o, li, old_o, no_return, ret)
            PopAcc(old_o)
            return ret

        if TCmp(it2, v, ('!PyObject_Call', \
                ('!PyObject_GetAttr', '?', ('CONST', '?')), ('CONST', '?'), ('NULL',))):
            ret = New(None, forcenewg)
            exprs = [('CONST', x) for x in v[2]]
            refs = exprs 
            li = gen_for_all_known(it, ret, ref_self)  
            old_o = o
            o = Out()
            ret2 = GenExpr(('!PyObject_Call', ('!PyObject_GetAttr', ref_self, ('CONST', v[1])), \
                    ('CONST', v[2]), ('NULL',)), o, ret)
            assert ret2 == ret or ret2 == ('CONST', None) ## or ret2[0] == 'CONST'
            join_cond_meth_call(o, li, old_o, no_return, ret)
            PopAcc(old_o)
            return ret                

    if len(it2) == 3 and it2[0] in frozenset_to_call_2:
        ret = New(None, forcenewg)
        exprs = [x for x in it2[2:]]
        refs = [Expr1(x, o) if x[0] != 'FAST' and not g_co.IsCVar(x) else x for x in exprs]
        PushAcc(exprs, refs)
        li = gen_for_all_known(it, ret, ref_self)  
        old_o = o
        o = Out()
        ret2 = GenExpr((it2[0], ref_self, refs[0]), o, ret)
        assert ret2 == ret or ret2 == ('CONST', None)
        join_cond_meth_call(o, li, old_o, no_return, ret)
        PopAcc(old_o)
        PopAcc(old_o)
        return ret

    if len(it2) == 2 and it2[0] in frozenset_to_call_1:
        ret = New(None, forcenewg)
        li = gen_for_all_known(it, ret, ref_self)  
        old_o = o
        o = Out()
        ret2 = GenExpr((it2[0], ref_self), o, ret)
        assert ret2 == ret or ret2 == ('CONST', None)
        join_cond_meth_call(o, li, old_o, no_return, ret)
        PopAcc(old_o)
        return ret
    
    ret = New(None, forcenewg)
    li = gen_for_all_known(it, ret, ref_self)  
    old_o = o
    o = Out()
    ret2 = GenExpr(GetAttr_to_GetAttrRaw(it2, it[1]), o, ret)
    assert ret2 == ret or ret2 == ('CONST', None)
    join_cond_meth_call(o, li, old_o, no_return, ret)
    PopAcc(old_o)
    return ret


def join_cond_meth_call(o, li, old_o, no_return, ret):
    assert type(o) is Out
    assert type(old_o) is Out
    if no_return:
        oo = Out()
        oo.Cls(ret)
    else:
        oo = Out()
    for k,v in li:
        assert type(v) is Out
        v.extend(oo)
    o.extend(oo)
    i = 0
    for k, v in li:
        assert type(old_o) is Out
        if i == 0:
            old_o.append(k)
        else:
            old_o.append('} else ' + k)
        old_o.extend(v)
        i += 1
    assert type(old_o) is Out
    old_o.append('} else {')
    old_o.extend(o)
    old_o.append('}')
    
def gen_for_all_known(it, ret, ref_self):
    assert type(it) is tuple
  
    li = []
    for i in range(len(it[3])):
        o = Out()
        _self2, it2 = it[3][i]
        t2, nmclass = _self2
        if type(t2) is str:
            isnewclass = t2 == T_NEW_CL_INST
            isoldclass = t2 == T_OLD_CL_INST
            if isnewclass:
                o.Raw('if (((PyObject *)Py_TYPE(',ref_self,')) == ', ('CALC_CONST', nmclass), ') {')
            elif isoldclass:    
                o.Raw('if (PyInstance_Check(', ref_self,') && ((PyInstanceObject *)', ref_self,\
                    ')->in_class == (PyClassObject*)', ('CALC_CONST', nmclass), ') {')
            else:
                Fatal('Not instance', _self2)
                assert False
        elif t2 in type_to_check:
            o.Raw('if (', type_to_check[t2],  '(', ref_self,')) {')
        elif t2 in type_to_check_t:
            o.Raw('if (', type_to_check_t[t2],  '(', ref_self,')) {')
        else:    
            Fatal('Strange COND_METH', _self2, t2)
            assert False
        if_ = o[0]
        assert len(o) == 1
        del o[0]
        assert len(o) == 0
        ret2 = GenExpr(it2, o, ret)
        if ret2[0] == 'CONST':
            o.INCREF(ret2)
            o.Raw(ret, ' = ', ret2, ';') 
        assert ret2 == ret or ret2[0] == 'CONST' 
        li.append((if_, o))
    return li
    
def upgrade_repl(ret, nm = None):    
    ret = repl_collected_module_attr(ret)    
    ret = repl(ret) 
    return ret        

def tree_pass_collect_type_return(a, nm): 
    global print_tree_node
    global type_def    
    if print_tree_node:
        pp('>> tree_pass_collect_type_return', nm, a)
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return False
        elif len(a) == 2 and type(a[0]) is str and a[0] == 'RETURN_VALUE':
            if nm not in type_def:
                type_def[nm] = {}
            if a[1][0] == '!CALL_CALC_CONST' and a[1][1] == nm:
                pass
            else:
                t = TypeExpr(a[1])
                if t is None:
                    if a[1] == ('FAST', 'self') and len(g_co.co_varnames) > 0 and \
                       g_co.co_varnames[0] == 'self' and g_co.co_argcount > 0: 
                        t = ('PSEVDO', 'self')
                type_def[nm][t] = True 
            return True
        elif a == ('CONTINUE',):
            return True
        elif a == ('BREAK_LOOP',):
            return True
        elif a == ('RAISE_VARARGS', 0, (('!LOAD_BUILTIN', 'AssertionError'),)):
            return True
        return False
    if type(a) is list:
        assert len(a) > 0 
        for a2 in a:
            if tree_pass_collect_type_return(a2, nm) and type(a2) is tuple:
                return True
    return False

def attempt_module_import_1(nm):
    try:
        if nm == filename[:-3] or not attempt_import_info:
            return None
        this = _my_import(nm)
        d = this.__dict__
        return this, d
    except:
        Debug('Module %s import unsuccessful1' % nm)     
        return None

def old_class_1(v):
    try:
        return (T_OLD_CL_INST, v.__class__.__name__)
    except:
        pass
    return None

def collect_module_type_attr(nm, acc = []):
    d = None
    if type(nm) is types.ModuleType:
        this = nm
        d = this.__dict__
    elif nm in sys.modules:    
        this = sys.modules[nm]
        d = this.__dict__
    else:
        return
    assert type(d) is dict
        ## ret_ret = attempt_module_import_1(nm)
        ## if ret_ret is None:
            ## return
        ## this, d = ret_ret
    if type(this) is types.ModuleType and this in acc:
        return   
    acc.append(this)
    for k in d.keys():
        v = getattr(this, k)
        if type(v) is types.ModuleType and v == this:
            continue
        t = type(v)
        if t is types.ModuleType:
            collect_module_type_attr(v, acc) 
        if t is types.InstanceType:
            t2 = old_class_1(v)
            if t2 is not None:
                t = t2
        else:
            if type(t) != type:
                t = (T_NEW_CL_INST, v.__class__.__name__)
            elif t is int:
                t = Kl_Int
            else:    
                t = (t, None)    
        if k not in self_attr_type:
            pass
        else:
            SetAttr(k, t)
            ##self_attr_type[k][t] = True  
       
def SetAttr(nm, t):
    global self_attr_type
    ## if nm == 'pprint' and IsModule(t):
        ## assert False
    if nm not in self_attr_type:
        self_attr_type[nm] = []
    self_attr_type[nm].append(t) 
    if len(self_attr_type[nm]) > 1:
        self_attr_type[nm] = uniq_list_type(self_attr_type[nm])  

def collect_set_attr(ret, nm):    
    v = []  
    if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'STORE':
        if nm != 'Init_filename':
            if TCmp(ret, v, ('STORE', (('STORE_NAME', '?'),), ('?',))):
                SetAttr(v[0], TypeExpr(v[1]))
                v = []
        if TCmp(ret, v, ('STORE', (('PyObject_SetAttr', '?', ('CONST', '?')),), ('?',))):
            SetAttr(v[1], TypeExpr(v[2])) 
        elif TCmp(ret, v, ('STORE', (('SET_VARS', '?'),), ( '?',))):
            if len(v[1]) > 0 and (v[1][0] in tags_one_step_expr or v[1][0][0] == '!'):
                t = TypeExpr(v[1])
                if IsTuple(t) and type(t[1]) is tuple:
                    t = t[1]
                else:
                    t = None
                for i, set2 in enumerate(v[0]):
                    v2 = []
                    if TCmp(set2, v2, ('PyObject_SetAttr', '?', ('CONST', '?'))):
                        t2 = None
                        if type(t) is tuple and i < len(t):
                            t2 = t[i]
                        SetAttr(v2[1], t2) 
            else:
                Fatal('Unhandled SetAttr in SET_VARS', ret)
                assert False
        elif TCmp(ret, v, ('STORE', '?', '?')):
            [ collect_module_type_attr (expr[1]) for expr in v[1] if expr[0] == '!IMPORT_NAME']
            if len(v[0]) == 1 and (type(v[0][0][0]) is int or v[0][0][0].startswith('STORE_')):
                pass
            elif len(v[0]) == 1 and v[0][0][0] == 'PyObject_SetItem':
                pass
            elif len(v[0]) == 1 and v[0][0][0] == '?PyObject_SetAttr':
                pass ##Debug('Variable arg PyObject_SetAttr', ret)
            elif len(v[0]) == 1 and v[0][0][0] == 'PyObject_SetAttr':
                pass ##Debug('Variable arg PyObject_SetAttr', ret)
            elif len(v[0]) == 1 and v[0][0][0] == 'UNPACK_SEQ_AND_STORE' and v[0][0][1] == 0:  
                for set2 in v[0][0][2]:              
                    v2 = []
                    if TCmp(set2, v2, ('PyObject_SetAttr', '?', ('CONST', '?'))):
                        SetAttr(v2[1], None)
                        pp('uiouio', ret)
 
            else:
                Fatal('Unhandled STORE', ret)
                assert False
    return ret    

def collect_default_args(ret, nm):    
    global default_args
    if type(ret) is tuple and len(ret) >= 3:
        if ret[0] == '!MK_FUNK':
            default_args[ret[1]] = ret[2]            
    return ret    

global_type = {}
detected_global_type = {}

def not_glob_detec(nm, expr):
    Debug('def %s, var %s -- global type not detected (%s)' % (g_co.co_name, nm, expr))

def glob_detec(nm, typ, expr):
    Debug('def %s, var %s -- global type %s detected (%s)' % (g_co.co_name, nm, typ, expr))
 
def glob_type_set(nm, typ, expr):
    global global_type
    if nm not in global_type:
        global_type[nm] = {}
    global_type[nm][typ] = expr  
    if typ is None:
        not_glob_detec(nm, expr)    
    else:
        glob_detec(nm, typ, expr) 
        
def collect_set_global(ret, nm):    
    global global_type
    if ret is None:
        return False
    if not (type(ret) is tuple or type(ret) is list):
        return False
    v = []  

    if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'STORE':
        if nm == 'Init_filename' and (TCmp(ret, v, ('STORE', (('STORE_NAME', '?'),), ('?',))) or TCmp(ret, v, ('STORE', (('STORE_CALC_CONST', ('STORE_NAME', '?')),), ('?',)))):
            if v[0] not in global_type or ret[1][0][0] == 'STORE_CALC_CONST':
                global_type[v[0]] = {}
            collect_set_global(v[1], nm)
            global_type[v[0]][TypeExpr(v[1])] = v[1] 
            if TypeExpr(v[1]) is None:
                Debug('Not detected type %s for %s' % (v[0], v[1]))
            return True
        v = []  
        if nm != 'Init_filename' and TCmp(ret, v, ('STORE', (('STORE_NAME', '?'),), ('?',))):
            collect_set_global(v[1], nm)
            return True
        v = []
        if TCmp(ret, v, ('STORE', (('STORE_GLOBAL', '?'),), ('?',))) or TCmp(ret, v, ('STORE', (('STORE_CALC_CONST', ('STORE_GLOBAL', '?')),), ('?',))):
            if v[0] not in global_type or ret[1][0][0] == 'STORE_CALC_CONST':
                global_type[v[0]] = {}
            collect_set_global(v[1], nm)
            global_type[v[0]][TypeExpr(v[1])] = v[1]  
            if TypeExpr(v[1]) is None:
                Debug('Not detected type %s for %s' % (v[0], v[1]))
            return True
        if TCmp(ret, v, ('STORE', (('STORE_FAST', '?'),), ('?',))):
            collect_set_global(v[1], nm)
            return True
        v = []
        if TCmp(ret, v, ('STORE', (('SET_VARS', '?'),), ('?',))):
            collect_set_global(v[1], nm)
            t = TypeExpr(v[1])
            for i, s in enumerate(v[0]):
                if s[0] == 'STORE_GLOBAL':
                    if s[1] not in global_type:
                        global_type[s[1]] = {}
                    if IsTuple(t) and t[1] is not None and i < len(t[1]):
                        global_type[s[1]][t[1][i]] = True                  
                        if t[1][i] is None:
                            Debug('Not detected type %s for %s' % (s[0], ret))
                    else:
                        global_type[s[1]][None] = True             
            return True
        v = []
        if TCmp(ret, v, ('STORE', (('PyObject_SetItem', '?', '?'),), ('?',))):
            collect_set_global(v[0], nm)
            collect_set_global(v[1], nm)
            collect_set_global(v[2], nm)
            return True
        v = []
        if TCmp(ret, v, ('STORE', (('PyObject_SetAttr', '?', '?'),), ('?',))):
            collect_set_global(v[0], nm)
            collect_set_global(v[1], nm)
            collect_set_global(v[2], nm)
            return True
        v = []
        if len(ret[1]) == 1 and ret[1][0][0] == 'STORE_CALC_CONST': ##TCmp(ret, v, ('STORE', (('STORE_CALC_CONST', '?'),), '?')):
            return True
    if type(ret) is tuple and len(ret) >= 1 and type(ret[0]) is str and ret[0] in ('!BULD_TUPLE', '!BULD_LIST'):
        for x in ret[1]:
            collect_set_global(x, nm)
        return True
        
    if type(ret) is tuple and len(ret) >= 1 and type(ret[0]) is str and ret[0] in ('UNPUSH', 'PRINT_ITEM_1'):
        collect_set_global(ret[1], nm)
        return True
    
    if type(ret) is tuple and len(ret) >= 1 and type(ret[0]) is str and ret[0][0] == '!' and ret[0] != '!LIST_COMPR':
        for x in ret[1:]:
            collect_set_global(x, nm)
        return True

    ## v = []
    ## if type(ret) is tuple and len(ret) >= 1 and type(ret[0]) is str and \
        ## ((ret[0][0] == '!' and ret[0] != '!LIST_COMPR') or \
         ## ret[0] in ('(IF', ')IF', '(WHILE', ')WHILE', \
                    ## ')(ELSE', 'RETURN', 'SET_VARS', 'UNPUSH')):
        ## return False
    v = []
    if type(ret) is tuple and len(ret) >= 1:
        if type(ret[0]) is tuple:
            return False
        v = []
        if TCmp(ret, v, ('CALC_CONST', '?')):
            return True
        v = []
        if TCmp(ret, v, ('CONST', '?')):
            return False
        v = []
        if TCmp(ret, v, (('CONST', '?'),)):
            return False
        v = []
        if TCmp(ret, v, (('!BUILD_TUPLE', '?'),)):
            for i, _v1 in enumerate(v[0]):
                collect_set_global(_v1, nm)
            return True
        v = []
        if TCmp(ret, v, (('!BUILD_LIST', '?'),)):
            for i, _v1 in enumerate(v[0]):
                collect_set_global(_v1, nm)
            return True
        v = []
        if TCmp(ret, v, (('!BUILD_MAP', '?'),)):
            for _v1, _v2 in v[0]:
                collect_set_global(_v1, nm)
                collect_set_global(_v2, nm)
            return True
        v = []
        ## if TCmp(ret, v, ('STORE_GLOBAL', '?')):
            ## if v[0] not in global_type:
                ## global_type[v[0]] = {}
            ## pp('364364356')
            ## pprint(ret)
            ## global_type[v[0]][None] = '?'        
            ## return True
        if TCmp(ret, v, ('DELETE_GLOBAL', '?')):
            if v[0] not in global_type:
                global_type[v[0]] = {}
            global_type[v[0]][None] = '?'        
            return True
    if nm == 'Init_filename':
        ## if TCmp(ret, v, ('STORE_NAME', '?')):
            ## if v[0] not in global_type:
                ## global_type[v[0]] = {}
            ## pp('364364356')
            ## pprint(ret)
            ## global_type[v[0]][None] = '?'        
            ## return True
        if TCmp(ret, v, ('DELETE_NAME', '?')):
            if v[0] not in global_type:
                global_type[v[0]] = {}
            global_type[v[0]][None] = '?'        
            return True
        ## if TCmp(ret, v, (('STORE_NAME', '?'),)):
            ## if v[0] not in global_type:
                ## global_type[v[0]] = {}
            ## global_type[v[0]][None] = '?'            
            ## return True             
    v = []
    if TCmp(ret, v, ('STORE_NAME', '?')):
        return True
    v = []
    if TCmp(ret, v, ('STORE_CALC_CONST', '?')):
        return True
    v = []
    if TCmp(ret, v, (('STORE_GLOBAL', '?'),)):
        if v[0] not in global_type:
            global_type[v[0]] = {}
        global_type[v[0]][None] = '?'            
        return True
    v = []
    if TCmp(ret, v, (('STORE_CALC_CONST', '?'),)):
        return True
    v = []
    if type(ret) is tuple and len(ret) == 3 and type(ret[0]) is str and \
        ret[0] == 'SET_EXPRS_TO_VARS' and \
        TCmp(ret, v, ('SET_EXPRS_TO_VARS', '?', '?')):
        for i, _v1 in enumerate(v[0]):
            _v2 = v[1][i]
            if _v1[0] == 'STORE_GLOBAL':
                if _v1[1] not in global_type:
                    global_type[_v1[1]] = {}
                global_type[_v1[1]][None] = None 
            collect_set_global(_v2, nm)
        return True
    v = []
    if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str and ret[0] == '!LIST_COMPR':
        if TCmp(ret, v, ('!LIST_COMPR', '?', '?')):
            varset = False
            if len(v[1][0]) == 1 and len(v[1][1]) == 1:
                stor, expr = v[1][0][0], v[1][1][0]
                if stor[0] == 'STORE_GLOBAL' or (stor[0] == 'STORE_NAME' and nm == 'Init_filename'):
                    v2 = []
                    if TCmp(expr, v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('!BUILD_TUPLE', ('?',)), ('NULL',))):
                        glob_type_set(stor[1], Kl_Cardinal, True)
                        varset = True
                    elif TCmp(expr, v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('CONST', '?'), ('NULL',))):
                        glob_type_set(stor[1], Kl_Cardinal, True)
                        varset = True
                    elif TCmp(expr, v2, ('!BUILD_LIST', '?')):
                        li = uniq_list_type([TypeExpr(x) for x in v2[0]])
                        if len(li) == 1:
                            glob_type_set(stor[1], li[0], True)
                            varset = True
                    elif TCmp(expr, v2, ('CONST', '?')) and type(v2[0]) is tuple:
                        li = uniq_list_type([TypeExpr(('CONST', x)) for x in v2[0]])
                        if len(li) == 1:
                            glob_type_set(stor[1], li[0], True)
                            varset = True
            temp = v[1]
            v = [v[0],None,None, None]
            collect_set_global(v[0], nm)
            while len(temp) > 0:
                v[1:] = temp[:3]
                temp = temp[3:]
                    
                for _v in v[1]:
                    if type(_v) is tuple and (_v[0] == 'STORE_GLOBAL' or (_v[0] == 'STORE_NAME'  and nm == 'Init_filename')) and not varset:
                        glob_type_set(_v[1], None, ret)
                collect_set_global(v[2], nm)
                collect_set_global(v[3], nm)
            return True
    
#*************        
        
        
    if len(ret) > 0 and type(ret[0]) is str and ret[0] == '(FOR':
        if TCmp(ret, v, ('(FOR', (('?', '?'),), ('!PyObject_Call', ('!LOAD_BUILTIN', '?'), ('CONST', ('?',)), ('NULL',)))) and\
            type(v[3]) is int:
            stor, nmvar, rng = v[:3]
            assert type(stor) is str    
            assert type(nmvar) is str    
            assert type(rng) is str    
            if rng in ('range', 'xrange') and (stor == 'STORE_GLOBAL' or (stor == 'STORE_NAME' and nm == 'Init_filename')):
                if nmvar not in global_type:
                    global_type[nmvar] = {}
                if v[3] > 0:    
                    global_type[nmvar][Int(0, v[3]-1)] = True  
                return True     
        if TCmp(ret, v, ('(FOR', (('?', '?'),), ('!PyObject_Call', ('!LOAD_BUILTIN', '?'), ('!BUILD_TUPLE', ('?',)), ('NULL',)))):
            stor, nmvar, rng = v[:3]
            assert type(stor) is str    
            assert type(nmvar) is str    
            assert type(rng) is str    
            if rng in ('range', 'xrange') and (stor == 'STORE_GLOBAL' or (stor == 'STORE_NAME' and nm == 'Init_filename')):
                if nmvar not in global_type:
                    global_type[nmvar] = {}
                t = TypeExpr(v[3])
                if IsInt(t):
                    global_type[nmvar][Int(0, t[1][1])] = True  
                elif rng == 'range':
                    global_type[nmvar][Kl_Cardinal] = True  
                else:
                    global_type[nmvar][Kl_IntUndefSize] = True  
                return True 
        if TCmp(ret, v, ('(FOR', (('?', '?'),), ('!BUILD_LIST', '?'))):
            li = uniq_list_type([TypeExpr(x) for x in v[2]])
            if len(li) == 1:
                stor, nmvar = v[:2]
                assert type(stor) is str    
                assert type(nmvar) is str    
                if (stor == 'STORE_GLOBAL' or (stor == 'STORE_NAME' and nm == 'Init_filename')):
                    if nmvar not in global_type:
                        global_type[nmvar] = {}
                    global_type[nmvar][li[0]] = True  
                    return True     
        if TCmp(ret, v, ('(FOR', (('?', '?'),), ('CONST', '?')))  and type(v[2]) is tuple:
            li = uniq_list_type([TypeExpr(('CONST', x)) for x in v[2]])
            if len(li) == 1:
                stor, nmvar = v[:2]
                assert type(stor) is str    
                assert type(nmvar) is str    
                if (stor == 'STORE_GLOBAL' or (stor == 'STORE_NAME' and nm == 'Init_filename')):
                    if nmvar not in global_type:
                        global_type[nmvar] = {}
                    global_type[nmvar][li[0]] = True  
                    return True     


        sets = ret[1]
        for sets in ret[1]:
            if sets is not None and (sets[0] == 'STORE_GLOBAL' or (sets[0] == 'STORE_NAME' and nm == 'Init_filename')):
                if sets[1] not in global_type:
                    global_type[sets[1]] = {}
                global_type[sets[1]][None] = True  
                Debug('Not detected FOR type %s for %s' % (sets[1], ret))
        return True            

    v = []
    if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'SEQ_ASSIGN':
        sets = ret[1]
        for sets in ret[1]:
            if sets is not None and sets[0] == 'STORE_GLOBAL':
                if sets[1] not in global_type:
                    global_type[sets[1]] = {}
                global_type[sets[1]][TypeExpr(ret[2])] = ret[2]  
        return True               
    v = []
    if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'IMPORT_FROM_AS':
        for _v in ret[4]:
            if _v[0] == 'STORE_GLOBAL':
                if _v[1] not in global_type:
                    global_type[_v[1]] = {}
                global_type[_v[1]][None] = None
        return True
    if  nm == 'Init_filename':
        v = []
        if type(ret) is tuple and len(ret) >1 and type(ret[0]) is str and \
           ret[0] == ')(EXCEPT':
            if TCmp(ret, v, (')(EXCEPT', ('?', '?'), (('STORE_NAME', '?'),))) and type(v[1]) is int:
                collect_set_global(v[0], nm)
                glob_type_set(v[2], None, ret)
                return 
            v = []
            if TCmp(ret, v, (')(EXCEPT', ('?',), (('STORE_NAME', '?'),))) :
                collect_set_global(v[0], nm)
                glob_type_set(v[1], None, ret)
                return

    v = []
    if type(ret) is tuple and len(ret) >1 and type(ret[0]) is str and \
       ret[0] == ')(EXCEPT':
        if TCmp(ret, v, (')(EXCEPT', ('?', '?'), (('STORE_GLOBAL', '?'),))) and type(v[1]) is int:
            collect_set_global(v[0], nm)
            glob_type_set(v[2], None, ret)
            return 
        v = []
        if TCmp(ret, v, (')(EXCEPT', ('?',), (('STORE_GLOBAL', '?'),))) :
            collect_set_global(v[0], nm)
            glob_type_set(v[1], None, ret)
            return
    
    _v = []            
    if TCmp(ret, _v, ('(WITH', '?', ('STORE_GLOBAL', '?'))):    
        if _v[1] not in global_type:
            global_type[_v[1]] = {}
        global_type[_v[1]][None] = None
        return True
    _v = []
    if TCmp(ret, _v, ('(WITH', '?', (('STORE_GLOBAL', '?'),))):    
        if _v[1] not in global_type:
            global_type[_v[1]] = {}
        global_type[_v[1]][None] = None
        return True
    _v = []
    if  nm == 'Init_filename' and TCmp(ret, _v, ('(WITH', '?', (('STORE_NAME', '?'),))):    
        if _v[1] not in global_type:
            global_type[_v[1]] = {}
        global_type[_v[1]][None] = None
        return True
    if len(ret) > 1 and type(ret[0]) is str and ret[0] == '.L':
        return False
    
    if type(ret) is tuple and tag_in_expr('STORE_GLOBAL', ret):
        pp('<', ret, '>')
        pprint(ret)
        Fatal('Can\'t collect type global variables', ret) 
        assert False
    if nm == 'Init_filename' and type(ret) is tuple and tag_in_expr('STORE_NAME', ret):
        pp('<', ret, '>')
        pprint(ret)
        Fatal('Can\'t collect type global variables', ret) 
        assert False

    return ret    

local_type = {}

def not_loc_detec(nm, expr):
    Debug('def %s, var %s -- local type not detected (%s)' % (g_co.co_name, nm, expr))

def loc_detec(nm, typ, expr):
    if nm == 'cc' and g_co.co_name == 'const_to' and typ == Kl_List:
        assert False
    Debug('def %s, var %s -- local type %s detected (%s)' % (g_co.co_name, nm, typ, expr))
 
def loc_type_set(nm, typ, expr):
    global local_type
    if nm not in local_type:
        local_type[nm] = {}
    local_type[nm][typ] = expr  
    if typ is None:
        not_loc_detec(nm, expr)    
    else:
        loc_detec(nm, typ, expr)    
def collect_set_local(a, nm):
    global local_type
    ret = a
    if type(a) is tuple:
        assert type(ret) is tuple
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return
        if len(a) >= 1 and type(a[0]) is tuple:
            for i in a:
                collect_set_local(i, nm)
            return
        if len(a) >= 1 and type(a[0]) is str and a[0] in ('!AND_BOOLEAN', '!OR_BOOLEAN'):
            for i in a:
                collect_set_local(i, nm)
            return
        if len(a) >= 1 and type(a[0]) is str and a[0] == '!PyObject_Call':
            collect_set_local(a[1], nm)
            if a[2][0] == '!BUILD_TUPLE':
                for i in a[2][1]:
                    collect_set_local(i, nm)
            if a[3] != ('NULL',):
                collect_set_local(a[3], nm)
            return
        v = []  
        if len(ret) == 2 and type(ret[0]) is str and ret[0] in ('RETURN_VALUE', '(IF', '(WHILE', 'UNPUSH', 'PRINT_ITEM_1', '!BOOLEAN'):
            collect_set_local(ret[1], nm)
            return
        if len(ret) == 3 and type(ret[0]) is str and ret[0] in ('PRINT_ITEM_TO_2',):
            collect_set_local(ret[1], nm)
            collect_set_local(ret[2], nm)
            return
        if len(ret) == 3 and type(ret[0]) is str and ret[0] in ('(IF', '(WHILE'):
            collect_set_local(ret[1], nm)
            return
        if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'PYAPI_CALL':
            temp = ret[1]
            for x in temp[1:]:
                if type(x) is tuple:
                    collect_set_local(x, nm)
            return
        if len(ret) > 2 and type(ret[0]) is str and ret[0] == 'RAISE_VARARGS_STMT' and ret[1] == 0:
            for x in ret[2:]:
                if type(x) is tuple:
                    collect_set_local(x, nm)
            return
        if len(ret) > 2 and type(ret[0]) is str and ret[0] == 'RAISE_VARARGS' and ret[1] == 0:
            for x in ret[2:]:
                if type(x) is tuple:
                    collect_set_local(x, nm)
            return
        if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'DELETE_FAST':
            loc_type_set(ret[1], None, ret)
            return
        if len(ret) >= 3 and ret[0] == 'UNPACK_SEQ_AND_STORE' and ret[1] == 0:  
            for s1 in ret[2]:
                if s1[0] == 'STORE_FAST':
                    loc_type_set(s1[1], None, ret)
                elif s1[0] == 'STORE_GLOBAL':
                    pass
                elif s1[0] == 'UNPACK_SEQ_AND_STORE' and s1[1] == 0:
                    collect_set_local(s1, nm)
                elif s1[0] == 'STORE_DEREF':
                    pass
                elif s1[0] == 'STORE_NAME':
                    pass
                elif s1[0] == 'PyObject_SetAttr':
                    pass
                elif s1[0] == 'PyObject_SetItem':
                    pass                                 
                else:
                    pprint(s1)
                    pp('-----')
                    pprint(ret)                                
                    assert False
            return          
        if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'STORE':
            if TCmp(ret, v, ('STORE', (('STORE_NAME', '?'),), ('?',))):
                collect_set_local(v[1], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_GLOBAL', '?'),), ('?',))):
                collect_set_local(v[1], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_DEREF', '?'),), ('?',))):
                collect_set_local(v[1], nm)
                return
            if TCmp(ret, v, ('STORE', (('PyObject_SetItem', '?', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                return
            if TCmp(ret, v, ('STORE', (('PyObject_SetAttr', '?', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                return
            if TCmp(ret, v, ('STORE', (('?PyObject_SetAttr', '?', '?', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                collect_set_local(v[3], nm)
                return            
            if TCmp(ret, v, ('STORE', (('STORE_SLICE_LV+3', '?', '?', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                collect_set_local(v[3], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_SLICE_LV+2', '?', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_SLICE_LV+1', '?', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_SLICE_LV+0', '?'),), ('?',))):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                return
            if TCmp(ret, v, ('STORE', (('STORE_FAST', '?'),), ('?',))):
                loc_type_set(v[0], TypeExpr(v[1]), v[1])
                collect_set_local(v[1], nm)
                return
 
            if TCmp(ret, v, ('STORE', (('SET_VARS', '?'),), ('?',))):
                t = TypeExpr(v[1])
                for i, s in enumerate(v[0]):
                    if s[0] == 'STORE_FAST':
                        if IsTuple(t) and t[1] is not None and type(t[1]) is tuple and i < len(t[1]):
                            loc_type_set(s[1], t[1][i], ret)
                        else:
                            loc_type_set(s[1], None, ret)
                    elif s[0] == 'UNPACK_SEQ_AND_STORE' and s[1] == 0:
                        collect_set_local(s, nm)
                    elif s[0] == 'STORE_GLOBAL':
                        pass
                    elif s[0] == 'STORE_DEREF':
                        pass
                    elif s[0] == 'STORE_NAME':
                        pass
                    elif s[0] == 'PyObject_SetAttr':
                        pass
                    elif s[0] == 'PyObject_SetItem':
                        pass                    
                    else:
                        pprint(s)
                        pp('-----')
                        pprint(ret)
                        assert False
                collect_set_local(v[1], nm)
                return

            v = []
            if TCmp(ret, v, ('STORE', (('STORE_CALC_CONST', '?'),), '?')):
                collect_set_local(v[1], nm)
                return
            v = []
            if TCmp(ret, v, ('STORE', (('UNPACK_SEQ_AND_STORE', '?', '?'),), ('?',))):    
                t = TypeExpr(v[2])
                for i, s in enumerate(v[1]):
                    if s[0] == 'STORE_FAST':
                        if IsTuple(t) and t[1] is not None and i < len(t[1]):
                            loc_type_set(s[1], t[1][i], ret)
                        else:
                            loc_type_set(s[1], None, ret)
                collect_set_local(v[2], nm)
                return

        if type(ret) is tuple and len(ret) == 3 and type(ret[0]) is str and \
           ret[0] == 'SET_EXPRS_TO_VARS' and \
           TCmp(ret, v, ('SET_EXPRS_TO_VARS', '?', '?')):
            for i, _v1 in enumerate(v[0]):
                if _v1[0] == 'STORE_FAST':
                    loc_type_set(_v1[1], TypeExpr(v[1][i]), v[1][i])
            collect_set_local(v[1], nm)
            return
        if type(ret) is tuple and len(ret) == 3 and type(ret[0]) is str and \
           ret[0] == 'SEQ_ASSIGN' and \
           TCmp(ret, v, ('SEQ_ASSIGN', '?', '?')):
            t = TypeExpr(v[1])
            for i, _v1 in enumerate(v[0]):
                if _v1[0] == 'STORE_FAST':
                    loc_type_set(_v1[1], t, v[1])
            collect_set_local(v[1], nm)
            return
    
        v = []
        if type(ret) is tuple and len(ret) >1 and type(ret[0]) is str and \
           ret[0] == ')(EXCEPT':
            if TCmp(ret, v, (')(EXCEPT', ('?', '?'), (('STORE_FAST', '?'),))) and type(v[1]) is int:
                collect_set_local(v[0], nm)
                loc_type_set(v[2], None, ret)
                return
            v = []
            if TCmp(ret, v, (')(EXCEPT', ('?',), (('STORE_FAST', '?'),))) :
                collect_set_local(v[0], nm)
                loc_type_set(v[1], None, ret)
                return
        v = []
        if type(ret) is tuple and len(ret) >1 and type(ret[0]) is str and \
           ret[0] == '(WITH':
            if TCmp(ret, v, ('(WITH', '?', ('STORE_FAST', '?'))):    
                collect_set_local(v[0], nm)
                loc_type_set(v[1], None, ret)
                return
            if TCmp(ret, v, ('(WITH', '?', (('STORE_FAST', '?'),))):    
                collect_set_local(v[0], nm)
                loc_type_set(v[1], None, ret)
                return
            if TCmp(ret, v, ('(WITH', '?', ('STORE_DEREF', '?'))):    
                collect_set_local(v[0], nm)
                loc_type_set(v[1], None, ret)
                return
            if TCmp(ret, v, ('(WITH', '?', (('STORE_DEREF', '?'),))):    
                collect_set_local(v[0], nm)
                loc_type_set(v[1], None, ret)
                return
            if TCmp(ret, v, ('(WITH', '?', ('STORE_NAME', '?'))):    
                collect_set_local(v[0], nm)
                return
            if TCmp(ret, v, ('(WITH', '?', (('STORE_NAME', '?'),))):    
                collect_set_local(v[0], nm)
                return
            if TCmp(ret, v, ('(WITH', '?', ('STORE_GLOBAL', '?'))):    
                collect_set_local(v[0], nm)
                return
            if TCmp(ret, v, ('(WITH', '?', (('STORE_GLOBAL', '?'),))):    
                collect_set_local(v[0], nm)
                return
            if TCmp(ret, v, ('(WITH', '?', (('SET_VARS', '?'),))):    
                collect_set_local(v[0], nm)
                for k in v[1]:
                    if type(k) is tuple and len(k) == 2 and k[0] == 'STORE_FAST':
                        loc_type_set(k[1], None, ret)
                return            
            if TCmp(ret, v, ('(WITH', '?', ('SET_VARS', '?'))):    
                collect_set_local(v[0], nm)
                for k in v[1]:
                    if type(k) is tuple and len(k) == 2 and k[0] == 'STORE_FAST':
                        loc_type_set(k[1], None, ret)
                return
            if TCmp(ret, v, ('(WITH', '?', ('PyObject_SetAttr', '?', '?'))):    
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                return
            if TCmp(ret, v, ('(WITH', '?', (('PyObject_SetAttr', '?', '?'),))):    
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                return
            if TCmp(ret, v, ('(WITH', '?', (('PyObject_SetItem', '?', '?'),))):    
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                collect_set_local(v[2], nm)
                return
            if TCmp(ret, v, ('(WITH', '?', ())):    
                collect_set_local(v[0], nm)
                return
            pprint(ret)
            Fatal('Can\'t collect type local variables WITH', ret) 
            assert False
        if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str and ret[0] == '(FOR':
            if len(ret[1]) == 2 and len(ret[1][0]) == 2 and ret[1][0][0] == 'STORE_FAST':
                if TCmp(ret, v, ('(FOR', (('STORE_FAST', '?'), '?'), 
                                ('!PyObject_Call', ('!LOAD_BUILTIN', 'enumerate'), \
                                    '?', ('NULL',)))):
                    typint = Kl_Cardinal
                    typseq = None
                    if v[2][0] == '!BUILD_TUPLE' and len(v[2][1]) == 1:
                        typseq = TypeExpr(v[2][1][0])
                        if IsList(typseq) or IsTuple(typseq) or IsStr(typseq):
                            typint = Int(0, MInt / 10)
                    elif v[2][0] == 'CONST' and type(v[2][1]) is tuple and len(v[2][1]) == 1:
                        typseq = TypeExpr(v[2][1][0])
                        if IsList(typseq) or IsTuple(typseq) or IsStr(typseq):
                            typint = Int(0, MInt / 10)

                    loc_type_set(v[0], typint, ret)
                    if v[1][0] == 'STORE_FAST':
                        if IsStr(typseq):
                            loc_type_set(v[1][1], Kl_Char, v[2])
                        else:
                            loc_type_set(v[1][1], None, v[2])
                    elif v[1][0] == 'UNPACK_SEQ_AND_STORE' and v[1][1] == 0:
                        t = None
                        for i, v5 in enumerate(v[1][2]):   
                            if v5[0] == 'STORE_FAST':
                                loc_type_set(v5[1], None, ret)
                            elif v5[0] == 'UNPACK_SEQ_AND_STORE' and v5[1] == 0:
                                for v57 in v5[2]:   
                                    if v57[0] == 'STORE_FAST':
                                        loc_type_set(v57[1], None, ret)
                                    else:    
                                        if type(v57) is tuple: # and 'STORE_FAST' in repr(v5):
                                            pp('<', v57, ':', ret, '>')
                                            Fatal('Can\'t collect FOR unpack type local variables', v57, ret)  
                                            assert False
                            else:    
                                if type(v5) is tuple: # and 'STORE_FAST' in repr(v5):
                                    pp('<', v5, ':', ret, '>')
                                    Fatal('Can\'t collect FOR unpack type local variables', v5, ret)  
                                    assert False
                    return
            if len(ret[1]) == 1 and len(ret[1][0]) == 2 and ret[1][0][0] == 'STORE_FAST':
                v = [ret[1][0][1], ret[2]] ##if TCmp(ret, v, ('(FOR', (('STORE_FAST', '?'),), '?')):
                v2 = []
                if IsStr(TypeExpr(v[1])):
                    loc_type_set(v[0], Kl_Char, True)
                    collect_set_local(v[1], nm)   
                    return                 
                elif IsUnicode(TypeExpr(v[1])):
                    loc_type_set(v[0], Kl_UnicodeChar, True)
                    collect_set_local(v[1], nm)   
                    return                 
                elif v[1][0] == 'CONST' and type(v[1][1]) is tuple and all([type(x) is int for x in v[1][1]]) and len(v[1][1]) > 0:
                    li = [x for x in v[1][1]]
                    li.sort()
                    loc_type_set(v[0], Int(li[0], li[-1]), True)
                    return                                            
                elif  v[1][0] == '!PyObject_Call' and 'range' in repr(v[1]):
                    if TCmp(v[1], v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), ('CONST', (int, int)), \
                                    ('NULL',))) or \
                        TCmp(v[1], v2, \
                                        ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('CONST', (int, int)), \
                                        ('NULL',))):
                        loc_type_set(v[0], Int(v2[0], v2[1]), True)
                        collect_set_local(v[1], nm)
                        return                                            
                    elif TCmp(v[1], v2, \
                                        ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), ('CONST', (int,)), \
                                        ('NULL',))) or \
                        TCmp(v[1], v2, \
                                        ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('CONST', (int,)), \
                                        ('NULL',))):
                        loc_type_set(v[0], Int(0, v2[0]), True)
                        collect_set_local(v[1], nm)
                        return
                    v2 = []                             
                    if TCmp(v[1], v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), \
                                    ('CONST', ('?',)), ('NULL',))):
                        if v2[0] is int:
                            loc_type_set(v[0], Int(0, v2[0]), True)
                        collect_set_local(v[1], nm)
                        return
                    if TCmp(v[1], v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), \
                                    ('!BUILD_TUPLE', ('?',)), ('NULL',))):
                        t = TypeExpr(v2[0])
                        if IsInt(t):
                            loc_type_set(v[0], Int(0, t[1][1]), ret)
                        else:
                            loc_type_set(v[0], Kl_Cardinal, True)
                        collect_set_local(v[1], nm)
                        return
                    if TCmp(v[1], v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), \
                                    ('!BUILD_TUPLE', ('?', '?')), ('NULL',))):
                        t = TypeExpr(v2[0])
                        t2 = TypeExpr(v2[1])
                        if IsInt(t) and IsInt(t2):
                            loc_type_set(v[0], join_int(t, t2), ret)
                        elif t is None and t2 is None:
                            loc_type_set(v[0], Kl_IntUndefSize, True)
                        else:    
                            if t2 is None:
                                loc_type_set(v[0], Kl_IntUndefSize, True)
                            else:    
                                loc_type_set(v[0], t, ret)
                        collect_set_local(v[1], nm)
                        return
                    if TCmp(v[1], v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), \
                                    ('!BUILD_TUPLE', ('?',)), ('NULL',))):
                        t = TypeExpr(v2[0])
                        if IsInt(t):
                            loc_type_set(v[0], Int(0, t[1][1]), ret)
                        elif t is None:
                            loc_type_set(v[0], Kl_IntUndefSize, True)
                        else:    
                            loc_type_set(v[0], t, ret)
                        collect_set_local(v[1], nm)
                        return
                    if TCmp(v[1], v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'xrange'), \
                                    ('!BUILD_TUPLE', ('?', '?')), ('NULL',))):
                        t = TypeExpr(v2[0])
                        t2 = TypeExpr(v2[1])
                        if IsInt(t) and IsInt(t2):
                            loc_type_set(v[0], join_int(t, t2), ret)
                        elif t is None and t2 is None:
                            loc_type_set(v[0], Kl_IntUndefSize, True)
                        else:    
                            if t2 is None:
                                loc_type_set(v[0], Kl_IntUndefSize, True)
                            else:    
                                loc_type_set(v[0], t, ret)
                        collect_set_local(v[1], nm)
                        return
                loc_type_set(v[0], None, ret)
                collect_set_local(v[1], nm)
                return
            v = []
            if TCmp(ret, v, ('(FOR', '?', '?')):
                collect_local_for_vars(v[0], ret)
                collect_set_local(v[1], nm)
                return
    
        v = []
        if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str and ret[0] == '!LIST_COMPR':
            if TCmp(ret, v, ('!LIST_COMPR', '?', '?')):
                varset = False
                if len(v[1][0]) == 1 and len(v[1][1]) == 1:
                    stor, expr = v[1][0][0], v[1][1][0]
                    if stor[0] == 'STORE_FAST':
                        v2 = []
                        if TCmp(expr, v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('!BUILD_TUPLE', ('?',)), ('NULL',))):
                            loc_type_set(stor[1], Kl_Cardinal, True)
                            varset = True
                        elif TCmp(expr, v2, ('!PyObject_Call', ('!LOAD_BUILTIN', 'range'), ('CONST', '?'), ('NULL',))):
                            if type(v2[0]) is int and v2[0] >= 0:
                                loc_type_set(stor[1], Int(0, v2[0]), True)
                            else:
                                loc_type_set(stor[1], (type(v2[0]), None), True)
                            varset = True
                        elif TCmp(expr, v2, ('!BUILD_LIST', '?')) and all([x[0] == 'CONST' and type(x[1]) is int for x in v2[0]]):
                            li = [x[1] for x in v2[0]]
                            li.sort()
                            if len(li) > 0:
                                loc_type_set(stor[1], Int(li[0], li[-1]), True)
                            varset = True
                        elif TCmp(expr, v2, ('CONST', '?')) and type(v2[0]) is tuple and len(v2[0]) > 0 and all([type(x) is int for x in v2[0]]):
                            li = list(v2[0])
                            li.sort()
                            loc_type_set(stor[1], Int(li[0], li[-1]), True)
                            varset = True
                        elif IsStr(TypeExpr(expr)):
                            collect_set_local(expr, nm)
                            collect_set_local(v[1][2], nm)
                            loc_type_set(stor[1], Kl_Char, True)
                            varset = True
                        elif IsUnicode(TypeExpr(expr)):
                            collect_set_local(expr, nm)
                            collect_set_local(v[1][2], nm)
                            loc_type_set(stor[1], Kl_UnicodeChar, True)
                            varset = True
                v_ = []
                if not varset and TCmp(ret, v_, ('!LIST_COMPR', '?',
                    ((('STORE_FAST', '?'), ('STORE_FAST', '?')), 
                    (('!PyObject_Call', ('!LOAD_BUILTIN', 'enumerate'), '?', ('NULL',)),), '?'))):
                        loc_type_set(v_[1], Kl_Cardinal, True)
                        loc_type_set(v_[2], None, ret)
                        collect_set_local(v_[0], nm)
                        collect_set_local(v_[3], nm)
                        collect_set_local(v_[4], nm)
                        return
                temp = v[1]
                v = [v[0],None,None, None]
                collect_set_local(v[0], nm)
                while len(temp) > 0:
                    v[1:] = temp[:3]
                    temp = temp[3:]
                    
                    for _v in v[1]:
                        if type(_v) is tuple and _v[0] == 'STORE_FAST' and not varset:
                            loc_type_set(_v[1], None, ret)
                    collect_set_local(v[2], nm)
                    collect_set_local(v[3], nm)
                return
        if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str and ret[0] == '!SET_COMPR':
            if TCmp(ret, v, ('!SET_COMPR', '?', '?')):
                temp = v[1]
                v = [v[0],None,None, None]
                collect_set_local(v[0], nm)
                while len(temp) > 0:
                    v[1:] = temp[:3]
                    temp = temp[3:]
                    
                    for _v in v[1]:
                        if type(_v) is tuple and _v[0] == 'STORE_FAST':
                            loc_type_set(_v[1], None, ret)
                    collect_set_local(v[2], nm)
                    collect_set_local(v[3], nm)
                return  
        if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str and ret[0] == '!MAP_COMPR':
            if TCmp(ret, v, ('!MAP_COMPR', '?', '?')):
                temp = v[1]
                v = [v[0],None,None, None]
                collect_set_local(v[0], nm)
                while len(temp) > 0:
                    v[1:] = temp[:3]
                    temp = temp[3:]
                    
                    for _v in v[1]:
                        if type(_v) is tuple and _v[0] == 'STORE_FAST':
                            loc_type_set(_v[1], None, ret)
                    collect_set_local(v[2], nm)
                    collect_set_local(v[3], nm)
                return                        
        if type(ret) is tuple and len(ret) > 0 and type(ret[0]) is str and ret[0] == '!COND_METH_EXPR':
            if TCmp(ret, v, ('!COND_METH_EXPR', '?', '?', '?')):
                collect_set_local(v[0], nm)
                collect_set_local(v[1], nm)
                return          
        if len(ret) > 0 and type(ret[0]) is str and ret[0] == 'IMPORT_FROM_AS':
            collect_set_local(ret[2], nm)
            collect_set_local(ret[3], nm)
            for _v in ret[4]:
                if _v[0] == 'STORE_FAST':
                    loc_type_set(_v[1], None, ret)
                elif _v[0] == 'STORE_CALC_CONST':
                    pass   
                elif _v[0] == 'STORE_GLOBAL':
                    pass 
                elif _v[0] == 'STORE_NAME':
                    pass  
                elif _v[0] == 'STORE_DEREF':
                    loc_type_set(_v[1], None, ret)  
                else:    
                    if type(_v) is tuple: # and 'STORE_FAST' in repr(_v):
                        pp('<', _v, ':', ret, '>')
                        Fatal('Can\'t collect FOR type local variables', _v, ret)   
                        assert False 
            return
        if type(ret) is tuple and len(ret) > 0: # and 'STORE_FAST' in repr_ret:
            if ret[0] == 'PY_TYPE':
                collect_set_local(ret[3], nm)
                return
            if ret[0] == 'CLONE':
                collect_set_local(ret[1], nm)
                return            
            if ret[0] == 'DELETE_GLOBAL':
                return
            if len(ret) == 2 and ret[0] in ('DELETE_SLICE+0', 'PRINT_NEWLINE_TO_1'):
                collect_set_local(ret[1], nm)
                return
            if ret[0] in ('DELETE_SUBSCR', '!_PyString_Join', \
                          'PRINT_ITEM_AND_NEWLINE_TO_2', 'DELETE_SLICE+1',\
                          'DELETE_SLICE+2', ')(EXCEPT', 'DELETE_ATTR_2'):
                if len(ret) > 1:
                    collect_set_local(ret[1], nm)
                if len(ret) > 2:
                    assert len(ret) == 3
                    collect_set_local(ret[2], nm)
                return
            if ret[0] in ('DELETE_SLICE+3',):
                collect_set_local(ret[1], nm)
                collect_set_local(ret[2], nm)
                collect_set_local(ret[3], nm)
                return
            if type(ret[0]) is str and len(ret) == 1:
                return
            if ret[0] in ('(TRY', ')ENDTRY', '.L', 'CALC_CONST', 'NULL', 'FAST', \
                          ')ENDIF', ')(ELSE', 'PRINT_NEWLINE', 'LOAD_CLOSURE', \
                          'BUILTIN'):
                return
            if ret == ('RAISE_VARARGS', 0):
                return
            if ret[0] in ('STORE_NAME', 'DELETE_NAME'):
                loc_type_set(ret[1], None, ret) 
                return
            if ret[0] in ('IMPORT_STAR', 'EXEC_STMT_3', 'EXEC_STMT_2', \
                          'EXEC_STMT_1', 'EXEC_STMT_0', 'EXEC_STMT'):
                for _nm in g_co.co_varnames:
                    loc_type_set(_nm, None, ret)
                return
            if ret[0] in ('YIELD_STMT',):
                collect_set_local(ret[1], nm)
                return
            if type(ret[0]) is not str or ret[0][0] != '!':
                pprint(ret)
                pp('<', ret, '>')
                pprint(ret)
                Fatal('Can\'t collect type local variables', ret) 
                assert False
                return   
        for i in a:
            collect_set_local(i, nm)
        return 
    if type(a) is list:
        assert len(a) > 0
        for i in a:
            collect_set_local(i, nm)
    return 

def collect_local_for_vars(v, ret):
    for _v in v:
        if type(_v) is tuple and _v[0] == 'STORE_FAST':
            loc_type_set(_v[1], None, ret)
        elif type(_v) is tuple and _v[0] == 'STORE_GLOBAL':
            pass
        elif type(_v) is tuple and _v[0] == 'STORE_NAME':
            pass
        elif type(_v) is tuple and _v[0] == 'STORE_DEREF':
            loc_type_set(_v[1], None, ret)            
        elif type(_v) is tuple and _v[0] == 'PyObject_SetAttr':
            pass
        elif type(_v) is tuple and _v[0] == 'UNPACK_SEQ_AND_STORE' and _v[1] == 0:
            collect_local_for_vars(_v[2], ret)
        else:    
            if type(_v) is tuple: # and 'STORE_FAST' in repr(_v):
                pp('<', _v, ':', ret, '>')
                Fatal('Can\'t collect FOR type local variables', _v, ret) 
                assert False
              
def tree_pass(a, upgrade_op, up, nm): 
    global print_tree_node
    if print_tree_node:
        pp('>> tree_pass', nm, a)
        
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return a
        while True:   
            assert type(a) is tuple
            r = tuple([tree_pass(v, upgrade_op,a, nm) for v in a])
            notchanged = all([r[i] is a[i] for i in range(len(r))])
            if notchanged:
                r = a
            r2 = upgrade_op(r,nm)
            notchanged = bool(notchanged and r2 == r)
            if notchanged:
                break
            a = r2
        return a
    if type(a) is list:
        assert len(a) > 0 
        while True:   
            a = repl_list(a,up) 
            assert type(a) is list
            r = [tree_pass(v, upgrade_op, a, nm) for v in a]
            notchanged = all([r[i] is a[i] for i in range(len(r))])
            if notchanged:
                r = a
            assert len(r) > 0
            r2 = upgrade_op(r,nm)
            notchanged = bool(notchanged and r2 == r)
            if notchanged:
                break
            a = r2
        return a
    return a

def tree_pass_upgrade_op(a, up, nm): 
    global print_tree_node
 
    if print_tree_node:
        pp('>> tree_pass_upgrade_op', nm, up, a)
        
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return a
        cnt = 0
        while True:   
            cnt += 1
            if cnt > 900:
                pp('----')
                pprint(a)
            if cnt >= 1000:
                pp('May be cycle at repl', nm)
                pprint(a)
                assert False
            assert type(a) is tuple

            if len(a) > 3 and a[0] == 'PY_TYPE' and a[3][0] == 'PY_TYPE':
                pp(a)
                assert False
            r = tuple([tree_pass_upgrade_op(v, a, nm) for v in a])
            if len(r) > 3 and r[0] == 'PY_TYPE' and r[3][0] == 'PY_TYPE':
                pp(r)
                assert False
            assert type(r) is tuple
            notchanged = all([r[i] is a[i] for i in range(len(r))])
            if notchanged:
                r = a
            else:
                assert any([r[i] != a[i] for i in range(len(r))])
            if cnt > 900:
                pprint(r)
            if len(r) > 3 and r[0] == 'PY_TYPE' and r[3][0] == 'PY_TYPE':
                pp(r)
                assert False
            r2 = upgrade_op(r,nm)
            if cnt > 900:
                pprint(r2)
            assert type(r2) is tuple
            notchanged = (notchanged and r2 == r)
            if notchanged:
                break
            elif a == r2:
                pp('//1 Cycle at tree_pass_upgrade_op', a)
                break
            a = r2
        return a
    if type(a) is list:
        assert len(a) > 0 
        while True:   
            a = repl_list(a,up) 
            assert type(a) is list
            r = [tree_pass_upgrade_op(v, a, nm) for v in a]
            notchanged = all([r[i] is a[i] for i in range(len(r))])
            if notchanged:
                r = a
            assert len(r) > 0
            r2 = upgrade_op(r,nm)
            notchanged = bool(notchanged and r2 == r)
            if notchanged:
                break
            a = r2
        return a
    return a

def tree_pass_upgrade_repl(a, up, nm): 
    global print_tree_node
    if print_tree_node:
        pp('>> tree_pass_upgrade_repl', nm, up, a)
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return a
        if len(a) > 0 and type(a[0]) is str and a[0] == '!BUILD_TUPLE':
            aa = a[1]
            r = tree_pass_upgrade_repl(aa, a, nm)
            notchanged = all([r[i] is aa[i] for i in range(len(r))])
            if notchanged:
                return a
            return ('!BUILD_TUPLE', r)
        while True:   
            assert type(a) is tuple
            r = tuple([tree_pass_upgrade_repl(v,a, nm) if type(v) is tuple else v for v in a])
            notchanged = all([r[i] is a[i] for i in range(len(r))])
            if notchanged:
                r = a
            r2 = upgrade_repl(r,nm)
            if notchanged and r2 != r:
                notchanged = False
            if notchanged:
                break
            a = r2
        return a
    if type(a) is list:
        assert len(a) > 0 
        while True:   
            a = repl_list(a,up) 
            assert type(a) is list
            r = [tree_pass_upgrade_repl(v, a, nm) for v in a]
            notchanged = all([r[i] is a[i] for i in range(len(r))])
            if notchanged:
                r = a
            assert len(r) > 0
            r2 = upgrade_repl(r,nm)
            if notchanged and r2 != r:
                notchanged = False
            if notchanged:
                break
            a = r2
        return a
    return a

def tree_pass_upgrade_op2(a, up, nm): 
    print a
    global print_tree_node
    assert a != ('PY_TYPE', 'NewClassInstance', 'MovedAttribute', ('CALC_CONST', '_importer'), None)
    if print_tree_node:
        pp('>> tree_pass_upgrade_op2', nm, up, a)
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return a
        while True:
            assert type(a) is tuple
            r = a
            changed = False
            for i, v in enumerate(a):
                if type(v) is tuple:
                    if v == ('PY_TYPE', 'NewClassInstance', 'MovedAttribute', ('CALC_CONST', '_importer'), None):
                        print '---', up
                    assert v != ('PY_TYPE', 'NewClassInstance', 'MovedAttribute', ('CALC_CONST', '_importer'), None)
                    v2 = tree_pass_upgrade_op2(v,a, nm)
                    if v is v2:
                        continue
                    if not changed:
                        changed = True
                        r = list(a)
                    r[i] = v2
            if changed:
                r = tuple(r)
            if r is not a:
                if r == a:
                    pp('/1', nm)
                    pprint(r)
                    assert False
            assert  r != ('PY_TYPE', 'NewClassInstance', 'MovedAttribute', ('CALC_CONST', '_importer'), None)
            r2 = upgrade_op2(r,nm)
            if r2 is not a:
                if r2 == a:
                    if r != a:
                        pp('/23')
                        pprint(r2)
                    pp('/1', nm)
                    pprint(r)
                    assert False
                changed = True 
            if not changed:
                break
            a = r2
        return a
    if type(a) is list:
        assert len(a) > 0 
        while True:   
            a = repl_list(a,up) 
            assert type(a) is list
            r = [tree_pass_upgrade_op2(v, a, nm) for v in a]
            changed = any([r[i] is not a[i] for i in range(len(r))])
            if not changed:
                r = a
            assert len(r) > 0
            r2 = upgrade_op2(r,nm)
            if not changed:
                changed = r2 is not r or bool(r2 != r)  

            if not changed:
                break
            a = r2
        return a
    return a
 
def tree_pass_readonly(a, up, nm):
    if type(a) is tuple:
        if len(a) > 0 and type(a[0]) is str and a[0] == 'CONST':
            return
        fill_direct_args(a,nm)
        [tree_pass_readonly(i, a, nm) if type(i) is tuple else i for i in a]
        return
    elif type(a) is list:
        [tree_pass_readonly(i, a, nm) for i in a]
    return

def ortogonal(a, upgrade,up=None):
    if type(a) is tuple:
        if len(a) > 0 and a[0] == 'CONST':
            return a
        r = tuple([ortogonal(i, upgrade,a) for i in a])
        if all([r[i] is a[i] for i in range(len(r))]):
            r = a
        while True:   
            r2 = upgrade(r)
            if r2 == r:
                break
            r = r2
        return r
    if type(a) is list:
        a = repl_list(a,up)
        r = [ortogonal(i, upgrade, a) for i in a]
        if all([r[i] is a[i] for i in range(len(r))]):
            r = a
        while True:   
            r2 = upgrade(r)
            if r2 == r:
                break
            r = r2
        return r
    return a
  
def debug_eq(a,b):  
    pp('{{{')
    pprint(a)
    pp('===')
    pprint(b)
    pp('}}}')
    
def eqexpr(a,b, debug=False):
    if a is b:
        return True
    if type(a) is list:
        if type(b) is list and len(a) == len(b):
            for i, v in enumerate(a):
                if not eqexpr(v, b[i], debug):
                    if debug: debug_eq(a,b)
                    return False
            return True
        return False
    elif type(a) is tuple:
        if type(b) is tuple and len(a) == len(b):
            for i, v in enumerate(a):
                v2 = b[i]
                if type(v) is str and type(v2) is str and v != v2:
                    if debug: debug_eq(a,b)
                    return False
                if type(v) is int and type(v2) is int and v != v2:
                    if debug: debug_eq(a,b)
                    return False
                if type(v) is bool and type(v2) is bool and v != v2:
                    if debug: debug_eq(a,b)
                    return False
                if type(v) is tuple and type(v2) is tuple and len(v) != len(v2):
                    if debug: debug_eq(a,b)
                    return False
                if type(v) != type(v2):
                    if debug: debug_eq(a,b)
                    return False
                if not eqexpr(v, v2, debug):
                    if debug: debug_eq(a,b)
                    return False
            return True
        if debug: debug_eq(a,b)
        return False
    elif type(a) is str and type(b) is str:
        return a == b
    elif type(a) is int and type(b) is int:
        return a == b
    elif type(a) is bool and type(b) is bool:
        return a is b
    elif type(a) == type(b) and a == b:
        return True
    if debug: debug_eq(a,b)
    return False

def eqexpr_untyped(a,b, debug=False):
    if a is b:
        return True
    if type(a) is list:
        if type(b) is list and len(a) == len(b):
            for i, v in enumerate(a):
                if not eqexpr(v, b[i], debug):
                    if debug: debug_eq(a,b)
                    return False
            return True
        return False
    elif type(a) is tuple:
        if len(a) == 5 and a[0] == 'PY_TYPE':
            a = a[3]
            assert type(a) is tuple
        if type(b) is tuple and len(b) == 5 and b[0] == 'PY_TYPE':
            b = b[3]
        if type(b) is tuple and len(a) == len(b):
            for i, v in enumerate(a):
                v2 = b[i]
                if type(v) is str and type(v2) is str and v != v2:
                    if debug: debug_eq(a,b)
                    return False
                if type(v) is int and type(v2) is int and v != v2:
                    if debug: debug_eq(a,b)
                    return False
                if type(v) is bool and type(v2) is bool and v != v2:
                    if debug: debug_eq(a,b)
                    return False
                if type(v) is tuple and type(v2) is tuple and len(v) != len(v2):
                    if debug: debug_eq(a,b)
                    return False
                if type(v) != type(v2):
                    if debug: debug_eq(a,b)
                    return False
                if not eqexpr(v, v2, debug):
                    if debug: debug_eq(a,b)
                    return False
            return True
        if debug: debug_eq(a,b)
        return False
    elif type(a) is str and type(b) is str:
        return a == b
    elif type(a) is int and type(b) is int:
        return a == b
    elif type(a) is bool and type(b) is bool:
        return a is b
    elif type(a) == type(b) and a == b:
        return True
    if debug: debug_eq(a,b)
    return False
  
def join_tuple_descr(a,c):
    assert type(a) is tuple
    assert type(c) is tuple  
    assert len(a) == len(c)
    ret = []
    for k, ak in enumerate(a):
        if ak is None:
            ret.append(c[k])
        elif c[k] is None:
            ret.append(ak)
        elif c[k] == ak:
            ret.append(ak)
        elif IsTuple(ak) and IsTuple(c[k]):
            ret.append((tuple, join_tuple_descr(ak[1], c[k][1])))
        elif ak is not None and ak[0] == 'Sequence' and (IsList(c[k]) or IsTuple(c[k])):
            ret.append(c[k])
        elif IsInt(c[k]) and IsInt(ak):
            ret.append(join_int(c[k], ak))
        elif IsStr(c[k]) and IsStr(ak):
            ret.append(join_str(c[k], ak))
        else:
            pprint(a)
            pprint(c)
            pp('[[[[[[[[[[[')
            pp(ak, c[k])
            assert False
    return tuple(ret)
  
def CondMethExpr(arg, expr, tupl):
    global n_bigpass
    assert arg is not None
    assert len(tupl) > 0
    if expr[0] == '!BOOLEAN' and expr[1][0] == 'CONST' and type(expr[1][1]) is bool:
        expr = expr[1]
    if expr[0] == '!COND_METH_EXPR' and arg == expr[1]:
        return expr
    if n_bigpass > 0:
        return expr
    return('!COND_METH_EXPR', arg, expr, tupl)
    
def replace_subexpr(a,b,c):
    assert type(b) is tuple
    assert type(c) is tuple

    if False:
        t1 = TypeExpr(b)
        t2 = TypeExpr(c)
        if t1 == t2 and t1 is not None:
            if not c[0] in ('CONST', 'CALC_CONST'):
                pp('>>> ??? 456', t1, t2, b, c)
        if t1 is not None and t2 is not None:
            if t1 == t2 and c[0] == 'PY_TYPE' and c[3] == b:
                pp(';;;;;;lll;;', b,c, t1, t2)
                assert False
            if IsIntUndefSize(t1) and IsInt(t2):
                pass
            elif IsMayBe(t1) and IsIntUndefSize(t1[1]) and IsInt(t2):
                pass
            elif t1 == t2 and c[0] in ('CONST', 'CALC_CONST'):
                pass
            elif IsTuple(t1) and IsTuple(t2) and type(t2[1]) is tuple and type(t1[1]) is int and len (t2[1]) >= t1[1]:
                pass
            elif IsTuple(t1) and IsTuple(t2) and type(t2[1]) is int and t1[1] is None:
                pass
            elif IsTuple(t1) and IsTuple(t2) and type(t2[1]) is int and type(t1[1]) is int and t1[1] <= t2[1]:
                pass
            elif t1 != t2 and (not ( not _match_type(t2, t1) and _match_type(t1, t2))):
                pp(_match_type(t1,t2))
                pp(_match_type(t2,t1))
                pp(t1, t2, b,c)
                pprint(t1)
                pprint(t2)
                assert False
    if type(a) is tuple:
        if len(c) == 5 and type(c[0]) is str and c[0] == 'PY_TYPE':
            if c[1] is tuple and type(c[2]) is tuple and all([x is None for x in c[2]]):
                assert False
            ## if type(c[1]) is str:
                ## assert c[1] != 'NIL'
            ## assert c[3][0] != 'PY_TYPE'
            if len(a) == 4 and type(a[0]) is str and a[0] == '!COND_METH_EXPR' and a[1] == b:
                a3 = a[3]
                assert type(a3) is tuple
                for ty, ex in a3: ##i in range(len(a3)):
                    ##ty, ex = a3[i]
                    if ty[0] == c[1] and ty[1] == c[2]:
                        return ex
                return a[2]                
            if len(a) == 5 and type(a[0]) is str and a[0] == 'PY_TYPE' and \
               eqexpr(c[3], b) and eqexpr(a[3], b) and a[1] == c[1]:
                if a[2] is None and c[2] is not None:
                    return c
                if c[2] is None and a[2] is not None:
                    return a
                if c[2] is not None and a[2] is not None:
                    if a[2] == c[2] and a[3] == c[3]:
                        return a             
                    if a[1] is int and c[1] is int:
                        if a[2] == c[2]:
                            return a
                        return ('PY_TYPE',) + intersect_int((int, a[2]), (int, c[2])) + a[3:]   
                    if type(a[2]) is tuple and type(c[2]) is tuple and len(a[2]) == len(c[2]) and a[3] == c[3]:
                        if a[1] is tuple:
                            ret = join_tuple_descr(a[2],c[2])
                            return ('PY_TYPE', a[1], ret, a[3], a[4])
                        elif a[1] == 'MayBe' and IsTuple(a[2]) and IsTuple(c[2]) and type(a[2][1]) is tuple and type(c[2][1]) is tuple:
                            ret = join_tuple_descr(a[2][1],c[2][1])
                            return ('PY_TYPE', a[1], (tuple, ret), a[3], a[4])
                if a[1] is tuple and c[1] is tuple:
                    if type(a[2]) is int and type(c[2]) is int:
                        if c[2] < a[2]:
                            return a
                        else:
                            return c
                    if type(a[2]) is tuple and type(c[2]) is int:
                        if c[2] <= len(a[2]):
                            return a
                        else:
                            return c  
                    if type(c[2]) is tuple and type(a[2]) is int:
                        if a[2] > len(c[2]):
                            return a
                        else:
                            return c    
                if a[1] is str and c[1] is str:
                    if type(a[2]) is int and type(c[2]) is int:
                        if c[2] < a[2]:
                            return a
                        else:
                            return c
                if not(c[2] is None or a[2] is None or (c[1] is int or a[1] is int and c[2] != a[2])):
                    pprint(a)
                    pp('-----')
                    pp(b)
                    pp('======')
                    pp(c)
                    pp('/////////')
                assert c[2] is None or a[2] is None or ((c[1] is int or a[1] is int) and c[2] != a[2]) or ((c[1] is tuple or a[1] is tuple) and c[2] != a[2]) or ((c[1] is str or a[1] is str) and c[2] != a[2])
                
            if len(b) == 5 and type(b[0]) is str and b[0] == 'PY_TYPE':
                if b[2] is None:
                    return c
                if c[2] is None and eqexpr(c[3], b[3]):
                    return b
        if len(a) > 2 and type(a[0]) is str and a[0] == 'PyObject_SetAttr' and eqexpr(a[1], b) and c[0] == '!MK_FUNK':
            return a
        if len(a) == 5 and type(a[0]) is str and a[0] == 'PY_TYPE' and \
           len(c) == 2 and type(c[0]) is str and c[0] == 'CONST' and \
           eqexpr(a[3], b):
            return c    
        if len(a) == len(b) and type(a[0]) == type(b[0]) and a[0] == b[0] and eqexpr(a,b):
            return c
        if a is c:
            return a
        if len(c) == 5 and len(a) == 5 and \
            type(c[0]) is str and type(a[0]) is str and \
            c[0] == 'PY_TYPE' and a[0] == 'PY_TYPE' and \
            a[3] == b:
            return c
        if len(a) == len(c) and type(a[0]) == type(c[0]) and a[0] == c[0] and eqexpr(a,c):
            return a
        if len(a) == 0:
            return a
        elif len(a) >= 1:
            for j, v in enumerate(a):
                if type(v) is tuple:
                    v2 = replace_subexpr(v, b, c)
                    if v2 is not v:
                        if j == len(a) - 1:
                            return a[:-1] + (v2,)
                        elif j == 0:
                            break
                        else:
                            return a[:j] + (v2,) + tuple([replace_subexpr(i,b,c) for i in a[j+1:]])
                    elif j == len(a) - 1:
                        return a
                elif j == len(a) - 1:
                    return a                        
            if type(a[0]) is str:
                if len(a) == 1:
                    return a
                elif len(a) == 2:
                    return (a[0], replace_subexpr(a[1],b,c))
                elif len(a) == 3:
                    return (a[0], replace_subexpr(a[1],b,c),replace_subexpr(a[2],b,c))
                elif len(a) == 4:
                    return (a[0], replace_subexpr(a[1],b,c),replace_subexpr(a[2],b,c),replace_subexpr(a[3],b,c))
            else:
                if len(a) == 1:
                    return (replace_subexpr(a[0],b,c),)
                elif len(a) == 2:
                    return (replace_subexpr(a[0],b,c), replace_subexpr(a[1],b,c))
                elif len(a) == 3:
                    return (replace_subexpr(a[0],b,c), replace_subexpr(a[1],b,c),replace_subexpr(a[2],b,c))
                elif len(a) == 4:
                    return (replace_subexpr(a[0],b,c), replace_subexpr(a[1],b,c),replace_subexpr(a[2],b,c),replace_subexpr(a[3],b,c))                
        return tuple([replace_subexpr(i,b,c) for i in a])
    if type(a) is list:
        if c[0] != 'PY_TYPE' or c[3] != b:
            return [replace_subexpr(i,b,c) for i in a]
        li = []
        i1 = 0
        while i1 < len(a):
            i = a[i1]
            if i[0] == '(IF' and i[1][0] == '!BOOLEAN' and i[1][1][0] == '!_EQ_' and i[1][1][1][0] == '!PyObject_Type':
                t = TypeExpr(i[1][1][2])
                if t is not None and t[0] == T_NEW_CL_TYP and c[1] == T_NEW_CL_INST and i[1][1][1][1] == b:
                    if t[1] == c[2]:
                        assert type(a[i1+1]) is list
                        li.extend(replace_subexpr(a[i1+1],b,c))
                    i1 += 2
                    if a[i1][0] == ')(ELSE':
                        if t[1] != c[2]:
                            assert type(a[i1+1]) is list
                            li.extend(replace_subexpr(a[i1+1],b,c))
                        i1 += 2
                    i1 += 1
                    continue
                if t is not None and t[0] == T_OLD_CL_TYP and c[1] == T_OLD_CL_INST and i[1][1][1][1] == b:
                    if t[1] == c[2]:
                        assert type(a[i1+1]) is list
                        li.extend(replace_subexpr(a[i1+1],b,c))
                    i1 += 2
                    if a[i1][0] == ')(ELSE':
                        if t[1] != c[2]:
                            assert type(a[i1+1]) is list
                            li.extend(replace_subexpr(a[i1+1],b,c))
                        i1 += 2
                    i1 += 1
                    continue   
                
            li.append(replace_subexpr(a[i1],b,c))
            i1 += 1
        return li
    return a    

def replace_type_subexpr_at_code_list(a,b,c):
    assert type(a) is list
    assert type(b) is tuple
    assert type(c) is tuple and len(c) == 5
    assert c[3] == b

    assert c[1] != 'NIL'
    li = []
    i1 = 0
    while i1 < len(a):
        i = a[i1]
        if i[0] == '(IF' and i[1][0] == '!BOOLEAN' and i[1][1][0] == '!_EQ_' and i[1][1][1][0] == '!PyObject_Type' and i[1][1][1][1] == b:
            t = TypeExpr(i[1][1][2])
            if type(t) is tuple and len(t) == 2 and \
              ((t[0] == T_NEW_CL_TYP and c[1] == T_NEW_CL_INST) or (t[0] == T_OLD_CL_TYP and c[1] == T_OLD_CL_INST)  or (t[0] == T_ANY_CL_TYP and c[1] == T_ANY_CL_INST)):
                if t[1] == c[2]:
                    assert type(a[i1+1]) is list
                    li.extend(replace_type_subexpr_at_code_list(a[i1+1],b,c))
                i1 += 2
                if a[i1][0] == ')(ELSE':
                    if t[1] != c[2]:
                        assert type(a[i1+1]) is list
                        li.extend(replace_type_subexpr_at_code_list(a[i1+1],b,c))
                    i1 += 2
                i1 += 1
                continue
        li.append(replace_type_subexpr_at_code_list(i,b,c) if type(i) is list else replace_type_subexpr_at_code_tuple(i,b,c))
        i1 += 1
    return li

def replace_type_subexpr_at_code_tuple(a,b,c):
    assert type(b) is tuple
    assert type(c) is tuple and len(c) == 5
    if type(a) is tuple:
        assert c[0] == 'PY_TYPE'
        assert c[3][0] != 'PY_TYPE'
        if len(a) == 4 and a[0] == '!COND_METH_EXPR' and a[1] == b:
            for i in range(len(a[3])):
                ty, ex = a[3][i]
                if ty[0] == c[1] and ty[1] == c[2]:
                    return ex
            return a[2]                
        if len(a) == 5 and type(a[0]) is str and a[0] == 'PY_TYPE' and \
            eqexpr(c[3], b) and eqexpr(a[3], b) and a[1] == c[1]:
            if a[2] is None and c[2] is not None:
                return c
            if c[2] is None and a[2] is not None:
                return a
            if c[2] is not None and a[2] is not None:
                if a[2] == c[2] and a[3] == c[3]:
                    return a                
                if type(a[2]) is tuple and type(c[2]) is tuple and len(a[2]) == len(c[2]) and a[3] == c[3]:
                    if a[1] is tuple:
                        ret = join_tuple_descr(a[2],c[2])
                        return ('PY_TYPE', a[1], ret, a[3], a[4])
                    elif a[1] == 'MayBe' and IsTuple(a[2]) and IsTuple(c[2]) and type(a[2][1]) is tuple and type(c[2][1]) is tuple:
                        ret = join_tuple_descr(a[2][1],c[2][1])
                        return ('PY_TYPE', a[1], (tuple, ret), a[3], a[4])
            if a[1] is tuple and c[1] is tuple:
                if type(a[2]) is int and type(c[2]) is int:
                    if c[2] < a[2]:
                        return a
                    else:
                        return c
                if type(a[2]) is tuple and type(c[2]) is int:
                    if c[2] <= len(a[2]):
                        return a
                    else:
                        return c  
                if type(c[2]) is tuple and type(a[2]) is int:
                    if a[2] > len(c[2]):
                        return a
                    else:
                        return c                                        
            if not(c[2] is None or a[2] is None or (c[1] is int or a[1] is int and c[2] != a[2])):
                pprint(a)
                pp('-----')
                pp(b)
                pp('======')
                pp(c)
                pp('/////////')
            assert c[2] is None or a[2] is None or (c[1] is int or a[1] is int and c[2] != a[2]) or (c[1] is tuple or a[1] is tuple and c[2] != a[2])
                
        if len(b) == 5 and type(b[0]) is str and b[0] == 'PY_TYPE':
            if b[2] is None:
                return c
            if c[2] is None and eqexpr(c[3], b[3]):
                return b
        if len(a) == len(b) and type(a[0]) == type(b[0]) and a[0] == b[0] and eqexpr(a,b):
            return c
        if a is c:
            return a
        if len(a) >= 4 and \
            len(a) == 5 and type(a[0]) is str and a[0] == 'PY_TYPE' and a[3] == b:
            return c
        if len(a) == len(c) and type(a[0]) == type(c[0]) and a[0] == c[0] and eqexpr(a,c):
            return a
        if len(a) == 0:
            return a
        elif len(a) >= 1:
            for j, v in enumerate(a):
                if type(v) is tuple:
                    v2 = replace_type_subexpr_at_code_tuple(v, b, c)
                    if v2 is not v:
                        if j == len(a) - 1:
                            return a[:-1] + (v2,)
                        elif j == 0:
                            break
                        else:
                            return a[:j] + (v2,) + tuple([replace_type_subexpr_at_code_tuple(i,b,c) for i in a[j+1:]])
                    elif j == len(a) - 1:
                        return a
                elif j == len(a) - 1:
                    return a                        
            if type(a[0]) is str:
                if len(a) == 1:
                    return a
                elif len(a) == 2:
                    return (a[0], replace_type_subexpr_at_code_tuple(a[1],b,c))
                elif len(a) == 3:
                    return (a[0], replace_type_subexpr_at_code_tuple(a[1],b,c),replace_type_subexpr_at_code_tuple(a[2],b,c))
                elif len(a) == 4:
                    return (a[0], replace_type_subexpr_at_code_tuple(a[1],b,c),replace_type_subexpr_at_code_tuple(a[2],b,c),replace_type_subexpr_at_code_tuple(a[3],b,c))
            else:
                if len(a) == 1:
                    return (replace_type_subexpr_at_code_tuple(a[0],b,c),)
                elif len(a) == 2:
                    return (replace_type_subexpr_at_code_tuple(a[0],b,c), replace_type_subexpr_at_code_tuple(a[1],b,c))
                elif len(a) == 3:
                    return (replace_type_subexpr_at_code_tuple(a[0],b,c), replace_type_subexpr_at_code_tuple(a[1],b,c),replace_type_subexpr_at_code_tuple(a[2],b,c))
                elif len(a) == 4:
                    return (replace_type_subexpr_at_code_tuple(a[0],b,c), replace_type_subexpr_at_code_tuple(a[1],b,c),replace_type_subexpr_at_code_tuple(a[2],b,c),replace_type_subexpr_at_code_tuple(a[3],b,c))                
        return tuple([replace_type_subexpr_at_code_tuple(i,b,c) for i in a])
    return a    

def replace_fastvar(a, d):
    if type(a) is tuple:
        ## if len(a) > 0 and a[0] == '!COND_EXPR':
        ## pprint(a)
        ## pprint(d)
        ## pp('-------------')

        if len(a) > 3 and a[0] == '!COND_METH_EXPR': # and a[1][0] == 'FAST' and a[1][1] in d:
            ##assert a[1][0] == 'FAST'
            new = replace_fastvar(a[1], d)
            t1 = TypeExpr(new)
            if t1 is not None:
                for t, e in a[3]:
                    if t == t1 or _match_type(t, t1):
                        return replace_fastvar(e,d)  
                pp(t1, 'is not compline in', [t for t,e in a[3]])
                return replace_fastvar(a[2],d)
        if len(a) == 4 and a[0] == '!PyObject_RichCompare(':
            v1,v2 = replace_fastvar(a[1], d), replace_fastvar(a[2], d)
            aa = (a[0], v1, v2, a[3])
            if  v1[0] == 'CONST' and v2[0] == 'CONST':
                ret_ret = calc_expr_2(a[3], v1[1], v1[1], aa)
                if ret_ret is not None:
                    return ret_ret
            return aa

        if len(a) == 3 and a[0] in ('!_EQ_', '!_NE_'):
            a1,a2 = a[1], a[2]
            if a2[0] == '!PyObject_Type':
                a1, a2 = a2, a1
            if a1[0] == '!PyObject_Type' and a1[1][0] == 'FAST' and a1[1][1] in d:
                assert a1[1][0] == 'FAST'
                new = d[a1[1][1]]
                t = None
                if new[0] == 'PY_TYPE':
                    t = (new[1], new[2])
                else:
                    t = TypeExpr(new)
                if t is not None:
                    if a2[0] == '!LOAD_BUILTIN' and a2[1] in d_built:
                        if d_built[a2[1]] == t[0]:
                            return ('CONST', a[0] == '!_EQ_')
                        else:
                            return ('CONST', a[0] == '!_NE_')
                    elif a2[0] == 'CALC_CONST':
                        t2 = TypeExpr(a2)
                        if t2 is not None and ((t[0] == T_NEW_CL_INST and t2[0] == T_NEW_CL_TYP) or (t[0] == T_OLD_CL_INST and t2[0] == T_OLD_CL_TYP)):
                            if t2[1] == t[1]:
                                return ('CONST', a[0] == '!_EQ_')
                            else:
                                return ('CONST', a[0] == '!_NE_')

        if len(a) == 2 and a[0] == '!BOOLEAN':
            aa = replace_fastvar(a[1], d)
            if aa[0] == 'CONST':
                return aa
            return ('!BOOLEAN', aa)
        if len(a) == 2 and a[0] == '!1NOT':
            aa = replace_fastvar(a[1], d)
            if aa[0] == 'CONST':
                return ('CONST', not aa[1])
            return ('!1NOT', aa)
        if len(a) >= 3 and a[0] in ('!OR_JUMP', '!OR_BOOLEAN', '!OR_JUMPED_STACKED'):
            aa = [replace_fastvar(x, d) for x in a[1:]]
            if all([x[0] == 'CONST' for x in aa]):
                return ('CONST', any([x[1] for x in aa]))

            while len(aa) > 1 and aa[-1][0] == 'CONST' and aa[-1][1] is False:
                del aa[-1]
            while len(aa) > 1 and aa[0][0] == 'CONST' and aa[0][1] is False:
                del aa[0]
            assert len(aa) != 0
            if len(aa) == 1:
                return aa[0]

            return (a[0],) + tuple(aa)
        if len(a) >= 3 and a[0] in ('!AND_JUMP', '!AND_BOOLEAN', '!AND_JUMPED_STACKED'):
            aa = [replace_fastvar(x, d) for x in a[1:]]
            if all([x[0] == 'CONST' for x in aa]):
                return ('CONST', all([x[1] for x in aa]))
            while len(aa) > 1 and aa[-1][0] == 'CONST' and aa[-1][1] is True:
                del aa[-1]
            while len(aa) > 1 and aa[0][0] == 'CONST' and aa[0][1] is True:
                del aa[0]
            if len(aa) == 0:
                return ('CONST', True)
            elif len(aa) == 1:
                return aa[0]
            return (a[0],) + tuple(aa)
        if len(a) > 3 and a[0] == 'PY_TYPE':
            if a[3][1] in d:
                assert a[3][0] == 'FAST'
                new = d[a[3][1]]
                if new[0] == 'PY_TYPE':
                    t1 = list(a)
                    t2 = list(new)
                    t1[3] = None
                    t2[3] = None
                    if t1 == t2:
                        return new
                    if t1 != t2: 
                        if a[1] is int and new[1] is int:
                            new = new[:1] + intersect_int(a[1:3], new[1:3]) + new[3:]
                            return new
                        else:
                            new = new[:1] + combine_type(a[1:3], new[1:3]) + new[3:]
                            return new
                            
                        Fatal('Illegal replace typed arg', a, new)
                        assert False
            a3 = replace_fastvar(a[3], d)
            t1 = a[1:3]
            t2 = TypeExpr(a3)
            if t1 == t2:
                return a3
            if t2 is None:
                return ('PY_TYPE', a[1], a[2], a3, None)
            if t1[0] is int and t2[0] is int:
                new = ('PY_TYPE',) + intersect_int(a[1:3], t2) + (a3, None)
                return new
            else:
                new = ('PY_TYPE',) + combine_type(a[1:3], t2) + (a3, None)
                return new
                
            Fatal('Illegal replace typed arg', a, new)
            assert False
            
            
        if len(a) == 2 and a[0] == 'FAST':
            return d[a[1]]
        return tuple([replace_fastvar(i,d) for i in a])
    if type(a) is list:
        li = []
        i = 0
        while i < len(a):
            if len(li) > 0 and li[-1][0] in ('RETURN_VALUE', 'RAISE_VARARGS'):
                return li
            it = a[i]
            if it[0] == '(IF': 
                v = []
                if TCmp(it, v, ('(IF', ('!BOOLEAN', ('!_NEQ_', ('FAST', '?'), ('CONST', None) ) ) )):
                    if v[0] in d and d[v[0]] == ('CONST', None):
                        if a[i+2][0] == ')ENDIF':
                            i += 3
                            continue
                        if a[i+2][0] == ')(ELSE':
                            li.extend(replace_fastvar(a[i+3], d))
                            i += 5
                            continue 
            
                it1 = replace_fastvar(it[1], d)  
                if it1[0] == 'CONST':
                    if not it1[1]:
                        if a[i+2][0] == ')ENDIF':
                            i += 3
                            continue
                        if a[i+2][0] == ')(ELSE':
                            li.extend(replace_fastvar(a[i+3], d))
                            i += 5
                            continue
                    else:
                        if a[i+2][0] == ')ENDIF':
                            li.extend(replace_fastvar(a[i+1], d))
                            i += 3
                            continue
                        if a[i+2][0] == ')(ELSE':
                            li.extend(replace_fastvar(a[i+1], d))
                            i += 5
                            continue
            li.append(replace_fastvar(it,d))
            i += 1
        return li
    return a    

    
def is_expandable_enumerate(iter):
    if not enumerate2for:
        return False
    v = []
    return TCmp(iter, v, ('!PyObject_Call', ('!LOAD_BUILTIN', 'enumerate'), \
                                            ('!BUILD_TUPLE', ('?',)), \
                                            ('NULL',)))
    
def generate_list_compr_enumerate(acc, val, store_ind, store_val, enumerated, cond, o): 
    assert cond is None or len(cond) == 1 
    assert type(o) is Out
    cond_var = None
    t = TypeExpr(enumerated)
    if IsListAll(t):
        return generate_list_compr_enumerate_list(acc, val, store_ind, store_val, enumerated, cond, o)
    if IsTuple(t):
        return generate_list_compr_enumerate_tuple(acc, val, store_ind, store_val, enumerated, cond, o)
    if t is not None and not IsDict(t) and t != ('Sequence', None) and not IsFile(t):
        Fatal('Known type enumerate list complete', t, enumerated)
    ref_expr = Expr1(enumerated, o)
    ref_iter = New()
    n_iter = New('long')
    o.Stmt(ref_iter, '=', 'PyObject_GetIter', ref_expr)
    o.Cls(ref_expr)
    o.Stmt(n_iter, '=', 0)
    o.append('for (;;) {')
    ref_temp = New()
    o.Stmt(ref_temp, '=', 'PyIter_Next', ref_iter)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref_temp, '){ break; }')
    generate_store(store_val, ref_temp, o, 'PyIter_Next')
    o.ZeroTemp(ref_temp)  
    generate_store_int(o, store_ind, n_iter)
    o.Stmt(n_iter, '++')
    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
    ref_val = Expr1(val[0], o)
    if acc is not None:
        o.Stmt('PyList_Append', acc, ref_val)
    o.Cls(ref_val)
    if cond is not None:
        o.append('}')
        o.Cls(cond_var)
    o.append('}')
    o.Cls(ref_iter, n_iter, ref_expr)

def generate_list_compr_enumerate_list(acc, val, store_ind, store_val, enumerated, cond, o): 
    assert cond is None or len(cond) == 1 
    assert type(o) is Out
    ref_expr = Expr1(enumerated, o)
    cond_var = None
    n_iter = New('long')
    o.Raw('for (', n_iter, ' = 0;', n_iter, ' < PyList_GET_SIZE(', ref_expr, ');', n_iter, ' ++) {')
    ref_temp = New()
    o.Raw(ref_temp, ' = PyList_GET_ITEM(', ref_expr, ', ', n_iter, ');')
    o.INCREF(ref_temp)
    generate_store(store_val, ref_temp, o, 'PyList_iter')
    o.ZeroTemp(ref_temp)  
    generate_store_int(o, store_ind, n_iter)
    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
    ref_val = Expr1(val[0], o)
    if acc is not None:
        o.Stmt('PyList_Append', acc, ref_val)
    o.Cls(ref_val)
    if cond is not None:
        o.append('}')
        o.Cls(cond_var)
    o.append('}')
    o.Cls(n_iter, ref_expr)

def generate_list_compr_enumerate_tuple(acc, val, store_ind, store_val, enumerated, cond, o): 
    assert cond is None or len(cond) == 1 
    assert type(o) is Out
    ref_expr = Expr1(enumerated, o)
    cond_var = None
    n_iter = New('long')
    o.Raw('for (', n_iter, ' = 0;', n_iter, ' < PyTuple_GET_SIZE(', ref_expr, ');', n_iter, ' ++) {')
    ref_temp = New()
    o.Raw(ref_temp, ' = PyTuple_GET_ITEM( ', ref_expr, ', ', n_iter, ' );')
    o.INCREF(ref_temp)
    generate_store(store_val, ref_temp, o, 'PyTuple_iter')
    o.ZeroTemp(ref_temp)  
    generate_store_int(o, store_ind, n_iter)
    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
    ref_val = Expr1(val[0], o)
    if acc is not None:
        o.Stmt('PyList_Append', acc, ref_val)
    o.Cls(ref_val)
    if cond is not None:
        o.append('}')
        o.Cls(cond_var)
    o.append('}')
    o.Cls(n_iter, ref_expr)

def cnamevar_for_store(store_ind, ctype = False):
    if store_ind[0] == 'STORE_FAST':
        fa = ('FAST', store_ind[1])
        if not IsCType(TypeExpr(fa)):
            return None
        if store_ind[1] in g_co.detected_type:
            if IsCType(g_co.detected_type[store_ind[1]]):
                if ctype:
                    return g_co.detected_type[store_ind[1]], CVarName(fa)
                return CVarName(fa)
        i = g_co.d_varnames[store_ind[1]]
        typed_arg = g_co.typed_arg_direct
        if i in typed_arg and is_current & IS_DIRECT:
            if IsCType(typed_arg[i]):
                if ctype:
                    return typed_arg[i], CVarName(fa)
                return CVarName(fa)
    it = store_ind
    if it[0] == 'STORE_GLOBAL' or (it[0] == 'STORE_NAME' and func == 'Init_filename'):
        if fast_globals and it[1] not in d_built and (it[1][0] != '_' or build_executable) \
           and not redefined_all  and not global_used_at_generator(it[1]):
            if IsCTypedGlobal(it[1]):
                add_fast_glob(it[1])
                if ctype:
                    return TypeGlobal(it[1]), CVarName(('!LOAD_GLOBAL', it[1]))
                return CVarName(('!LOAD_GLOBAL', it[1]))        
    return None

def generate_store_int(o, store_ind, n_iter, _expr = None):
    assert type(o) is Out
    if _expr is None:
        _expr = 'PyInt_AsLong'    
    cnm = cnamevar_for_store(store_ind)
    if cnm is not None:
        o.Raw(cnm, ' = ', n_iter, ';')
    else:
        generate_full_store_int(o, store_ind, n_iter, _expr)
    
def generate_full_store_int(o, store_ind, n_iter, tag):
    assert type(o) is Out
    ref_int = New()
    o.PushInt(ref_int, n_iter)   
    generate_store(store_ind, ref_int, o, tag)
    o.Cls(ref_int)     

def generate_list_compr_iteritems(acc, val, store_1, store_2, dic, cond, o): 
    assert cond is None or len(cond) == 1 
    assert type(o) is Out
    ref_expr = Expr1(dic, o)
    cond_var = None
    
    pos = New('Py_ssize_t')
    o.Stmt(pos, '=', 0)
    k, v = New(), New()
    o.Raw('while (PyDict_Next(', ref_expr, ', ', ('&', pos), ', ', ('&', k), ', ', ('&', v), ')) {')
    o.INCREF(k)       
    o.INCREF(v)       
    generate_store(store_1, k, o, 'PyDict_Next')
    generate_store(store_2, v, o, 'PyDict_Next')
    o.Cls(k,v)
 
    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
    ref_val = Expr1(val[0], o)
    if acc is not None:
        o.Stmt('PyList_Append', acc, ref_val)
    o.Cls(ref_val)
    if cond is not None:
        o.append('}')
        o.Cls(cond_var)
    o.append('}')
    o.Cls(pos, ref_expr)
    
def generate_store_ctype(o, store_ind, iter, _expr):
    assert type(o) is Out
    tupl = cnamevar_for_store(store_ind, True)
    if tupl is not None:
        ctyp, cnm = tupl
        if IsInt(ctyp):
            o.Raw(cnm, ' = PyInt_AS_LONG ( ', iter, ' );')
        else:
            pp(ctyp)
            assert False       
            
    else:
        generate_store(store_ind, iter, o, _expr)    

def generate_list_compr_iterkeys(acc, val, store, dic, cond, o): 
    assert cond is None or len(cond) == 1 
    assert type(o) is Out
    ref_expr = Expr1(dic, o)
    cond_var = None
    
    pos = New('Py_ssize_t')
    o.Stmt(pos, '=', 0)
    k, v = New(), New()
    o.Raw('while (PyDict_Next(', ref_expr, ', ', ('&', pos), ', ', ('&', k), ', ', ('&', v), ')) {')
    o.Raw(v, ' = 0;')
    o.INCREF(k)       
    generate_store_ctype(o, store, k, 'PyDict_Next')
    o.ClsFict(v)
    o.Cls(k,v)
 
    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
    ref_val = Expr1(val[0], o)
    if acc is not None:
        o.Stmt('PyList_Append', acc, ref_val)
    o.Cls(ref_val)
    if cond is not None:
        o.append('}')
        o.Cls(cond_var)
    o.append('}')
    o.Cls(pos, ref_expr)

def generate_list_compr_itervalues(acc, val, store, dic, cond, o): 
    assert cond is None or len(cond) == 1 
    assert type(o) is Out
    ref_expr = Expr1(dic, o)
    
    cond_var = None
    
    pos = New('Py_ssize_t')
    o.Stmt(pos, '=', 0)
    k, v = New(), New()
    o.Raw('while (PyDict_Next(', ref_expr, ', ', ('&', pos), ', ', ('&', k), ', ', ('&', v), ')) {')
    o.INCREF(k)       
    o.INCREF(v)       
    generate_store(store, v, o, 'PyDict_Next')
    o.Cls(k,v)
 
    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
    ref_val = Expr1(val[0], o)
    if acc is not None:
        o.Stmt('PyList_Append', acc, ref_val)
    o.Cls(ref_val)
    if cond is not None:
        o.append('}')
        o.Cls(cond_var)
    o.append('}')
    o.Cls(pos, ref_expr)

def generate_list_compr(val, descr_compr, o, forcenewg):
    global g_co
    assert type(o) is Out
    prev_compr = g_co.list_compr_in_progress
    g_co.list_compr_in_progress = True
    acc0 = GenExpr(('!BUILD_LIST', ()),o, forcenewg)
    store,expr,cond = descr_compr[0:3]

    v = []
    if True:
        if len(descr_compr) == 3 and len(store) == 2 and len(expr) == 1 and \
            TCmp(descr_compr, v, (('?', '?'), (('!PyObject_Call', \
            ('!PyObject_GetAttr', '?', ('CONST', 'iteritems')), \
            ('CONST', ()), \
            ('NULL',)),), \
            '?')) and IsDict(TypeExpr(v[2])):    
            generate_list_compr_iteritems(acc0, val, store[0], store[1], v[2], cond, o)
            return acc0                             
        if len(descr_compr) == 3 and len(store) == 1 and len(expr) == 1:
            if TCmp(descr_compr, v, (('?',), (('!PyObject_Call', \
                ('!PyObject_GetAttr', '?', ('CONST', 'iterkeys')), \
                ('CONST', ()), \
                ('NULL',)),), \
                '?')) and IsDict(TypeExpr(v[1])):    
                generate_list_compr_iterkeys(acc0, val, store[0], v[1], cond, o)
                return acc0  
            if IsDict(TypeExpr(expr[0])):
                generate_list_compr_iterkeys(acc0, val, store[0], expr[0], cond, o)
                return acc0              
        if len(descr_compr) == 3 and len(store) == 1 and len(expr) == 1 and \
            TCmp(descr_compr, v, (('?',), (('!PyObject_Call', \
            ('!PyObject_GetAttr', '?', ('CONST', 'itervalues')), \
            ('CONST', ()), \
            ('NULL',)),), \
            '?')) and IsDict(TypeExpr(v[1])):    
            generate_list_compr_itervalues(acc0, val, store[0], v[1], cond, o)
            return acc0    
    if len(descr_compr) == 3 and len(store) == 2 and len(expr) == 1 and \
                is_expandable_enumerate(expr[0]):
        generate_list_compr_enumerate(acc0, val, store[0], store[1], \
                                      expr[0][2][1][0], cond, o)
        return acc0                             
    recursive_gen_func_list_compr(acc0, val, store,expr, cond, descr_compr[3:], o, '')
    g_co.list_compr_in_progress = prev_compr
    return acc0

def generate_list_compr_no_result(val, descr_compr, o):
    global g_co
    assert type(o) is Out
    prev_compr = g_co.list_compr_in_progress
    g_co.list_compr_in_progress = True
    acc0 = None
    store,expr,cond = descr_compr[0:3]

    v = []
    if True:
        if len(descr_compr) == 3 and len(store) == 2 and len(expr) == 1 and \
            TCmp(descr_compr, v, (('?', '?'), (('!PyObject_Call', \
            ('!PyObject_GetAttr', '?', ('CONST', 'iteritems')), \
            ('CONST', ()), \
            ('NULL',)),), \
            '?')) and IsDict(TypeExpr(v[2])):    
            generate_list_compr_iteritems(acc0, val, store[0], store[1], v[2], cond, o)
            return acc0                             
        if len(descr_compr) == 3 and len(store) == 1 and len(expr) == 1 and \
            TCmp(descr_compr, v, (('?',), (('!PyObject_Call', \
            ('!PyObject_GetAttr', '?', ('CONST', 'iterkeys')), \
            ('CONST', ()), \
            ('NULL',)),), \
            '?')) and IsDict(TypeExpr(v[1])):    
            generate_list_compr_iterkeys(acc0, val, store[0], v[1], cond, o)
            return acc0  
        if len(descr_compr) == 3 and len(store) == 1 and len(expr) == 1 and \
            TCmp(descr_compr, v, (('?',), (('!PyObject_Call', \
            ('!PyObject_GetAttr', '?', ('CONST', 'itervalues')), \
            ('CONST', ()), \
            ('NULL',)),), \
            '?')) and IsDict(TypeExpr(v[1])):    
            generate_list_compr_itervalues(acc0, val, store[0], v[1], cond, o)
            return acc0    
    if len(descr_compr) == 3 and len(store) == 2 and len(expr) == 1 and \
                is_expandable_enumerate(expr[0]):
        generate_list_compr_enumerate(acc0, val, store[0], store[1], \
                                      expr[0][2][1][0], cond, o)
        return acc0                             
    recursive_gen_func_list_compr(acc0, val, store,expr, cond, descr_compr[3:], o, 'UNPUSH')
    g_co.list_compr_in_progress = prev_compr
    return acc0

def generate_unpush_list_compr(it, o):
    assert type(it) is tuple
    assert type(o) is Out     
    assert len(it) == 3
    assert type(o) is Out
    prev_compr = g_co.list_compr_in_progress
    g_co.list_compr_in_progress = True
    generate_list_compr_no_result(it[1],it[2],o)  
    g_co.list_compr_in_progress = prev_compr
    return None   

def generate_set_compr(val, descr_compr, o, forcenewg):
    assert type(o) is Out
    acc0 = GenExpr(('!BUILD_SET', ()),o, forcenewg)
    store,expr,cond = descr_compr[0:3]
    recursive_gen_set_compr(acc0, val, store,expr, cond, descr_compr[3:], o)
    return acc0

def recursive_gen_set_compr(acc, val, store,expr, cond,tail, o):
    assert len(expr) == 1
    assert cond is None or len(cond) == 1
    assert type(o) is Out
    ref_iter = Expr1(expr[0], o)
    o.append('for (;;) {')
    ref_temp = New()
    o.Stmt(ref_temp, '=', 'PyIter_Next', ref_iter)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref_temp, '){ break; }')
    if len(store) == 1:
        generate_store(store[0], ref_temp, o, 'PyIter_Next')
    else:  
        if store is not None:  
            generate_store(('SET_VARS', store), ref_temp, o, 'PyIter_Next')
    o.ZeroTemp(ref_temp)  

    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
        o.Cls(cond_var)
    if len(tail) == 0:
        ref_val = Expr1(val[0], o)
        o.Stmt('PySet_Add', acc, ref_val)
        o.Cls(ref_val)
    else:
        store1,expr1, cond1 = tail[0:3]
        recursive_gen_set_compr(acc, val, store1,expr1, cond1, tail[3:], o)
    if cond is not None:
        o.append('}')
    o.append('}')
    o.Cls(ref_iter)

def generate_map_compr(val, descr_compr, o, forcenewg):
    assert type(o) is Out
    acc0 = GenExpr(('!BUILD_MAP', ()),o, forcenewg)
    store,expr,cond = descr_compr[0:3]

    recursive_gen_map_compr(acc0, val, store,expr, cond, descr_compr[3:], o)
    return acc0

def recursive_gen_map_compr(acc, val, store,expr, cond,tail, o):
    assert len(expr) == 1
    assert cond is None or len(cond) == 1
    assert type(o) is Out
    ref_expr = Expr1(expr[0], o)
    ref_iter = New()
    o.Stmt(ref_iter, '=', 'PyObject_GetIter', ref_expr)
    o.Cls(ref_expr)
    
    o.append('for (;;) {')
    ref_temp = New()
    o.Stmt(ref_temp, '=', 'PyIter_Next', ref_iter)
    o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
    UseLabl()
    o.Stmt('if (!', ref_temp, '){ break; }')
    if len(store) == 1:
        generate_store(store[0], ref_temp, o, 'PyIter_Next')
    else:  
        if store is not None:  
            generate_store(('SET_VARS', store), ref_temp, o, 'PyIter_Next')
    o.ZeroTemp(ref_temp)  

    if cond is not None:
        o1, cond_var = shortage(generate_logical_expr(cond[0]))
        o.extend(o1)
        o.Stmt('if (', cond_var, '){')
        o.Cls(cond_var)
    if len(tail) == 0:
        ref_k = Expr1(val[0], o)
        ref_v = Expr1(val[1], o)
        o.Stmt('PyDict_SetItem', acc, ref_k, ref_v)
        o.Cls(ref_k, ref_v)
    else:
        store1,expr1, cond1 = tail[0:3]
        recursive_gen_map_compr(acc, val, store1,expr1, cond1, tail[3:], o)
    if cond is not None:
        o.append('}')
    o.append('}')
    o.Cls(ref_iter)

def generate_func_list_compr(val, descr_compr, o, func_nm):
    assert type(o) is Out
    if func_nm == 'all':
        acc0 = New('int')
        o.Raw(acc0, ' = 1;')
    elif func_nm == 'any':
        acc0 = New('int')
        o.Raw(acc0, ' = 0;')
    elif func_nm == 'UNPUSH':
        acc0 = None
    else:
        Fatal('456')
        assert False
        return
    store,expr,cond = descr_compr[0:3]

    recursive_gen_func_list_compr(acc0, val, store,expr, cond, descr_compr[3:], o, func_nm)
    return acc0

def recursive_gen_func_list_compr(acc, val, store,expr, cond,tail, o, func_nm):
    global g_co
    assert len(expr) == 1
    assert cond is None or len(cond) == 1
    assert type(o) is Out
    ref_temp = None
    t0 = TypeExpr(expr[0])
    islist = IsListAll(t0)
    istuple = IsTuple(t0)
    isstr = IsStr(t0)
    ref_expr = None
    ref_iter = None
    pos = None
    cnt = None
    nmvar_repl = None
    ##isctype = False
    store_ref = None
    is_assigned = None
    is_used = None
    flagpr = False
    oleno = len(o)
    if len(g_co.fast_used_at_list_compr) > 0 and len(store) == 1 and store[0][0] == 'STORE_FAST':
        if store[0][1] in g_co.fast_used_at_list_compr and not IsCType(TypeExpr(('FAST',store[0][1]))):
            flagpr = True    
    if len(store) == 1 and (islist or istuple or isstr) and store[0][0] == 'STORE_FAST':
        nmvar_repl = store[0][1]
        ##isctype = g_co.IsCVar(('FAST', nmvar_repl))
        is_used = nmvar_repl in g_co.used_fastlocals
    if islist:
        pos = New('int')
        v = []
        if TCmp(expr[0], v, 
                      ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'range'), \
                      ('!BUILD_TUPLE', ('?',)), \
                      ('NULL',))):
            ref_arg = Expr1(v[0], o)
            cnt = New('Py_ssize_t')
            o.Raw(cnt, ' = PyInt_AS_LONG ( ', ref_arg,' );')
            o.Cls(ref_arg)
            o.Raw('for (', pos, ' = 0;', pos, ' < ', cnt, ';', pos, ' ++) {')
            ref_temp = New()
            o.Raw(ref_temp, ' = PyInt_FromLong(', pos, ');')
        elif TCmp(expr[0], v, 
                      ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'xrange'), \
                      ('!BUILD_TUPLE', ('?',)), 
                      ('NULL',))):
            if IsInt(TypeExpr(v[0])):
                ref_arg = Expr1(v[0], o)
                cnt = New('Py_ssize_t')
                o.Raw(cnt, ' = PyInt_AS_LONG ( ', ref_arg,' );')
                o.Cls(ref_arg)
                o.Raw('for (', pos, ' = 0;', pos, ' < ', cnt, ';', pos, ' ++) {')
                ref_temp = New()
                o.Raw(ref_temp, ' = PyInt_FromLong(', pos, ');')  
            else:
                v = []
        elif TCmp(expr[0], v, 
                      ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'range'), \
                      ('CONST', ('?',)),
                      ('NULL',))):
            if type(v[0]) is int:
                ref_arg = None
                cnt = v[0]
                o.Raw('for (', pos, ' = 0;', pos, ' < ', cnt, ';', pos, ' ++) {')
                ref_temp = New()
                o.Raw(ref_temp, ' = PyInt_FromLong(', pos, ');')            
        else:
            ref_expr = Expr1(expr[0], o)
            if False and is_used:
                o.Raw(is_assigned, ' = 0;')
                o.Raw(store_ref, ' = GETLOCAL(', nmvar_repl, ');')
            o.Raw('for (', pos, ' = 0;', pos, ' < PyList_GET_SIZE(', ref_expr, ');', pos, ' ++) {')
            ref_temp = New()
            o.Raw(ref_temp, ' = PyList_GET_ITEM(', ref_expr, ', ', pos, ');')
            o.INCREF(ref_temp)
        if len(store) == 1:
            if True:
                generate_store(store[0], ref_temp, o, 'PyList_GET_ITEM')
        else:  
            if store is not None:  
                generate_store(('SET_VARS', store), ref_temp, o, 'PyList_GET_ITEM')
            
    elif istuple:
        ref_expr = Expr1(expr[0], o)
        pos = New('int')
        len_expr = ConC('PyTuple_GET_SIZE(', ref_expr, ')')
        if ref_expr[0] == 'CONST':
            len_expr = len(ref_expr[1])
        o.Raw('for (', pos, ' = 0;', pos, ' < ', len_expr, ';', pos, ' ++) {')
        ref_temp = New()
        o.Raw(ref_temp, ' = PyTuple_GET_ITEM( ', ref_expr, ', ', pos, ' );')
        o.INCREF(ref_temp)
        if len(store) == 1:
            generate_store(store[0], ref_temp, o, 'PyTuple_GET_ITEM')
        else:  
            if store is not None:  
                generate_store(('SET_VARS', store), ref_temp, o, 'PyTuple_GET_ITEM')
    elif isstr:
        ref_expr = Expr1(expr[0], o)
        pos = New('int')
        len_expr = ConC('PyString_GET_SIZE(', ref_expr, ')')
        if ref_expr[0] == 'CONST':
            len_expr = len(ref_expr[1])            
        o.Raw('for (', pos, ' = 0;', pos, ' < ', len_expr, ';', pos, ' ++) {')
        ref_temp = New()
        o.Raw(ref_temp, ' = PyString_FromStringAndSize(PyString_AS_STRING(', ref_expr, ')+', pos, ', 1);')
        if len(store) == 1:
            generate_store(store[0], ref_temp, o, 'PyString_GET_ITEM')
        else:  
            if store is not None:  
                generate_store(('SET_VARS', store), ref_temp, o, 'PyString_GET_ITEM')

    else:    
        v = []
        if TCmp(expr[0], v, 
                      ('!PyObject_Call', \
                      ('!LOAD_BUILTIN', 'enumerate'), \
                      ('!BUILD_TUPLE', ('?',)), 
                      ('NULL',))):   
            ref_expr = Expr1(v[0], o)
            ref_iter = New()
            pos = New('long')
            o.Stmt(ref_iter, '=', 'PyObject_GetIter', ref_expr)
            o.Cls(ref_expr)
            o.Raw(pos, ' = 0;')
            o.append('for (;;) {')
            ref_temp = New()
            o.Stmt(ref_temp, '=', 'PyIter_Next', ref_iter)
            o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
            UseLabl()
            o.Stmt('if (!', ref_temp, '){ break; }')
            if len(store) == 2:
                generate_store(store[1], ref_temp, o, 'PyIter_Next')
                o.Cls(ref_temp)  
                generate_store_int(o, store[0], pos)
                o.Stmt(pos, '++')
            elif len(store) == 1:
                generate_store(store[0], ref_temp, o, 'PyIter_Next')
            else:  
                if store is not None:  
                    generate_store(('SET_VARS', store), ref_temp, o, 'PyIter_Next')
        else:
            ref_expr = Expr1(expr[0], o)
            ref_iter = New()
            o.Stmt(ref_iter, '=', 'PyObject_GetIter', ref_expr)
            o.Cls(ref_expr)
            o.append('for (;;) {')
            ref_temp = New()
            o.Stmt(ref_temp, '=', 'PyIter_Next', ref_iter)
            o.Raw('if (PyErr_Occurred()) goto ', labl, ';')
            UseLabl()
            o.Stmt('if (!', ref_temp, '){ break; }')
            if len(store) == 1:
                generate_store(store[0], ref_temp, o, 'PyIter_Next')
            else:  
                if store is not None:  
                    generate_store(('SET_VARS', store), ref_temp, o, 'PyIter_Next')
    if ref_temp is not None:
        o.ZeroTemp(ref_temp)  
    condlist = []
    if cond is not None:
        cond0 = type_in_if(cond[0], {})
        to_expr = None
        if cond0[0] == '!AND_JUMP':
            to_expr = cond0
        elif (cond0[0] == '!BOOLEAN' and cond0[1][0] == '!AND_BOOLEAN'):
            to_expr = cond0[1]
        if to_expr is not None:    
            condlist = generate_cond_and(to_expr, o)            
            for o1, logic in condlist:
                o.extend(o1)
                o.Stmt('if (', logic, ') {')
                o.Cls(logic)
        else:
            condlist = [1]
            o1, cond_var = shortage(generate_logical_expr(cond0))
            o.extend(o1)
            if type(cond_var) is str:
                if cond_var.startswith('(') and cond_var.endswith(')') and '(' not in cond_var[1:] and ')' not in cond_var[:-1]:
                    cond_var = cond_var[1:-1]
            o.Stmt('if (', cond_var, '){')
            o.Cls(cond_var)
    if len(tail) == 0:
        if func_nm in ('all', 'any'):
            o1, cond_var = shortage(generate_logical_expr(val[0]))
            o.extend(o1)
            if func_nm == 'all':
                o.Raw('if (!(', cond_var,')) {')
                o.Raw(acc, ' = 0;')
                o.Raw('}') 
            else:
                o.Raw('if (', cond_var,') {')
                o.Raw(acc, ' = 1;')
                o.Raw('}') 
        elif func_nm == 'len':
            ref_val = Expr1(val[0], o)
            o.Cls(ref_val)
            o.Raw(acc, ' += 1;')
        elif func_nm == 'UNPUSH':
            ref_val = Expr1(val[0], o)
            o.Cls(ref_val)
        elif func_nm == '':
            ref_val = Expr1(val[0], o)
            o.Stmt('PyList_Append', acc, ref_val)
            o.Cls(ref_val)
        else:
            Fatal('321')
            assert False
        o.Cls(cond)
    else:
        store1,expr1, cond1 = tail[0:3]
        recursive_gen_func_list_compr(acc, val, store1,expr1, cond1, tail[3:], o, func_nm)
    for e_it in condlist:
        o.append('}')
    o.append('}')
    
    o.Cls(ref_iter, pos, cnt)
    
    if False:
        if is_used:
            o.Raw('if (', is_assigned, ') {')
            o.INCREF(('FAST', nmvar_repl))
            o.Cls(store_ref)
            o.Raw('} else {')
            o.Raw(('FAST', nmvar_repl), ' = ', store_ref, ';')
            o.Raw(store_ref, ' = 0;')
            o.Raw('}')
            o.Cls(is_assigned)
        else:
            o.Raw('if (', ('FAST', nmvar_repl), ') {')
            o.INCREF(('FAST', nmvar_repl))
            o.Raw('}')
        g_co.used_fastlocals[nmvar_repl] = True
    o.Cls(is_assigned, store_ref)
    o.Cls(ref_expr)
    if flagpr and False:
        oo1 = o[oleno:]
        oo = Out()
        oo.extend(oo1)
        pprint(oo)
        optimize(oo)
        pprint(oo)
        print '--------------'
    
  
def generate_cond_and(to_expr, o):
    assert type(o) is Out
    e = []
    for i in range(1, len(to_expr)):
        if to_expr[i][0] == '!BOOLEAN' and to_expr[i][1][0] == '!AND_BOOLEAN':
            for j in range(1, len(to_expr[i][1])):
                e.append(to_expr[i][1][j])
        else: 
            e.append(to_expr[i])  
    condlist = []
    logic2 = New('int')
    for e_it in e:
        o1, logic = shortage(generate_logical_expr(e_it, logic2))    
        if type(logic) is str and logic.startswith('(') and logic.endswith(')'):
            logic = logic[1:-1].strip()
        if type(logic) is str and logic.startswith('!(') and logic.endswith(')'):
            if len(o1) >0 and o1[-1].startswith(logic[2:-1] + ' = '):
                logic = '!(' + o1[-1][len(logic):-1] + ')'
                del o1[-1]
        if len(o1) > 0 and o1[-1].startswith('long_'):
            v2 = {}
            if TxMatch(o1, len(o1)-1, """
                long_$3 = $4;""", v2) and logic.startswith('long_' + v2[3] + ' '):
                logic = v2[4] + logic[5+len(v2[3]):]
                del o1[-1]
        if logic != '1' or len(o1) != 0:
            condlist.append((o1, logic))
            
    i = 0
    while i < len(condlist):
        j = i + 1
        j2 = i
        while j < len(condlist):
            if len(condlist[j][0]) == 0:
                j2 = j
                j += 1                    
            else:
                break
        if i != j2:
            s = ''
            for o1, logical in condlist[i:j2+1]:
                if type(logical) is not str:
                    logical = ConC(logical)
                    s += logical + ' && '
                else:
                    s += '(' + logical + ') && '
            s = s[:-4]  
            condlist[i:j2+1] = [(condlist[i][0], s)]
        i += 1 
    o.Cls(logic2)
    return condlist

def generate_cond_or(to_expr, o):
    assert type(o) is Out
    e = []
    for i in range(1, len(to_expr)):
        if to_expr[i][0] == '!BOOLEAN' and to_expr[i][1][0] == '!OR_BOOLEAN':
            for j in range(1, len(to_expr[i][1])):
                e.append(to_expr[i][1][j])
        else: 
            e.append(to_expr[i])  
    condlist = []
    logic2 = New('int')
    for e_it in e:
        o1, logic = shortage(generate_logical_expr(e_it, logic2))    
        if type(logic) is str and logic.startswith('(') and logic.endswith(')'):
            logic = logic[1:-1].strip()
        if type(logic) is str and logic.startswith('!(') and logic.endswith(')'):
            if len(o1) >0 and o1[-1].startswith(logic[2:-1] + ' = '):
                logic = '!(' + o1[-1][len(logic):-1] + ')'
                del o1[-1]
        if len(o1) > 0 and o1[-1].startswith('long_'):
            v2 = {}
            if TxMatch(o1, len(o1)-1, """
                long_$3 = $4;""", v2) and logic.startswith('long_' + v2[3] + ' '):
                logic = v2[4] + logic[5+len(v2[3]):]
                del o1[-1]
        if logic != '1' or len(o1) != 0:
            condlist.append((o1, logic))
            
    i = 0
    while i < len(condlist):
        j = i + 1
        j2 = i
        while j < len(condlist):
            if len(condlist[j][0]) == 0:
                j2 = j
                j += 1                    
            else:
                break
        if i != j2:
            s = ''
            for o1, logical in condlist[i:j2+1]:
                if type(logical) is not str:
                    logical = ConC(logical)
                    s += logical + ' || '
                else:
                    s += '(' + logical + ') || '
            s = s[:-4]  
            condlist[i:j2+1] = [(condlist[i][0], s)]
        i += 1 
    o.Cls(logic2)
    return condlist
    
def generate_len_list_compr(val, descr_compr, o):
    assert type(o) is Out
    acc0 = New('Py_ssize_t')
    o.Raw(acc0, ' = 0;')
    store,expr,cond = descr_compr[0:3]

    recursive_gen_func_list_compr(acc0, val, store,expr, cond, descr_compr[3:], o, 'len')
    return acc0

def AssignCalcConst(nm, ref, o, expr):
    assert type(o) is Out
    if is_mnemonic_const(nm):
        return
    if IsCTypedGlobal(nm) and not redefined_all and fast_globals:
        add_fast_glob(nm)
        t = TypeGlobal(nm)
        assert IsCType(t)
        cnm = CVarName(('CALC_CONST', nm))
        assert type(cnm) is str
        generate_store_to_ctype(o, cnm, t, ref)
        o.ClsFict(ref)
        if istempref(ref) and ref not in g_refs2:
            o.Raw(ref, ' = 0;')  
        return
        
    calculated_const[nm].store_calced = True
    if CVar(calc_const_to(nm)) != CVar(ref):
        o.Stmt(calc_const_to(nm), '=', ref)
        if False:
            o.INCREF(ref)
    for a,b,c in Iter3(nm, 'ModuleAttr', None):
        if (nm, c) not in calculated_const:
            continue
        calculated_const[(nm,c)].store_calced = True
        if c != '.__dict__':
            r = New()
            o.Stmt(r, '=', 'PyObject_GetAttr', ref, ('CONST', c))
            o.INCREF(r)
            o.Stmt(calc_const_to((nm, c)), '=', r)
            o.Cls(r)

        else:
            t = TypeExpr(expr)
            if t is None:
                Fatal('Can\'t detect old/new class of calculated const %s' % nm, expr)
                assert False
            if t[0] == T_NEW_CL_INST and t[1] not in detected_slots:
                o.Raw(calc_const_to((nm, c)), ' = *_PyObject_GetDictPtr(', calc_const_to(nm), ');')
            elif t[0] == T_OLD_CL_INST and t[1] not in compiled_slots:
                o.Raw(calc_const_to((nm, c)), ' = ((PyInstanceObject *)', calc_const_to(nm), ')->in_dict;')
            else:
                Fatal('Can\'t detect any class of calculated const %s' % nm, expr)
                assert False

def IsCTypedGlobal(k):
    return bool(k in detected_global_type and IsCType(detected_global_type[k]))

def TypeGlobal(k):
    if k in detected_global_type:
        return detected_global_type[k]
    return None

def IsCVar(it):
    if type(it) is tuple and len(it) >= 2:
        if it[0] == 'PY_TYPE':
            if IsCVar(it[3]):
                return True
            return False
        elif it[0] == '!@PyInt_FromSsize_t':
            if IsCVar(it[2]):
                return True
            return False
        head = it[0]
        assert type(head) is str
        if head == 'FAST':
            pos = g_co.d_varnames[it[1]]
            typed_arg = g_co.typed_arg_direct
            if pos in typed_arg and is_current & IS_DIRECT:
                if IsCType(typed_arg[pos]):
                    return True
            if it[1] in g_co.detected_type:
                if IsCType(g_co.detected_type[it[1]]):
                    return True
        elif head == '!LOAD_GLOBAL' and it[1] not in d_built and ( it[1][0] != '_' or build_executable ) and \
             not redefined_all:
            if fast_globals and not global_used_at_generator(it[1]):
                if IsCTypedGlobal(it[1]): 
                    return CVarName(it) is not None
            if IsCType(TypeExpr(it)):
                return CVarName(it) is not None
        elif func == 'Init_filename' and  head == '!LOAD_NAME' and it[1] not in d_built and (it[1][0] != '_' or build_executable) and not redefined_all:
            if fast_globals and not global_used_at_generator(it[1]):
                if IsCTypedGlobal(it[1]): 
                    return CVarName(it) is not None
                
    return False        

prev_cur_co = None
prev_have_ctype = False
def have_ctype_local_variable():
    global g_co, prev_cur_co, prev_have_ctype
    if prev_cur_co is not None and g_co.c_name == prev_cur_co.c_name:
        return prev_have_ctype
    prev_cur_co = g_co
    prev_have_ctype = True
    typed_arg = g_co.typed_arg_direct
    for pos, it1 in enumerate(g_co.co_varnames):
        if pos in typed_arg and is_current & IS_DIRECT:
            t = typed_arg[pos]
            if IsCType(t):
                return True
        if it1 in g_co.detected_type:
            t = g_co.detected_type[it1]
            if IsCType(t):
                return True
    prev_have_ctype = False
    return False

def CVarName(it):
    if type(it) is tuple and len(it) >= 2:
        head = it[0]
        assert type(head) is str
        if head == 'PY_TYPE':
            return CVarName(it[3])
        if it[0] == '!@PyInt_FromSsize_t':
            return CVarName(it[2])
        if head == 'FAST':
            pos = g_co.d_varnames[it[1]]
            typed_arg = g_co.typed_arg_direct
            if pos in typed_arg and is_current & IS_DIRECT:
                t = typed_arg[pos]
                if IsCType(t):
                    return 'Loc_' + Type2CType(t) + '_' + it[1]
            if it[1] in g_co.detected_type:
                t = g_co.detected_type[it[1]]
                if IsCType(t):
                    return 'Loc_' + Type2CType(t) + '_' + it[1]
        if head == '!LOAD_GLOBAL' and it[1] not in d_built and (it[1][0] != '_' or build_executable) and not redefined_all:
            if fast_globals and not global_used_at_generator(it[1]):
                if IsCTypedGlobal(it[1]):
                    t = TypeGlobal(it[1])
                    return 'Glob_' + Type2CType(t) + '_' + it[1]
        if func == 'Init_filename' and  head == '!LOAD_NAME' and it[1] not in d_built and (it[1][0] != '_' or build_executable) and not redefined_all:
            if fast_globals and not global_used_at_generator(it[1]):
                if IsCTypedGlobal(it[1]):
                    t = TypeGlobal(it[1])
                    return 'Glob_' + Type2CType(t) + '_' + it[1]
        if head == 'CALC_CONST' and it[1] not in d_built and (it[1][0] != '_' or build_executable) and not redefined_all:
            if fast_globals : #and not global_used_at_generator(it[1]):
                if IsCTypedGlobal(it[1]):
                    t = TypeGlobal(it[1])
                    return 'Glob_' + Type2CType(t) + '_' + it[1]
    return None

def CSetVariable(o, var, val):
    assert type(o) is Out
    nm = CVarName(var)
    if nm is None:
        return False
    t1 = TypeExpr(var)
    t2 = TypeExpr(val)

    if IsCType(t2) and Type2CType(t1) == Type2CType(t2):
        if val[0] == 'CONST':
            generate_store_to_ctype(o, nm, t1, val)
            return True
        if val[0] == '!CALL_CALC_CONST':
            generate_call_calc_const(val, o, None, nm)
            return True
        if val[0] == 'PY_TYPE' and IsCVar(val[3]):
            o.Raw(nm, ' = ', CVarName(val[3]), ';')
            return True
        if IsCVar(val):
            o.Raw(nm, ' = ', CVarName(val), ';')
            return True
        o2, s, ty, checktupl, checktuplerr = attempt_str_direct_type_generation(val, t2)
        assert type(ty) is set
        if s is not None:
            labl_err = add_check_message(checktupl, checktuplerr, o2)
            if len(o2) > 0:
                o.extend(o2)
            o.Raw(nm, ' = ', s, ';')
            for v in ty:
                o.Cls(v)
            o.Cls(s)
            return True    

        if IsBool(t1) and val[0] == '!BOOLEAN':
            o1, int_val = shortage(generate_logical_expr(val[1]))
            o.extend(o1)
            o.Raw(nm, ' = ', int_val, ';')
            o.Cls(int_val)
            return True
        if IsBool(t1) and val[0] != '!BOOLEAN':
            o1, int_val = shortage(generate_logical_expr(val))
            assert type(int_val) is not str or not int_val.startswith('(int_')
            o.extend(o1)
            o.Raw(nm, ' = ', int_val, ';')
            o.Cls(int_val)
            return True  
        if IsInt(t1) and val[0] == '!PY_SSIZE_T':   
            o1, int_val = short_gen_size_t((val[1]))
            o.extend(o1)
            o.Raw(nm, ' = ', int_val, ';')
            o.Cls(int_val)
            return True
        if IsChar(t1):
            if val[0] == '!BINARY_SUBSCR_Int' and IsStr(TypeExpr(val[1])) and val[2] == ('CONST', 0):
                ref = Expr1(val[1], o)
                o.Raw(nm, ' = (unsigned char) *PyString_AS_STRING ( ', ref, ' );')
                o.Cls(ref)
                return True

            ref = Expr1(val, o)
            v2 = {}
            if len(o) > 0 and TxMatch(o, len(o)-1, """
                                       temp[$1] = PyString_FromStringAndSize($2, 1);
                                       """, v2):
                if ConC(ref) == ('temp[' + v2[1] + ']'):
                    o.Cls(ref)
                    del o[-1]
                    del o[-1]
                    o.Raw(nm, ' = (unsigned char) *(', v2[2], ');')
                    return True
                    
            o.Raw(nm, ' = (unsigned char) *PyString_AS_STRING ( ', ref, ' );')
            o.Cls(ref)
            return True
        if IsInt(t1):
            ref = Expr1(val, o)
##            t = TypeExpr(val)
            if IsInt(t2):
                int_1 = nm
                ref, int_1 = to_long(o, ref, int_1) 
                if int_1 != nm:
                    o.Raw(nm, ' = ', int_1, ';')
                o.Cls(ref)
                o.Cls(int_1)
            else:
                o.Stmt(nm, '=', 'PyInt_AsLong', ref)
                o.Cls(ref)
            v = []
            return True    

        if IsFloat(t1):  
            ref = Expr1(val, o)
##            t = TypeExpr(val)
            if IsFloat(t2):
                int_1 = nm
                ref, int_1 = to_float(o, ref, int_1) 
                if int_1 != nm:
                    o.Raw(nm, ' = ', int_1, ';')
            else:
                o.Stmt(nm, '=', 'PyFloat_AsDouble', ref)
            o.Cls(ref)
            v = []
            return True    
    return False    

def generate_store_to_ctype(o, cnm_, t, ref):
    global g_refs2
    assert type(cnm_) is str
    assert type(o) is Out
    cnm = cnm_ + ' = '
    assert '=  =' not in cnm

    if IsInt(t):        
        if ref[0] == 'CONST':
            o.Raw(cnm, ref[1], ';')
        else:    
            o.Raw(cnm, 'PyInt_AsLong(', ref, ');')
            if istempref(ref) and ref not in g_refs2:
                o.Raw('Py_CLEAR(', ref, ');')
    elif IsFloat(t):        
        if ref[0] == 'CONST':
            o.Raw(cnm, float_str(ref[1]),';')
        else:    
            o.Raw(cnm, 'PyFloat_AsDouble(', ref, ');')
            if istempref(ref) and ref not in g_refs2:
                o.Raw('Py_CLEAR(', ref, ');')
    elif IsChar(t):        
        if ref[0] == 'CONST':
            o.Raw(cnm,  charhex(ref[1]), ';')
        else:    
            o.Raw(cnm, '*', Str_AS_STRING(ref), ';')
            if istempref(ref) and ref not in g_refs2:
                o.Raw('Py_CLEAR(', ref, ');')
    elif IsBool(t):        
        if ref[0] == 'CONST':
            if ref[1]:
                o.Raw(cnm, '1;')
            else:    
                o.Raw(cnm, '0;')
        else:    
            o.Raw(cnm, 'PyObject_IsTrue(', ref, ');')
            if istempref(ref) and ref not in g_refs2:
                o.Raw('Py_CLEAR(', ref, ');')
    else:
        assert False            

def generate_store(it, ref, o, expr):
    assert type(it) is tuple
    assert type(o) is Out     
    global func
    assert type(it) is tuple
    if it[0] == 'STORE_CALC_CONST':
        it = it[1]

        assert type(it) is tuple
        if fast_globals and it[1] not in d_built and (it[1][0] != '_' or build_executable) \
           and not redefined_all: ## and not global_used_at_generator(it[1]):
            AssignCalcConst(it[1], ref, o, expr)
            if not istempref(ref) and not IsCTypedGlobal(it[1]) :
                o.INCREF(ref)
            add_fast_glob(it[1])
            o.ClsFict(ref)
            if istempref(ref) and ref not in g_refs2:
                o.Raw(ref, ' = 0;')            
        elif it[0] == 'STORE_GLOBAL' or (it[0] == 'STORE_NAME' and func == 'Init_filename'):
            AssignCalcConst(it[1], ref, o, expr)
            o.Stmt('PyDict_SetItem', 'glob', ('CONST', it[1]), ref)
            if istempref(ref):
                o.Cls(ref)
        elif it[0] == 'STORE_NAME':
            AssignCalcConst(it[1], ref, o, expr)
            o.Stmt('PyObject_SetItem', 'f->f_locals', ('CONST', it[1]), ref)
        else:
            Fatal('generate_store', it)
            assert False
        o.ClsFict(ref)
        return
    if it[0] == 'STORE_GLOBAL' or (it[0] == 'STORE_NAME' and func == 'Init_filename'):
        if fast_globals and it[1] not in d_built and (it[1][0] != '_' or build_executable) \
           and not redefined_all  and not global_used_at_generator(it[1]):
            if not istempref(ref) and not IsCTypedGlobal(it[1]) :
                o.INCREF(ref)
            add_fast_glob(it[1])
            if IsCTypedGlobal(it[1]):
                t = TypeGlobal(it[1])
                cnm = CVarName(('!LOAD_GLOBAL', it[1]))
                generate_store_to_ctype(o, cnm, t, ref)
            elif it[1] in calculated_const:
                pass
            else:        
                o.Stmt('SETSTATIC', it[1], ref)
            o.ClsFict(ref)
            if istempref(ref) and ref not in g_refs2:
                o.Raw(ref, ' = 0;')            
        else:    
            o.Stmt('PyDict_SetItem', 'glob', ('CONST', it[1]), ref)
            if istempref(ref):
                o.Cls(ref)
            o.ClsFict(ref)
        return
    if it[0] == 'STORE_NAME':
        if is_current & IS_DICTIONABLE_CFUNC:
            o.Stmt('PyDict_SetItem', '_f_locals', ('CONST', it[1]), ref)
            if istempref(ref):
                o.Cls(ref)
            o.ClsFict(ref)            
        else:
            o.Stmt('PyObject_SetItem', 'f->f_locals', ('CONST', it[1]), ref)
            o.Cls(ref)
        return
    if it[0] == 'STORE_FAST':
        if it[1] in g_co.detected_type:
            t = g_co.detected_type[it[1]]
            if IsCType(t):
                cnm = CVarName(('FAST', it[1]))
                generate_store_to_ctype(o, cnm, t, ref) 
            else:        
                if not istempref(ref):
                    o.INCREF(ref)
                o.Stmt('SETLOCAL', nmvar_to_loc(it[1]), ref)
        else:
            i = g_co.d_varnames[it[1]]
            typed_arg = g_co.typed_arg_direct
            if i in typed_arg and is_current & IS_DIRECT:
                t = typed_arg[i]
                if IsCType(t):
                    cnm = CVarName(('FAST', it[1]))
                    generate_store_to_ctype(o, cnm, t, ref)
                else:        
                    if not istempref(ref):
                        o.INCREF(ref)
                    o.Stmt('SETLOCAL', nmvar_to_loc(it[1]), ref)
            else:
                if not istempref(ref):
                    o.INCREF(ref)
                o.Stmt('SETLOCAL', nmvar_to_loc(it[1]), ref)
        o.ClsFict(ref)
        if istempref(ref) and ref not in g_refs2:
            o.Raw(ref, ' = 0;')
        return
    if it[0] == 'STORE_DEREF':
        o.Stmt('PyCell_Set', ('LOAD_CLOSURE',it[1]), ref)
        o.Cls(ref)
        return
    if it[0] == 'PyObject_SetAttr':
        generate_SetAttr(it, ref, o)
        return
    if it[0] == '?PyObject_SetAttr':
        ref1, ref2 = Expr(o, it[1:3])
        o.Stmt('PyObject_SetAttr', ref1, ref2, ref)
        proc = Expr1(it[3], o)   
        o.Stmt('if (', proc, '==', load_builtin(it[3][1]), ') {')
        o.Stmt('PyObject_SetAttr', ref1, ref2, ref)
        o.Cls(ref, ref1, ref2)
        o.append('} else {')
        ref4 = New()
        tupl = Expr1(('!BUILD_TUPLE', (ref1, ref2, ref)), o)
        o.Stmt(ref4, '=', 'PyObject_Call', proc, tupl, ('NULL',))
        o.Cls(tupl, ref4)
        o.append('}')
        o.Cls(proc)
        return
# Code crash unknown -- no crash currently   
    if it[0] == 'PyObject_SetItem':
        it2 = it[2]
        if it2[0] == 'PY_TYPE' and it2[1] is int:
            it2 = it2[3]
        if it2[0] == '!@PyInt_FromSsize_t':
            islist = IsList(TypeExpr(it[1]))
            if islist:
                ref1 = Expr1(it[1], o)
                if not istempref(ref):
                    o.INCREF(ref)
                else:    
                    o.ClsFict(ref)
                o.Stmt('PyList_SetItem', ref1, it2[1], ref)
                o.Cls(ref1)
                return
            if not islist:
                ref1 = Expr1(it[1], o)
                o.Stmt('if (PyList_CheckExact(', ref1, ')) {')
                if not istempref(ref):
                    o.INCREF(ref)
                o.Stmt('PyList_SetItem', ref1, it2[1], ref)
                o.append('} else {')
                ref2 = Expr1(it2[2],o)
                o.Stmt('PyObject_SetItem', ref1, ref2, ref)
                o.Cls(ref2, ref)
                o.append('}')
                o.Cls(ref1)
                return
            
    if it[0] == 'PyObject_SetItem' and it[2][0] == 'CONST' and type(it[2][1]) is int:
        ref1 = Expr1(it[1], o)
        ty = TypeExpr(it[1])
        islist = IsList(ty)
        if islist:
            o.ClsFict(ref)
            if not istempref(ref):
                o.INCREF(ref)
            if it[2][1] >= 0:    
                ErrHandler(o, 'PyErr_SetString(PyExc_IndexError, "list assignment index out of range");', 
                           ConC('PyList_GET_SIZE( ', ref1, ' ) < ', it[2][1]+1))
                o.Raw('SETLISTITEM(', ref1, ', ', it[2][1],', ', ref, ');')           
                ##o.Stmt('PyList_SetItem', ref1, it[2][1], ref)
            else:    
                n = New('long')
                o.Raw(n, ' = PyList_GET_SIZE(', ref1, ') + ', it[2][1], ';')
                o.Stmt('PyList_SetItem', ref1, n, ref)
                o.Cls(n)
        elif IsDict(ty):   
            o.Stmt('PyDict_SetItem', ref1, it[2], ref)
            o.Cls(ref)
        else:
            if it[2][1] >= 0:    
                o.ClsFict(ref)
                o.Raw('if (PyList_CheckExact(', ref1, ') && PyList_GET_SIZE(', ref1,') > ', it[2][1], ') {')
                if not istempref(ref):
                    o.INCREF(ref)
                o.Raw('SETLISTITEM(', ref1, ', ', it[2][1],', ', ref, ');')
                o.append('} else {')
                o.Stmt('PyObject_SetItem', ref1, it[2], ref)
                if istempref(ref):
                    o.DECREF(ref)
                o.append('}')
            else:    
                o.Stmt('PyObject_SetItem', ref1, it[2], ref)
                o.Cls(ref)
        o.Cls(ref1)
        return
    if it[0] == 'PyObject_SetItem':
        ty = TypeExpr(it[1])
        ty_ind = TypeExpr(it[2])
        if IsDict(ty):        
            ref1, ref2 = Expr(o, it[1:3])
            o.Stmt('PyDict_SetItem', ref1, ref2, ref)
            o.Cls(ref, ref1, ref2)
        elif IsListAll(ty) and IsInt(ty_ind):        
            ref1 = Expr1(it[1],o)
            if not istempref(ref):
                o.INCREF(ref)
            o2,ind = short_gen_size_t(it[2])
            o.extend(o2)
            if type(ind) is int:
                if ind < 0:
                    ind2 = New('long')
                    o.Raw(ind2, ' = ', ind, ' + PyList_GET_SIZE(', ref1, ');')
                    ind = ind2
                else:
                    pass    
            else:    
                if not istemptyped(ind) and not IsCardinal(ty_ind):
                    ind_ = New('long')
                    o.Raw(ind_, ' = ', ind, ';')
                    ind = ind_
                if not IsCardinal(ty_ind):
                    o.Stmt('if (', ind, '< 0) {')
                    o.Raw(ind, ' += PyList_GET_SIZE(', ref1, ');')
                    o.append('}')
            o.Stmt('PyList_SetItem', ref1, ind, ref)
            o.ClsFict(ref)
            o.Cls(ind, ref, ref1)
        elif IsListAll(ty) and ty_ind == Kl_Slice:
            ref1, ref2 = Expr(o, it[1:3])
            o.Stmt('PyObject_SetItem', ref1, ref2, ref)
            o.Cls(ref, ref1, ref2)
        elif IsListAll(ty):        
            ref1 = Expr1(it[1],o)
            if not istempref(ref):
                o.INCREF(ref)
            refind = LikeExpr1(it[2], o)
            o.Raw('if (PyInt_CheckExact( ', refind,' )) {')
            ind = New('long')
            o.Raw(ind, ' = PyInt_AS_LONG ( ', refind,' );')
            o.Stmt('if (', ind, '< 0) {')
            o.Raw(ind, ' += PyList_GET_SIZE(', ref1, ');')
            o.append('}')
            o.Stmt('PyList_SetItem', ref1, ind, ref)
            o.Cls(ind)
            o.append('} else {')
            o.Stmt('PyObject_SetItem', ref1, refind, ref)
            o.DECREF(ref)
            o.append('}')    
            o.ClsFict(ref)
            o.Cls(ind, ref, ref1, refind)
        else:    
            if ty is not None and not IsSequence(ty):
                Debug( 'typed SetItem', ty, it)
            ref1, ref2 = Expr(o, it[1:3])
            o.Stmt('PyObject_SetItem', ref1, ref2, ref)
            o.Cls(ref, ref1, ref2)
        return
    
    if it[0] == 'STORE_SLICE_LV+0':
        t = TypeExpr(it[1])
        if IsList(t):
            assign_list_slice(it, o, ref)
            return    
        if t is not None:
            Debug('typed Store slice', t,it)
        ref1 = Expr1(it[1],o)
        o.Stmt('_PyEval_AssignSlice', ref1, 'NULL', 'NULL', ref)
        o.Cls(ref, ref1)
        return    
    if it[0] == 'STORE_SLICE_LV+3':
        t = TypeExpr(it[1])
        if IsList(t) and it[2][0] == 'CONST' and it[3][0] == 'CONST' and \
                         type(it[2][1]) is int and type(it[3][1]) is int and \
                         it[3][1] >= it[2][1] and it[2][1] >= 0:
            ref1 = Expr1(it[1],o)
            o.Stmt('PyList_SetSlice', ref1, it[2][1], it[3][1], ref)
            o.Cls(ref, ref1)
            return    
        if IsList(t) and it[3][0] == '!PyNumber_Add' and it[3][1] == it[2] and it[3][2][0] == 'CONST' and\
           type(it[3][2][1]) is int:
                if IsInt(TypeExpr(it[2])): 
                    store_list_slice_r(it, o, ref)
                    return
                else:
                    store_list_slice_r2(it, o, ref)
                    return
              
        if t is not None:
            Debug('typed Store slice', t, it)
        ref1, ref2, ref3 = Expr(o, it[1:])
        o.Stmt('_PyEval_AssignSlice', ref1, ref2, ref3, ref)
        o.Cls(ref, ref1, ref2, ref3)
        return    
    if it[0] == 'STORE_SLICE_LV+1':
        t = TypeExpr(it[1])
        if IsList(t):
            assign_list_slice(it, o, ref)
            return    
        elif t is not None:
            Debug('typed Store slice', TypeExpr(it[1]),it)

        ref1, ref2 = Expr(o, it[1:])
        o.Stmt('_PyEval_AssignSlice', ref1, ref2, 'NULL', ref)
        o.Cls(ref, ref1, ref2)
        return    
    if it[0] == 'STORE_SLICE_LV+2':
        t = TypeExpr(it[1])
        if t is not None:
            Debug('typed Store slice', t, it)
        ref1, ref2 = Expr(o, it[1:])
        o.Stmt('_PyEval_AssignSlice', ref1, 'NULL', ref2, ref)
        o.Cls(ref, ref1, ref2)
        return    
    if it[0] == 'SET_VARS':  
        mass_store(o,ref,it[1],expr)
        return       
    if it[0] == 'UNPACK_SEQ_AND_STORE' and it[1] == 0:  
        mass_store(o,ref,it[2],expr)
        return       
    Fatal('', it)
    assert False
    
def store_list_slice_r(it, o, ref):
    assert type(it) is tuple
    assert type(o) is Out     
    ref1 = Expr1(it[1],o)
    o2,ind1 = short_gen_size_t(it[2])
    o.extend(o2)
    ind2 = None
    if type(ind1) is int:
        if ind1 < 0:
            if ind2 is None:
                ind2 = New('long')
                o.Raw(ind2, ' = PyList_GET_SIZE(', ref1, ');')                        
            _ind1 = New('long')
            o.Stmt(_ind1, '=', ind1, '+', ind2)
            ind1 = _ind1
    elif ind1[0] == 'CONST':
        if ind1[1] < 0:
            if ind2 is None:
                ind2 = New('long')
                o.Raw(ind2, ' = PyList_GET_SIZE(', ref1, ');')                        
            _ind1 = New('long')
            o.Stmt(_ind1, '=', ind1[1], '+', ind2)
            ind1 = _ind1
    else:        
        if not istemptyped(ind1) and not IsCardinal(TypeExpr(it[2])):
            ind_ = New('long')
            o.Raw(ind_, ' = ', ind1, ';')
            ind1 = ind_
        if not IsCardinal(TypeExpr(it[2])):
            o.Stmt('if (', ind1, '< 0) {')
            if ind2 is None:
                ind2 = New('long')
                o.Raw(ind2, ' = PyList_GET_SIZE(', ref1, ');')                       
            o.Stmt(ind1, '=', ind1, '+', ind2)
            o.append('}')                        
    o.Stmt('PyList_SetSlice', ref1, ind1, ConC(ind1, ' + ',it[3][2][1]), ref)
    o.Cls(ref, ref1, ind1, ind2)
    return
    
def store_list_slice_r2(it, o, ref):
    assert type(it) is tuple
    assert type(o) is Out     
    ref1 = Expr1(it[1],o)
    ref2 = Expr1(it[2], o)
    o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
    ind1 = New('long')

    o.Stmt(ind1, '=', 'PyInt_AS_LONG', ref2)
    if not IsCardinal(TypeExpr(it[2])):
        o.Stmt('if (', ind1, '< 0) {')
        o.Raw(ind1, ' += PyList_GET_SIZE(', ref1, ');')
        o.append('}')

    o.Stmt('PyList_SetSlice', ref1, ind1, ConC(ind1, ' + ',it[3][2][1]), ref)
    o.Raw('} else {')
    ref3 = New()
    o.Stmt(ref3, '=', it[3][0][1:], it[3][1], it[3][2])
    o.Stmt('_PyEval_AssignSlice', ref1, ref2, ref3, ref)
    o.Cls(ref3)    
    o.Raw('}')
    o.Cls(ref, ref1, ind1, ref2)
    return

    
def charhex(ch):
    assert type(ch) is str and len(ch) == 1
    if 'A' <= ch <= 'Z':
        return '\'' + ch + '\''
    if 'a' <= ch <= 'z':
        return '\'' + ch + '\''
    if '0' <= ch <= '9':
        return '\'' + ch + '\''
    if ch in '~!@#$%^&*()_+-=[]{};:|/?.>,<':
        return '\'' + ch + '\''
    v = ord(ch)
    if v == 0:
        return '\'\\0\''
    s = hex(v)[2:]
    if len(s) < 2:
        s = '0' + s
    assert len(s) == 2
    return '\'\\x' + s + '\''
    
def assign_list_slice(it, o, ref, plus_1 = False):
    assert type(it) is tuple
    assert type(o) is Out     
    ref1 = Expr1(it[1],o)
    if it[0] == 'DELETE_SLICE+0':
        o.Stmt('PyList_SetSlice', ref1, 0, 'PY_SSIZE_T_MAX', 'NULL')
        o.Cls(ref1)
        return    
    if it[0] == 'STORE_SLICE_LV+0': 
        o.Raw('if ( PyList_SetSlice ( ', ref1, ' , 0 , PY_SSIZE_T_MAX , ', ref, ' ) == -1) goto ', labl, ';')
        UseLabl()
        o.Cls(ref1, ref)
        return    
    o2,ind1 = short_gen_size_t(it[2], True)
    o.extend(o2)
    ind2 = None
    if type(ind1) is int:
        if ind1 < 0:
            _ind1 = New('long')
            o.Stmt(_ind1, '=', ind1, '+', ConC( 'PyList_GET_SIZE(', ref1, ')' ))
            ind1 = _ind1
            if not plus_1:
                o.Stmt('if (', ind1, '< 0) {')
                o.Stmt(ind1, '=', 0) 
                o.append('}')            
    elif ind1[0] == 'CONST':
        if ind1[1] < 0:
            _ind1 = New('long')
            o.Stmt(_ind1, '=', ind1[1], '+', ConC( 'PyList_GET_SIZE(', ref1, ')' ))
            ind1 = _ind1
            if not plus_1:
                o.Stmt('if (', ind1, '< 0) {')
                o.Stmt(ind1, '=', 0) 
                o.append('}')     
    else:
        if not istemptyped(ind1):
            ind_ = New('long')
            o.Raw(ind_, ' = ', ind1, ';')
            ind1 = ind_
        o.Stmt('if (', ind1, '< 0) {')
        o.Stmt(ind1, '=', ind1, '+', ConC( 'PyList_GET_SIZE(', ref1, ')' ))
        if not plus_1:
            o.Stmt('if (', ind1, '< 0) {')
            o.Stmt(ind1, '=', 0) 
            o.append('}')          
        o.append('}')                        
    if plus_1:    
        ind2 = New('long')
        o.Stmt(ind2, '=', ind1, '+', 1)
        o.Stmt('PyList_SetSlice', ref1, ind1, ind2, ref)
    else:
        o.Stmt('PyList_SetSlice', ref1, ind1, 'PY_SSIZE_T_MAX', ref)
    o.Cls(ref, ref1, ind1, ind2)
    return    
 
def handle_unpack_except(o, src_len, trg_len):
    assert type(o) is Out
    if type(src_len) is int and type(trg_len) is int:
        if src_len >  trg_len:
            o.Raw('PyErr_Format(PyExc_ValueError, "too many values to unpack");')
            o.Raw('goto ', labl, ';')
            UseLabl()
        if src_len < trg_len:
            add_s = '%s, %s == 1 ? "" : "s"' % (src_len, src_len)
            o.Raw('PyErr_Format(PyExc_ValueError, "need more than %d value%s to unpack", ', add_s, ');')
            o.Raw('goto ', labl, ';')
            UseLabl()
        return

    o_2 = Out() 
    o_2.Raw('PyErr_Format(PyExc_ValueError, "too many values to unpack");')
    o_2.Raw('goto ', labl, ';')
    tolabl = append_to_exception(o_2)          
    
    o.Raw('if (', src_len, ' > ', trg_len, ') goto ', tolabl, ';')
    UseLabl()

    o_2 = Out() 
    add_s = '%s, %s == 1 ? "" : "s"' % (CVar(src_len), CVar(src_len))
    o_2.Raw('PyErr_Format(PyExc_ValueError, "need more than %d value%s to unpack", ', add_s, ');')
    o_2.Raw('goto ', labl, ';')
    tolabl = append_to_exception(o_2)          
    
    o.Raw('if (', src_len, ' < ', trg_len, ') goto ', tolabl, ';')
    UseLabl()

def mass_store(o,ref,its,expr, t = None):
    assert type(o) is Out     
    if t is None:
        t = TypeExpr(expr)
    PushAcc([expr], [ref])
    src_len = New('int')
    trg_len = len([x for x in its if x is not None]) 
    if IsList(t):
        o.Raw(src_len, ' = PyList_GET_SIZE(', ref, ');')
        handle_unpack_except(o, src_len, trg_len)        
        for i,iit in enumerate(its):
            if iit is None: continue
            if iit[0] == 'STORE_FAST' and iit[1] in g_co.unused_fast_var: continue
            ref1 = ConC('PyList_GET_ITEM( ', ref, ', ', i, ' )')
            generate_store(iit,ref1,o, ('!PyList_GET_ITEM', expr, i))
    elif IsTuple(t): 
        if t[1] is None:        
            o.Stmt(src_len, '=', 'PyTuple_GET_SIZE', ref)
        elif type(t[1]) is int:
            o.Cls(src_len)
            src_len = t[1]  
        else:
            o.Cls(src_len)
            src_len = len(t[1])    
        handle_unpack_except(o, src_len, trg_len)        
        for i,iit in enumerate(its):
            if iit is None: continue
            if iit[0] == 'STORE_FAST' and iit[1] in g_co.unused_fast_var: continue
            ref1 = ConC('PyTuple_GET_ITEM( ', ref, ', ', i, ' )')
            generate_store(iit,ref1,o, ('!PyTuple_GET_ITEM', expr, i))
    else:        
        if t is not None:
            Debug('UNused type expr in mass store', t, expr)
        if (t is not None and t[0] == 'MayBe' and IsTuple(t[1])):
            o.Stmt('if (PyTuple_CheckExact(', ref, ') ) {')
        else:
            o.Stmt('if (PyList_CheckExact(', ref, ') ) {')
            o.Raw(src_len, ' = PyList_GET_SIZE(', ref, ');')
            handle_unpack_except(o, src_len, trg_len)        
            for i,iit in enumerate(its):
                if iit is None: continue
                if iit[0] == 'STORE_FAST' and iit[1] in g_co.unused_fast_var: continue
                ref1 = ConC('PyList_GET_ITEM( ', ref, ', ', i, ' )')
                generate_store(iit,ref1,o, ('!PyList_GET_ITEM', expr, i))
            o.Stmt('} else if (PyTuple_CheckExact(', ref, ') ) {')
        o.Raw(src_len, ' = PyTuple_GET_SIZE(', ref, ');')
        handle_unpack_except(o, src_len, trg_len)        
        for i,iit in enumerate(its):
            if iit is None: continue
            if iit[0] == 'STORE_FAST' and iit[1] in g_co.unused_fast_var: continue
            ref1 = ConC('PyTuple_GET_ITEM( ', ref, ', ', i, ' )')
            generate_store(iit,ref1,o, ('!PyTuple_GET_ITEM', expr, i))
        o.append('} else {')
        ref2 = New()
        o.Stmt(ref2, '=', 'PySequence_Tuple', ref)
        o.Raw(src_len, ' = PyTuple_GET_SIZE(', ref2, ');')
        handle_unpack_except(o, src_len, trg_len)        
        for i,iit in enumerate(its):
            if iit is None: continue
            if iit[0] == 'STORE_FAST' and iit[1] in g_co.unused_fast_var: continue
            ref1 = ConC('PyTuple_GET_ITEM( ', ref2, ', ', i, ' )')
            generate_store(iit,ref1,o, ('!PyTuple_GET_ITEM', expr, i))
        o.Cls(ref2)
        o.append('}')
    PopAcc(o)
    o.Cls(src_len, ref)
    return       
    
g_acc2 = []
g_refs2 = []
g_len_acc = []

def PopAcc(o, clear = True):
    assert type(o) is Out
    global g_acc2, g_refs2
    to_clear = []
    if clear:
        to_clear = g_refs2[g_len_acc[-1]:]
    del g_acc2[g_len_acc[-1]:]
    del g_refs2[g_len_acc[-1]:]
    del g_len_acc[-1]
    for g in to_clear:
        if istempref(g):
            o.Cls(g)    

def PushAcc(acc,refs):
    global g_acc2, g_refs2
    g_len_acc.append(len(g_acc2))
    g_acc2.extend(acc)
    g_refs2.extend(refs)
    
def PopClearAll(o):
    assert type(o) is Out
    global g_acc2, g_refs2, g_len_acc
    grefs = g_refs2[:]
    while len(grefs) > 0:
        r = grefs[-1]
        if istempref(r):
            o.CLEAR(r)
        del grefs[-1]

predeclared_chars = {}
def add_predeclaration_char_const(ind_const):
    global predeclared_chars
    predeclared_chars[ind_const] = True

def Obj2C(ref, t = None):
    if t is None:
        assert False
        ##t = TypeExpr(ref, False)
    if IsInt(t):
        return Int_AS_LONG(ref)
    if IsChar(t):
        return Str_AS_CHAR(ref)
    if IsBool(t):
        return Bool_AS_INT(ref)
    if IsFloat(t):
        return Float_AS_DOUBLE(ref)
    pp(ref, t)
    assert False

def Str_AS_CHAR(ref0):
    if ref0[0] == 'CONST':
        assert type(ref0[1]) is str
        assert len(ref0[1]) == 1
        r = Str_for_C(ref0[1])
        if r.startswith('"'):
            r = "'" + r[1:-1] + "'"
        return r
    return ConC('*PyString_AS_STRING ( ', ref0, ' )')    

def Int_AS_LONG(ref0):
    if ref0[0] == 'CONST':
        assert type(ref0[1]) is int
        return ConC(ref0[1])
    return ConC('PyInt_AS_LONG ( ', ref0, ' )')  

def Float_AS_DOUBLE(ref0):
    if ref0[0] == 'CONST':
        assert type(ref0[1]) is float
        return ConC(ref0[1])
    return ConC('PyFloat_AS_DOUBLE ( ', ref0, ' )')    

def Bool_AS_INT(ref0):
    if ref0[0] == 'CONST':
        assert type(ref0[1]) is bool or type(ref0[1]) is int
        if ref0[1]:
            return '1'
        else:
            return '0'
    return ConC('(', ref0, ' == Py_True)')    

def Str_AS_STRING(ref0):
    if ref0[0] == 'CONST':
        assert type(ref0[1]) is str
        ind_const = index_const_to(ref0[1])
        add_predeclaration_char_const(ind_const)
        return ConC('const_string_', ind_const)
    return ConC('PyString_AS_STRING ( ', ref0, ' )')    

def Str_GET_SIZE(ref0):
    if ref0[0] == 'CONST':
        assert type(ref0[1]) is str
        return ConC(len(ref0[1]))
    return ConC('PyString_GET_SIZE ( ', ref0, ' )')  

def is_mkfunc_const(proc, expr):
    if expr[0] in ('!MK_FUNK', '!_PyEval_BuildClass', '!MK_CLOSURE'):
        return True
    if len(proc) != 2:
        return False
    if not (type(proc[0]) is str):
        return False
    if proc[0] != 'CALC_CONST':
        return False
    if found_value_calc_const(proc[1]) and get_value_calc_const(proc[1])[0] in ('!MK_FUNK', '!_PyEval_BuildClass', '!MK_CLOSURE'):
            return True
    return False

def LikeExpr1(_it, o, skip_float = None):
    assert type(o) is Out
    if _it[0] == 'PY_TYPE':
        it = _it[3]
    else:
        it = _it
    if it[0] == '!BINARY_SUBSCR_Int':
        t = TypeExpr(it[1])
        d = {}
        if (IsListAll(t) or IsTuple(t)) and is_tuple_pack_arg(it, d):
            if check_index_BUILD_TUPLE(d, o):
                return get_tuple_pack_arg(it, d)
    if it[0] == '!PyObject_GetAttr' and is_tuple_pack_arg(it, {}):
        return get_tuple_pack_arg(it, {})
        
    return GenExpr(_it, o, None, None, skip_float)

def Expr1(it, o):
    assert type(o) is Out
    return GenExpr(it, o)

def Expr(o, it):
    assert type(o) is Out
    return [GenExpr(x, o) for x in it]
    
def Str_for_C(s):
    r = ''
    assert type(s) is str
    for c in s:
        if (c.isalnum() or c == ' ') and not (('a' <= c <= 'f') or ('A' <= c <= 'F') or ('0' <= c <= '9')):
            r  += c
        elif c == '\n':
            r += '\\n'
        elif c == '\r':
            r += '\\r'
        elif c == '\t':
            r += '\\t'
        else:
            h = hex(ord(c))
            assert h.startswith('0x')
            h = h[2:]
            if len(h) < 2:
                h = '0' + h
            r += '\\x' + h    
    return '"' + r + '"'            

def Char_for_C(s):
    assert type(s) is str
    r = ''
    assert len(s) == 1
    c = s[0]
    if c.isalnum() or c == ' ':
        r  = c
    elif c == '\n':
        r = '\\n'
    elif c == '\r':
        r = '\\r'
    elif c == '\t':
        r = '\\t'
    else:    
        h = hex(ord(c))
        assert h.startswith('0x')
        h = h[2:]
        if len(h) < 2:
            h = '0' + h
        r = '\\x' + h    
    return "'" + r + "'"   

def generate_SetAttr_slots(it, ref, o):
    li = []
    if it[2][1] in inverted_compiled_slots:
        li = inverted_compiled_slots[it[2][1]]
   
    ref1, ref2 = Expr(o, it[1:])
    
    li2 = Out()
    for k in li: 
        if len(li2) == 0:
            li2.Raw('if (((PyObject *)Py_TYPE(', ref1, ')) == ', ('CALC_CONST', k), ') {')
        else:    
            li2.Raw('} else if (((PyObject *)Py_TYPE(', ref1, ')) == ', ('CALC_CONST', k), ') {')
        li2.Raw('SETATTR(', k, ',', ref1, ',', it[2][1], ',', ref, ');')
        
    if len(li2) == 0:
        li2.Stmt('PyObject_SetAttr', ref1, ref2, ref)
    else:
        li2.Raw('} else {')
        li2.Stmt('PyObject_SetAttr', ref1, ref2, ref)
        li2.Raw('}')
    li2.Cls(ref, ref1, ref2)
    o.extend(li2)
    return 


def generate_SetAttr(it, ref, o):
    assert type(it) is tuple
    assert type(o) is Out     
    t = TypeExpr(it[1])
    remove_temporary_long_when_push_int_from_long(o)
    if len(compiled_slots) > 0 and it[2][0] == 'CONST' and not it[2][1].startswith('__'):
        if type(t) is tuple and t[0] in ('NewClassInstance', 'OldClassInstance') and is_GETATTR_compiled(t[1], it[2][1]):
                ref1, ref2 = Expr(o, it[1:])
                o.Raw('SETATTR(', t[1], ',', ref1, ',', it[2][1], ',', ref, ');')
                o.Cls(ref, ref1, ref2)
                return
        elif t is None:
            return generate_SetAttr_slots(it, ref, o)
        else:
            li = []
            for v in compiled_slots.itervalues():
                li.extend(list(v))
            if it[2][1] in li:
                pp('+NOTYPED NOGENERATED ', t, it[2][1], TypeExpr(it), it, ref)
    
    if len(detected_slots) == 0 and it[2][0] == 'CONST' and not it[2][1].startswith('__') and (it[1][0] == 'FAST' or (it[1][0] == 'PY_TYPE' and it[1][3][0] == 'FAST')) and not redefined_attribute:
        isattrs = IsAnyAttrInstance(it[2][1])
        ismeth = len (IterMethod(it[2][1], None)) > 0
        var = it[1]
        isinst = False
        if var[0] == 'PY_TYPE':
            isinst = var[1] == 'NewClassInstance' or var[1] == 'OldClassInstance'
            var = var[3]
        if not ismeth and isattrs and var[1] in g_co.d_varnames and \
            g_co.d_varnames[var[1]] < g_co.co_argcount:
            if ('STORE_FAST', var[1]) not in g_co.store_and_delete_and_fast and \
               ('DELETE_FAST', var[1]) not in g_co.store_and_delete_and_fast:                
            ## s1 = ('STORE_FAST', var[1])
            ## s2 = ('DELETE_FAST', var[1])
            ## srepr = repr(g_co.cmds[1])
            ## if not repr(s1) in srepr and not repr(s2) in srepr:
                if isinst:
                    o.Raw('if (PyDict_SetItem(_', var[1], '_dict, ', it[2], ', ', ref, ') == -1) goto ', labl, ';')
                    UseLabl()
                    g_co.dict_getattr_used[var[1]] = True
                    o.Cls(ref)
                    return
                o.Raw('if (_' + var[1] + '_dict) {')
                o.Raw('if (PyDict_SetItem(_', var[1], '_dict, ', it[2], ', ', ref, ') == -1) goto ', labl, ';')
                UseLabl()
                g_co.dict_getattr_used[var[1]] = True
                o.append('} else {')
                o.Stmt('PyObject_SetAttr', var, it[2], ref)
                o.append('}')
                o.Cls(ref)
                return
    if t is not None and t[0] == T_OLD_CL_INST and t[1] not in detected_slots:
        ismeth = len (IterMethod(it[2][1], None)) > 0
        if  not ismeth and it[2][0] == 'CONST' and IsAttrInstance(t[1], it[2][1]):
            ref1 = Expr1(it[1], o)
            o.Stmt('PyDict_SetItem', '((PyInstanceObject *)' + CVar(ref1) + ')->in_dict', it[2], ref)
            o.Cls(ref1, ref)
            return

    elif t is not None and t[0] == T_OLD_CL_INST and it[1][0] == 'CALC_CONST' and t[1] not in detected_slots:
        if it[2][0] == 'CONST' and IsAttrInstance(t[1], it[2][1]):
            if Is3(it[1][1], 'ModuleAttr', '.__dict__'):
                o.Stmt('PyDict_SetItem', calc_const_to((it[1][1], '.__dict__')), it[2], ref)
                o.Cls(ref)
                return
    elif t is not None and t[0] == T_NEW_CL_INST and t[1] not in detected_slots and it[1][0] == 'CALC_CONST' and not auto_slots:
        if it[2][0] == 'CONST' and IsAttrInstance(t[1], it[2][1]):
            if Is3(it[1][1], 'ModuleAttr', '.__dict__'):
                o.Stmt('PyDict_SetItem', calc_const_to((it[1][1], '.__dict__')), it[2], ref)
                o.Cls(ref)
                return
            r = Expr1(it[1], o)
            dic = New()
            o.Raw(dic, ' = *_PyObject_GetDictPtr(',r,');')
            o.INCREF(dic)
            o.Cls(r)
            o.Stmt('PyDict_SetItem', dic, it[2], ref)
            o.Cls(dic)
            o.Cls(ref)
            return
    ref1, ref2 = Expr(o, it[1:])
    o.Stmt('PyObject_SetAttr', ref1, ref2, ref)
    o.Cls(ref, ref1, ref2)
    return

def IsMethod(nmcl, nmslot):
    assert type(nmcl) is str and type(nmslot) is str
    for cl, slot, nmcode, isstaticmeth, isclassmeth, isderived in all_meth:
        if cl == nmcl and slot == nmslot:
            return True
    if nmslot[0] == '_':
        for cl, slot, nmcode, isstaticmeth, isclassmeth, isderived in all_meth:
            if nmcode is not None and cl == nmcl and slot == ('_' + cl + nmcode) and nmcode == nmslot:
                return True
    return False            


def IterMethod(nmslot, nmcode):
    li = []
    for a, b, c, isstaticmeth, isclassmeth, isderived in all_meth:
        if nmcode is not None and c != nmcode:
            continue
        if b == nmslot:
            li.append((a,b,c))
        elif nmslot[0] == '_' and b == '_' + a + c:
            li.append((a,b,c))

    return li


def ValMethod(nmcl, nmslot):
    assert type(nmcl) is str and type(nmslot) is str
    for cl, slot, nmcode, isstaticmeth, isclassmeth, isderived in all_meth:
        if cl == nmcl and slot == nmslot:
            return nmcode
    if nmslot[0] == '_':
        for cl, slot, nmcode, isstaticmeth, isclassmeth, isderived in all_meth:
            if cl == nmcl and slot == ('_' + cl + nmcode and nmcode == nmslot):
                return nmslot
            
    pp(nmcl, nmslot)
    assert False
    return None 

def ValMethod3(nmcl, nmslot):
    assert type(nmcl) is str and type(nmslot) is str
    list_meth = [(isstaticmeth, isclassmeth, nmcode, isderived) for cl, slot, nmcode, isstaticmeth, isclassmeth, isderived in all_meth if cl == nmcl and slot == nmslot]
    if len(list_meth) > 1:
        list_meth = list(set(list_meth))
    if len(list_meth) > 1:
        list_meth = [(isstaticmeth, isclassmeth, nmcode, isderived) for isstaticmeth, isclassmeth, nmcode, isderived in list_meth if isderived == False]
        list_meth = list(set(list_meth))
        assert len(list_meth) == 1 
    assert len(list_meth) <= 1
    if len(list_meth) == 1:
        return list_meth[0][:3]
    if nmslot[0] == '_':
        for cl, slot, nmcode, isstaticmeth, isclassmeth, isderived in all_meth:
            if cl == nmcl and slot == ('_' + cl + nmcode and nmcode == nmslot):
                return isstaticmeth, isclassmeth, nmslot
            
    pp(nmcl, nmslot)
    assert False
    return None 


def CodeInit(nmcl):
    assert type(nmcl) is str 
    for cl, slot, nmcode, isstaticmeth, isclassmeth, isderived in all_meth:
        if cl == nmcl and slot == '__init__':
            return nmcode
    return None 
    
attr_instance = {}

def SetAttrInstance(nmcl, nmattr):
    attr_instance[(nmcl, nmattr)] = True    
    
def IsFatherAttrInstance(nmcl, nmslot):
    for a,c in all_derived.keys(): #Iter3(nmcl, 'Derived', None):
        if a != nmcl:
            continue
        if c[0] == '!CALC_CONST':
            if IsAttrInstance(c[1], nmslot):
                return True
    return False

def IsAttrInstance(nmcl, nmslot):
    assert type(nmslot) is str
    if (nmcl, nmslot) in attr_instance and not nmslot.startswith('__'):
        return True
    elif nmcl is not None and nmslot[0] == '_' and (nmcl, '_' + nmcl + nmslot) in attr_instance:
        return True
    if IsFatherAttrInstance(nmcl, nmslot):
        return True
    return False

def IsAnyAttrInstance(nmslot):
    assert type(nmslot) is str
    for k in attr_instance.iterkeys():
        a,c = k
        if c == nmslot and not nmslot.startswith('__'):
            return True
        elif nmslot[0] == '_' and c == '_' + a + nmslot:
            return True
    return False
    
def generate_GetAttr(it,o, forcenewg):
    assert type(it) is tuple
    assert type(o) is Out     
    t = TypeExpr(it[1])
    ## if len(compiled_slots) > 0 and it[2][0] == 'CONST' and not it[2][1].startswith('__'):
        ## if it[2][1] in inverted_compiled_slots:
            ## pp('NOTYPED NOGENERATED ', t, it[2][1], TypeExpr(it))
            ## pprint(compiled_slots)
            

    if len(detected_slots) == 0 and it[2][0] == 'CONST' and not it[2][1].startswith('__') and not redefined_attribute:
        ismeth = len (IterMethod(it[2][1], None)) > 0
        if it[1][0] == 'FAST' or (it[1][0] == 'PY_TYPE' and it[1][3][0] == 'FAST'):
            right_obj = False
            if type(t) is tuple and t[0] in ('NewClassInstance', 'OldClassInstance'):
                right_obj = True
            if it[1][0] == 'FAST':
                nmvar = it[1][1]
            else:    
                nmvar = it[1][3][1]
            isattrs = IsAnyAttrInstance(it[2][1])
            if not ismeth and isattrs and nmvar in g_co.d_varnames and \
               len([True for i, nm in enumerate(g_co.co_varnames) \
                  if i < g_co.co_argcount and nm == nmvar]) > 0:
                if ('STORE_FAST', nmvar) not in g_co.store_and_delete_and_fast and \
                   ('DELETE_FAST', nmvar) not in g_co.store_and_delete_and_fast:
                    if right_obj:
                        ref = New(None, forcenewg)
                        o.Raw(ref, ' = PyDict_GetItem(_', nmvar, '_dict, ', it[2], ');')
                        o.INCREF(ref)
                        g_co.dict_getattr_used[nmvar] = True
                        return ref
                    ref = New(None, forcenewg)
                    o.Raw('if (_' + nmvar + '_dict && (',ref, ' = PyDict_GetItem(_', nmvar, '_dict, ', it[2], ')) != 0) {')
                    o.INCREF(ref)
                    g_co.dict_getattr_used[nmvar] = True
                    o.append('} else {')
                    o.Stmt(ref, '=', 'PyObject_GetAttr', it[1], it[2])
                    o.append('}')
                    return ref
        if not ismeth and t is not None and t[0] != 'MayBe' and t[0] in (T_OLD_CL_INST, T_NEW_CL_INST) and \
           IsAttrInstance(t[1], it[2][1]):
            if t[0] == T_OLD_CL_INST  and t[1] not in detected_slots:
                if it[1][0] == 'CALC_CONST':
                    if Is3(it[1][1], 'ModuleAttr', '.__dict__'):
                        ref = New(None, forcenewg)
                        o.Stmt(ref, '=', 'PyDict_GetItem', calc_const_to((it[1][1], '.__dict__')), it[2])
                        return ref
                r = Expr1(it[1], o)
                ref = New(None, forcenewg)
                o.Stmt(ref, '=', 'PyDict_GetItem', '((PyInstanceObject *)' + CVar(r) + ')->in_dict', it[2])
                o.Cls(r)
                return ref
            elif t[0] == T_NEW_CL_INST  and t[1] not in detected_slots and not auto_slots:
                if it[1][0] == 'CALC_CONST':
                    if Is3(it[1][1], 'ModuleAttr', '.__dict__'):
                        ref = New(None, forcenewg)
                        o.Stmt(ref, '=', 'PyDict_GetItem', calc_const_to((it[1][1], '.__dict__')), it[2])
                        return ref
                r = Expr1(it[1], o)
                dic = dic = ConC('*_PyObject_GetDictPtr(',r,')')
                ref = New(None, forcenewg)
                o.Stmt(ref, '=', 'PyDict_GetItem', dic, it[2])
                o.Cls(r)
                return ref
        elif t is not None and t[0] is types.ModuleType:
            if t[1] is not None and ModuleHaveAttr(t[1], it[2][1]):
                r = Expr1(it[1], o)
                ref = New(None, forcenewg)
                o.Raw('if ((', ref, ' = PyDict_GetItem(PyModule_GetDict(' + CVar(r) + '), ', it[2], ')) == 0) goto ', labl, ';')
                o.INCREF(ref)
                o.Cls(r)
                UseLabl()
                return ref
    if t is not None:
        Debug('Non-Generic GetAttr type', t, it[2], it[1], g_co.co_name)
    if it[2][1] == '?':
        Fatal('', it)    
        assert False
    Debug('Standard Getattr', it)
    ref,attr = [Expr1(x, o) if type(x) is tuple and len(x) > 0 else x \
              for i,x in enumerate(it) if i > 0]
    newg = New(None, forcenewg)  
    o.Stmt(newg, '=', 'PyObject_GetAttr', ref, attr)
    o.Cls(ref,attr)
    return newg   
    
def verif(it):
        if it[0] in ('!MK_FUNK', '!CALL_CALC_CONST', '!STR_CONCAT', '!STR_CONCAT3', '!STR_CONCAT2', '!STR_CONCAT_N', \
                     '!CLASS_CALC_CONST_NEW', '!CLASS_CALC_CONST', '!IMPORT_NAME', '!PyObject_Call', '!PyDict_GetItem',\
                     '!PyInt_Type.tp_str', '!PyCFunction_Call', '!_PyEval_BuildClass',\
                     '!PyDict_Items', '!PyDict_Keys', '!PyList_AsTuple', '!PyString_Format',\
                     '!_PyList_Extend', '!PyDict_Copy', '!PyDict_Values'):
            return    
        typs = tuple([TypeExpr(x) if type(x) is tuple and len(x) > 0 else None for i,x in enumerate(it) if i > 0])
        typs2 = [x for x in typs if x is not None]
        if it[0] == '!c_LOAD_NAME' and typs == (None, Kl_String):
            return
        if it[0] == '!PyNumber_Add' and IsTuple(typs[0]) and IsSequence(typs[1]):
            return
        if len(typs2) > 0:
            Debug('Concret type operation %s %s -- %s' % (it[0], tuple(typs), it))  
 
def check_GenExpr_warn(it, forcenewg):
    _v = []
    if forcenewg is not None and it[0] in tags_one_step_expr:
        Debug('Copy unhandled', forcenewg, '=', it)
    if TCmp(it, _v, ('!PyObject_Call', ('!PyObject_GetAttr', '?', ('CONST', '?')), '?', '?')):
        t = TypeExpr(_v[0])
        if t is not None and _v[3] == ('NULL',):
            if t not in _Kl_Simples and type(t[1]) is str:
                if IsAnyClass(t[1]) and not Is3(t[1], ('Attribute', _v[1])):
                    if IsAttrInstance(t[1], _v[1]):       
                        pass
                    elif not IsMethod(t[1], _v[1]):       
                        Debug( 'Call UNKNOWN method known classes: %s -> %s' % (t, _v[1]),it)
                    else:
                        HideDebug( 'Call method known classes: %s -> %s' % (t, _v[1]),it)
    if type(it) is tuple and len(it) == 3 and type(it[0]) is str and \
        type(it[1]) is tuple and len(it[1]) >= 1 and it[1][0] == 'CONST' and \
        type(it[2]) is tuple and len(it[2]) >= 1 and it[2][0] == 'CONST':
        if it[2] != ('CONST', 'join'):    
            Debug('Constant binary operation unhandled', it)
    if type(it) is tuple and len(it) == 2 and type(it[0]) is str and it[0] != 'CONST' and\
        type(it[1]) is tuple and len(it[1]) >= 1 and it[1][0] == 'CONST':            
        Debug('Constant unary operation unhandled', it)
    if type(it) is tuple and len(it) > 1 and it[0] != 'CONST' and type(it[0]) is str:  
        if type(it[1]) is tuple and len(it[1]) > 1 and type(it[1][0]) is str and IsCVar(it[1]):    
            Debug('Operation of typed var', it)
        if len(it) > 2 and  type(it[2]) is tuple and len(it[2]) > 1 and type(it[2][0]) is str and IsCVar(it[2]):    
            Debug('Operation of typed var', it)
            
def check_index_BUILD_TUPLE(d, o):
    assert type(o) is Out
    o2 = Out()
##    ret = None
    if len(d) > 0:

        for k1 in d.keys():
            assert type(k1) is tuple and len(k1) == 2
            if k1[1][0] == '!BINARY_SUBSCR_Int':
                get_tuple_pack_arg(k1[1], d)

        li = d.items()
        li = [(len(repr(k)), k, v) for k,v in li]
        li.sort()
        li = [(k, v) for l, k,v in li]
        
        for k1,v in li:
            assert type(k1) is tuple and len(k1) == 2
            ty, k = k1
            if k[0] == '!BINARY_SUBSCR_Int':
                k = get_tuple_pack_arg(k, d)
                if k is None:
                    return False
            if k[0] == '!PyObject_GetAttr':
                k = get_tuple_pack_arg(k, d)
                if k is None:
                    return False
            if ty is tuple:
                ErrHandler(o2, 'PyErr_SetString(PyExc_IndexError, "tuple index out of range");', ConC('PyTuple_GET_SIZE( ', k, ' ) < ', v+1))
            elif ty is list:
                ErrHandler(o2, 'PyErr_SetString(PyExc_IndexError, "list index out of range");', ConC('PyList_GET_SIZE( ', k, ' ) < ', v+1))
    if len(o2) < len(o) and len(o2) > 0 and o2 == o[-len(o2):]:
        return True
    o.extend(o2)
    return True

def true_attempt_direct(it):
    if it[0] in set_not_attempt:
        return False
    if it[0] == 'PY_TYPE' and it[3][0] in set_not_attempt:
        return False
    return True

def GenExpr(it,o, forcenewg=None,typed=None, skip_float = None):
    global _n2c, g_acc2, g_refs2
    assert type(o) is Out 
    
    if not hide_debug:
        check_GenExpr_warn(it, forcenewg)
    for x in g_acc2:        
        if it == x:
            if it[0] == 'CONST' and type(x[1]) != type(it[1]):
                continue
            ind = g_acc2.index(it)
            assert forcenewg is None or forcenewg == g_refs2[ind]
            if forcenewg is None or forcenewg == g_refs2[ind]:
                return g_refs2[ind]    
    if type(it) is int or istempref(it):
        return it
    assert type(it) is tuple
    head = it[0]
    assert type(head) is str
 
    if true_attempt_direct(it): # and TypeExpr(it) is not None:
        ## pprint(o)
        ## pprint(it)
        ref = attempt_direct_type_generation(it, o, forcenewg)
        if ref is not None:
            return ref
    if head == 'PY_TYPE':
        if it[3][0] == 'PY_TYPE':
            if it[0:3] == it[3][0:3]:
                it = it[3]
        if it[3][0] == 'PY_TYPE':
            pprint(g_co)
            pprint(it)
        assert it[3][0] != 'PY_TYPE'
      
        if typed is not None:
            Debug(typed, it[4], it)
            assert typed == it[4]
        if typed is None and it[4] is not None:
            Debug('Unhandled C-type', it)   
        if it[1] is float:    
            return GenExpr(it[3],o,forcenewg, typed, False)
        else:
            return GenExpr(it[3],o,forcenewg, typed, True)

    assert isinstance(head, types.StringTypes) ##or type(head) is int
    tempor = False    

    if head == 'FAST':
        pos = g_co.d_varnames[it[1]]
        typed_arg = g_co.typed_arg_direct
        if pos in typed_arg and is_current & IS_DIRECT:
            t = typed_arg[pos]
            if IsCType(t):
                cnm = CVarName(it)
                ref2 = New(None,forcenewg)
                CType2Py(o, ref2, cnm, t)
                return ref2    
        if it[1] in g_co.detected_type:
            t = g_co.detected_type[it[1]]
            if IsCType(t):
                cnm = CVarName(it)
                ref2 = New(None,forcenewg)
                CType2Py(o, ref2, cnm, t)
                return ref2    
    if head == 'CALC_CONST' and it[1] not in d_built and (it[1][0] != '_' or build_executable) and not redefined_all and \
       fast_globals and not global_used_at_generator(it[1]):
        if IsCTypedGlobal(it[1]):
            t = TypeGlobal(it[1])
            cnm = CVarName(it)
            ref2 = New(None,forcenewg)
            CType2Py(o, ref2, cnm, t)
            return ref2 
    if head == 'CALC_CONST' and it[1] not in d_built and (it[1][0] != '_' or build_executable) and not redefined_all and \
        not global_used_at_generator(it[1]):
            if type(it[1]) is str and not it[1].startswith('.'):
                o_2 = Out() 
                o_2.Raw('PyErr_Format(PyExc_NameError, GLOBAL_NAME_ERROR_MSG, ', '"%s"' % it[1], ');')
                o_2.Raw('goto ', labl, ';')
                tolabl = append_to_exception(o_2)            
                
                o.Raw('if (', it, ' == 0) goto ', tolabl, ';')
                UseLabl()
            return it

    if head == 'CALC_CONST' and type(it[1]) is tuple and it[1] not in d_built and global_used_at_generator(it[1]):
        return GenExpr(('!PyObject_GetAttr', ('CALC_CONST', it[1][0]), ('CONST', it[1][1])),o, forcenewg)

    if head == 'CALC_CONST' and type(it[1]) is not tuple and it[1] not in d_built and global_used_at_generator(it[1]):
        return GenExpr(('!LOAD_GLOBAL', it[1]),o, forcenewg)
    
    if head[0] == '!':
        tempor = True
        head = head[1:]
    elif head[0] == '=':
        head = 'INPLACE_' + head[1:]
        tempor = True  
    assert type(head) is str
    if not tempor:
        if len(it) > 1:
            if head not in tags_one_step_expr:
                Fatal('', it, len(it))
                assert False
            assert head in tags_one_step_expr
        return it  
     
    if tempor and head == 'LOAD_NAME' and func == 'Init_filename':
        return GenExpr(('!LOAD_GLOBAL', it[1]),o, forcenewg)
    if tempor and head == 'LOAD_NAME':
        if is_current & IS_DICTIONABLE_CFUNC:
            return GenExpr(('!c_LOAD_NAME', '_f_locals', ('CONST', it[1])),o, forcenewg)
        else:
            return GenExpr(('!c_LOAD_NAME', 'f->f_locals', ('CONST', it[1])),o, forcenewg)
    if head == 'LOAD_GLOBAL' and it == ('!LOAD_GLOBAL', g_co.default_args_nm()):
        return it
    if tempor and head == 'LOAD_GLOBAL' and it[1] not in d_built and (it[1][0] != '_' or build_executable) and not redefined_all:
        if fast_globals and not global_used_at_generator(it[1]):
            if IsCTypedGlobal(it[1]):
                t = TypeGlobal(it[1])
                cnm = CVarName(it)
                ref2 = New(None,forcenewg)
                CType2Py(o, ref2, cnm, t)
                return ref2    
            return it
        ref = New(None, forcenewg)
        
        o_2 = Out() 
        o_2.Raw('PyErr_Format(PyExc_NameError, GLOBAL_NAME_ERROR_MSG, ', '"%s"' % it[1], ');')
        o_2.Raw('goto ', labl, ';')
        tolabl = append_to_exception(o_2)            
        
        o.Raw('if ((', ref, ' = PyDict_GetItem( glob, ', ('CONST', it[1]), ')) == 0) goto ', tolabl, ';')
        UseLabl()
        o.INCREF(ref)
        return ref

    if tempor and head == 'LOAD_GLOBAL':
        return GenExpr(('!c_LOAD_GLOBAL', ('CONST', it[1]), hash(it[1])),o, forcenewg)
    if head == 'LOAD_BUILTIN':
        return ('BUILTIN', it[1])
    if head in ('OR_JUMPED_STACKED', 'AND_JUMPED_STACKED'):
        ref = forcenewg
        if ref is None:
            ref = New()
        return generate_and_or_jumped_stacked(it[1:], o, ref, head == 'AND_JUMPED_STACKED', 0)
    if head in ('AND_BOOLEAN', 'OR_BOOLEAN'):
        o1, logic = generate_logical_expr(it) 
        o.extend(o1)
        return logic

    if head in ('AND_JUMP', 'OR_JUMP'):
        o1,logic = shortage(generate_logical_expr(it))
        o.extend(o1)
        ref = New(None, forcenewg)
        o.Stmt(ref, '=','PyBool_FromLong', logic)
        o.Cls(logic)
        return ref
    if (head == 'PyObject_RichCompare(' or head == 'PyObject_RichCompare' ) and IsBool(TypeExpr(it)):
        o1,logic = shortage(generate_logical_expr(it))
        o.extend(o1)
        ref = New(None, forcenewg)
        o.Stmt(ref, '=','PyBool_FromLong', logic)
        o.Cls(logic)
        return ref
        
    if head == 'PyList_GetSlice':
        ref1 = Expr1(it[1], o)
        if it[2] < 0:
            it1 = New('long')
            o.Raw(it1, ' = PyList_GET_SIZE( ', ref1, ' ) - ', abs (it[2]), ';')
            o.Raw('if (', it1, ' < 0) { ', it1, ' = 0; }')
        else:
            it1 = it[2]
        if it[3] < 0:
            it2 = New('long')
            o.Raw(it2, ' = PyList_GET_SIZE( ', ref1, ' ) - ', abs (it[3]), ';')
            o.Raw('if (', it2, ' < 0) { ', it2, ' = 0; }')
        else:
            it2 = it[3]
        ref = New(None, forcenewg)
        o.Raw('if ((', ref, ' = PyList_GetSlice( ', ref1, ' , ', it1, ' , ', it2, ' )) == 0) goto ', labl, ';')
        UseLabl()
        o.Cls(ref1, it1, it2)
        return ref
    
    if head == 'PyTuple_GetSlice':
        ref1 = Expr1(it[1], o)
        if it[2] < 0:
            it1 = New('long')
            o.Raw(it1, ' = PyTuple_GET_SIZE( ', ref1, ' ) - ', abs (it[2]), ';')
            o.Raw('if (', it1, ' < 0) { ', it1, ' = 0; }')
        else:
            it1 = it[2]
        if it[3] < 0:
            it2 = New('long')
            o.Raw(it2, ' = PyTuple_GET_SIZE( ', ref1, ' ) - ', abs (it[3]), ';')
            o.Raw('if (', it2, ' < 0) { ', it2, ' = 0; }')
        else:
            it2 = it[3]
        ref = New(None, forcenewg)
        o.Raw('if ((', ref, ' = PyTuple_GetSlice( ', ref1, ' , ', it1, ' , ', it2, ' )) == 0) goto ', labl, ';')
        UseLabl()
        o.Cls(ref1, it1, it2)
        return ref
    
    if head == 'COND_METH_EXPR':
        return generate_cond_meth_expr_new(it, o, forcenewg, False)
    if head == 'BUILD_TUPLE':
        d = {}
        if False:
            li = []
            repeat_expr = {}
            for x in it[1]:  
                g = Expr1(x, o)
                if not istempref(g):
                    li.append(g)
                elif g in g_refs2:
                    if g in repeat_expr:
                        Fatal('Repeated expr', it, repeat_expr, g)
                        assert False
                    gg = New()
                    o.Raw(gg, ' = ', g, ';')   
                    li.append(gg)    
                    repeat_expr[gg] = True   
                else:    
                    remove_temporary_long_when_push_int_from_long(o)
                    li.append(g)
            newg = New(None,forcenewg)  
            s = ConC('if ((', newg, ' = PyTuple_Pack ( ', len(li))
            for g in li:
                s += ConC(' , ', g)
            s += ConC(' )) == 0) goto ', labl, ';')
            o.append(s)
            UseLabl()
            for g in li:
                o.Cls(g)
        elif all([is_tuple_pack_arg(x, d) or x[0] == '!BUILD_TUPLE' for x in it[1]]) and len(it[1]) > 0:
            li = []
            repeat_expr = {}
            if not check_index_BUILD_TUPLE(d, o):
                [pprint(x) for x in it[1]]
                pprint(d)
                assert False
            for x in it[1]:  
                if x[0] == '!BUILD_TUPLE':
                    g = Expr1(x, o)
                else:
                    g = get_tuple_pack_arg(x, d)
                li.append(g)
            newg = New(None,forcenewg)  
            s = ConC('if ((', newg, ' = PyTuple_Pack ( ', len(li))
            for g in li:
                s += ConC(' , ', g)
            s += ConC(' )) == 0) goto ', labl, ';')
            o.append(s)
            UseLabl()
            for g in li:
                o.Cls(g)            
        else:
            li = []
            repeat_expr = {}
            for x in it[1]:  
                g = Expr1(x, o)
                if not istempref(g):
                    o.INCREF(g) 
                    li.append(g)
                elif g in g_refs2:
                    if g in repeat_expr:
                        Fatal('Repeated expr', it, repeat_expr, g)
                        assert False
                    gg = New()
                    o.Raw(gg, ' = ', g, ';')   
                    o.INCREF(gg) 
                    li.append(gg)    
                    repeat_expr[gg] = True   
                else:    
                    remove_temporary_long_when_push_int_from_long(o)
                    li.append(g)
            newg = New(None,forcenewg)  
            o.Stmt(newg,'=', 'PyTuple_New', len(it[1]))
            for i,g in enumerate(li):
                o.Stmt('PyTuple_SET_ITEM', newg, i, g)
                if g not in g_refs2:
                    o.ZeroTemp(g)  
                o.ClsFict(g)
        return newg
    if head == 'GET_ITER':
        ref = Expr1(it[1], o)
        ref2 = New(None,forcenewg)
        o.Stmt(ref2, '=', 'PyObject_GetIter', ref)
        o.Cls(ref)
        return ref2
 
    if head == 'PySequence_Repeat':
    #### Trouble at count < 0 
        if IsList(TypeExpr(it[1])) and it[1][0] == '!BUILD_LIST':
            Debug('Repeat list n', it[1], it[2])
               
        if it[1][0] == 'CONST' and type(it[1][1]) is str and len(it[1][1]) == 1 and IsInt(TypeExpr(it[2])):
            if it[2][0] == 'CONST' and it[2][1] <= 0:
                ref2 = New(None,forcenewg)
                o.Stmt(ref2, '=', 'PyString_FromStringAndSize', 'NULL', 0)
                return ref2
            elif it[2][0] == 'CONST' and it[2][1] > 0:
                n2 = it[2][1]   
                ref2 = New(None,forcenewg)
                o.Stmt(ref2, '=', 'PyString_FromStringAndSize', 'NULL', n2)
                o.Raw('memset( PyString_AS_STRING( ', ref2, ' ), (unsigned char)', str(ord(it[1][1])), ', ', n2, ' );')

                ## cref = New('charref')
                ## o.Raw(cref, ' = ', Str_AS_STRING(ref2), ';')
                ## n1 = New('Py_ssize_t')
                ## o.Raw('for (', n1, ' = 0; ', n1, ' < ', n2, '; ', n1, '++){')
                ## o.Raw(cref, '[', n1, '] = (unsigned char)', str(ord(it[1][1])), ';')
                ## o.append('}')
                ## o.Cls(n1, cref)
                return ref2
            else:
                if it[2][0] == 'CONST':
                    n2 = it[2][1]
                else:   
                    n2 = New('Py_ssize_t')
                    n = Expr1(it[2], o)
                    o.Raw(n2, ' = PyInt_AS_LONG ( ', n,' );')
                    o.Cls(n)
                ref2 = New(None,forcenewg)
                o.Raw('if (', n2, ' <= 0) {')
                o.Stmt(ref2, '=', 'PyString_FromStringAndSize', 'NULL', 0)
                o.append('} else {')    
                o.Stmt(ref2, '=', 'PyString_FromStringAndSize', 'NULL', n2)
                o.Raw('memset( PyString_AS_STRING( ', ref2, ' ), (unsigned char)', str(ord(it[1][1])), ', ', n2, ' );')

                ## cref = New('charref')
                ## o.Raw(cref, ' = ', Str_AS_STRING(ref2), ';')
                ## n1 = New('Py_ssize_t')
                ## o.Raw('for (', n1, ' = 0; ', n1, ' < ', n2, '; ', n1, '++){')
                ## o.Raw(cref, '[', n1, '] = (unsigned char)', str(ord(it[1][1])), ';')
                ## o.append('}')
                o.Cls(n2)
                o.append('}')    
                return ref2
        if IsInt(TypeExpr(it[2])):       
            ref = Expr1(it[1], o)
            if it[2][0] == 'CONST':
                n2 = it[2][1]
            else:   
                n = Expr1(it[2], o)
                n2 = New('Py_ssize_t')
                o.Raw(n2, ' = PyInt_AS_LONG ( ', n,' );')
                o.Cls(n)
            ref2 = New(None,forcenewg)
            o.Stmt(ref2, '=', 'PySequence_Repeat', ref, n2)
            o.Cls(ref)
            o.Cls(n2)
            return ref2
        verif(it)
        ref1 = Expr1(it[1], o)
        ref2 = Expr1(it[2], o)

        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
        o.Stmt(new, '=', 'PyNumber_Multiply', ref1, ref2)
        o.Cls(ref1, ref2)
        return new
        
    if head == 'PySequence_GetSlice' and IsStr(TypeExpr(it[1])):
        if type(it[2]) is int and it[3] == 'PY_SSIZE_T_MAX' and it[2] >= 0:
            ref1 = Expr1(it[1], o)
            ref = New(None,forcenewg)
            o.Raw('if (PyString_GET_SIZE(', ref1,') > ', it[2], ') {')
            o.Raw(ref, ' = PyString_FromStringAndSize( ', Str_AS_STRING(ref1), ' + ', it[2], ' , ', Str_GET_SIZE(ref1), ' - ', it[2], ');')
            o.append('} else {')
            o.Raw(ref, ' = PyString_FromStringAndSize( \"\" , 0);')
            o.append('}')
            o.Cls(ref1)
            return ref
        if type(it[2]) is int and type(it[3]) is int and it[2] >= 0 and it[3] >= 0 and it[3] >= it[2]:
            ref1 = Expr1(it[1], o)
            ref = New(None,forcenewg)
            size_ref1 = Str_GET_SIZE(ref1)
            o.Raw('if (', size_ref1, ' > ', it[2], ') {')
            _dlt = it[3] - it[2]
            _intlen = New('long')
            if it[2] != 0:
                o.Raw(_intlen, ' = ', size_ref1, ' - ', it[2], ';')
            else:
                o.Raw(_intlen, ' = ', size_ref1, ';')
            o.Raw('if (', _intlen, ' > ', _dlt, ') ', _intlen, ' = ', _dlt, ';')
            if it[2] != 0:
                o.Raw(ref, ' = PyString_FromStringAndSize( ', Str_AS_STRING(ref1), ' + ', it[2], ' , ', _intlen, ');')
            else:
                o.Raw(ref, ' = PyString_FromStringAndSize( ', Str_AS_STRING(ref1), ' , ', _intlen, ');')
            o.append('} else {')
            o.Raw(ref, ' = PyString_FromStringAndSize( \"\" , 0);')
            o.append('}')
            o.Cls(ref1)
            o.Cls(_intlen)
            return ref        
        if type(it[2]) is int and type(it[3]) is int and it[2] >= 0 and it[3] < 0 :
            ref1 = Expr1(it[1], o)
            ref = New(None,forcenewg)
            o.Raw('if (PyString_GET_SIZE(', ref1,') > ', it[2] - it[3], ') {')
            o.Raw(ref, ' = PyString_FromStringAndSize( ', Str_AS_STRING(ref1), ' + ', it[2], ' , ', Str_GET_SIZE(ref1), ' - ', it[2] - it[3], ');')
            o.append('} else {')
            o.Raw(ref, ' = PyString_FromStringAndSize( \"\" , 0);')
            o.append('}')
            o.Cls(ref1)
            return ref  
        Debug('Typed GetSlice of string', it)        
        
    if head == 'BUILD_LIST':
      li = []
      repeat_expr = {}
      for x in it[1]:  
         g = Expr1(x, o)
         if not istempref(g):
             o.INCREF(g) 
             li.append(g)
         elif g in g_refs2:
             if g in repeat_expr:
                Fatal('Repeated expr', it, repeat_expr, g)
                assert False
             gg = New()
             o.Raw(gg, ' = ', g, ';')   
             o.INCREF(gg) 
             li.append(gg)    
             repeat_expr[gg] = True   
         else:    
             remove_temporary_long_when_push_int_from_long(o)
             li.append(g) 
      newg = New(None,forcenewg)  
      o.Stmt(newg,'=', 'PyList_New', len(it[1]))
      for i,g in enumerate(li):
         o.Stmt('PyList_SET_ITEM', newg, i, g)
         if g not in g_refs2:
            o.ZeroTemp(g)  
         o.ClsFict(g)
      return newg

    if head == 'IMPORT_NAME':
        return generate_import_name(it, o)
    
    if head == 'BUILD_SET':
      ret = New(None, forcenewg)  
      o.Stmt(ret, '=', 'PySet_New', 'NULL') 
      for v in it[1]:
          v = Expr1(v, o)
          o.Stmt('PySet_Add', ret, v)
          o.Cls(v)
      return ret    
        
    if head == 'BUILD_MAP':
      ret = New(None, forcenewg)  
      if len(it[1]) > 5:
        o.Stmt(ret,'=', '_PyDict_NewPresized', len(it[1])) 
      else:
        o.Stmt(ret,'=', 'PyDict_New') 
      for k, v in it[1]:
          k = Expr1(k, o)
          v = Expr1(v, o)
          o.Stmt('PyDict_SetItem', ret, k, v)
          o.Cls(k, v)
      return ret
    if head == 'MK_CLOSURE':
        assert len(it) == 4
        co = _n2c[it[1]]
        assert type(co) is code_extended
        if not co.can_be_codefunc(): ## co.co_flags & CO_GENERATOR:
            ref1 = New(None, forcenewg)
            o.Stmt(ref1, '=', 'PyFunction_New', const_to(co), 'glob')
            ref2 = Expr1(it[2], o)
            o.Stmt('PyFunction_SetClosure', ref1, ref2)
            o.Cls(ref2)
            if it[3][0] == 'CONST' and type(it[3][1]) is tuple:
                if len(it[3][1]) > 0:
                    o.Stmt('PyFunction_SetDefaults', ref1, it[3])
                return ref1
            if it[3][0] == '!BUILD_TUPLE' and type(it[3][1]) is tuple:
                ref2 = Expr1(it[3], o)
                o.Stmt('PyFunction_SetDefaults', ref1, ref2)
                o.Cls(ref2)
                return ref1
            Fatal('GenExpr', it)
            assert False

        ref1 = New(None, forcenewg)
        o.Stmt(ref1, '=', 'Py2CFunction_New', const_to( _n2c[it[1]]))
        ref2 = Expr1(it[2], o)
        o.Stmt('Py2CFunction_SetClosure', ref1, ref2)
        o.Cls(ref2)
        if it[3][0] == 'CONST' and type(it[3][1]) is tuple:
            if len(it[3][1]) > 0:
                o.Stmt('Py2CFunction_SetDefaults', ref1, it[3])
            return ref1
        if it[3][0] == '!BUILD_TUPLE' and type(it[3][1]) is tuple:
            ref2 = Expr1(it[3], o)
            o.Stmt('Py2CFunction_SetDefaults', ref1, ref2)
            o.Cls(ref2)
            return ref1
        Fatal('GenExpr', it)
        assert False
    if head == 'LOAD_CLOSURE':
        return ('LOAD_CLOSURE', it[1])    
    if head == 'LOAD_DEREF':
        return GenExpr(('!PyCell_Get',('LOAD_CLOSURE', it[1])), o, forcenewg, typed)
    if head == 'MK_FUNK':
        co = _n2c[it[1]]
        assert type(co) is code_extended
        if not co.can_C():
            if len(it) == 3 and it[2][0] == 'CONST' and type(it[2][1]) is tuple:
                ref1 = New(None, forcenewg)
                if len(it[2][1]) > 0: # or len(co.co_cellvars + co.co_freevars) != 0:
                    o.Stmt(ref1, '=', 'PyFunction_New', const_to(co), 'glob')
                    o.Stmt('PyFunction_SetDefaults', ref1, it[2])
                else:
                    o.Stmt(ref1, '=', 'PyFunction_New', const_to( co), 'glob')
                        
                return ref1
            if len(it) == 3 and it[2][0] == '!BUILD_TUPLE' and type(it[2][1]) is tuple:
                ref1 = New(None, forcenewg)
                o.Stmt(ref1, '=', 'PyFunction_New', const_to(co), 'glob')
                ref2 = Expr1(it[2], o)
                o.Stmt('PyFunction_SetDefaults', ref1, ref2)
                if co.direct_cmds is not None:
                    nmdefault = co.default_args_nm() 
                    add_fast_glob(nmdefault)
                    o.INCREF(ref2)
                    o.Stmt('SETSTATIC', nmdefault, ref2)                
                o.Cls(ref2)
                return ref1
            Fatal('GenExpr', it)
            assert False
            return None
        if co.can_be_cfunc():
            if len(it) == 3 and it[2][0] == '!BUILD_TUPLE' and type(it[2][1]) is tuple and len(it[2][1]) > 0:
                ref = Expr1(it[2], o)
                if not istempref(ref):
                    o.INCREF(ref)
                nmdefault = co.default_args_nm() 
                add_fast_glob(nmdefault)
                o.Stmt('SETSTATIC', nmdefault, ref)
                o.ClsFict(ref)
                if istempref(ref) and ref not in g_refs2:
                    o.Raw(ref, ' = 0;')   
                ref = None
            
            ref1 = New(None, forcenewg)
            ismeth = type_methfunc(co)[1]
            if not ismeth:
                o.Raw(ref1, ' = PyCFunction_New ( &methfunc_', co.cmds[0][1], ', NULL);')
            else:
                o.Raw(ref1, ' = Py2CFunction_NewFull( &methfunc_', co.cmds[0][1], ', 0, NULL/*self*/, NULL/*module*/, glob, ',const_to(N2C(co.cmds[0][1])),');')
                #o.Raw(ref1, ' = __pyx_binding_PyCFunctionType_NewEx ( &methfunc_', co.cmds[0][1], ', NULL, NULL);')
                Used('Py2CFunction_NewFull')
            return ref1

        if co.can_be_codefunc():
            if len(it) == 3 and it[2][0] == 'CONST' and type(it[2][1]) is tuple:
                ref1 = New(None, forcenewg)
                if len(it[2][1]) > 0: # or len(co.co_cellvars + co.co_freevars) != 0:
                    o.Stmt(ref1, '=', 'Py2CFunction_New', const_to( co))
                    if False:
                        o.Raw('PyObject_SetAttrString(', ref1, ', "func_defaults", ', const_to(it[2]), ');')
                    else:
                        o.Stmt('Py2CFunction_SetDefaults', ref1, it[2])
                else:
                    o.Stmt(ref1, '=', 'Py2CFunction_New', const_to( co))
                        
                return ref1
            if len(it) == 3 and it[2][0] == '!BUILD_TUPLE' and type(it[2][1]) is tuple:
                ref1 = New(None, forcenewg)
                o.Stmt(ref1, '=', 'Py2CFunction_New', const_to(co))
                ref2 = Expr1(it[2], o)
                o.Stmt('Py2CFunction_SetDefaults', ref1, ref2)
                if co.direct_cmds is not None:
                    nmdefault = co.default_args_nm() 
                    add_fast_glob(nmdefault)
                    o.INCREF(ref2)
                    o.Stmt('SETSTATIC', nmdefault, ref2)                     
                o.Cls(ref2)
                return ref1
        Fatal('GenExpr', it)
        assert False

    if head == 'BINARY_SUBSCR_Int':
        ref = LikeExpr1(it[1], o)
        ref1 = New(None, forcenewg)
        if ref1 != forcenewg and forcenewg is not None:
            pp(it)
            pprint(o)
            assert False
        t = TypeExpr(it[1])
        islist = IsListAll(t)
        if IsDict(t):        
            ref2 = GenExpr(it[2], o, None, None, True)
            
            o_2 = Out() 
            tupl = New()
            o_2.Raw('if ((', tupl, ' = PyTuple_Pack(1, ', ref2, ')) == 0) goto ', labl, ';') 
            o_2.Raw('PyErr_SetObject(PyExc_KeyError, ', tupl, ');')
            o_2.Cls(tupl)            
            o_2.Raw('goto ', labl, ';')
            tolabl = append_to_exception(o_2)                   
            
            o.Raw('if ((', ref1, ' = PyDict_GetItem(', ref, ', ', ref2, ')) == 0) goto ', tolabl, ';')
            UseLabl()
            o.INCREF(ref1)
            o.Cls(ref, ref2)
            return ref1
        elif IsTuple(t):        
            if it[2][1] >= 0:
                GetTupleItem(o, t, ref1, ref, it[2][1])
            else:
                o.Stmt(ref1, '=', 'PyTuple_GetItem', ref, 'PyTuple_GET_SIZE(' + CVar(ref) + ') ' + str(it[2][1]))
        elif IsStr(t): # after. Too many low-lewel code.
            if it[2][0] == 'CONST' and type(it[2][1]) is int and it[2][1] >= 0:
                StrIndexErrHandler(o, ConC('PyString_GET_SIZE( ', ref, ' ) <= ', it[2][1]))
                o.Raw(ref1, ' = PyString_FromStringAndSize(PyString_AS_STRING(', ref, ')+', it[2][1], ', 1);')
                UseLabl()
                return ref1
            if it[2][0] == 'CONST' and type(it[2][1]) is int and it[2][1] == -1:
                StrIndexErrHandler(o, ConC('PyString_GET_SIZE( ', ref, ' ) == 0'))
                o.Raw(ref1, ' = PyString_FromStringAndSize(PyString_AS_STRING(', ref, ')+(PyString_GET_SIZE( ', ref, ' )-1), 1);')
                UseLabl()
                return ref1
            o.Stmt(ref1, '=', 'PyObject_GetItem', ref, it[2])
        elif expand_BINARY_SUBSCR or islist:
            if not islist:
                o.Stmt('if (PyList_CheckExact(', ref, ')) {')
            if it[2][1] >= 0:
                o.Stmt(ref1, '=', 'PyList_GetItem', ref, it[2][1])
                assert 'INCREF' in o[-1]
            else:
                o.Stmt(ref1, '=', 'PyList_GetItem', ref, 'PyList_GET_SIZE(' + CVar(ref) + ') ' + str(it[2][1]))
                assert 'INCREF' in o[-1]
            if not islist:
                o.append('} else {')
                o.Stmt(ref1, '=', 'PyObject_GetItem', ref, it[2])
                o.append('}')
        else:
            verif(it)
            if t is not None and t != Kl_Buffer and not IsSequence(t) and not IsMayBe(t):
                Debug('not None', it, t)
                o.Stmt(ref1, '=', 'PyObject_GetItem', ref, it[2])
            else:    
                o.Stmt(ref1, '=', '_c_BINARY_SUBSCR_Int', ref, it[2][1], it[2])
        o.Cls(ref)
        v2 = {}
        if len(o) >= 3 and istempref(ref) and TxMatch(o, len(o)-3, """
            if ((temp[$0] = _c_BINARY_SUBSCR_Int ( $2 , $3 , const$4 )) == 0) goto label_$7;
            if ((temp[$1] = _c_BINARY_SUBSCR_Int ( temp[$0] , $5 , const$6 )) == 0) goto label_$7;
            CLEARTEMP($0);
            """, v2):   
                TxRepl(o, len(o)-3, """if ((temp[$1] = c_BINARY_SUBSCR_2_Int ( $2 , $3 , $5 )) == 0) goto label_$7;""", v2)  
                Used('c_BINARY_SUBSCR_2_Int')
        return ref1
    if head == 'from_ceval_BINARY_SUBSCR':
        return generate_from_ceval_binary_subscr(it, o, forcenewg) 
 
    if head.startswith('_PyString_') and head != '_PyString_Join':
        return generate_pystring_op(head, it, forcenewg, o)

    if head == 'PyObject_Hash':
        verif(it)
        ref1 = Expr1(it[1], o)
        n1 = New('long')  
        o.Stmt(n1, '=', head, ref1)
        o.Cls(ref1)
        ret = New(typed, forcenewg)  
        o.PushInt(ret, n1)
        o.Cls(n1)
        return ret
    if head == '_PyList_Pop':
        assert IsList(TypeExpr(it[1]))
        ref0 = Expr1(it[1], o)
        ref = New(None, forcenewg)
        if len(it) == 3:
            if it[2][0] == 'CONST':
                ind1 = New('long')
                if it[2][1] < 0:
                    o.Raw(ind1, ' = PyList_GET_SIZE(', ref0, ') - ', abs(it[2][1]), ';')
                else:    
                    o.Stmt(ind1, '=', it[2][1])
            else:
                o1,ind1 = short_gen_size_t(it[2], True)
                o.extend(o1)
                if not istemptyped(ind1):
                    ind_ = New('long')
                    o.Raw(ind_, ' = ', ind1, ';')
                    ind1 = ind_
                o.Stmt('if (', ind1, '< 0) {')
                o.Raw(ind1, ' += PyList_GET_SIZE(', ref0, ');')
                o.append('}')                      
        elif len(it) == 2:        
            ind1 = New('long')
            o.Raw(ind1, ' = PyList_GET_SIZE(', ref0, ') - 1;')
        else:
            Fatal('iiiijfjhg', it)
            assert False
            return
        o.Stmt(ref, '=', 'PyList_GetItem', ref0, ind1)
        o.Stmt('PyList_SetSlice', ref0, ind1, ConC(ind1, ' + ', 1), 'NULL')
        o.Cls(ind1, ref0)
        return ref

    if head == '_PyDict_Get' and IsDict(TypeExpr(it[1])):
        ref0, ref1 = Expr(o, it[1:3])
        ref = New(None, forcenewg)
        if istempref(ref):
            o.Raw(ref, ' =  PyDict_GetItem(', ref0, ', ', ref1, ');')
            o.Raw('if (', ref, ' == 0) {') 
            ref3 = GenExpr(it[3], o, ref)
            if istempref(ref3) and istempref(ref) and ref3 != ref:
                pprint(o)
                Fatal('Not eq tempref', it, ref3, ref, it[3])
                assert False
            elif ref3 != ref:
                o.Raw(ref, ' = ', ref3, ';')
                o.INCREF(ref)        
            o.append('} else {')
            o.INCREF(ref)        
            o.append('}')
            if ref3 != ref:
                o.Cls(ref3)
        else:
            Fatal('', it)
            assert False
        o.Cls(ref0, ref1)
        return ref

    if head == 'PyObject_GetAttr':
        return generate_GetAttr(it,o, forcenewg)

    if head == 'PyObject_GetAttr3':
        t = TypeExpr(it[1])
        if t is not None:
            Debug('Typed GetAttr3', t, it)
        ref0, ref1 = Expr(o, it[1:3])
        ref = New(None, forcenewg)
        if istempref(ref):
            o.Raw(ref, ' = PyObject_GetAttr(', ref0, ', ', ref1, ');')
            o.Cls(ref0, ref1)
            o.Raw('if (', ref, ' == 0 && PyErr_ExceptionMatches(PyExc_AttributeError)) {')
            o.Raw('PyErr_Clear();')
            ref3 = GenExpr(it[3], o, ref)
            if istempref(ref3) and istempref(ref) and ref3 != ref:
                Fatal('Not eq tempref', it, ref3, ref)
                assert False
            elif ref3 != ref:
                o.Raw(ref, ' = ', ref3, ';')
                o.INCREF(ref)        
            if ref3 != ref:
                o.Cls(ref3)
            o.append('}')
        else:
            Fatal('', it)
            assert False
        return ref

    if head == '@PyInt_FromSsize_t':
        return GenExpr(it[2],o, forcenewg)
        
    if head in ('c_Py_EQ_Int', 'c_Py_NE_Int', 'c_Py_LT_Int', 'c_Py_LE_Int', 'c_Py_GT_Int', 'c_Py_GE_Int'):
        ref = LikeExpr1(it[1], o)
        n = 'NULL'
        t = TypeExpr(it[1])
        if t is not None:
            Debug('typed compare', t, it)
        if type(it[2]) is int:
            int_t = it[2] 
            n = const_to(int_t)   
        elif it[2][0] == 'CONST' and type(it[2][1]) is int:
            int_t = it[2][1]    
            n = const_to(int_t)   
        elif it[2][0] in ('!PY_SSIZE_T',):
            int_t = GenExpr(it[2][1],o, forcenewg, 'Py_ssize_t')
        else:
            Fatal('CMP', it)
            assert False
            return
        ret = New('int')    
        o.Stmt(ret,'=', head, ref, int_t, n)
        o.Cls(ref, int_t)
        return ret
    if head == 'CHR_BUILTIN':
        t = TypeExpr(it[1])
        #if not IsNoneOrInt(t) and t != Kl_IntUndefSize:
        return GenExpr(('!PyObject_Call', ('!LOAD_BUILTIN', 'chr'), ('!BUILD_TUPLE', (it[1],)), 'NULL'),o, forcenewg,typed, skip_float )
        
    if head == 'PY_SSIZE_T':
        o1,n = short_gen_size_t(it[1])
        o.extend(o1)
        if type(n) is int:
            return ('CONST', n)
        ref = New(None, forcenewg)
        o.PushInt(ref, n)
        o.Cls(n)
        return ref     
    if head == 'STR_CONCAT':
        return GenExpr_STR_CONCAT(it, o, forcenewg)
    if head == 'LIST_COMPR':
        assert len(it) == 3
        prev_compr = g_co.list_compr_in_progress
        g_co.list_compr_in_progress = True
        ref = generate_list_compr(it[1],it[2],o, forcenewg)  
        g_co.list_compr_in_progress = prev_compr
        return ref
    if head == 'SET_COMPR':
        assert len(it) == 3
        prev_compr = g_co.list_compr_in_progress
        g_co.list_compr_in_progress = True
        ref = generate_set_compr(it[1],it[2],o, forcenewg)  
        g_co.list_compr_in_progress = prev_compr
        return ref
    if head == 'MAP_COMPR':
        assert len(it) == 3
        prev_compr = g_co.list_compr_in_progress
        g_co.list_compr_in_progress = True
        ref = generate_map_compr(it[1],it[2],o, forcenewg)  
        g_co.list_compr_in_progress = prev_compr
        return ref
    if head == 'BOOLEAN':
        o1,logic = shortage(generate_logical_expr(it[1]))
        o.extend(o1)
        ref = New(None, forcenewg)
        o.Stmt(ref, '=','PyBool_FromLong', logic)
        o.Cls(logic)        
        return ref
    if head == '1NOT' and it[1][0] == '!BOOLEAN':
        o1, int_val = shortage(generate_logical_expr(it[1]))
        o.extend(o1)
        ref = New(None, forcenewg)
        o.Stmt(ref, '=','PyBool_FromLong', ConC('!(', int_val, ')'))
        o.Cls(int_val)
        return ref

    if head in ('_EQ_', '_NEQ_'):
        Fatal('GenExpr', it)
        assert False
    if head == 'AND_BOOLEAN':
        Fatal('GenExpr', it)
        assert False
    if head == '1NOT':
        ref1 = Expr1(it[1], o)
        n = New('int')
        o.Stmt(n, '=', 'PyObject_Not', ref1)
        o.Cls(ref1)
        ref = New(None, forcenewg)
        o.Stmt('if (', n, ') {')
        o.Stmt(ref, '=', 'Py_True')
        o.append('} else {')
        o.Stmt(ref, '=', 'Py_False')
        o.append('}')
        o.Cls(n)
        o.INCREF(ref)
        return ref
    if head == '$PyDict_SymmetricUpdate':
        if it[1][0] == '!BUILD_MAP':
            ref1, ref2 = Expr(o, it[1:3])
            o.Stmt('PyDict_Update', ref1, ref2)
            o.Cls(ref2)
            return ref1
        Fatal('GenExpr', it)
        assert False
    if (head == 'CLASS_CALC_CONST_NEW' and ##it[1] in compiled_slots  and 
            CodeInit(it[1]) is not None) and auto_slots:
        nminit = CodeInit(it[1])
##        coinit = N2C(nminit)
        li = it[2]
        if li[0] == 'CONST':
            li = [('CONST', x) for x in li[1]]
        elif li[0] == '!BUILD_TUPLE':
            li = list(li[1])
        else:
            assert False
        
        if subroutine_can_be_direct(nminit, len(li)+1): # and not (coinit.co_flags & 0x4 and (coinit.co_argcount > 1 and it[2][0] not in('BUILD_TUPLE', 'CONST'))):
            ref = New(None, forcenewg)
            o.Raw(ref, ' = ((PyTypeObject *)', ('CALC_CONST', it[1]), ')->tp_new(((PyTypeObject *)', ('CALC_CONST', it[1]), '), ', ('CONST', ()), ', NULL);')      
            o.INCREF(ref)
            ref2 = New()
            o.Raw(ref2, ' = ', ref, ';')
            li = ('!BUILD_TUPLE', (ref2,) + tuple(li))
            generate_statement('UNPUSH', ('UNPUSH', ('!CALL_CALC_CONST', nminit, li)), o)

            return ref
    if head == 'CLASS_CALC_CONST_NEW' or head == 'CLASS_CALC_CONST_DIRECT' or head == 'CLASS_CALC_CONST':
        ref = GenExpr(('!PyObject_Call', ('CALC_CONST', it[1]), it[2], ('NULL',)), o, forcenewg)
        return ref
    if head == 'CALL_CALC_CONST':
        return generate_call_calc_const(it,o, forcenewg)
    if head == 'CALL_CALC_CONST_INDIRECT':
        return generate_call_calc_const_indirect(it,o, forcenewg)
            
    if head == 'PyObject_Call':
        if it[3] == 'NULL' or (len(it[3]) == 1 and it[3][0] == 'NULL'):
            return generate_PyObject_Call_nokey(it, o, forcenewg)
        return generate_PyObject_Call_with_dictionary(it, o, forcenewg)

    if head.startswith('PyNumber_'):
        return GenNumberExpr(it, o, forcenewg, typed, skip_float)
    if head == '?Raise':
        return generate_raise_zerodivision(it, o)
    if head == 'COND_EXPR':
        t1 = TypeExpr(it[2])
        t2 = TypeExpr(it[3])
        if IsBool(t1) and IsBool(t2):
            logic2 = New('int')
            o1, logic = shortage(generate_logical_expr(it[1]))
            o.extend(o1)
            o.Stmt('if (', logic, ') {')
            o1, logic = shortage(generate_logical_expr(it[2]))
            o.extend(o1)
            o.Raw(logic2, ' = ', logic, ';')
            o.Raw('} else {')
            o1, logic = shortage(generate_logical_expr(it[3]))
            o.extend(o1)
            o.Raw(logic2, ' = ', logic, ';')
            o.Raw('}')  
            ref = New(None, forcenewg)
            o.Stmt(ref, '=', 'PyBool_FromLong', logic2)
            o.Cls(logic2)
            return ref          
        o1, logic = shortage(generate_logical_expr(it[1]))
        if type(logic) is str:
            logic = logic.strip()
            if logic.startswith('(') and logic.endswith(')'):
                if '(' not in logic[1:-1] and ')' not in logic[1:-1]:
                    logic = logic[1:-1]
                    logic = logic.strip()
                elif logic.startswith('(GETLOCAL('):
                    if logic.count(')') == 2:
                        logic = logic[1:-1]
                        logic = logic.strip()
                    elif logic.count(' ') == 2:
                        logic_ = logic[1:-1].split(' ')
                        pp(logic_)
                        if logic_[0].startswith('GETLOCAL(') and logic_[2].startswith('GETLOCAL(') and logic_[1] in ('==', '!='):
                            logic = logic[1:-1]
                            logic = logic.strip()
                        

        o.extend(o1)
        onlyone, onlytwo = False, False
        if logic in ('(!(0))', '1', '(1)', '((1))'):
            onlyone = True
        elif logic in ('(!(1))', '0', '(0)', '((1))'):
            onlytwo = True
        ref_prev = None
        if forcenewg is not None:
            assert istempref(forcenewg)
            ref_prev = forcenewg
            o.CLEAR(ref_prev)
        else:
            ref_prev = New()    
        assert ref_prev is not None
        if not onlyone and not onlytwo:
            o.Stmt('if (', logic, ') {')
        if not onlytwo:
            ref = GenExpr(it[2], o, ref_prev)    
            if ref != ref_prev:
                if istempref(ref):
                    pprint((forcenewg, ref,ref_prev))
                    pprint(it)
                    pprint(o)
                assert not istempref(ref)
                o.Raw(ref_prev, ' = ', ref, ';')
                o.INCREF(ref_prev)  
        if not onlyone and not onlytwo:
            o.append('} else {')
        if not onlyone:
            ref = GenExpr(it[3], o, ref_prev)
            if ref != ref_prev:
                assert not istempref(ref)
                o.Raw(ref_prev, ' = ', ref, ';')
                o.INCREF(ref_prev) 
        if not onlyone and not onlytwo:
            o.append('}')
        o.Cls(logic)
        return ref_prev        

    if head == '_PyEval_BuildClass' and it[3][1] in compiled_slots:
        reto = common_call(head, it, o, typed, forcenewg)
        nmcl = it[3][1]
        for nmsl in compiled_slots[nmcl] :
            if nmsl == '__dict__':
                continue
            o.Raw('offset_' + nmcl + '_' + nmsl, ' = _Py2C_slot_offset((PyTypeObject *)', reto, ', "', nmsl, '");')
            o.Raw('assert(offset_' + nmcl + '_' + nmsl + ' != -1);')
            Used('_Py2C_slot_offset')
        return reto
  
                
#
# Base part
#
    return common_call(head, it, o, typed, forcenewg)

Libr('_Py2C_slot_offset',
"""static int _Py2C_slot_offset(PyTypeObject * r, char * nm);""",
"""
static int _Py2C_slot_offset(PyTypeObject * r, char * nm)
{
    int i;
    i = 0;
    while (r->tp_members[i].name) {
        /*fputs(r->tp_members[i].name, stdout);
        fputc(012, stdout);
        fputc(015,stdout);
        */
        if (strcmp(nm, r->tp_members[i].name) == 0) return r->tp_members[i].offset;
        i++;
    }
    return -1;
}
""")

Libr('_PyString_GetSlice',
"""
static PyObject * _PyString_GetSlice(PyObject *a, long i, long j);
""",
"""
static PyObject * _PyString_GetSlice(PyObject *a, long i, long j)
{
    if (i < 0) i += PyString_GET_SIZE(a);
    if (j < 0) j += PyString_GET_SIZE(a);
    if (i < 0)
        i = 0;
    if (j < 0)
        j = 0; 
    if (i > PyString_GET_SIZE(a))
        i = PyString_GET_SIZE(a);
    if (j > PyString_GET_SIZE(a))
        j = PyString_GET_SIZE(a);
    if (i == 0 && j == PyString_GET_SIZE(a)) {
        Py_INCREF(a);
        return a;
    }
    if (j < i)
        j = i;
    return PyString_FromStringAndSize(PyString_AS_STRING(a) + i, j-i);
}
""")

def generate_pystring_op_logical(it, logic):  
    assert type(it) is tuple
    assert IsStr(TypeExpr(it[1]))
    head = it[0]
    assert type(head) is str
    if head[0] == '!':
        head = head[1:]
    assert type(head) is str
    o = Out()
    if not IsBool(TypeExpr(it)):
        return o, None
    
    if head == '_PyString_ctype':
        if IsChar(TypeExpr(it[1])):
            pprint(it)
            pp(';;;', TypeExpr(it[1]))
            assert False
        if IsStr(TypeExpr(it[1]))  and it[2] not in ('islower', 'isupper'):
            assert False
        if IsStr(TypeExpr(it[1])) and it[2] in ('islower', 'isupper'):
            ref0 = Expr1(it[1], o)
            ind = New('Py_ssize_t')
            islow = New('int')
            isup = New('int')
            o.Raw(isup, ' = 0;')
            o.Raw(islow, ' = 0;')
            o.Raw('for (', ind, ' = 0; ', ind, ' < PyString_GET_SIZE ( ', ref0, ' ); ', ind, ' ++) {')
            o.Raw(isup, ' |= isupper( PyString_AS_STRING ( ', CVar(ref0),' )[', CVar(ind), '] );')
            o.Raw(islow, ' |= islower( PyString_AS_STRING ( ', CVar(ref0),' )[', CVar(ind), '] );')
            o.Raw('}')
            Used('ctype')
            if it[2] == 'islower':
                o.Raw(logic, ' = ', islow, ' && !', isup, ';')
            elif it[2] == 'isupper':
                o.Raw(logic, ' = ', isup, ' && !', islow, ';')
            else:
                assert False
            o.Cls(ref0, ind, islow, isup)
            return o, logic       
    pprint(it)
    assert False
    return None, None


def generate_pystring_op(head, it, forcenewg, o):  
    assert type(it) is tuple
    assert type(o) is Out 
    assert IsStr(TypeExpr(it[1]))
    
    if head == '_PyString_ctype':
        if IsChar(TypeExpr(it[1])):
            assert False
        if IsStr(TypeExpr(it[1])) and it[2] in ('islower', 'isupper'):
            ref0 = Expr1(it[1], o)
            ind = New('Py_ssize_t')
            islow = New('int')
            isup = New('int')
            o.Raw(isup, ' = 0;')
            o.Raw(islow, ' = 0;')
            o.Raw('for (', ind, ' = 0; ', ind, ' < PyString_GET_SIZE ( ', ref0, ' ); ', ind, ' ++) {')
            o.Raw(isup, ' |= isupper( PyString_AS_STRING ( ', CVar(ref0),' )[', CVar(ind), '] );')
            o.Raw(islow, ' |= islower( PyString_AS_STRING ( ', CVar(ref0),' )[', CVar(ind), '] );')
            o.Raw('}')
            Used('ctype')
            ref = New(None, forcenewg)
            if it[2] == 'islower':
                o.Stmt(ref, '=', 'PyBool_FromLong', ConC(islow, ' && !', isup))
            elif it[2] == 'isupper':
                o.Stmt(ref, '=', 'PyBool_FromLong', ConC(isup, ' && !', islow))
            else:
                assert False
            o.Cls(ref0, ind, islow, isup)
            return ref

    pprint(it)
    assert False

def remove_temporary_long_when_push_int_from_long(o):
    assert type(o) is Out
    if len(o) < 2:
        return
    v2 = {}
    if o[-1].startswith('if ((temp[') and 'PyInt_FromLong' in o[-1] and TxMatch(o, len(o)-1, """
        if ((temp[$2] = PyInt_FromLong ( $3 )) == 0) goto label_$0;
        """, v2):       
            if v2[3].startswith('PyIF') or v2[3].startswith('fastsearch'):
                TxRepl(o, len(o)-2, """temp[$2] = PyInt_FromLong ( $3 );""", v2) 
                return
            if len(o) > 1 and o[-2] =='}':
                pass
            elif len(o) > 2 and o[-3] =='}' and o[-2].startswith('CLEARTEMP'):
                pass            
            else:
                return
    if len(o) < 2:
        return        
    if o[-2].startswith('long_') and 'PyInt_FromLong' in o[-1] and TxMatch(o, len(o)-2, """
        long_$1 = $2;
        temp[$3] = PyInt_FromLong ( long_$1 );
        """, v2):              
            TxRepl(o, len(o)-2, """temp[$3] = PyInt_FromLong ( $2 );""", v2) 
            return
    if len(o) >= 3 and o[-3].startswith('long_') and 'PyInt_FromLong' in o[-2] and TxMatch(o, len(o)-3, """
        long_$1 = $2;
        temp[$3] = PyInt_FromLong ( long_$1 );
        CLEARTEMP($4);
        """, v2) and v2[3] != v2[4] and 'temp[' not in v2[2]:              
            TxRepl(o, len(o)-3, """
                   temp[$3] = PyInt_FromLong ( $2 );
                   CLEARTEMP($4);""", v2) 
                     

def remove_temporary_double_when_push_float_from_double(o):
    pass

def generate_import_name(it, o):
    assert type(it) is tuple
    assert type(o) is Out     
    importer = Expr1(('!PyDict_GetItem', 'bdict', ('CONST', '__import__')),o)
    if g_co.c_name == 'Init_filename':
        loc = 'glob'
    elif is_current & IS_DICTIONABLE_CFUNC:
        loc = '_f_locals'
    else:
        loc = 'f->f_locals == 0 ? Py_None : f->f_locals'
    if it[2][0] == 'CONST' and it[2][1] == -1:
        it3 = it[3]
        if it3 == ('CONST', None):
            it3 = ('Py_None',)
        tupl = ('!BUILD_TUPLE', ( ('CONST',it[1]), \
                                    ('glob',), \
                                    (loc,),\
                                    it3))  

    else:        
        tupl = ('!BUILD_TUPLE', ( ('CONST',it[1]), \
                                    ('glob',), \
                                    (loc,),\
                                    it[3], it[2]))  
#    arg = Expr1(tupl,o)
    
    ret = Expr1(('PY_TYPE', types.ModuleType, it[1], ('!PyEval_CallObject', importer, tupl), None), o) #('PY_TYPE', tuple, None, arg, None)),o )   
    o.Cls(importer)
    return ret

def generate_raise_zerodivision(it, o):
    assert type(it) is tuple
    assert type(o) is Out     
    gen = [Expr1(x, o) if type(x) is tuple and len(x) > 0 else x \
            for i,x in enumerate(it) if i > 2]
    o.Cls(*gen)

    refs = [('BUILTIN', 'ZeroDivisionError'), ('CONST', "division by 0"), 'NULL']
    o.Stmt('_PyEval_DoRaise', refs[0], refs[1], refs[2])
    if refs[0] != 'NULL':
            o.INCREF(refs[0])
    if refs[1] != 'NULL':
        o.INCREF(refs[1])
    if refs[2] != 'NULL':
        o.INCREF(refs[2])        
    o.Cls(*refs)
    o.Stmt('goto', labl)
    UseLabl()
    return ('CONST', None)

def generate_call_calc_const_indirect(it,o, forcenewg):
    assert type(it) is tuple
    assert type(o) is Out     
    d_nm = 'codefunc_' + it[1]
    ret = New(None, forcenewg)
    co = N2C(it[1])  
    assert type(co) is code_extended 
    if co.can_be_cfunc():
        assert not co.method_class
        d_nm = 'cfunc_' + it[1]
        ref1 = Expr1(it[2], o)
        
        met = type_methfunc(co)[0]
        if met == "METH_NOARGS": 
            assert ref1 == ('CONST', ())
            o.Raw('if ((', ret, ' = ', d_nm, '( NULL, NULL)) == 0) goto ', labl, ';') 
        elif met == "METH_O" or met == "METH_NOARGS":
            o.Raw('if ((', ret, ' = ', d_nm, '( NULL, ', ref1, ')) == 0) goto ', labl, ';') 
        else:
            o.Raw('if ((', ret, ' = ', d_nm, '( NULL, ', ref1, ', NULL)) == 0) goto ', labl, ';') 
        UseLabl()
        o.Cls(ref1)
        return ret
    if it[2] == ('CONST', ()):
        refs = []
    elif it[2][0] == '!BUILD_TUPLE':
        refs = Expr(o, it[2][1])
    elif it[2][0] == 'CONST':
        refs = [('CONST', x) for x in it[2][1]]
    else:
        Fatal('GenExpr', it)
        assert False
        return ret 
    assert type(refs) is list
    argcount = co.co_argcount
    assert len(refs) == argcount      
    tupl = (ret, ' = _Call_CompiledWithFrame(', d_nm, ', ', const_to(co), ', ', argcount)
    Used('_Call_CompiledWithFrame')
    for ref in refs:
        tupl = tupl + (', ', ref)
    tupl = tupl + (')',)    
    tupl = ('if ((',) + tupl + (') == 0) goto ', labl, ';') 
    o.Raw(*tupl)
    UseLabl()
    if len(refs) > 0:
        o.Cls(*refs)
    return ret

def append_to_exception(o_2):
    assert type(o_2) is Out
    if tuple(o_2) not in g_co.to_exception:
        g_co.to_exception[tuple(o_2)] = New('label')
    return g_co.to_exception[tuple(o_2)]

def generate_from_ceval_binary_subscr(it, o, forcenewg):
    assert type(it) is tuple
    assert type(o) is Out     
    t = TypeExpr(it[1])
    ty_ind = TypeExpr(it[2])
    islist = IsList(t)
    if t is None:
        pass
    elif IsListAll(t):
        islist = True    

    if islist and IsInt(ty_ind):
        ty_ind = TypeExpr(it[2])
        ref0 = LikeExpr1(it[1], o)
        o2,ind1 = short_gen_size_t(it[2])
        o.extend(o2)
        ref = New(None, forcenewg)            
        if IsCardinal(ty_ind):
            o.Stmt(ref, '=', 'PyList_GetItem', ref0, ind1)
        elif IsNegInt(ty_ind):
            o.Stmt(ref, '=', 'PyList_GetItem', ref0, ConC(ind1, ' + PyList_GET_SIZE(', ref0, ')'))
        else:
            o.Stmt(ref, '=', 'PyList_GetItem', ref0, ConC('PyIF(', ind1, ' >= 0, ', ind1, ', ', ind1, ' + PyList_GET_SIZE(', ref0, '))'))
        o.Cls(ind1, ref0)
        return ref  

    if IsTuple(t) and IsInt(ty_ind):
        ty_ind = TypeExpr(it[2])
        ref0 = LikeExpr1(it[1], o)
        o2,ind1 = short_gen_size_t(it[2])
        o.extend(o2)
        ref = New(None, forcenewg)            
        if IsCardinal(ty_ind):
            o.Stmt(ref, '=', 'PyTuple_GetItem', ref0, ind1)
        elif IsNegInt(ty_ind):
            o.Stmt(ref, '=', 'PyTuple_GetItem', ref0, ConC(ind1, ' + PyTuple_GET_SIZE(', ref0, ')'))
        else:
            o.Stmt(ref, '=', 'PyTuple_GetItem', ref0, ConC('PyIF(', ind1, ' >= 0, ', ind1, ', ', ind1, ' + PyTuple_GET_SIZE(', ref0, '))'))
        o.Cls(ind1, ref0)
        return ref  



    if it[2][0] == '!PyInt_FromSsize_t':
        if not islist and t is not None:
            verif(it)
        ref = LikeExpr1(it[1], o)
        ref1 = New(None, forcenewg)
        if not islist:
            o.Stmt('if (PyList_CheckExact(', ref, ')) {')
        o.Stmt(ref1, '=', 'PyList_GetItem', ref, it[2][1])
        if not islist:
            o.append('} else {')
            ref2 = LikeExpr1(it[2],o)
            o.Stmt(ref1, '=', 'PyObject_GetItem', ref, ref2)
            o.Cls(ref2)
            o.append('}')
        o.Cls(ref)
        return ref1
    if it[2][0] == '!@PyInt_FromSsize_t':
        if not islist and t is not None and not IsDict(t) and not IsTuple(t):
            Debug('not islist? is notdict', it, t)
        ref = LikeExpr1(it[1], o)
        ref1 = New(None, forcenewg)
        if IsDict(t):
            ref2 = LikeExpr1(it[2][2], o)
            
            o_2 = Out() 
            tupl = New()
            o_2.Raw('if ((', tupl, ' = PyTuple_Pack(1, ', ref2, ')) == 0) goto ', labl, ';') 
            o_2.Raw('PyErr_SetObject(PyExc_KeyError, ', tupl, ');')
            o_2.Cls(tupl)            
            o_2.Raw('goto ', labl, ';')
            tolabl = append_to_exception(o_2)            
            
            o.Raw('if ((', ref1, ' = PyDict_GetItem(', ref, ', ', ref2, ')) == 0) goto ', tolabl, ';')
            UseLabl()
            o.INCREF(ref1)
            o.Cls(ref, ref2)
            return ref1

        if IsTuple(t):
            GetTupleItem(o, t, ref1, ref, it[2][1])
            o.Cls(ref)
            return ref1
        elif expand_BINARY_SUBSCR or islist: 
            if not islist:
                o.Stmt('if (PyList_CheckExact(', ref, ')) {')
            o.Stmt(ref1, '=', 'PyList_GetItem', ref, it[2][1])
            if not islist:
                verif(it)
                o.append('} else {')
                ref2 = Expr1(it[2][2],o)
                o.Stmt(ref1, '=', 'PyObject_GetItem', ref, ref2)
                o.Cls(ref2)
                o.append('}')
        else:    
            verif(it)
            ref2 = LikeExpr1(it[2][2],o)
            o.Stmt(ref1, '=', '_c_BINARY_SUBSCR_Int', ref, it[2][1], ref2)
            o.Cls(ref2)
        o.Cls(ref)
        return ref1
    if islist:
        ty_ind = TypeExpr(it[2])
        ref0 = LikeExpr1(it[1], o)
        ref1 = LikeExpr1(it[2], o, True)
        ref = New(None, forcenewg)
        ind = None
        if ty_ind is None or IsInt(ty_ind) or IsIntUndefSize(ty_ind):    
            ind = New('long')
        if ty_ind is None or IsIntUndefSize(ty_ind):
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
        if ty_ind is None or IsInt(ty_ind) or IsIntUndefSize(ty_ind): 
            if ref1[0] != 'CONST':   
                o.Stmt(ind, '=', 'PyInt_AS_LONG', ref1)
                if IsInt(ty_ind):
                    o.Cls(ref1)
                if not IsCardinal(ty_ind):
                    o.Stmt('if (', ind, '< 0) {')
                    o.Raw(ind, ' += PyList_GET_SIZE(', ref0, ');')
                    o.append('}')
                o.Stmt(ref, '=', 'PyList_GetItem', ref0, ind)
                o.Cls(ind)
            elif ref1[1] >= 0:    
                o.Stmt(ref, '=', 'PyList_GetItem', ref0, ref1[1])
                o.Cls(ind)
            else: ##if ref1[1] < 0:    
                o.Raw(ind, ' = PyList_GET_SIZE(', ref0, ') + ', ref1[1], ';')
                o.Stmt(ref, '=', 'PyList_GetItem', ref0, ind)
                o.Cls(ind)
        if ty_ind is None or IsIntUndefSize(ty_ind):
            o.append('} else {')
        if not IsInt(ty_ind):
            o.Stmt(ref, '=', 'PyObject_GetItem', ref0, ref1)
        if ty_ind is None or IsIntUndefSize(ty_ind):
            o.append('}')
        o.Cls(ref1)
        o.Cls(ref0)
        return ref
    if IsDict(t):
        ref0 = LikeExpr1(it[1], o)
        ref1 = LikeExpr1(it[2], o, True)
        ref = New(None, forcenewg)
        o_2 = Out() 
        tupl = New()
        o_2.Raw('if ((', tupl, ' = PyTuple_Pack(1, ', ref1, ')) == 0) goto ', labl, ';') 
        o_2.Raw('PyErr_SetObject(PyExc_KeyError, ', tupl, ');')
        o_2.Cls(tupl)            
        o_2.Raw('goto ', labl, ';')
        tolabl = append_to_exception(o_2)
        o.Raw('if ((', ref, ' = PyDict_GetItem(', ref0, ', ', ref1, ')) == 0) goto ', tolabl, ';')
        UseLabl()
        o.INCREF(ref)
        o.Cls(ref0, ref1)
        return ref

    if IsTuple(t):
        ref0 = LikeExpr1(it[1], o)
        ref1 = LikeExpr1(it[2], o, True)
        ref = New(None, forcenewg)
        ind = None
        if ty_ind is None or IsInt(ty_ind) or IsIntUndefSize(ty_ind):   
            if ref1[0] == 'CONST' and type(ref1[1]) is int and ref1[1] >= 0:
                ind = ref1[1] 
            else:
                ind = New('long')
        if ty_ind is None or IsIntUndefSize(ty_ind):
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
        if ty_ind is None or IsInt(ty_ind) or IsIntUndefSize(ty_ind):    
            if  type(ind) is not int:
                o.Stmt(ind, '=', 'PyInt_AS_LONG', ref1)
                if IsInt(ty_ind):
                    o.Cls(ref1)
                if not IsCardinal(ty_ind):
                    o.Stmt('if (', ind, '< 0) {')
                    o.Raw(ind, ' += PyTuple_GET_SIZE(',ref0,');')
                    o.append('}')
            GetTupleItem(o, t, ref, ref0, ind)
            o.Cls(ind)
        if ty_ind is None or IsIntUndefSize(ty_ind):
            o.append('} else {')
        if not IsInt(ty_ind):
            o.Stmt(ref, '=', 'PyObject_GetItem', ref0, ref1)
        if ty_ind is None or IsIntUndefSize(ty_ind):
            o.append('}')
        o.Cls(ref1)
        o.Cls(ref0)
        return ref
    if IsStr(t):
        ty_ind = TypeExpr(it[2])
        ref0 = LikeExpr1(it[1], o)
        ref1 = GenExpr(it[2], o, None, None, True)
        ref = New(None, forcenewg)
        ind = None
        if ty_ind is None or IsInt(ty_ind) or IsIntUndefSize(ty_ind):    
            ind = New('long')
        if ty_ind is None or IsIntUndefSize(ty_ind):
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
        if ty_ind is None or IsInt(ty_ind) or IsIntUndefSize(ty_ind):    
            o.Stmt(ind, '=', 'PyInt_AS_LONG', ref1)
            if IsInt(ty_ind):
                o.Cls(ref1)
            if not IsCardinal(ty_ind):
                o.Stmt('if (', ind, '< 0) {')
                if ref0[0] == 'CONST':
                    o.Raw(ind, ' += ', len(ref0[1]), ';')
                else:
                    o.Raw(ind, ' += PyString_GET_SIZE(',ref0,');')
                o.append('}')

            if not IsCardinal(ty_ind):
                if ref0[0] == 'CONST':
                    len_ref0 = len(ref0[1])
                    StrIndexErrHandler(o, ConC(ind, ' < 0 || ', ind, ' >= ',len_ref0))
                else:
                    StrIndexErrHandler(o, ConC(ind, ' < 0 || ', ind, ' >= PyString_GET_SIZE(',ref0,')'))    
            else:
                if ref0[0] == 'CONST':
                    len_ref0 = len(ref0[1])
                    StrIndexErrHandler(o, ConC(ind, ' >= ',len_ref0))
                else:    
                    StrIndexErrHandler(o, ConC(ind, ' >= PyString_GET_SIZE(',ref0,')'))                
            UseLabl()
            ch = ConC('(', Str_AS_STRING(ref0), ' + ', ind, ')') 
            o.Raw(ref, ' = PyString_FromStringAndSize(', ch, ', 1);')
            o.Cls(ind)
        if ty_ind is None or IsIntUndefSize(ty_ind):
            o.append('} else {')
        if not IsInt(ty_ind):
            o.Stmt(ref, '=', 'PyObject_GetItem', ref0, ref1)
        if ty_ind is None or IsIntUndefSize(ty_ind):
            o.append('}')
        o.Cls(ref1)
        o.Cls(ref0)
        return ref
    verif(it)
    t = TypeExpr(it[1]) 
    if t is not None and t[0] in ('NewClassInstance', 'OldClassInstance'):
        Debug('Typed BINARY_SUBSCR not specialised: %s ( %s, %s )' % (it, t, TypeExpr(it[2])))

    ref0 = LikeExpr1(it[1], o)
    ref1 = LikeExpr1(it[2], o, True)
    ref = New(None, forcenewg)
    if ref1[0] == 'CONST' and type(ref1[1]) is int:
        o.Raw('if ((', ref, ' = _c_BINARY_SUBSCR_Int ( ', ref0, ' , ', ref1[1], ' , ', ref1, ' )) == 0) goto ', labl, ';')
        UseLabl()
        Used('_c_BINARY_SUBSCR_Int')
    elif ref1[0] == 'FAST' and IsInt(ty_ind) and not g_co.IsCVar(ref1):
        o.Raw('if ((', ref, ' = _c_BINARY_SUBSCR_Int ( ', ref0, ' , PyInt_AS_LONG ( ', ref1, ' ) , ', ref1, ' )) == 0) goto ', labl, ';')
        UseLabl()
        Used('_c_BINARY_SUBSCR_Int')
    else:
        o.Stmt(ref, '=', 'PyObject_GetItem', ref0, ref1)
    o.Cls(ref1, ref0)
    return ref        
        
def GetTupleItem(o, t, ref, ref0, ind):
    assert IsTuple(t)
    assert type(o) is Out
    if type(ind) is int and IsInTupleInd(t, ind):
        o.Raw(ref, ' = PyTuple_GET_ITEM ( ', ref0, ' , ', ind, ' );')
        o.INCREF(ref)
    else:
        o.Stmt(ref, '=', 'PyTuple_GetItem', ref0, ind)        
        
def generate_call_calc_const(it, o, forcenewg, nmtypvar = None):
    assert type(it) is tuple
    assert type(o) is Out     
    d_nm = '_Direct_' + it[1]
    is_const_default = True
    co = N2C(it[1])    
    argcount = co.co_argcount
    is_varargs = co.co_flags & 0x4
    pynumbadd = False

    hidden = co.hidden_arg_direct
    typed_arg = co.typed_arg_direct
    ty2 = {}
    for k,v in typed_arg.items():
        if k not in hidden:
            ty2[k] = v
    typed_arg = ty2    

    if it[1] in default_args and default_args[it[1]][0] != 'CONST':
        is_const_default = False
    if it[2] == ('CONST', ()):
        refs = []
    elif it[2][0] == '!BUILD_TUPLE':
        refs = []
        d = {}
        di = {}
        for i, e in enumerate(it[2][1]):
            if is_tuple_pack_arg(e, d):
                di[i] = True
        if len(d) > 0:
            
            for k in d.keys():
                ty, k = k
                if k[0] == '!BINARY_SUBSCR_Int' and (list, k[1]) not in d and (tuple, k[1]) not in d:
                    d = {}
                    di = {} ## too strong !!!
                    break
        assert check_index_BUILD_TUPLE(d, o)  
        for i, e in enumerate(it[2][1]):
            targ_ctype = None
            if i in typed_arg and IsCType(typed_arg[i]) and IsCType(TypeExpr(e)):
                targ_t = typed_arg[i]
                targ_ctype = Type2CType(targ_t)
                assert targ_ctype == Type2CType(TypeExpr(e))
                o2, s, ty, checktupl, checktuplerr = attempt_str_direct_type_generation(e)
                assert type(ty) is set
                if s is not None:
                    labl_err = add_check_message(checktupl, checktuplerr, o2)     
                    if len([v for v in ty if istempref(v)]) > 0:
                        ind1 = New(targ_ctype)
                        o2.Raw(ind1, ' = ', s, ';')
                        for v in ty:
                            o2.Cls(v)
                        o.extend(o2)
                        s = ind1
                    else:
                        for v in ty:
                            o2.Cls(v)
                        o.extend(o2)
                    refs.append(s)
                    continue
                if e[0] != 'PY_TYPE' and e[0] != '!PyObject_GetAttr':
                    pp(typed_arg, co.typed_arg_direct)
                    pp('567---+++',  o2, s, ty, checktupl, checktuplerr)
                    pp('567---', i,e, targ_t, TypeExpr(e))
                    pprint(o[-40:])
##                    pprint(g_co.__dict__)
            elif i in typed_arg and IsCType(typed_arg[i]):
                if e[0] == 'PY_TYPE':
                    pp(typed_arg, co.typed_arg_direct)
                    pp('567--- Ctype PY_TYPE', TypeExpr(e), TypeExpr(e[3]), e)
                    pp('567--- CType incopatible', i, typed_arg[i], TypeExpr(e), e, g_co.c_name, '->', 
                       co.c_name, '(', (co.hidden_arg_direct, co.typed_arg_direct, co.typed_arg_direct_changed), ')<-', \
                       (g_co.hidden_arg_direct, g_co.typed_arg_direct, g_co.typed_arg_direct_changed))
                    pprint(o[-40:])
##                    pprint(g_co.__dict__)
            
            if i in typed_arg and IsCType(typed_arg[i]) and IsCVar(e) and \
                    Type2CType(typed_arg[i]) == Type2CType(TypeExpr(e)):
                ref_0 = CVarName(e)
            elif i in typed_arg and typed_arg[i][0] is int: 
                if e[0] == 'CONST':
                    ref_0 = e[1]
                    if type(ref_0) is float:
                        if math.isinf(ref_0) or math.isnan(ref_0):
                            ref_0 = float_str(ref_0)
                else:    
                    ref_0 = generate_int_expr(e, o, True)
                    if ref_0 is None:
                        ref_0 = Expr1(e, o)
                        if istempref(ref_0):
                            typ3 = New('long')
                            o.Raw(typ3, ' = PyInt_AS_LONG ( ', ref_0, ' );')
                            o.Cls(ref_0)
                            ref_0 = typ3
                        else:
                            ref_0 = ConC('PyInt_AS_LONG ( ', ref_0, ' )')
            elif i in typed_arg and typed_arg[i][0] is float:
                if e[0] == 'CONST':
                    ref_0 = e[1]
                    if type(ref_0) is float:
                        if math.isinf(ref_0) or math.isnan(ref_0):
                            ref_0 = float_str(ref_0)
                else:    
                    ref_0 = Expr1(e, o)
                    typ3 = New('double')
                    o.Raw(typ3, ' = PyFloat_AS_DOUBLE ( ', ref_0, ' );')
                    o.Cls(ref_0)
                    ref_0 = typ3
            elif i in typed_arg and typed_arg[i][0] is bool:
                if e[0] == 'CONST':
                    if e[1]:
                        ref_0 = 1
                    else:
                        ref_0 = 0  
                else:    
                    typ3 = New('int')
                    ref_0 = Expr1(e, o)
                    o.Raw(typ3, ' = PyObject_IsTrue(', ref_0, ');')
                    o.Cls(ref_0)
                    ref_0 = typ3
            elif i in typed_arg and IsChar(tuple(typed_arg[i][:2])):
                ref_0 = Expr1(e, o)
                if ref_0[0] == 'CONST':
                    ref_0 = charhex(ref_0[1])
                else:    
                    typ3 = New('char')
                    o.Raw(typ3, ' = *', Str_AS_STRING(ref_0), ';')
                    o.Cls(ref_0)
                    ref_0 = typ3
            elif is_varargs and i >= argcount:
                ref_0 = e
            else:      
                if i in di:
                    ref_0 = get_tuple_pack_arg(e, d)
                else:
                    ref_0 = Expr1(e, o)
            refs.append(ref_0)            
    elif it[2][0] == '!PyNumber_Add' and it[2][1][0] == '!BUILD_TUPLE' and IsTuple(TypeExpr(it[2][2])):
        refs = []
        d = {}
        di = {}
        pynumbadd = True
        for i, e in enumerate(it[2][1][1] + (it[2][2],)):
            if is_tuple_pack_arg(e, d):
                di[i] = True
        if len(d) > 0:
            
            for k in d.keys():
                ty, k = k
                if k[0] == '!BINARY_SUBSCR_Int' and (list, k[1]) not in d and (tuple, k[1]) not in d:
                    d = {}
                    di = {} ## too strong !!!
                    break
        assert check_index_BUILD_TUPLE(d, o)         
        for i, e in enumerate(it[2][1][1] + (it[2][2],)):
            if i in typed_arg and IsCType(typed_arg[i]) and IsCVar(e) and \
                    Type2CType(typed_arg[i]) == Type2CType(TypeExpr(e)):
                ref_0 = CVarName(e)
            elif i in typed_arg and typed_arg[i][0] is int: 
                if e[0] == 'CONST':
                    ref_0 = e[1]
                    if type(ref_0) is float:
                        if math.isinf(ref_0) or math.isnan(ref_0):
                            ref_0 = float_str(ref_0)
                else:    
                    ref_0 = generate_int_expr(e, o, True)
                    if ref_0 is None:
                        ref_0 = Expr1(e, o)
                        if istempref(ref_0):
                            typ3 = New('long')
                            o.Raw(typ3, ' = PyInt_AS_LONG ( ', ref_0, ' );')
                            o.Cls(ref_0)
                            ref_0 = typ3
                        else:
                            ref_0 = ConC('PyInt_AS_LONG ( ', ref_0, ' )')
            elif i in typed_arg and typed_arg[i][0] is float:
                if e[0] == 'CONST':
                    ref_0 = e[1]
                else:    
                    ref_0 = Expr1(e, o)
                    typ3 = New('double')
                    o.Raw(typ3, ' = PyFloat_AS_DOUBLE ( ', ref_0, ' );')
                    o.Cls(ref_0)
                    ref_0 = typ3
            elif i in typed_arg and typed_arg[i][0] is bool:
                if e[0] == 'CONST':
                    if e[1]:
                        ref_0 = 1
                    else:
                        ref_0 = 0  
                else:    
                    typ3 = New('int')
                    ref_0 = Expr1(e, o)
                    o.Raw(typ3, ' = PyObject_IsTrue(', ref_0, ');')
                    o.Cls(ref_0)
                    ref_0 = typ3
            elif i in typed_arg and typed_arg[i][0] is str and typed_arg[i][1] == 1:
                ref_0 = Expr1(e, o)
                if ref_0[0] == 'CONST':
                    ref_0 = charhex(ref_0[1])
                else:    
                    typ3 = New('char')
                    o.Raw(typ3, ' = *', Str_AS_STRING(ref_0), ';')
                    o.Cls(ref_0)
                    ref_0 = typ3
            elif is_varargs and i >= argcount:
                ref_0 = e
            else:      
                if i in di:
                    ref_0 = get_tuple_pack_arg(e, d)
                else:
                    ref_0 = Expr1(e, o)
            refs.append(ref_0)          
    elif it[2][0] == 'CONST':
        refs = []
        for i, e in enumerate(it[2][1]):
            ref_0 = ('CONST', e)
            if i in typed_arg and typed_arg[i][0] is int:
                ref_0 = ref_0[1]
            elif i in typed_arg and typed_arg[i][0] is float:
                ref_0 = ref_0[1]
                if type(ref_0) is float:
                    if math.isinf(ref_0) or math.isnan(ref_0):
                        ref_0 = float_str(ref_0)
            elif i in typed_arg and typed_arg[i][0] is bool:
                if ref_0[1]:
                    ref_0 = 1
                else:
                    ref_0 = 0    
            elif i in typed_arg and typed_arg[i][0] is str and typed_arg[i][1] == 1:
                if ref_0[0] == 'CONST':
                    ref_0 = charhex(ref_0[1])
                else:    
                    typ3 = New('char')
                    o.Raw(typ3, ' = *', Str_AS_STRING(ref_0), ';')
                    o.Cls(ref_0)
                    ref_0 = typ3
            refs.append(ref_0)
    else:
        Fatal('GenExpr', it)
        assert False
        return
    assert type(refs) is list
       
    if not is_varargs:
        if argcount != len(refs):
            if argcount > len(refs):
                if it[1] in default_args:
                    if is_const_default:
                        _refs2 = [('CONST', x) for x in default_args[it[1]][1]]
                    else:
                        _refs2 = []
                        defaul = 'GETSTATIC(' + co.default_args_nm() + ')'
                        for jj, x in enumerate(default_args[it[1]][1]):
                            if x[0] == 'CONST':
                                _refs2.append(x)
                            else:
                                y = New()
                                o.Raw(y, ' = PyTuple_GET_ITEM ( ', defaul, ' , ', jj, ');')
                                o.Raw('Py_INCREF(',y,');')                        
                                _refs2.append(y)

                    add_args = argcount - len(refs)
                    pos_args = len(_refs2) - add_args
                    len_refs = len(refs)                       
                    for i1, ref_0 in enumerate(_refs2[pos_args:]):
                        i = i1 + len_refs
                        if i in typed_arg and typed_arg[i][0] is int:
                            if ref_0[0] == 'CONST':
                                ref_0 = ref_0[1]
                            else:    
                                if istempref(ref_0):
                                    typ3 = New('long')
                                    o.Raw(typ3, ' = PyInt_AS_LONG ( ', ref_0, ' );')
                                    o.Cls(ref_0)
                                    ref_0 = typ3
                                else:
                                    ref_0 = ConC('PyInt_AS_LONG ( ', ref_0, ' )')                                    
                        elif i in typed_arg and typed_arg[i][0] is bool:
                            if ref_0[0] == 'CONST':
                                if ref_0[1]:
                                    ref_0 = 1
                                else:
                                    ref_0 = 0  
                            else:    
                                typ3 = New('int')
                                o.Raw(typ3, ' = PyObject_IsTrue(', ref_0, ');')
                                o.Cls(ref_0)
                                ref_0 = typ3
                        elif i in typed_arg and typed_arg[i][0] is str and typed_arg[i][1] == 1:
                            if ref_0[0] == 'CONST':
                                ref_0 = charhex(ref_0[1])
                            else:    
                                typ3 = New('char')
                                o.Raw(typ3, ' = *', Str_AS_STRING(ref_0), ';')
                                o.Cls(ref_0)
                                ref_0 = typ3
                        refs.append(ref_0)                      
    else: 
        assert len(hidden) == 0
        lenrefs = len(refs)
        if argcount > len(refs):
            if it[1] in default_args:
                if is_const_default:
                    _refs2 = [('CONST', x) for x in default_args[it[1]][1]]
                else:
                    pp('/111 !!', 'Strange default value', default_args[it[1]])
                    _refs2 = [Expr1(x, o) for x in default_args[it[1]]]
                add_args = argcount - len(refs)
                pos_args = len(_refs2) - add_args
                refs = refs + _refs2[pos_args:]
        rargs = refs[:argcount]
        rtupl = refs[argcount:]
        isconst = all([x[0] == 'CONST' for x in rtupl])
        if not isconst and pynumbadd and len(rtupl) == 1:
            rtupl2 = Expr1(tuple(rtupl[0]), o)
        elif isconst:
            rtupl2 = Expr1(('CONST', tuple([x[1] for x in rtupl])), o)
        else:    
            rtupl2 = Expr1(('!BUILD_TUPLE', tuple(rtupl)), o)
        argcount += 1
        for i, e in enumerate(rargs):
            if i < lenrefs:
                continue
            if i in typed_arg and IsCType(typed_arg[i]) and IsCVar(e) and \
                    Type2CType(typed_arg[i]) == Type2CType(TypeExpr(e)):
                ref_0 = CVarName(e)
            elif i in typed_arg and typed_arg[i][0] is int and type(e) is tuple: 
                if e[0] == 'CONST':
                    ref_0 = e[1]
                else:    
                    ref_0 = Expr1(e, o)
                    if istempref(ref_0):
                        typ3 = New('long')
                        o.Raw(typ3, ' = PyInt_AS_LONG ( ', ref_0, ' );')
                        o.Cls(ref_0)
                        ref_0 = typ3
                    else:
                        ref_0 = ConC('PyInt_AS_LONG ( ', ref_0, ' )')    
            elif i in typed_arg and typed_arg[i][0] is float and type(e) is tuple:
                if e[0] == 'CONST':
                    ref_0 = e[1]
                    if type(ref_0) is float:
                        if math.isinf(ref_0) or math.isnan(ref_0):
                            ref_0 = float_str(ref_0)
                else:    
                    ref_0 = Expr1(e, o)
                    typ3 = New('double')
                    o.Raw(typ3, ' = PyFloat_AS_DOUBLE ( ', ref_0, ' );')
                    o.Cls(ref_0)
                    ref_0 = typ3
            elif i in typed_arg and typed_arg[i][0] is bool and type(e) is tuple:
                if e[0] == 'CONST':
                    if e[1]:
                        ref_0 = 1
                    else:
                        ref_0 = 0  
                else:    
                    typ3 = New('int')
                    ref_0 = Expr1(e, o)
                    o.Raw(typ3, ' = PyObject_IsTrue(', ref_0, ');')
                    o.Cls(ref_0)
                    ref_0 = typ3
            elif i in typed_arg and IsChar(tuple(typed_arg[i][0:2])) and type(e) is tuple:
                ref_0 = Expr1(e, o)
                if ref_0[0] == 'CONST':
                    ref_0 = charhex(ref_0[1])
                else:    
                    typ3 = New('char')
                    o.Raw(typ3, ' = *', Str_AS_STRING(ref_0), ';')
                    o.Cls(ref_0)
                    ref_0 = typ3
            else:        
                ref_0 = e 
            rargs[i] = ref_0
        refs = rargs + [rtupl2]

    assert type(refs) is list
    if len(refs) != argcount:
        pprint(('// 1', refs, it, g_co.co_name))
        pp(refs, argcount)
        pp(it)
        pprint(o[-40:])

    assert len(refs) == argcount      
    _refs2 = []
    for i,x in enumerate(refs):              
        if i not in hidden:
            _refs2.append(x)
    co_call = N2C(it[1])        
    if not co_call.IsRetVoid() and not co_call.IsRetBool() and not co_call.IsRetInt() and not co_call.IsRetFloat() and not co_call.IsRetChar():  
        if nmtypvar is None:     
            ref = New(None, forcenewg)
            tupl = (ref, '=', d_nm) + tuple(_refs2)
            o.Stmt(*tupl)
            if len(_refs2) > 0:
                o.Cls(*_refs2)
            return ref
        elif istemptyped(nmtypvar):
            ref = New(None, forcenewg)
            tupl = (ref, '=', d_nm) + tuple(_refs2)
            o.Stmt(*tupl)
            o.Stmt(nmtypvar, '=', 'PyObject_IsTrue', ref)
            assert CVar(nmtypvar).startswith('int_')
            o.Cls(*_refs2)
            o.Cls(ref)
            return [nmtypvar]
        else:
            assert False

    elif co_call.IsRetVoid():
        tupl = (d_nm,) + tuple(_refs2)
        li = ['if (',d_nm, '(']
        for i, re in enumerate(_refs2):
            if i > 0:
                li.append(', ')
            li.append(re)
        li.append(') == -1) goto ')
        li.append(labl)
        li.append(';')
        UseLabl()
        tupl = tuple(li) 
        o.Raw(*tupl)
        if len(_refs2) > 0:
            o.Cls(*_refs2)
        return ('CONST', None)
    elif co_call.IsRetBool() and type(nmtypvar) is not bool:
        if nmtypvar is not None:
            logical = nmtypvar    
        else:    
            logical = New('int')
        li = ['if ((',logical, ' = ', d_nm, '(']
        for i, re in enumerate(_refs2):
            if i > 0:
                li.append(', ')
            li.append(re)
        li.append(')) == -1) goto ')
        li.append(labl)
        li.append(';')
        UseLabl()
        tupl = tuple(li)    
        o.Raw(*tupl)
        if len(_refs2) > 0:
            o.Cls(*_refs2)
        if nmtypvar is None:    
            ref = New(None, forcenewg)
            o.Raw(ref, ' = PyBool_FromLong(', logical, ');')
            o.Cls(logical)
            return ref
        return
    elif co_call.IsRetBool() and type(nmtypvar) is bool:
        li = ['if (',d_nm, '(']
        for i, re in enumerate(_refs2):
            if i > 0:
                li.append(', ')
            li.append(re)
        li.append(') == -1) goto ')
        li.append(labl)
        li.append(';')
        UseLabl()
        tupl = tuple(li)    
        o.Raw(*tupl)
        if len(_refs2) > 0:
            o.Cls(*_refs2)
        return nmtypvar
    elif co_call.IsRetInt():
        if nmtypvar is not None:
            logical = nmtypvar    
        else:    
            logical = New('long')
        li = ['if ((',logical, ' = ', d_nm, '(']
        for i, re in enumerate(_refs2):
            if i > 0:
                li.append(', ')
            li.append(re)
        li.append(')) == -1 && PyErr_Occurred()) goto ')
        li.append(labl)
        li.append(';')
        UseLabl()
        tupl = tuple(li)    
        o.Raw(*tupl)
        if len(_refs2) > 0:
            o.Cls(*_refs2)
        if nmtypvar is None:    
            ref = New(None, forcenewg)
            o.PushInt(ref, logical)
            o.Cls(logical)
            return ref
        return
    elif co_call.IsRetFloat():
        if nmtypvar is not None:
            logical = nmtypvar    
        else:    
            logical = New('double')
        li = ['if ((',logical, ' = ', d_nm, '(']
        for i, re in enumerate(_refs2):
            if i > 0:
                li.append(', ')
            li.append(re)
        li.append(')) == -1 && PyErr_Occurred()) goto ')
        li.append(labl)
        li.append(';')
        UseLabl()
        tupl = tuple(li)    
        o.Raw(*tupl)
        if len(_refs2) > 0:
            o.Cls(*_refs2)
        if nmtypvar is None:    
            ref = New(None, forcenewg)
            o.Raw(ref, ' = PyFloat_FromDouble (', logical, ');')
            o.Cls(logical)
            return ref
        return
    elif co_call.IsRetChar():
        if nmtypvar is not None:
            logical = nmtypvar    
        else:    
            logical = New('char')
        li = ['if ((',logical, ' = ', d_nm, '(']
        for i, re in enumerate(_refs2):
            if i > 0:
                li.append(', ')
            li.append(re)
        li.append(')) == \'\\xff\' && PyErr_Occurred()) goto ')
        li.append(labl)
        li.append(';')
        UseLabl()
        tupl = tuple(li)    
        o.Raw(*tupl)
        if len(_refs2) > 0:
            o.Cls(*_refs2)
        if nmtypvar is None:    
            ref = New(None, forcenewg)
            o.Raw(ref, ' = PyString_FromStringAndSize ((char *)&', logical, ', 1);')
            o.Cls(logical)
            return ref
        return
    Fatal('')
    assert False
    return None

def Expr1_for_STR_CONCAT(x, o):
    if x[0] != '!CHR_BUILTIN':
        return LikeExpr1(x, o), False
    v2 = {}
    if len(o) >= 5 and TxMatch(o, len(o)-5, """
        {
        char __s[1];
        __s[0] = (unsigned char)long_$3;
        if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto label_$10;
        }""", v2):              
        return Expr1(x, o), False
    ref = Expr1(x, o)
    if TxMatch(o, len(o)-5, """
        {
        char __s[1];
        __s[0] = (unsigned char)long_$3;
        if ((temp[$0] = PyString_FromStringAndSize ( __s , 1 )) == 0) goto label_$10;
        }""", v2):  
            n2 = 'long_' + v2[3]
            if is_not_active_typed(n2):
                n2 = reactivate_typed(n2)
            assert type(n2) is not str
            del o[-5:]
            return n2, True
    return ref, False

def GenExpr_STR_CONCAT(it, o, forcenewg):
    assert type(it) is tuple
    assert type(o) is Out     
    args = it[1:]
    isstr = [IsStr(TypeExpr(x)) for x in args]
    if all(isstr):
        refs_ = [Expr1_for_STR_CONCAT(x, o) for x in args]
        refs = [x[0] for x in refs_]
        refs_ischr = [x[1] for x in refs_]
        l_vals = []
        for i, x in enumerate(args):
            ta = TypeExpr(x)
            if IsChar(ta):
                l_vals.append(1)
            elif x[0] != 'CONST' or type(x[1]) is not str:
                r0 = New('int')
                l_vals.append(r0)
                o.Raw(r0, ' = PyString_GET_SIZE ( ', refs[i], ' );')
            else:
                l_vals.append(len(x[1]))
        ref = New(None, forcenewg)
        var_len = ' + '.join([CVar(x) for x in l_vals])
        o.Raw(ref, ' = PyString_FromStringAndSize(NULL, ', var_len, ');')
        cref = New('charref')
        o.Raw(cref, ' = ', Str_AS_STRING(ref), ';')
        for i, x in enumerate(args):
            if l_vals[i] == 0:
                pass
            elif l_vals[i] == 1:
                if not refs_ischr[i]:
                    o.Raw('*', cref, '++ = *', Str_AS_STRING(refs[i]), ';')
                else:
                    o.Raw('*', cref, '++ = (unsigned char)', refs[i], ';')
            elif l_vals[i] == 2:
                o.Raw('*', cref, '++ = ', Str_AS_STRING(refs[i]), '[0];')
                o.Raw('*', cref, '++ = ', Str_AS_STRING(refs[i]), '[1];')
            elif l_vals[i] == 3:
                o.Raw('*', cref, '++ = ', Str_AS_STRING(refs[i]), '[0];')
                o.Raw('*', cref, '++ = ', Str_AS_STRING(refs[i]), '[1];')
                o.Raw('*', cref, '++ = ', Str_AS_STRING(refs[i]), '[2];')
            else:    
                o.Raw('memcpy(', cref, ', ', Str_AS_STRING(refs[i]), ', ', l_vals[i], ');')
                if i == len(args) - 1:
                    pass
                else:
                    o.Raw(cref, ' += ', l_vals[i], ';')
        o.Cls(*refs)            
        o.Cls(*l_vals)            
        o.Cls(cref)
        return ref    
    if len(it) > 4 and len(it) <= 64:
        return GenExpr(('!STR_CONCAT_N', len(it)-1) + it[1:], o, forcenewg)
    elif len(it) == 4:
        return GenExpr(('!STR_CONCAT3', it[1], it[2], it[3]), o, forcenewg)
    elif len(it) == 3:
        return GenExpr(('!STR_CONCAT2', it[1], it[2]), o, forcenewg)
    elif len(it) > 64:
        return GenExpr(('!STR_CONCAT_N', len(it[1:63])) + it[1:63] + ((('!STR_CONCAT',) + it[63:]),), o, forcenewg)
    else:
        Fatal('GenExpr', it)
        assert False

def call_fastcall(it, o, forcenewg):
    assert type(it) is tuple
    assert type(o) is Out     
    ref1 = LikeExpr1(it[1], o)
    if it[2] == ('CONST', ()):
        refs = []
    elif it[2][0] == '!BUILD_TUPLE':
        refs = Expr(o, it[2][1])
    elif it[2][0] == 'CONST':
        refs = [('CONST', x) for x in it[2][1]]
    else:
        Fatal('GenExpr call fastcall', it)
        assert False
        return
    assert type(refs) is list
    ref = New(None, forcenewg)
    if len(refs) == 0:
        tupl = (ref, ' = FastCall0(', ref1, ')')
        Used('FastCall0')
    else:    
        tupl = (ref, ' = FastCall(', len(refs), ', ', ref1)
        Used('FastCall')
        for _r in refs:
            tupl = tupl + (', ', _r)
        tupl = tupl + (')',)    
    tupl = ('if ((',) + tupl + (') == 0) goto ', labl, ';') 
    o.Raw(*tupl)
    UseLabl()
    if len(refs) > 0:
        o.Cls(*refs)
    o.Cls(ref1)    
    return ref

def generate_PyObject_Call_nokey(it, o, forcenewg):
    assert type(it) is tuple
    assert type(o) is Out     
    if it[1][0] == '!LOAD_GLOBAL' and it[1][1] in d_built:
        skip_built = False
        if it[2][0] == '!BUILD_TUPLE':
            args = it[2][1]
        elif it[2][0] == 'CONST':
            args = tuple([('CONST', x) for x in it[2][1]])
        else:
            skip_built = True
            args = []
        if not skip_built:    
            cm = attempt_direct_builtin(it[1][1],args, it[2])
            if cm is not None:
                proc = LikeExpr1(it[1], o)   
                o.Stmt('if (', proc, '==', load_builtin(it[1][1]), ') {')
                ref = GenExpr(cm, o,forcenewg)
                o.append('} else {')
                tupl = Expr1(it[2], o)
                o.Stmt(ref, '=', 'FirstCFunctionCall', proc, tupl, ('NULL',))
                o.Cls(tupl)
                o.append('}')
                o.Cls(proc)
                return ref
            
    if it[1][0] == '!LOAD_BUILTIN' and it[2][0] == '!BUILD_TUPLE' and \
       len(it[2][1]) == 1 and it[2][1][0][0] == '!LIST_COMPR' and it[1][1] in ('all', 'any'):
            prev_compr = g_co.list_compr_in_progress
            g_co.list_compr_in_progress = True
            it1 = it[2][1][0]
            
            logical = generate_func_list_compr(it1[1],it1[2],o, it[1][1]) 
            g_co.list_compr_in_progress = prev_compr
            ref = New(None, forcenewg)
            o.Stmt(ref, '=', 'PyBool_FromLong', logical)
            o.Cls(logical)
            return ref

    if it[1][0] == '!LOAD_BUILTIN' and it[2][0] == '!BUILD_TUPLE' and \
       len(it[2][1]) == 2 and it[1][1] in ('min', 'max'):
        t1 = TypeExpr(it[2][1][0])
        t2 = TypeExpr(it[2][1][1])
        if IsInt(t1) and IsInt(t2):
            ref1 = LikeExpr1(it[2][1][0],o)
            if ref1[0] == 'CONST' and type(ref1[1]) is int:
                n1 = ref1[1]
            else:
                v2 = {}
                if len(o) > 0 and TxMatch(o, len(o) - 1, "temp[$0] = PyInt_FromLong ( $1 );", v2):
                    n1 = '( ' + v2[1] + ' )'
                    o.Cls(ref1)
                    del o[-1]
                    del o[-1]
                    ref1 = None
                else:
                    n1 = ConC ('PyInt_AS_LONG ( ', ref1, ' )')
                
            ref2 = LikeExpr1(it[2][1][1],o)
            if ref2[0] == 'CONST' and type(ref2[1]) is int:
                n2 = ref2[1]
            else:
                v2 = {}
                if len(o) > 0 and TxMatch(o, len(o) - 1, "temp[$0] = PyInt_FromLong ( $1 );", v2):
                    n2 = '( ' + v2[1] + ' )'
                    o.Cls(ref2)
                    del o[-1]
                    del o[-1]
                    ref2 = None
                else:
                    n2 = ConC ('PyInt_AS_LONG ( ', ref2, ' )')
            ref = New(None, forcenewg)
            if it[1][1] == 'max':
                o.Stmt(ref, '=', 'PyInt_FromLong', ConC('PyIF( ', n1, ' > ', n2, ' , ', n1, ' , ', n2, ' )'))
            else:
                o.Stmt(ref, '=', 'PyInt_FromLong', ConC('PyIF( ', n1, ' > ', n2, ' , ', n2, ' , ', n1, ' )'))
            o.Cls(ref1, ref2)
            return ref
 

    s = save_tempgen()    
    o2 = Out()    
    proc = GenExpr(it[1],o2)
    o2.Cls(proc)
    restore_tempgen(s)
 
    if not IsBuiltFunc(TypeExpr(it[1])) and not is_mkfunc_const(proc, it[1]) and \
       it[2][0] in ('!BUILD_TUPLE', 'CONST') and len(it[2][1]) < 15 and it[1][0] != '!LOAD_BUILTIN' and\
       not accurate_frame(it):
        return call_fastcall(it, o, forcenewg) 
    ref = New(None, forcenewg)
    proc = GenExpr(it[1], o)
    tupl = GenExpr(it[2], o)   
    variant = not is_mkfunc_const(proc, it[1])
 
    t = TypeExpr(it[1])
    if IsBuiltFunc(t):
        o.Stmt(ref, '=', 'PyCFunction_Call', proc, tupl, ('NULL',))
    elif variant and not accurate_frame(it):    
        if it[1][0] == '!LOAD_BUILTIN':
            if it[1][1] in d_built and type(d_built[it[1][1]]) == type(len):
                o.Stmt(ref, '=', 'PyCFunction_Call', proc, tupl, ('NULL',))
            else:    
                Debug('+Call PyObject_Call builtin (variant)', it[1], TypeExpr(it[1]))
                o.Stmt(ref, '=', 'PyObject_Call', proc, tupl, ('NULL',))
        else:        
            o.Stmt(ref, '=', 'FirstCFunctionCall', proc, tupl, ('NULL',))
    else:
        o.Stmt(ref, '=', 'PyObject_Call', proc, tupl, ('NULL',))
    o.Cls(proc, tupl)
    return ref


def generate_PyObject_Call_with_dictionary(it, o, forcenewg):
    assert type(it) is tuple
    assert type(o) is Out  
    assert len(it) >= 4
    assert it[3] != ('NULL',) and it[3] != 'NULL'   
            
    if it[1][0] == '!LOAD_BUILTIN' and it[2][0] == '!BUILD_TUPLE' and \
       len(it[2][1]) == 1 and it[2][1][0][0] == '!LIST_COMPR' and it[1][1] in ('all', 'any'):
            pp('Call_w_Dict2', it)

    if it[1][0] == '!LOAD_BUILTIN' and it[2][0] == '!BUILD_TUPLE' and \
       len(it[2][1]) == 2 and it[1][1] in ('min', 'max'):
           pp('Call_w_Dict3', it)
 

    s = save_tempgen()    
    o2 = Out()    
    proc = GenExpr(it[1],o2)
    o2.Cls(proc)
    restore_tempgen(s)
 
    ref = New(None, forcenewg)
    proc = GenExpr(it[1], o)
    tupl = GenExpr(it[2], o)   
    variant = not is_mkfunc_const(proc, it[1])

    type_d = TypeExpr(it[3])
    d = None
    if IsDict(type_d):
        d = GenExpr(it[3], o)
    elif IsListAll(type_d) or IsTuple(type_d):
        if it[3][0] == 'CONST':
            pp('Call_w_Dict5 FromConst', it)
            d = GenExpr(('!PyObject_Call', ('!LOAD_BUILTIN', 'dict'), ('CONST', (it[3][1],)), ('NULL',)), o)
        else:
            d = GenExpr(('!PyObject_Call', ('!LOAD_BUILTIN', 'dict'), ('!BUILD_TUPLE', (it[3],)), ('NULL',)), o)
    else:
        d = GenExpr(('!PyObject_Call', ('!LOAD_BUILTIN', 'dict'), ('!BUILD_TUPLE', (it[3],)), ('NULL',)), o)

 
    t = TypeExpr(it[1])
    if IsBuiltFunc(t):
        o.Stmt(ref, '=', 'PyCFunction_Call', proc, tupl, d)
    elif variant and not accurate_frame(it):    
        if it[1][0] == '!LOAD_BUILTIN':
            if it[1][1] in d_built and type(d_built[it[1][1]]) == type(len):
                o.Stmt(ref, '=', 'PyCFunction_Call', proc, tupl, d)
            else:    
                Debug('+Call PyObject_Call builtin (variant)', it[1], TypeExpr(it[1]))
                o.Stmt(ref, '=', 'PyObject_Call', proc, tupl, d)
        else:        
            o.Stmt(ref, '=', 'FirstCFunctionCall', proc, tupl, d)
    else:
        o.Stmt(ref, '=', 'PyObject_Call', proc, tupl, d)
    o.Cls(proc, tupl, d)
    
    return ref

def short_gen_size_t(it, check = False):
    o1 = None
    ind1 = None
    if type(it) is int:
        return Out(), it
    if type(it) is tuple:
        o1 = Out()
        ind1 = generate_int_expr(it, o1, check)
        if len(o1) == 0 and ind1 is not None:
            return o1, ind1
    if ind1 is not None:
        return o1, ind1
##    t = TypeExpr(it)
    assert type(o1) is Out
    o1.Cls(ind1)
    o2, ind2 = shortage( generate_ssize_t_expr(it))
    assert type(o2) is Out
    if ind1 is not None and (ind1 != ind2 or o2 != o1):
        optimize(o1)
        if ind1 is not None and (ind1 != ind2 or o2 != o1) and not(ind1 == ind2 and len(o2) > len(o1)):
            pp('================')
            pprint(o1)
            pp(ind1)
            pp('----------')
            pp(ind2)
            pprint(o2)
            pp('=============')
    return o2, ind2
    
def common_call(head, it, o, typed, forcenewg):
    assert type(it) is tuple
    assert type(o) is Out     
    verif(it)

    if head == '_PyEval_ApplySlice':
        t0 = TypeExpr(it[1])
        t1 = TypeExpr(it[2])
        t2 = TypeExpr(it[3])
        if it[2] == 'NULL' and IsInt(t2):
            ref0 = LikeExpr1(it[1], o)
            o2,ind2 = short_gen_size_t(it[3])
            o.extend(o2)
            ref = New(None, forcenewg)
            if IsStr(t0):
                if IsCardinal(t2):
                    o.Raw('if ( ', ind2, ' <= PyString_GET_SIZE ( ', ref0, ' ) ) {')
                    o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', ref0, ' ) , ', ind2, ' );')
                    o.Raw('} else {')
                    o.Raw(ref, ' = ', ('CONST', ''), ';')
                    o.INCREF(ref)
                    o.Raw('}')
                elif t2[1][1] < 0:
                    o.Raw('if ( ', ind2, ' >= -PyString_GET_SIZE ( ', ref0, ' ) ) {')
                    o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', ref0, ' ) , PyString_GET_SIZE ( ', ref0, ' ) - ', ind2, ' );')
                    o.Raw('} else {')
                    o.Raw(ref, ' = ', ('CONST', ''), ';')
                    o.INCREF(ref)
                    o.Raw('}')
                else:
                    o.Raw('if ( ', ind2, ' >= 0 && ', ind2, ' <= PyString_GET_SIZE ( ', ref0, ' ) ) {')
                    o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', ref0, ' ) , ', ind2, ' );')
                    o.Raw('} else if ( ', ind2, ' < 0 && ', ind2, ' >= -PyString_GET_SIZE ( ', ref0, ' ) ) {')
                    o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', ref0, ' ) , PyString_GET_SIZE ( ', ref0, ' ) - ', ind2, ' );')
                    o.Raw('} else {')
                    o.Raw(ref, ' = ', ('CONST', ''), ';')
                    o.INCREF(ref)
                    o.Raw('}')
            elif IsList(t0) and IsCardinal(t2):
                o.Stmt(ref, '=', 'PyList_GetSlice', ref0, '0', ind2)
            elif IsTuple(t0) and IsCardinal(t2):
                o.Stmt(ref, '=', 'PyTuple_GetSlice', ref0, '0', ind2)
            else:
                o.Stmt(ref, '=', 'PySequence_GetSlice', ref0, '0', ind2)
            o.Cls(ind2, ref0)
            return ref
        if it[3] == 'NULL' and IsInt(t1):
            ref0 = LikeExpr1(it[1], o)
            o1,ind1 = short_gen_size_t(it[2])
            o.extend(o1)
            ref = New(None, forcenewg)
            if IsStr(t0):
                if IsCardinal(t1):
                    o.Raw('if ( ', ind1, ' <= PyString_GET_SIZE ( ', ref0, ' ) ) {')
                    o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', ref0, ' ) + ', ind1, ' , PyString_GET_SIZE ( ', ref0, ' ) - ', ind1, ' );')
                    o.Raw('} else {')
                    o.Raw(ref, ' = ', ('CONST', ''), ';')
                    o.INCREF(ref)
                    o.Raw('}')
                elif t1[1][1] < 0:
                    o.Raw('if ( ', ind1, ' >= -PyString_GET_SIZE ( ', ref0, ' ) ) {')
                    o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', ref0, ' ) + ( PyString_GET_SIZE ( ', ref0, ' ) + ', ind1, ' ) , - ', ind1, ' );')
                    o.Raw('} else {')
                    o.Raw(ref, ' = ', ('CONST', ''), ';')
                    o.INCREF(ref)
                    o.Raw('}')
                else:
                    o.Raw('if ( ', ind1, ' >= 0 && ', ind1, ' <= PyString_GET_SIZE ( ', ref0, ' ) ) {')
                    o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', ref0, ' ) + ', ind1, ' , PyString_GET_SIZE ( ', ref0, ' ) - ', ind1, ' );')
                    o.Raw('} else if ( ', ind1, ' < 0 && ', ind1, ' >= -PyString_GET_SIZE ( ', ref0, ' ) ) {')
                    o.Raw(ref, ' = PyString_FromStringAndSize ( PyString_AS_STRING ( ', ref0, ' ) + ( PyString_GET_SIZE ( ', ref0, ' ) + ', ind1, ' ) , - ', ind1, ' );')
                    o.Raw('} else {')
                    o.Raw(ref, ' = ', ('CONST', ''), ';')
                    o.INCREF(ref)
                    o.Raw('}')
            elif IsList(t0) and IsCardinal(t1):
                o.Stmt(ref, '=', 'PyList_GetSlice', ref0, ind1, 'PY_SSIZE_T_MAX')
            elif IsTuple(t0) and IsCardinal(t1):
                o.Stmt(ref, '=', 'PyTuple_GetSlice', ref0, ind1, 'PY_SSIZE_T_MAX')
            else:
                o.Stmt(ref, '=', 'PySequence_GetSlice', ref0, ind1, 'PY_SSIZE_T_MAX')
            o.Cls(ind1, ref0)
            return ref  
        elif IsInt(t1) and IsInt(t2):      
            ref0 = LikeExpr1(it[1], o)
            o1,ind1 = short_gen_size_t(it[2])
            o.extend(o1)
            o2,ind2 = short_gen_size_t(it[3])
            o.extend(o2)
            ref = New(None, forcenewg)
            assert ind1 != ind2
            if IsList(t0) and IsCardinal(t1) and IsCardinal(t2):
                o.Stmt(ref, '=', 'PyList_GetSlice', ref0, ind1, ind2)
            elif IsTuple(t0) and IsCardinal(t1) and IsCardinal(t2):
                o.Stmt(ref, '=', 'PyTuple_GetSlice', ref0, ind1, ind2)
            else:
                o.Stmt(ref, '=', 'PySequence_GetSlice', ref0, ind1, ind2)
            o.Cls(ind1, ind2, ref0)
            return ref              
        it1 = Expr1(it[1], o)
        it2 = it[2]
        if it2 != 'NULL':
            it2 = GenExpr(it2,o, None,None, True)
        it3 = it[3]
        if it3 != 'NULL':
            it3 = GenExpr(it3,o, None,None, True)
        gen = [ it1, it2, it3]
    else:
        gen = [LikeExpr1(x, o) if type(x) is tuple and len(x) > 0 else x \
                    for i,x in enumerate(it) if i > 0]
    if head == '_PyInt_Format':
        gen[0] = ('TYPE_CONVERSION', '(PyIntObject *)', gen[0])      
    if head == '_PyList_Extend':
        gen[0] = ('TYPE_CONVERSION', '(PyListObject *)', gen[0])      
    newg = New(typed, forcenewg)  
    args = (newg, '=', head)  + tuple(gen)       
    o.Stmt(*args)
    o.Cls(*gen)
    return newg   

def GenBitExpr(it, o, forcenewg):
    assert type(it) is tuple
    assert type(o) is Out     
    head = it[0]
    assert type(head) is str

    n1, n2 = None, None
    if it[1][0] == 'CONST':
        n1 = it[1][1]
        ref1 = it[1]
    else:
        if not IsCVar(it[1]):
            ref1 = GenExpr(it[1], o, None, None, True)
        else:
            n1 = CVarName(it[1])
            ref1 = None        
        
    if it[2][0] == 'CONST':
        n2 = it[2][1]
        ref2 = it[2]
    else:
        if not IsCVar(it[2]):
            ref2 = GenExpr(it[2], o, None, None, True)
        else:
            n2 = CVarName(it[2])
            ref2 = None   
    if forcenewg is not None:
        new = forcenewg
    else:
        new = New()    
    check = True    
    t1 = TypeExpr(it[1])
    t2 = TypeExpr(it[2])
    is_eqarg = is_eq_arg(it[1],it[2])
    skip_int = not_int_op(ref1, ref2, it[1], it[2])
    if (IsIntUndefSize(t1) and IsIntUndefSize(t2)) or (IsInt(t1) and IsIntUndefSize(t2)) or (IsIntUndefSize(t1) and IsInt(t2))\
        or (IsInt(t1) and IsInt(t2)):
            skip_int = False    
    cl_r1, cl_r2 = False, False
    if not skip_int:
        check = not IsInt(t1) or not IsInt(t2)
        if it[1][0] != 'CONST' and it[2][0] != 'CONST':
            if check:
                if IsInt(t1):
                    assert ref2 is not None
                    o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
                elif IsInt(t2):
                    assert ref1 is not None
                    o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
                else:
                    assert ref1 is not None and ref2 is not None
                    if is_eqarg:
                        o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
                    else:
                        o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' )) {')
            if n1 is None:
                n1 = 'PyInt_AS_LONG ( ' + CVar(ref1) + ' )'
            if n2 is None:
                n2 = 'PyInt_AS_LONG ( ' + CVar(ref2) + ' )'
        elif it[1][0] == 'CONST' and it[2][0] != 'CONST' and type(it[1][1]) is int:
            if check:
                o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
            n1 = str(it[1][1])
            if n2 is None:
                n2 = 'PyInt_AS_LONG ( ' + CVar(ref2) + ' )'
        elif it[1][0] != 'CONST' and it[2][0] == 'CONST' and type(it[2][1]) is int:
            if check:
                o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            if n1 is None:
                n1 = 'PyInt_AS_LONG ( ' + CVar(ref1) + ' )'
            n2 = str(it[2][1])
        else:
            skip_int = True
    op = '???'
    if not skip_int:
        if head == '!PyNumber_And' or head == '!PyNumber_InPlaceAnd':
            op = '&'
        elif head == '!PyNumber_Or' or head == '!PyNumber_InPlaceOr':
            op = '|'
        elif head == '!PyNumber_Xor' or head == '!PyNumber_InPlaceXor':
            op = '^'
        elif head == '!PyNumber_Rshift' or head == '!PyNumber_InPlaceRshift':
            op = '>>'
        elif head == '!PyNumber_Lshift' or head == '!PyNumber_InPlaceLshift':
            op = '<<'
        if op in ('&', '|') and is_eqarg:
            o.Raw(new, ' = ', ref1, ';')
            o.INCREF(new)
        elif op == '^' and is_eqarg:
            o.Raw(new, ' = ', ('CONST', 0), ';')
            o.INCREF(new)
        else:
            o.PushInt(new, ConC(n1, ' ', op, ' ', n2))
    if check and not skip_int:
        o.append('} else {')
        if ref1 is None:
            ref1 = New()
            o.Raw (ref1, ' = PyInt_FromLong ( ', n1, ' );')
            cl_r1 = True
        if ref2 is None:
            ref2 = New()
            o.Raw (ref2, ' = PyInt_FromLong ( ', n2, ' );')
            cl_r2 = True
        assert ref1 is not None and ref2 is not None
        o.Stmt(new, '=', head[1:], ref1, ref2)
        if cl_r1:
            o.Cls(ref1)
        if cl_r2:
            o.Cls(ref2)              
        o.append('}')
    elif check and skip_int:    
        verif(it)
        if ref1 is None:
            ref1 = New()
            o.Raw (ref1, ' = PyInt_FromLong ( ', n1, ' );')
            cl_r1 = True
        if ref2 is None:
            ref2 = New()
            o.Raw (ref2, ' = PyInt_FromLong ( ', n2, ' );')
            cl_r2 = True        
        assert ref1 is not None and ref2 is not None
        o.Stmt(new, '=', head[1:], ref1, ref2)
        if cl_r1:
            o.Cls(ref1)
        if cl_r2:
            o.Cls(ref2)           
    elif not check and not skip_int:
        pass
    else:
        verif(it)
        assert ref1 is not None and ref2 is not None
        o.Stmt(new, '=', head[1:], ref1, ref2)
    o.Cls(ref1, ref2)
    return new

def ErrHandler(o, err, cond):
    assert type(cond) is str
    o_2 = Out() 
    o_2.Raw(err)
    o_2.Raw('goto ', labl, ';')
    tolabl = append_to_exception(o_2)                   
    UseLabl()      
    if cond is True or cond == '1':
        o.Raw('goto ', tolabl, ';')    
    elif cond is False or cond == '0':
        pass
    else:    
        o.Raw('if ( ',cond, ' ) goto ', tolabl, ';')      
    return

def IntDivErrHandler(o, cond):
    ErrHandler(o, 'PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");', cond)

def NegShiftErrHandler(o, cond):
    ErrHandler(o, 'PyErr_SetString(PyExc_ValueError, "negative shift count");', cond)

def StrIndexErrHandler(o, cond):
    ErrHandler(o, 'PyErr_SetString(PyExc_IndexError, "string index out of range");', cond)

def ChrRangeErrHandler(o, cond):
    ErrHandler(o, 'PyErr_SetString(PyExc_ValueError, \"chr() arg not in range(256)\");', cond)

arifm_n = {'!PyNumber_Multiply':'*', '!PyNumber_Divide':'/', '!PyNumber_Add':'+', '!PyNumber_Subtract':'-'}

def GenNumberExpr(it, o, forcenewg, typed, skip_float):
    assert type(it) is tuple
    assert type(o) is Out     
    global arifm_n
    if it[0] not in ('!PyNumber_Long', '!PyNumber_TrueDivide', '!PyNumber_ToBase'):
        attempt = attempt_direct_type_generation(it, o, forcenewg)
        if attempt is not None:
            return attempt
    head = it[0]
    assert type(head) is str
    if (head == '!PyNumber_Lshift' or head == '!PyNumber_InPlaceLshift'):
        t1 = TypeExpr(it[1])
        t2 = TypeExpr(it[2])
        if it[2][0] == 'CONST' and type(it[2][1]) is int and it[2][1] >= 1 and it[2][1] <= 31:
            shif = it[2][1]
            if IsShort(t1) and shif < 16:
                if it[1][0] == '!@PyInt_FromSsize_t':
                    ref1 = None
                    n1 = New('long')
                    o.Raw(n1, ' = ', it[1][1], ';')
                elif IsCVar(it[1]):
                    n1 = CVarName(it[1])
                    ref1 = None                    
                else:    
                    ref1 = GenExpr(it[1], o, None, None, True)
                    n1 = New('long')
                    o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
                    o.Cls(ref1)
                if forcenewg is not None:
                    new = forcenewg
                else:
                    new = New()    
                o.PushInt(new, ConC('(', n1, ' << ', it[2][1], ')'))
                o.Cls(n1)
                return new
            elif IsInt(t1):
                if it[1][0] == '!@PyInt_FromSsize_t':
                    ref1 = None
                    n1 = New('long')
                    o.Raw(n1, ' = ', it[1][1], ';')
                elif IsCVar(it[1]):
                    n1 = CVarName(it[1])
                    ref1 = None                    
                else:    
                    ref1 = GenExpr(it[1], o, None, None, True)
                    n1 = New('long')
                    o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
                if forcenewg is not None:
                    new = forcenewg
                else:
                    new = New()    
                o.Raw('if (', n1, ' < (LONG_MAX >> ', it[2][1], ') && ', n1, ' >= 0) {')
                o.PushInt(new, ConC('(', n1, ' << ', it[2][1], ')'))
                o.Cls(n1)
                o.Raw('} else {')
                if ref1 is None:
                    ref1 = Expr1(it[1], o)
                    o.Raw('if ((', new, ' = ', head[1:], '(', ref1, ', ', it[2], ')) == 0) goto ', labl, ';')
                    o.Cls(ref1)
                else:
                    o.Raw('if ((', new, ' = ', head[1:], '(', ref1, ', ', it[2], ')) == 0) goto ', labl, ';')
                UseLabl()
                o.append('}')
                o.Cls(ref1)
                return new
            elif IsIntUndefSize(t1) or t1 is None:
                ref1 = GenExpr(it[1], o, None, None, True)
                n1 = New('long')
                if forcenewg is not None:
                    new = forcenewg
                else:
                    new = New()    
                o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && (', n1, ' = PyInt_AS_LONG ( ', ref1, ' )) < (LONG_MAX >> ', it[2][1], ') && ', n1, ' >= 0) {')
                o.PushInt(new, ConC('(', n1, ' << ', it[2][1], ')'))
                o.Cls(n1)
                o.Raw('} else {')
                o.Raw('if ((', new, ' = ', head[1:], '(', ref1, ', ', it[2], ')) == 0) goto ', labl, ';')
                UseLabl()
                o.append('}')
                o.Cls(ref1)
                return new 
        if it[1] == ('CONST', 1) and type(it[1][1]) is int:    
            if IsInt(t2):
                ref1 = GenExpr(it[2], o, None, None, True)
                n1 = New('long')
                o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 

                if forcenewg is not None:
                    new = forcenewg
                else:
                    new = New()    

                o.Raw('if (', n1, ' < (LONG_BIT-1)) {')
                o.PushInt(new, ConC('(0x1 << ', n1, ')'))
                o.Cls(n1)
                o.Raw('} else {')
                o.Raw('if ((', new, ' = ', head[1:], '(', it[1], ', ', ref1, ')) == 0) goto ', labl, ';')
                UseLabl()
                o.append('}')
                o.Cls(ref1)
                return new
            elif IsIntUndefSize(t2) or t2 is None:
                ref1 = GenExpr(it[2], o, None, None, True)
                n1 = New('long')
                if forcenewg is not None:
                    new = forcenewg
                else:
                    new = New()    
                o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && (', n1, ' = PyInt_AS_LONG ( ', ref1, ' )) < (LONG_BIT-1)) {')
                o.PushInt(new, ConC('(0x1 << ', n1, ')'))
                o.Cls(n1)
                o.Raw('} else {')
                o.Raw('if ((', new, ' = ', head[1:], '(', it[1], ', ', ref1, ')) == 0) goto ', labl, ';')
                UseLabl()
                o.append('}')
                o.Cls(ref1)
                return new
        if it[1][0] == '!PyNumber_And' and IsShort(TypeExpr(it[1])) and IsInt(TypeExpr(it[2])):    
            bitmax = None
            if it[1][1][0] == 'CONST':
                bitmax = it[1][1][1]
                assert bitmax >= 0
            if it[2][1][0] == 'CONST':
                bitmax = max(bitmax, it[2][1][1])
                assert it[2][1][1] >= 0
            if bitmax is not None:
                lenbit = 0
                while bitmax != 0:
                    lenbit += 1
                    bitmax >>= 1
                assert lenbit > 0    
                if lenbit < 32:
                    ref1 = GenExpr(it[1], o, None, None, True)
                    n0 = New('long')
                    o.Raw(n0, ' = PyInt_AS_LONG ( ', ref1, ' );') 
                    o.Cls(ref1)
                    ref1 = Expr1(it[2], o)
                    n1 = New('long')
                    o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
    
                    if forcenewg is not None:
                        new = forcenewg
                    else:
                        new = New()    
    
                    o.Raw('if (', n1, ' < (LONG_BIT - ',lenbit,')) {')
                    o.PushInt(new, ConC('(',n0,' << ', n1, ')'))
                    o.Cls(n1)
                    o.Raw('} else {')
                    ref2 = New()
                    o.Raw (ref2, ' = PyInt_FromLong ( ', n0, ' );')                
                    o.Raw('if ((', new, ' = ', head[1:], '(', ref2, ', ', ref1, ')) == 0) goto ', labl, ';')
                    UseLabl()
                    o.Cls(ref2)
                    o.append('}')
                    o.Cls(ref1)
                    o.Cls(n0)
                    return new
                
    if head == '!PyNumber_Rshift' or head == '!PyNumber_InPlaceRshift':
        t1 = TypeExpr(it[1])
        t2 = TypeExpr(it[2])
        if it[2][0] == 'CONST' and type(it[2][1]) is int and (31 >= it[2][1] >= 1) and IsInt(t1):
            if it[1][0] == '!@PyInt_FromSsize_t':
                ref1 = None
                n1 = New('long')
                o.Raw(n1, ' = ', it[1][1], ';')
            else:    
                ref1 = GenExpr(it[1], o, None, None, True)
                n1 = New('long')
                o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
                o.Cls(ref1)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
            o.Raw(n1, ' = Py_ARITHMETIC_RIGHT_SHIFT(long, ', n1, ', ', it[2][1], ');')
            o.PushInt(new, n1)
            o.Cls(n1)
            return new
        if it[2][0] == 'CONST' and type(it[2][1]) is int and (31 >= it[2][1] >= 1) and t1 is None:
            ref1 = GenExpr(it[1], o, None, None, True)
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            n1 = New('long')
            o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
            o.Raw(n1, ' = Py_ARITHMETIC_RIGHT_SHIFT(long, ', n1, ', ', it[2][1], ');')
            o.PushInt(new, n1)
            o.Cls(n1)
            o.append('} else {')
            o.Raw('if ((', new, ' = ', head[1:], '(', ref1, ', ', it[2], ')) == 0) goto ', labl, ';')
            UseLabl()
            o.append('}')
            o.Cls(ref1)
            return new
        if IsInt(t1) and IsInt(t2):
            if it[1][0] == 'CONST':
                n1 = it[1][1]
            else:
                ref1 = GenExpr(it[1], o, None, None, True)
                n1 = New('long')
                o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );')
                o.Cls(ref1) 
            if it[2][0] == 'CONST':
                n2 = it[2][1]
            else:
                ref2 = Expr1(it[2], o)
                n2 = New('long')
                o.Raw(n2, ' = PyInt_AS_LONG ( ', ref2, ' );') 
                o.Cls(ref2) 
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()     
            if type(n2) is not int:
                NegShiftErrHandler(o, ConC(n2, ' < 0'))
            elif n2 >= 0:
                pass
            elif n2 < 0:
                NegShiftErrHandler(o, '1')
        
            o.Raw(new, ' = PyInt_FromLong ( _PyInt_Rshift ( ', n1, ', ', n2, ' ) );')
            Used('_PyInt_Rshift')
            o.Cls(n1, n2)
            return new
        if ( IsIntUndefSize(t1) or t1 is None ) and IsInt(t2):
            ref1 = GenExpr(it[1], o, None, None, True)
            if it[2][0] == 'CONST':
                n2 = it[2][1]
                ref2 = it[2]
            else:
                if not IsCVar(it[2]):
                    ref2 = Expr1(it[2], o)
                    n2 = New('long')
                    o.Raw(n2, ' = PyInt_AS_LONG ( ', ref2, ' );') 
                else:
                    n2 = CVarName(it[2])
                    ref2 = None
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()             
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            if type(n2) is not int:
                NegShiftErrHandler(o, ConC(n2, ' < 0'))
            elif n2 >= 0:
                pass
            elif n2 < 0:
                NegShiftErrHandler(o, '1')
            o.Raw(new, ' = PyInt_FromLong ( _PyInt_Rshift ( PyInt_AS_LONG ( ', ref1, ' ), ', n2, ' ) );')
            o.append('} else {')
            if ref2 is None:
                ref2 = Expr1(it[2], o)
                o.Raw('if ((', new, ' = ', head[1:], '(', ref1, ', ', ref2, ')) == 0) goto ', labl, ';')
                o.Cls(ref2)
            else:
                o.Raw('if ((', new, ' = ', head[1:], '(', ref1, ', ', ref2, ')) == 0) goto ', labl, ';')

            UseLabl()
            o.append('}')
            o.Cls(ref1, ref2, n2)
            Used('_PyInt_Rshift')
            return new
        if not IsLong(t2) and not IsLong(t1):
            n1, n2 = None, None
            ref1, ref2 = None, None
            if IsCVar(it[1]):
                n1 = CVarName(it[1])
            elif it[1][0] == 'CONST':
                n1 = it[1][1]
            else:
                ref1 = GenExpr(it[1], o, None, None, True)
            if n1 is None:
                n1 = ConC('PyInt_AS_LONG ( ', ref1, ' )')
            if IsCVar(it[2]):
                n2 = CVarName(it[2])
            elif it[2][0] == 'CONST':
                n2 = it[2][1]
            else:
                ref2 = Expr1(it[2], o)
            if n2 is None:
                n2 = ConC('PyInt_AS_LONG ( ', ref2, ' )')

    
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()     
            if IsInt(t2):
                if ref1 is None:
                    pprint(it)
                    pp(t1, t2)
                    
                assert ref1 is not None
                o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')        
            elif IsInt(t1):
                o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
                assert ref2 is not None
            else:
                assert not IsInt(t1) and not IsInt(t2)
                assert ref1 is not None
                assert ref2 is not None
                o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' )) {')
            if IsInt(t2) and it[2][0] == 'CONST' and it[2][1] >= 0:   
                o.Raw(new, ' = PyInt_FromLong ( _PyInt_Rshift ( ', n1,', ', it[2][1], ' ) );')
            else:
                NegShiftErrHandler(o, ConC('PyInt_AS_LONG ( ', ref2, ' ) < 0'))
                o.Raw(new, ' = PyInt_FromLong ( _PyInt_Rshift ( ', n1,', ', n2,' ) );')
            o.append('} else {')
            cl_r1, cl_r2 = False, False
            if ref1 is None:
                ref1 = New()
                o.Raw (ref1, ' = PyInt_FromLong ( ', n1, ' );')
                cl_r1 = True
            if ref2 is None:
                ref2 = New()
                o.Raw (ref2, ' = PyInt_FromLong ( ', n2, ' );')
                cl_r2 = True            
            assert ref1 is not None and ref2 is not None
            o.Raw('if ((', new, ' = ', head[1:], '(', ref1, ', ', ref2, ')) == 0) goto ', labl, ';')
            if cl_r1:
                o.Cls(ref1)
            if cl_r2:
                o.Cls(ref2)             
            UseLabl()
            o.append('}')
            o.Cls(ref1, ref2)
            Used('_PyInt_Rshift')
            return new


    if head == '!PyNumber_Multiply' or head == '!PyNumber_InPlaceMultiply':
        ref = GenMultNew1(head,it,o,forcenewg)
        if ref is not None:
            return ref

    if head in ('!PyNumber_And', '!PyNumber_InPlaceAnd', \
                '!PyNumber_Or', '!PyNumber_InPlaceOr', \
                '!PyNumber_Xor', '!PyNumber_InPlaceXor'):
        return GenBitExpr(it, o, forcenewg)
    
    if head in arifm_n and IsFloat(TypeExpr(it)):
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
        fl = GenFloatExpr(it,o)
        o.Stmt(new, '=', 'PyFloat_FromDouble', fl)
        o.Cls(fl)
        return new  
    if head == '!PyNumber_Multiply':
        return generate_mul_new(head, it, o, forcenewg, typed, skip_float)

    if head in ('!PyNumber_Divide', '!PyNumber_FloorDivide', '!PyNumber_Remainder'):
        t1 = TypeExpr(it[1])
        t2 = TypeExpr(it[2])
        if IsInt(t1) and IsInt(t2):
            pp(it)
            assert False
            ## n1,n2,n3 = None,None,None
            ## ref1 = GenExpr(it[1], o, None, None, skip_float)
            ## if ref1[0] == 'CONST':
                ## n1 = ref1[1]
            ## elif ref1[0] == 'FAST' and not g_co.IsCVar(ref1):
                ## n1 = ConC('PyInt_AS_LONG ( ', ref1, ' )')
            ## else:
                ## n1 = New('long')
                ## o.Stmt(n1, '=', 'PyInt_AS_LONG', ref1)
            ## ref2 = GenExpr(it[2], o, None, None, skip_float)
            ## if ref2[0] == 'CONST':
                ## n2 = ref2[1]
            ## elif ref2[0] == 'FAST' and not g_co.IsCVar(ref2):
                ## n2 = ConC('PyInt_AS_LONG ( ', ref2, ' )')
            ## else:
                ## n2 = New('long')
                ## o.Stmt(n2, '=', 'PyInt_AS_LONG', ref2)
                
            ## if forcenewg is not None:
                ## new = forcenewg
            ## else:
                ## new = New()                    

            ## n3 = New('long') 
            ## if head == '!PyNumber_Divide':
                ## o.Raw(n3, ' = _PyInt_Div(', n1, ', ', n2, ');')
                ## Used('_PyInt_Div')
            ## elif head == '!PyNumber_FloorDivide':
                ## o.Raw(n3, ' = _PyInt_Div(', n1, ', ', n2, ');')
                ## Used('_PyInt_Div')               
            ## elif head == '!PyNumber_Remainder':   
                ## if IsCardinal(t1) and IsCardinal(t2): 
                    ## o.Raw(n3, ' = ', n1, ' % ', n2, ';')
                ## else:
                    ## o.Raw(n3, ' = _PyInt_Mod(', n1, ', ', n2, ');')
                    ## Used('_PyInt_Mod')
                
            ## else:
                ## Fatal('', it)   
                ## assert False
            ## o.PushInt(new, n3)
            ## o.Cls(n1, n2, n3, ref1, ref2)
            ## return new

        if IsInt(t1) and IsFloat(t2) and \
                head == '!PyNumber_Divide':
            ref1 = GenExpr(it[1], o, None, None, skip_float)
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
                
            n1,n2,n3 = None,None,None
            n3 = New('double')
                
            if ref1[0] == 'CONST':
                n1 = ref1[1]
            else:
                n1 = New('long')
                o.Stmt(n1, '=', 'PyInt_AS_LONG', ref1)
            if ref2[0] == 'CONST':
                n2 = str(ref2[1])
            else:
                n2 = New('double')
                o.Stmt(n2, '=', 'PyFloat_AsDouble', ref2)
            o.Stmt(n3, '=', n1, '/', n2)
            o.Stmt(new, '=', 'PyFloat_FromDouble', n3)
            o.Cls(n1, n2, n3, ref1, ref2)
            return new
        
        if t1 is None and IsFloat(t2) and \
                head == '!PyNumber_Divide':
            ref1 = GenExpr(it[1], o, None, None, skip_float)
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
                
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')    
            n1,n2,n3 = None,None,None
            n3 = New('double')
                
            if ref1[0] == 'CONST':
                n1 = ref1[1]
            else:
                n1 = New('long')
                o.Stmt(n1, '=', 'PyInt_AS_LONG', ref1)
            if ref2[0] == 'CONST':
                n2 = str(ref2[1])
            else:
                n2 = New('double')
                o.Stmt(n2, '=', 'PyFloat_AsDouble', ref2)
            o.Stmt(n3, '=', n1, '/', n2)
            o.Stmt(new, '=', 'PyFloat_FromDouble', n3)
            o.Cls(n1, n2, n3)
            o.Raw('} else if (PyFloat_CheckExact( ', ref1, ' )) {')    
            n1,n2,n3 = None,None,None
            n3 = New('double')
                
            if ref1[0] == 'CONST':
                n1 = ref1[1]
            else:
                n1 = New('double')
                o.Stmt(n1, '=', 'PyFloat_AS_DOUBLE', ref1)
            if ref2[0] == 'CONST':
                n2 = str(ref2[1])
            else:
                n2 = New('double')
                o.Stmt(n2, '=', 'PyFloat_AsDouble', ref2)
            o.Stmt(n3, '=', n1, '/', n2)
            o.Stmt(new, '=', 'PyFloat_FromDouble', n3)
            o.Cls(n1, n2, n3)
            o.Raw('} else {')    
            o.Stmt(new, '=', it[0][1:], ref1, ref2)
            o.Raw('}')
            o.Cls(ref1, ref2)
            return new        
        
        if ( t1 is None or t1 == Kl_IntUndefSize ) and ( t2 is None or t2 == Kl_IntUndefSize ) and (head =='!PyNumber_Divide' or head =='!PyNumber_FloorDivide'):
            ref1 = GenExpr(it[1], o, None, None, skip_float)
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
                
            o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' ) && !( PyInt_AS_LONG ( ', ref1, ' ) == LONG_MIN /*' + str((MInt*-1)-1)+'l*/ && PyInt_AS_LONG ( ', ref2, ' ) == -1 )) {')
            IntDivErrHandler(o, ConC('PyInt_AS_LONG ( ', ref2, ' ) == 0'))
            o.PushInt(new, ConC('_PyInt_Div(PyInt_AS_LONG ( ', ref1, ' ), PyInt_AS_LONG ( ', ref2, ' ))'))            
            o.append('} else {')
            o.Stmt(new, '=', head[1:], ref1, ref2)
            o.append('}')
            UseLabl()
            Used('_PyInt_Div')
            o.Cls(ref1, ref2)
            return new
        if ( t1 is None or t1 == Kl_IntUndefSize ) and ( t2 is None or t2 == Kl_IntUndefSize ) and head =='!PyNumber_Remainder':
            ref1 = GenExpr(it[1], o, None, None, skip_float)
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
                
            o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' )) {')
            IntDivErrHandler(o, ConC('PyInt_AS_LONG ( ', ref2, ' ) == 0'))
            o.PushInt(new, ConC('_PyInt_Mod(PyInt_AS_LONG ( ', ref1, ' ), PyInt_AS_LONG ( ', ref2, ' ))'))
            o.append('} else {')
            o.Stmt(new, '=', head[1:], ref1, ref2)
            o.append('}')
            UseLabl()
            Used('_PyInt_Mod')            
            o.Cls(ref1, ref2)
            return new
        if ( t1 is None or t1 == Kl_IntUndefSize ) and IsInt(t2) and head =='!PyNumber_Remainder':
            ref1 = GenExpr(it[1], o, None, None, skip_float)
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
                
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            if ref2[0] == 'CONST':
                o.PushInt(new, ConC('_PyInt_Mod(PyInt_AS_LONG ( ', ref1, ' ), ', ref2[1], ')'))
            else:    
                o.PushInt(new, ConC('_PyInt_Mod(PyInt_AS_LONG ( ', ref1, ' ), PyInt_AS_LONG ( ', ref2, ' ))'))
            o.append('} else {')
            o.Stmt(new, '=', head[1:], ref1, ref2)
            o.append('}')
            UseLabl()
            Used('_PyInt_Mod')
            o.Cls(ref1, ref2)
            return new        
        if ( t1 is None or t1 == Kl_IntUndefSize ) and IsInt(t2) and (head =='!PyNumber_Divide' or head =='!PyNumber_FloorDivide'):
            ref1 = GenExpr(it[1], o, None, None, skip_float)
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            if ref2[0] == 'CONST':
                if ref2[1] == 0:
                    IntDivErrHandler(o, '1')
                    o.PushInt(new, '0')
                else:
                    o.PushInt(new, ConC('PyInt_AS_LONG ( ', ref1, ' ) / ', ref2[1]))
            else:   
                IntDivErrHandler(o, ConC('PyInt_AS_LONG ( ', ref2, ' ) == 0')) 
                o.PushInt(new, ConC('PyInt_AS_LONG ( ', ref1, ' ) / PyInt_AS_LONG ( ', ref2, ' )'))
            o.append('} else {')
            o.Stmt(new, '=', head[1:], ref1, ref2)
            o.append('}')
            UseLabl()
            o.Cls(ref1, ref2)
            return new       
    if head == '!PyNumber_Power':
        ## if it[2] == ('CONST', 2) and it[3] == 'Py_None':
            ## ref1 = Expr1(it[1], o)
            ## ref2 = GenExpr(('!PyNumber_Multiply', ref1, ref1), o, forcenewg, typed, skip_float)
            ## o.Cls(ref1)
            ## return ref2
        if IsInt(TypeExpr(it[1])) and IsFloat(TypeExpr(it[2])) and it[3] == 'Py_None':
            ref1 = Expr1(it[1], o)
            dbl = Expr1(it[2], o)
            fl = New('double')
            if dbl[0] != 'CONST':
                o.Stmt(fl, '=', 'PyFloat_AsDouble', dbl)
            else:    
                o.Raw(fl, ' = ', str(dbl[1]), ';')
            o.Raw(fl, ' = pow( (double) PyInt_AsLong(', ref1, '), ', fl, ');')
            ref3 = New()
            o.Raw(ref3, ' = PyFloat_FromDouble( ', fl, ' );')
            o.Cls(ref1, dbl, fl)
            return ref3
            
    if head == '!PyNumber_Add' and IsInt(TypeExpr(it[1])) and IsBool(TypeExpr(it[2])):        
        if it[1][0] == 'CONST':
            r2 = Expr1(it[2],o)
            add = New('long')
            o, add = ToTrue(o,add,r2, it[2])            
            n1 = str(it[1][1])
            o.Stmt(add, '=', add, '+', n1)
            new = New(None, forcenewg)
            o.PushInt(new, add)
            o.Cls(add, n1)
            return new
        r1,r2 = Expr(o, it[1:])
        n1 = New('long')
        o.Stmt(n1, '=', 'PyInt_AS_LONG', r1)
        add = New('int')
        o.Stmt(add, '=', 'PyObject_IsTrue', r2)
        o.Stmt(n1, '=', n1, '+', add)
        new = New(None, forcenewg)
        o.PushInt(new, n1)
        o.Cls(r1,r2, add, n1)
        return new
        
    if head in ('!PyNumber_Subtract', '!PyNumber_Add', '!PyNumber_InPlaceSubtract', '!PyNumber_InPlaceAdd'):
        return GenPlusMinusNew(head[1:],it,o,forcenewg, skip_float)

    if head in ('!PyNumber_Negative',):
        if len(it) > 3:
            Fatal('GenNumberExpr', it)
            assert False
        t = TypeExpr(it) 
        t1 = TypeExpr(it[1])  
        assert not IsInt(t1) or t1[1][0] == (-MInt - 1)  
        ref1 = GenExpr(it[1], o, None, None, skip_float)
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
            
        n1,n2,n3 = None,None, None
        canbeint = (IsNoneOrInt(t1) or IsIntUndefSize(t1)) and not IsMayBeFloat(t1) and not IsFloat(t1)
        canbefloat = (t1 in (None, Kl_Float) or IsMayBeFloat(t1)) and not skip_float
        onlyint = False
        onlyfloat = False
        if canbeint:
            cmp_is = IsInt(t1)
            n3 = New('long')
            
            if not cmp_is:
                o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && PyInt_AS_LONG ( ', ref1, ') > INT_MIN) {')
            else:
                onlyint = True

            if ref1[0] == 'CONST':
                n1 = ref1[1]
            else:
                n1 = New('long')
                o.Stmt(n1, '=', 'PyInt_AS_LONG', ref1)
            
            o.Stmt(n3, '=', 0, '-', n1)
            o.PushInt(new, n3)
            o.Cls(n1, n3)
        if canbefloat and not onlyint:
            cmp_is = t1 in (Kl_Float,)
            if canbeint:
                pre = '} else '
            else:
                pre = ''     
            if not cmp_is:
                o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ')) {')
                t1 = Kl_Float
            else:
                if canbeint:
                    o.append(pre + 'if (1) {')
                else:
                    onlyfloat = True    
            if IsFloat(t1) or IsMayBeFloat(t1):
                s1 = 'PyFloat_AS_DOUBLE('+ CVar(ref1)+')'    
            elif IsInt(t1):
                s1 = '(double)PyInt_AS_LONG ( '+ CVar(ref1)+' )'    
                Fatal('Strange bracvh in negate operation', t1, it)
                assert False
            else:    
                s1 = 'PyFloat_AsDouble('+ CVar(ref1)+')'    
            if ref1[0] == 'CONST':
                s1 = '((double)' + str(ref1[1]) +')'
            o.Raw(new, ' = PyFloat_FromDouble(-(', s1, '));')
        if onlyint and not IsShort(t):
            pass
        elif onlyint or onlyfloat:
            pass
        else:
            if canbeint:
                o.append('} else {')
                o.Stmt(new, '=', head[1:], ref1)
                o.append('}')
            elif canbefloat:    
                o.append('} else {')
                o.Stmt(new, '=', head[1:], ref1)
                o.append('}')
            else:
                o.Stmt(new, '=', head[1:], ref1)
        o.Cls(ref1)
        return new


    if head in ('!PyNumber_Invert',):
        if len(it) > 3:
            Fatal('GenNumberExpr', it)
            assert False
        t = TypeExpr(it) 
        t1 = TypeExpr(it[1])    
        ref1 = GenExpr(it[1], o, None, None, True)
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
            
        n1,n2,n3 = None,None, None
        canbeint = IsNoneOrInt(t1)
        onlyint = False
        
        if canbeint:
            cmp_is = IsInt(t1)
            n3 = New('long')
            
            if not cmp_is:
                o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            else:
                onlyint = True

            if ref1[0] == 'CONST':
                n1 = ref1[1]
            else:
                n1 = New('long')
                o.Stmt(n1, '=', 'PyInt_AS_LONG', ref1)
            
            o.Raw(n3, ' = ~', n1, ';')
            o.PushInt(new, n3)
            o.Cls(n1, n3)

        if onlyint and not IsShort(t):
            pass
        elif onlyint :
            pass
        else:
            if canbeint:
                o.append('} else {')
                o.Stmt(new, '=', head[1:], ref1)
                o.append('}')
 
            else:
                o.Stmt(new, '=', head[1:], ref1)
        o.Cls(ref1)
        return new
                
#
# Base part
#   
    return common_call(head[1:], it, o, typed, forcenewg)

def get_arg_int(it1, o_, skip_float, t2):
    ref, _ty1 = _get_arg_int(it1, o_, skip_float, t2)
    ty1 = []
    if type(_ty1) is str:
            li = list_all_typed()
            for temp_ty in li:
                str_ty = ConC(temp_ty).strip()
                if name_in(str_ty, _ty1):
                    reactivate_typed(str_ty)
                    ty1.append(temp_ty) 
    return ref, _ty1, ty1

def get_arg_float(it1, o_, skip_float, t2):
    ref, _ty1 = _get_arg_float(it1, o_, skip_float, t2)
    ty1 = []
    if type(_ty1) is str:
            li = list_all_typed()
            for temp_ty in li:
                str_ty = ConC(temp_ty).strip()
                if name_in(str_ty, _ty1):
                    reactivate_typed(str_ty)
                    ty1.append(temp_ty) 
    return ref, _ty1, ty1

def _get_arg_int(it1, o_, skip_float, t2):
    assert type(it1) is tuple
    assert type(o_) is Out     
    l1 = None
    ref1 = None
    o = Out()
    v2 = {}
    is_num_2 = IsIntOrFloat(t2)
    if IsCVar(it1):
        l1 = CVarName(it1)
        if not is_num_2:
            ref1 = GenExpr(it1, o, None, None, skip_float)
            remove_temporary_long_when_push_int_from_long(o)
        o_.extend(o)
        return ref1, l1            
 
    ref1 = LikeExpr1(it1, o, skip_float)
    if len(o) > 2:
        o_last = o[-1]
        assert type(o_last) is str
        if o_last.startswith('CLEARTEMP(') and 'PyInt_FromLong' in o[-2] and ('temp[' + o_last[10:-2] + ']') not in o[-2]:
            o[-2], o[-1] = o_last, o[-2]
    if ref1[0] == 'CONST' and type(ref1[1]) is int:
        l1 = ref1[1]
    elif istempref(ref1):
        remove_temporary_long_when_push_int_from_long(o)
        if len(o) > 0:
            o_last = o[-1]
            assert type(o_last) is str
            if o_last.startswith('temp[') and TxMatch(o, len(o)-1, """temp[$0] = PyInt_FromLong ( $11 );""", v2):
                if type(v2[11]) is str and (' ' not in v2[11].strip() or (' long_' not in v2[11] and not v2[11].startswith('long_'))):
                    l1 = v2[11].strip()
                    assert type(l1) is str
                    if ' ' in l1:
                        l1 = '(' + l1 + ')'
                    elif l1.startswith('Glob_long_') or l1.startswith('Loc_long_'):
                        pass
                    elif l1.startswith('long_') and l1[5:].isdigit():
                        if is_not_active_typed(l1):
                            l1 = reactivate_typed(l1)  
                    if is_num_2:
                        o.Cls(ref1)
                        ref1 = None
                        if o[-1].startswith('CLEARTEMP('):
                            del o[-1]
                        del o[-1]
            elif o_last.startswith('if ((temp[') and TxMatch(o, len(o)-1, """if ((temp[$0] = PyInt_FromLong ( $11 )) == 0) goto label_$12;""", v2):
                if type(v2[11]) is str and (' ' not in v2[11].strip() or (' long_' not in v2[11] and not v2[11].startswith('long_'))):
                    l1 = v2[11].strip()
                    assert type(l1) is str
                    if ' ' in l1:
                        l1 = '(' + l1 + ')'
                    elif l1.startswith('Glob_long_') or l1.startswith('Loc_long_'):
                        pass
                    elif l1.startswith('long_') and l1[5:].isdigit():
                        if is_not_active_typed(l1):
                            l1 = reactivate_typed(l1)  
                        assert type(l1) is not str
                    if is_num_2:
                        o.Cls(ref1)
                        ref1 = None
                        if o[-1].startswith('CLEARTEMP('):
                            del o[-1]
                        del o[-1]

            else:
                if 'PyInt_FromLong' in o_last:
                    pprint(o)
                assert 'PyInt_FromLong' not in o_last
    if l1 is None and len(o) > 0:
            o_last = o[-1]
            assert type(o_last) is str        
            if o_last.startswith('temp[') and TxMatch(o, len(o)-1, """temp[$0] = PyInt_FromLong ( $11 );""", v2):
                if type(v2[11]) is str and (' ' not in v2[11].strip() or (' long_' not in v2[11] and not v2[11].startswith('long_'))):
                    l1 = v2[11].strip()
                    assert type(l1) is str
                    if ' ' in l1:
                        l1 = '(' + l1 + ')'
                    elif l1.startswith('Glob_long_') or l1.startswith('Loc_long_'):
                        pass
                    elif l1.startswith('long_') and l1[5:].isdigit():
                        if is_not_active_typed(l1):
                            l1 = reactivate_typed(l1)  
                        assert type(l1) is not str
                    if is_num_2:
                        o.Cls(ref1)
                        ref1 = None
                        o_last = o[-1]
                        assert type(o_last) is str        
                        if o_last.startswith('CLEARTEMP('):
                            del o[-1]
                        del o[-1]  
                else:
                    o.Cls(ref1)
                    ref1 = None
                    o_last = o[-1]
                    assert type(o_last) is str        
                    if o_last.startswith('CLEARTEMP('):
                        del o[-1]
                    del o[-1]                     
                    l1 = New('long') 
                    o.Raw(l1, ' = ', v2[11].strip(), ';')
                     
    if l1 is None:
        l1 = New('long')        
        o.Raw(l1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
    o_.extend(o)
    return ref1, l1

def _get_arg_float(it1, o_, skip_float, t2):
    assert type(it1) is tuple
    assert type(o_) is Out     
    l1 = None
    ref1 = None
    o = Out()
    v2 = {}
 
    is_num_2 = IsIntOrFloat(t2)
    if IsCVar(it1):
        l1 = CVarName(it1)
        if not is_num_2:
            ref1 = GenExpr(it1, o, None, None, skip_float)
            remove_temporary_double_when_push_float_from_double(o)
        o_.extend(o)
        return ref1, l1            
 
    ref1 = GenExpr(it1, o, None, None, skip_float)
    if ref1[0] == 'CONST' and type(ref1[1]) is int:
        l1 = ref1[1]
    elif istempref(ref1):
        remove_temporary_double_when_push_float_from_double(o)
        if  len(o) > 0 and TxMatch(o, len(o)-1, "if ((temp[$0] = PyFloat_FromDouble ( $11 )) == 0) goto label_$10;", v2):
            TxRepl(o, len(o)-1, "temp[$0] = PyFloat_FromDouble ( $11 );", v2)
        v2 = {}
        if len(o) > 0 and TxMatch(o, len(o)-1, """temp[$0] = PyFloat_FromDouble ($11);""", v2):
            if len(o) > 1:
                optimize(o)
            v2 = {}
            if TxMatch(o, len(o)-1, """temp[$0] = PyFloat_FromDouble ($11);""", v2):
                l1 = v2[11].strip()
                assert type(l1) is str
                if (' ' not in l1 or (' double_' not in l1 and not l1.startswith('double_'))):
                    if ' ' in l1:
                        l1 = '(' + l1 + ')'
                    elif l1.startswith('Glob_double_') or l1.startswith('Loc_double_'):
                        pass
                    elif l1.startswith('double_') and l1[5:].isdigit():
                        if is_not_active_typed(l1):
                            l1 = reactivate_typed(l1)  
                        assert type(l1) is not str
                    if is_num_2:
                        o.Cls(ref1)
                        ref1 = None
                        o_last = o[-1]
                        assert type(o_last) is str        
                        if o_last.startswith('CLEARTEMP('):
                            del o[-1]
                        del o[-1]
        elif len(o) > 0:
            if 'PyFloat_FromDouble' in o[-1]:
                pprint(o)
            assert 'PyFloat_FromDouble' not in o[-1]
    o_.extend(o)
    return ref1, l1

def generate_dynamic_check_result_mult_is_int(l1, l2, is_eq_op):
    if type(l1) is tuple and l1[0] == 'CONST' and type(l1[1]) is int:
        l1 = l1[1]
    if type(l2) is tuple and l2[0] == 'CONST' and type(l2[1]) is int:
        l2 = l2[1]
    isl1 = type(l1) is int and l1 >= (-1 << 15) and l1 <= (1 << 15)
    isl2 = type(l2) is int and l2 >= (-1 << 15) and l2 <= (1 << 15)
    n_isl1 = type(l1) is int and (l1 <= (-1 << 15) or l1 >= (1 << 15))
    n_isl2 = type(l2) is int and (l2 <= (-1 << 15) or l2 >= (1 << 15))
    sl1 = ConC('Py2C_CanBeIntMult(', l1, ')')
    sl2 = ConC('Py2C_CanBeIntMult(', l2, ')')
    if is_eq_op:
        if isl1:
            return 'if (1) {'
        elif n_isl1:
            return 'if (0) {'
        return ConC('if (', sl1, ') {')
    if isl1 and isl2:
        return 'if (1) {'
    if n_isl1 and n_isl2:
        return 'if (0) {'
    if isl1:
        return ConC('if (', sl2, ') {')
    if isl2:
        return ConC('if (', sl1, ') {')
    if isl1:
        sl1 = '1'
    if isl2:
        sl2 = '1'
    if n_isl1:
        return 'if (0) {'
    if n_isl2:
        return 'if (0) {'
    return ConC('if (', sl1, ' && ', sl2, ') {')

    
def generate_mul_new(head, it, o, forcenewg, typed, skip_float):
    assert type(it) is tuple
    assert type(o) is Out     
    t = TypeExpr(it)
    t1 = TypeExpr(it[1])
    t2 = TypeExpr(it[2])
    is1 = IsInt(t1)
    is2 = IsInt(t2)
    fs1 = IsFloat(t1)
    fs2 = IsFloat(t2)
    is_eq_op = t1 == t2 and it[1] == it[2] and repr(it[1]) == repr(it[2]) and 'STORE' not in repr(it[1])
    ref1 = None
    ref2 = None
    ty1 = []
    ty2 = []
    if is1:
        ref1, l1, ty1 = get_arg_int(it[1], o, skip_float, t2)
    elif fs1:
        ref1, l1, ty1 = get_arg_float(it[1], o, skip_float, t2)
    else:
        l1 = None
        ref1 = GenExpr(it[1], o, None, None, skip_float)
        if  IsSequence(t2):
            remove_temporary_long_when_push_int_from_long(o)
    if is_eq_op:    
        ref2 = None
        l2 = None
    else:
        if is2:
            ref2, l2, ty2 = get_arg_int(it[2], o, skip_float, t1)
        elif fs2:
            ref2, l2, ty2 = get_arg_float(it[2], o, skip_float, t1)
        else:
            l2 = None
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if IsSequence(t1):
                remove_temporary_long_when_push_int_from_long(o)

    if forcenewg is not None:
        new = forcenewg
    else:
        new = New()    
    if skip_float is None:
        skip_float = False
    if it[1][0] == '!BUILD_LIST' or it[1][0] == '!BUILD_TUPLE' or it[1][0] == '!ORD_BUILTIN' or it[1][0] == '!PyNumber_Xor' or it[2][0] == '!PyNumber_Xor':    
        skip_float = True
    if not skip_float:
        if (IsIntUndefSize(t2) or IsInt(t2)) and (IsIntUndefSize(t1) or IsInt(t1)):
            skip_float = True
    if IsLong(t1) or IsLong(t2):
        skip_float = True
    if IsKlNone(t1) or IsKlNone(t2):
        skip_float = True
    if t1 is not None and t1[0] == 'MayBe' and t1[1][0] is float:
        skip_float = False 
    if t2 is not None and t2[0] == 'MayBe' and t2[1][0] is float:
        skip_float = False 
    if is1 and is2:
        skip_float = True
    if IsStr(t1) or IsListAll(t1) or IsTuple(t1) or IsStr(t2) or IsListAll(t2) or IsTuple(t2) or \
            (IsIntUndefSize(t1) and IsIntUndefSize(t2)) or (IsInt(t1) and IsIntUndefSize(t2)) or (IsIntUndefSize(t1) and IsInt(t2))\
            or (IsInt(t1) and IsInt(t2)):
        skip_float = True
    if IsLong(t1) or IsLong(t2):
        skip_int = True
    else:
        skip_int = not_int_op(ref1, ref2, it[1], it[2])
    if (IsIntUndefSize(t1) and IsIntUndefSize(t2)) or (IsInt(t1) and IsIntUndefSize(t2)) or (IsIntUndefSize(t1) and IsInt(t2))\
        or (IsInt(t1) and IsInt(t2)) or (IsIntUndefSize(t1) and t2 is None) or (IsIntUndefSize(t2) and t1 is None)\
        or (IsInt(t1) and t2 is None) or (IsInt(t2) and t1 is None):
            skip_int = False
    if skip_int and typed == 'Py_ssize_t':
        skip_int = False
    if t1 is not None and t1[0] == 'MayBe' and t1[1][0] is float:
        skip_int = True
        skip_float = False
    if t2 is not None and t2[0] == 'MayBe' and t2[1][0] is float:
        skip_int = True      
        skip_float = False     
    if IsLong(t1) or IsLong(t2):
        skip_float = True
        skip_int = True    
    if IsStr(t1) or IsUnicode(t1) or IsStr(t2) or IsUnicode(t2) or \
            IsSequence(t1) or IsSequence(t2) or IsComplex(t1) or IsComplex(t2):
        skip_float = True
        skip_int = True    
    if not skip_float:   
        bin_arg_float(o, ref1, ref2, True, t1, t2, is_eq_op, l1, l2)
        r1 = ref1
        r2 = ref2
        if r1[0] == 'CONST':
            r1 = r1[1]
        elif is1:
            r1 = ConC('(double)', l1)   
        elif IsIntUndefSize(t1) or IsInt(t1):
            r1 = ConC('(double)PyInt_AS_LONG (', r1, ')')   
        else:
            r1 = ConC('PyFloat_AS_DOUBLE(', r1, ')')   
        if is_eq_op:
            r2 = r1
        elif r2[0] == 'CONST':
            r2 = r2[1]
        elif is2:
            r2 = ConC('(double)', l2)   
        elif IsIntUndefSize(t2) or IsInt(t2):
            r2 = ConC('(double)PyInt_AS_LONG (', r2, ')')   
        else:
            r2 = ConC('PyFloat_AS_DOUBLE(', r2, ')')   
        o.Raw(new, ' = PyFloat_FromDouble(', r1, ' * ', r2, ');')
    if not skip_int and skip_float and is1 and is2:
        if IsInt(t):
            if not is_eq_op:
                o.PushInt(new, ConC(l1, ' * ', l2))
            else:
                o.PushInt(new, ConC(l1, ' * ', l1))
        else:
            if not is_eq_op:
                o.Raw(*generate_dynamic_check_result_mult_is_int(l1, l2, is_eq_op))
                o.PushInt(new, ConC(l1, ' * ', l2))
                o.append('} else {')
                cl_r1, cl_r2 = False, False
                if IsCVar(it[1]):
                    ref1 = GenExpr(it[1], o, None, None, skip_float)
                if IsCVar(it[2]):
                    ref2 = GenExpr(it[2], o, None, None, skip_float)
                if ref1 is None:
                    ref1 = New()
                    o.Raw (ref1, ' = PyInt_FromLong ( ', l1, ' );')
                    cl_r1 = True
                if ref2 is None:
                    ref2 = New()
                    o.Raw (ref2, ' = PyInt_FromLong ( ', l2, ' );')
                    cl_r2 = True
                assert ref1 is not None and ref2 is not None
                if True:
                    o.Raw(new, ' = PyInt_Type.tp_as_number->nb_multiply(', ref1, ', ', ref2, ');')
                else:
                    o.Stmt(new, '=', head[1:], ref1, ref2)
                if cl_r1:
                    o.Cls(ref1)
                if cl_r2:
                    o.Cls(ref2)
                if IsCVar(it[1]):
                    o.Cls(ref1)
                if IsCVar(it[2]):
                    o.Cls(ref2)
            else:
                o.Raw(*generate_dynamic_check_result_mult_is_int(l1, l2, is_eq_op))
                o.PushInt(new, ConC(l1, ' * ', l1))
                o.append('} else {')
                cl_r1 = False
                if IsCVar(it[1]):
                    ref1 = GenExpr(it[1], o, None, None, skip_float)
                if ref1 is None:
                    ref1 = New()
                    o.Raw (ref1, ' = PyInt_FromLong ( ', l1, ' );')
                    cl_r1 = True
                assert ref1 is not None
                assert ref2 is None
                if True:
                    o.Raw(new, ' = PyInt_Type.tp_as_number->nb_multiply(', ref1, ', ', ref1, ');')
                else:
                    o.Stmt(new, '=', head[1:], ref1, ref1)
                if cl_r1:
                    o.Cls(ref1)
                if IsCVar(it[1]):
                    o.Cls(ref1)
            o.append('}')
        o.Cls(l1, l2)
        o.Cls(ref1, ref2)
        o.Cls(*ty1)
        o.Cls(*ty2)
        return new
    elif not skip_int:
        if not skip_float:
            if not is1 and not is2 and not is_eq_op:
                o.Raw('} else if (PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' )) {')
            elif (not is1 and is2) or (not is1 and is_eq_op):    
                o.Raw('} else if (PyInt_CheckExact( ', ref1, ' )) {')
            elif is1 and not is2:    
                o.Raw('} else if (PyInt_CheckExact( ', ref2, ' )) {')
            else:    
                o.append('} else if (1) {')
        else:
            if not is1 and not is2 and not is_eq_op:
                o.Raw('if (PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' )) {')
            elif (not is1 and is2) or (not is1 and is_eq_op): 
                o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            elif is1 and not is2:    
                o.Raw('if (PyInt_CheckExact( ', ref2, ' )) {')
            else:    
                o.append('if (1) {')
        if not is1:        
            l1 = New('long')        
            o.Raw(l1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
        if not is2 and not is_eq_op:    
            l2 = New('long')        
            o.Raw(l2, ' = PyInt_AS_LONG ( ', ref2, ' );') 
        if IsInt(t):
            o.PushInt(new, ConC(l1, ' * ', l2))
        else:
            if not is_eq_op:
                o.Raw(*generate_dynamic_check_result_mult_is_int(l1, l2, is_eq_op))
                o.PushInt(new, ConC(l1, ' * ', l2))
                o.append('} else {')
                assert ref1 is not None and ref2 is not None
                if True:
                    o.Raw(new, ' = PyInt_Type.tp_as_number->nb_multiply(', ref1, ', ', ref2, ');')
                else:
                    o.Stmt(new, '=', head[1:], ref1, ref2)
                o.append('}')
            else:
                o.Raw(*generate_dynamic_check_result_mult_is_int(l1, l2, is_eq_op))
                o.PushInt(new, ConC(l1, ' * ', l1))
                o.append('} else {')
                assert ref1 is not None and ref2 is None
                if True:
                    o.Raw(new, ' = PyInt_Type.tp_as_number->nb_multiply(', ref1, ', ', ref1, ');')
                else:
                    o.Stmt(new, '=', head[1:], ref1, ref1)
                o.append('}')                    
        o.Cls(l1, l2)
        o.append('} else {')
    else:    
        if not skip_float:    
            o.append('} else {')
        else:    
            o.append('{')
    if not is_eq_op:
        o.Stmt(new, '=', head[1:], ref1, ref2)
    else:
        o.Stmt(new, '=', head[1:], ref1, ref1)
    o.append('}')
    o.Cls(ref1, ref2)
    o.Cls(*ty1)
    o.Cls(*ty2)    
    return new
    

def to_long_0(o, ref2, n2, v2):
    n2_old = n2
    n2 = v2[1].strip()
    assert type(n2) is str
    del o[-1]
    le = len(o)
    o.Cls(ref2)
    if len(o) > le:
        assert len(o) == le + 1
        del o[-1]
    if is_not_active_typed(n2) and n2.startswith('long_'):
        n2 = reactivate_typed(n2)
    elif n2.startswith('Loc_') and ' ' not in n2:
        pass
    elif len(o) > 0 and (n2.startswith('Py_ssize_t_') or n2.startswith('long_') or n2.startswith('int_')) and (n2 + ' = ') in o[-1]:
        if n2_old is None:
            _n = New('long')
        else:
            _n = n2_old
        o[-1] = o[-1].replace(n2 + ' = ', ConC(_n) + ' = ')
        assert (ConC(_n) + ' = ') in o[-1]
        n2 = _n
    else: 
        if n2_old is None:
            _n = New('long')
        else:
            _n = n2_old
        if CVar(_n) != n2:
            o.Raw(_n, ' = ', n2, ';')
            n2 = _n
    return n2

def to_long(o, ref2, n2):
    if not istempref(ref2) and ref2[0] != 'CONST':
        if n2 is None:
            n2 = New('long')
        o.Stmt(n2, '=', 'PyInt_AS_LONG', ref2)
        return ref2, n2
    v2 = []
    tail = []
    while len(o) > 0 and (o[-1].startswith('CLEARTEMP') or o[-1].startswith('Py_CLEAR')):
        tail = [o[-1]] + tail
        del o[-1]
    if len(o) > 0 and TextMatch(o[-1], ('temp[', '*', '] = PyInt_FromLong (', '*', ');'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_long_0(o, ref2, n2, v2)
    elif len(o) > 0 and TextMatch(o[-1], ('if ((temp[', '*', '] = PyInt_FromLong ( ', '*', ' )) == 0) goto ', '*', ';'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_long_0(o, ref2, n2, v2)
    else:  
        if n2 is None:
            n2 = New('long')
        o.Stmt(n2, '=', 'PyInt_AS_LONG', ref2)
    o.extend(tail)
    return ref2, n2    

def to_float_0(o, ref2, n2, v2):
    n2_old = n2
    n2 = v2[1].strip()
    assert type(n2) is str
    del o[-1]
    le = len(o)
    o.Cls(ref2)
    if len(o) > le:
        assert len(o) == le + 1
        del o[-1]
    n2_2 = None
    if is_not_active_typed(n2) and n2.startswith('double_'):
        n2 = reactivate_typed(n2)
        n2_2 = ConC(n2)
    elif n2.startswith('Loc_') and ' ' not in n2:
        pass
    elif n2.startswith('Glob_') and ' ' not in n2:
        pass
    if len(o) > 0 and n2_2 is not None and (n2_2.startswith('Py_ssize_t_') or n2_2.startswith('long_') or n2_2.startswith('int_') or n2_2.startswith('double_')) and (n2_2 + ' = ') in o[-1]:
        if n2_old is None:
            _n = New('double')
        else:
            _n = n2_old
        o[-1] = o[-1].replace(n2_2 + ' = ', ConC(_n) + ' = ')
        assert (ConC(_n) + ' = ') in o[-1]
        n2 = _n
    else: 
        if n2_old is None:
            _n = New('double')
        else:
            _n = n2_old
        if CVar(_n) != n2_2:
            o.Raw(_n, ' = ', n2, ';')
            n2 = _n
    return n2

def to_float(o, ref2, n2):
    if not istempref(ref2) and ref2[0] != 'CONST':
        if n2 is None:
            n2 = New('double')
        o.Stmt(n2, '=', 'PyFloat_AS_DOUBLE', ref2)
        return ref2, n2
    v2 = []
    tail = []
    while len(o) > 0 and (o[-1].startswith('CLEARTEMP') or o[-1].startswith('Py_CLEAR')):
        tail = [o[-1]] + tail
        del o[-1]
    if len(o) > 0 and TextMatch(o[-1], ('temp[', '*', '] = PyFloat_FromDouble (', '*', ');'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_float_0(o, ref2, n2, v2)
    elif len(o) > 0 and TextMatch(o[-1], ('if ((temp[', '*', '] = PyFloat_FromDouble ( ', '*', ' )) == 0) goto ', '*', ';'), v2) and v2[0] == str(ref2[1]):
        ref2, n2 = None, to_float_0(o, ref2, n2, v2)
    else:  
        if n2 is None:
            n2 = New('double')
        o.Stmt(n2, '=', 'PyFloat_AS_DOUBLE', ref2)
    o.extend(tail)
    return ref2, n2    

def IsNotIntFloat(t):
    if IsStr(t) or IsTuple(t) or IsListAll(t) or IsLong(t) or \
       ( t is not None and (IsOldInst(t) or IsOldType(t))) or \
       (not IsInt(t) and not IsFloat(t)) and not IsSequence(t) and not IsDict(t):
        return True
    return False

def is_not_int_float(it):
    assert type(it) is tuple
   
    if type(it) is tuple:
        if it[0] in ('!PyList_GetSlice', '!PyTuple_GetSlice', '!PySequence_GetSlice', \
                     '!_PyEval_ApplySlice', '!BUILD_LIST', '!BUILD_TUPLE'):
            return True
        if it[0] == 'CONST' and type(it[1]) in (list, tuple, str, long): 
            return True
        if IsNotIntFloat(TypeExpr(it)):    
            return True   
    return False

def GenMultNew1(head,it,o,forcenewg):
    assert type(it) is tuple
    assert type(o) is Out     
    revert = False
    if it[1][0] == 'CONST' and type(it[1][1]) is int and head == '!PyNumber_Multiply':
        it = (it[0], it[2], it[1])
        revert = True
    assert type(it) is tuple
    t = TypeExpr(it) 
    t1 = TypeExpr(it[1]) 
    t2 = TypeExpr(it[2]) 

    n1,n2,n3 = None,None,None
    
    if IsBool(t1) and IsInt(t2):
        ref1 = Expr1(it[1], o)
        add = New('int')
        o.Stmt(add, '=', 'PyObject_IsTrue', ref1)     
        o.Cls(ref1)   
        ref2 = Expr1(it[2], o)
        if it[2][0] == 'CONST':
            n1 = it[2][1]
        else:
            n1 = New('long')
            o.Stmt(n1, '=', 'PyInt_AS_LONG', ref2)
            o.Cls(ref2)  
        n3 = ConC('(', add, '?', n1, ':0)')
        new = New(None, forcenewg)
        o.PushInt(new, n3)
        o.Cls(add, n1)
        return new        
        
    if IsChar(t1) and IsInt(t2):
        ref1 = Expr1(it[1], o)
        n1 = New('char')
        o.Raw(n1, ' = ', Str_AS_STRING(ref1), '[0];') 
        o.Cls(n1)
        ref2 = Expr1(it[2], o)
        if istempref(ref2):
            n2 = New('long')
            o.Raw(n2, ' = PyInt_AS_LONG ( ', ref2, ' );') 
            o.Cls(ref2)
        elif ref2[0] == 'CONST':
            n2 = ref2[1]
        elif g_co.IsCVar(ref2):
            n2 = ref2
        elif it[2][0] == '!@PyInt_FromSsize_t':
            n2 = it[2][1]
        else:
            pp(ref2, it[2])
            assert False
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
        o.Raw(new, ' = PyString_FromStringAndSize (NULL, ', n2, ');')
        o.Raw('memset( PyString_AS_STRING( ', new, ' ), ', n1, ', ', n2, ' );')
        ## n3 = New('int')
        ## s1 = New('charref')
        ## o.Raw(s1, ' = PyString_AS_STRING ( ', new, ' );')
        ## o.Raw('for (', n3, ' = 0;', n3, ' < ', n2, ';', n3, ' ++) {')
        ## o.Raw(s1, '[', n3, '] = ', n1, ';')
        ## o.Raw('}')
        o.Cls(n1, n2)
        return new
    if IsChar(t2) and IsInt(t1) and it[2][0] == 'CONST':
        ref1 = Expr1(it[1], o)
        if istempref(ref1):
            n1 = New('long')
            o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
            o.Cls(ref1)
        elif ref1[0] == 'CONST':
            n1 = ref1[1]
        else:
            assert False
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
        o.Raw(new, ' = PyString_FromStringAndSize (NULL, ', n1, ');')
        h =  charhex(it[2][1]) 
        o.Raw('memset (PyString_AS_STRING ( ', new, ' ), ', h, ', ', n1, ');')
        o.Cls(n1)
        return new
             
    if it[2][0] == 'CONST' and type(it[2][1]) is int and IsInt(t1):
        if it[1][0] == '!@PyInt_FromSsize_t' and not g_co.IsCVar(it[1][2]):
            ref1 = it[1][2]
            n1 = New('long')
            o.Raw(n1, ' = ', it[1][1], ';')
        else:    
            ref1 = Expr1(it[1], o)
            n1 = New('long')
            o.Raw(n1, ' = PyInt_AS_LONG ( ', ref1, ' );') 
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()    
        n2 = New('long')    
        if it[2][1] == 1:
            o.Raw(n2, ' = ',n1, ';')
            o.PushInt(new, n2)
            o.Cls(ref1)
            o.Cls(n1, n2)  
            return new          
        elif it[2][1] == 0:
            o.Cls(ref1)
            o.Cls(n1, n2) 
            return ('CONST', 0)              
        else:
            o.Raw(n2, ' = ',n1, ' * ', it[2][1], ';')
            if IsInt(t):
                o.PushInt(new, n2)
            else:
                o.Raw('if (', n2, ' / ', it[2][1], ' == ', n1, ') {')
                o.PushInt(new, n2)
                o.append('} else {')
                assert ref1 is not None and it[2] is not None
                if True:
                    if not revert:
                        o.Raw(new, ' = PyInt_Type.tp_as_number->nb_multiply(', ref1, ', ', it[2], ');')
                    else:    
                        o.Raw(new, ' = PyInt_Type.tp_as_number->nb_multiply(', it[2], ', ', ref1, ');')
                else:
                    if not revert:
                        o.Raw('if ((', new, ' = ', head[1:], ' ( ', ref1, ' , ', it[2], ' )) == 0) goto ', labl, ';')
                    else:    
                        o.Raw('if ((', new, ' = ', head[1:], ' ( ', it[2], ' , ', ref1, ' )) == 0) goto ', labl, ';')
                    
                o.append('}')
            o.Cls(ref1)
            o.Cls(n1, n2)
            return new
    if it[2][0] == 'CONST' and type(it[2][1]) is int and (t1 is None or IsIntUndefSize(t1)):
        if it[2][1] == 0:
            ref1 = Expr1(it[1], o)
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
            o.Raw(new, ' = ', it[2], ';')
            o.INCREF(new)
            o.append('} else {')
            if not revert:
                o.Raw('if ((', new, ' = ', head[1:], ' ( ', ref1, ' , ', it[2], ' )) == 0) goto ', labl, ';')
            else:    
                o.Raw('if ((', new, ' = ', head[1:], ' ( ', it[2], ' , ', ref1, ' )) == 0) goto ', labl, ';')
            UseLabl()
            o.append('}')
            o.Cls(ref1)
            return new

        if it[2][1] == 1:
            ref1 = Expr1(it[1], o)
            o.Raw('if (PyInt_CheckExact( ', ref1, ' )) {')
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New()    
            o.Raw(new, ' = ', ref1, ';')
            if istempref(ref1):
                o.Raw(ref1, ' = 0;')
            else:
                o.INCREF(new)      
            o.append('} else {')
            if not revert:
                o.Raw('if ((', new, ' = ', head[1:], ' ( ', ref1, ' , ', it[2], ' )) == 0) goto ', labl, ';')
            else:    
                o.Raw('if ((', new, ' = ', head[1:], ' ( ', it[2], ' , ', ref1, ' )) == 0) goto ', labl, ';')
            UseLabl()
            o.Cls(ref1)
            o.append('}')
            return new
        
def GenPlusMinusIntUndefSize(head,it,o,forcenewg, t1, t2):
    pprint((head,it,o,forcenewg, t1, t2), )
    assert False
    return None

def GenPlusMinusNew(head,it,o,forcenewg, skip_float):
    assert type(it) is tuple
    assert type(o) is Out     
    assert type(head) is str       
    if len(it) > 3:
        Fatal('GenNumberExpr', it) 
        assert False
    t = TypeExpr(it) 
    t1 = TypeExpr(it[1]) 
    t2 = TypeExpr(it[2]) 
    if IsInt(t1) and IsInt(t2):
        if IsIntUndefSize(t):
            pass
        else:
            pp(';;98', t, t1, t2)
            pp(';;981', it)
   
    if IsIntUndefSize(t):
        temp_ref = GenPlusMinusIntUndefSize(head,it,o,forcenewg, t1, t2)
        if temp_ref is not None:
            return temp_ref

    is1 = IsInt(t1)
    is2 = IsInt(t2)
    fs1 = IsFloat(t1)
    fs2 = IsFloat(t2)
    n1,n2,n3 = None,None,None
    f1, f2 = None, None
    o1 = Out()
    o2 = Out()
    o_old = o
    assert type(o_old) is Out
    o = Out()
    is_eq_op = t1 == t2 and it[1] == it[2] and repr(it[1]) == repr(it[2]) and 'STORE' not in repr(it[1])
    canbeint = CanBeInt(t1,t2)
    canbefloat = CanBeFloat(t1,t2) and not skip_float
    bit_op = ('!PyNumber_Rshift', '!PyNumber_Lshift', '!PyNumber_Or', '!PyNumber_Xor', '!PyNumber_And')
    if it[1][0] in bit_op or it[2][0] in bit_op:
        canbefloat = False
    if is_not_int_float(it) or IsStr(t1) or IsTuple(t1) or IsListAll(t1) or IsStr(t2) or IsTuple(t2) or IsListAll(t2):
        canbeint = False
        canbefloat = False
    can_else = True  

    ref1 = None
    ref2 = None
    v2 = {}
    ty1 = []
    ty2 = []
    if is1:
        ref1, n1, ty1 = get_arg_int(it[1], o, skip_float, t1)
    elif fs1:
        ref1, n1, ty1 = get_arg_float(it[1], o, skip_float, t1)
    else:
        n1 = None
        ref1 = GenExpr(it[1], o, None, None, skip_float)
        if  IsSequence(t2):
            remove_temporary_long_when_push_int_from_long(o)
    if is_eq_op:    
        ref2 = None
        n2 = None
    else:
        if is2:
            ref2, n2, ty2 = get_arg_int(it[2], o, skip_float, t2)
        elif fs2:
            ref2, n2, ty2 = get_arg_float(it[2], o, skip_float, t2)
        else:
            n2 = None
            ref2 = GenExpr(it[2], o, None, None, skip_float)
            if IsSequence(t1):
                remove_temporary_long_when_push_int_from_long(o)


    if ref1 == ('CONST', None):
        return ref1
    if ref2 == ('CONST', None):
        return ref2
    if forcenewg is not None:
        new = forcenewg
    else:
        new = New()    
    if canbeint:
        cmp_is1, cmp_is2 = (IsInt(t1), IsInt(t2))
        cond = None
        if is_eq_op and not cmp_is1:
            cond = ConC('PyInt_CheckExact( ', ref1, ' )')
        elif not cmp_is1 and not cmp_is2:
            cond = ConC('PyInt_CheckExact( ', ref1, ' ) && PyInt_CheckExact( ', ref2, ' )')
        elif cmp_is1 and not cmp_is2:
            cond = ConC('PyInt_CheckExact( ', ref2, ' )')
        elif not cmp_is1 and cmp_is2:
            cond = ConC('PyInt_CheckExact( ', ref1, ' )')
        else:
            if IsShort(t1) and IsShort(t2) and not canbefloat:
                can_else = False
            elif IsInt(t1) and IsShort(t2) and IsInt(t) and not canbefloat:
                can_else = False
            elif IsInt(t2) and IsShort(t1) and IsInt(t) and not canbefloat:
                can_else = False
            else:
                cond = '1'

        if n1 is not None:
            pass
        elif ref1 is None:
            pass
        elif ref1[0] == 'CONST':
            n1 = ref1[1]
        else:
            n1 = ConC('PyInt_AS_LONG ( ', ref1, ' )')
        if not is_eq_op:
            if n2 is not None:
                pass
            elif ref2 is None:
                pass
            elif ref2[0] == 'CONST':
                n2 = ref2[1]
            else:
                n2 = ConC('PyInt_AS_LONG ( ', ref2, ' )')
            
        if n1 is None or (n2 is None and not is_eq_op):
            pp('///:', n1, n2, ref1, ref2)
            pprint(it)
            pprint(o[:-20])
            pp(cond)
            assert n1 is not None
            assert n2 is not None
        if is_eq_op:
            n2 = n1
            ref2 = ref1
        if head in ('PyNumber_Add', 'PyNumber_InPlaceAdd'):
            if not can_else:
                n3 = '(' + ConC(n1, ' + ', n2) + ')'
            else:
                n3 = New('long')
                if cond != '1':
                    cond = cond + ConC(' && ((', n3, ' = ', n1, ' + ', n2, '), ')
                else:
                    cond = ConC('((', n3, ' = ', n1, ' + ', n2, '), ')
                if n1 == n2:
                    cond = cond + ConC('!((', n3, '^', n1, ') < 0))')
                else:
                    cond = cond + ConC('!((', n3, '^', n1, ') < 0 && (', n3, '^', n2, ') < 0))')
                o.Raw('if (', cond, ') {')
        else:   
            if not can_else:
                n3 = '(' + ConC(n1, ' - ', n2) + ')'
            else:
                n3 = New('long')
                if cond != '1':
                    cond = cond + ConC(' && ((', n3, ' = ', n1, ' - ', n2, '), ')
                else:
                    cond = ConC('((', n3, ' = ', n1, ' - ', n2, '), ')
                cond = cond + ConC('!((', n3, '^', n1, ') < 0 && (', n3, '^~', n2, ') < 0))')
                o.Raw('if (', cond, ') {')
        o.PushInt(new, n3)
        o.Cls(n3)
    if canbefloat:
        if is_eq_op:
            n2 = n1
            ref2 = ref1        
        cmp_is1, cmp_is2 = (IsIntOrFloat(t1), IsIntOrFloat(t2))
        if canbeint:
            pre = '} else '
        else:
            pre = ''     
        if not cmp_is1 and not cmp_is2:
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ') && PyFloat_CheckExact(', ref2, ')) {')
            t1 = Kl_Float
            t2 = Kl_Float
        elif cmp_is1 and not cmp_is2:
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref2, ')) {')
            t2 = Kl_Float
        elif not cmp_is1 and cmp_is2:
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ')) {')
            t1 = Kl_Float
        else:
            o.append(pre + 'if (1) {')
        if f1 is not None:
            s1 = f1
        elif IsFloat(t1):
            s1 = 'PyFloat_AS_DOUBLE('+ CVar(ref1)+')'    
        elif IsInt(t1):
            s1 = '(double)PyInt_AS_LONG ( '+ CVar(ref1)+' )'    
        else:    
            s1 = 'PyFloat_AsDouble('+ CVar(ref1)+')'    
        if f2 is not None:
            s2 = f2
        elif IsFloat(t2):
            s2 = 'PyFloat_AS_DOUBLE('+ CVar(ref2)+')'    
        elif IsInt(t2):
            s2 = '(double)PyInt_AS_LONG ( '+ CVar(ref2)+' )'    
        else:    
            s2 = 'PyFloat_AsDouble('+ CVar(ref2)+')'    
        if ref1 is None and n1 is not None:
            s1 = '((double)' + ConC(n1) +')'
        elif ref1 is None and f1 is not None:
            s1 = ConC(f1) 
        elif ref1[0] == 'CONST':
            s1 = '((double)' + str(ref1[1]) +')'
        if ref2 is None and n2 is not None:
            s2 = '((double)' + ConC(n2) +')'
        elif ref2 is None and f2 is not None:
            s2 = ConC(f2)
        elif ref2[0] == 'CONST':
            s2 = '((double)' + str(ref2[1]) +')'
        if head in ('PyNumber_Add', 'PyNumber_InPlaceAdd'):
            o.Raw(new, ' = PyFloat_FromDouble(', s1, ' + ', s2, ');')
        else:    
            o.Raw(new, ' = PyFloat_FromDouble(', s1, ' - ', s2, ');')
    _1 = False
    _2 = False
    if canbeint:
        if not canbefloat and not can_else:
            pass ##o.append('}')
        else:   
            o.Stmt('} else {') 
            if ref1 is None:
                ref1 = New()
                o.PushInt(ref1, n1)
                _1 = True
            if ref2 is None:
                ref2 = New()
                o.PushInt(ref2, n2)
                _2 = True
            o.Stmt(new, '=', head, ref1, ref2)
            if _1:
                o.Cls(ref1)
            if _2:
                o.Cls(ref2)
            o.append('}')
    elif canbefloat:    
        o.append('} else {')
        if ref1 is None and f1 is None:
            ref1 = New()
            o.PushInt(ref1, n1)
            _1 = True
        if ref2 is None and f2 is None :
            ref2 = New()
            o.PushInt(ref2, n2)
            _2 = True
        if ref1 is None and f1 is not None:
            ref1 = New()
            o.PushFloat(ref1, f1)
            _1 = True
        if ref2 is None and f2 is not None :
            ref2 = New()
            o.PushFloat(ref2, f2)
            _2 = True
        o.Stmt(new, '=', head, ref1, ref2)
        if _1:
            o.Cls(ref1)
        if _2:
            o.Cls(ref2)
        o.append('}')
    else:
        if is_eq_op:
            n2 = n1
            ref2 = ref1        
        verif(it)
        if ref1 is None:
            ref1 = New()
            if IsInt(t1):
                o.PushInt(ref1, n1)
            elif IsFloat(t1):
                o.PushFloat(ref1, n1)
            else:
                assert False
            _1 = True
        if ref2 is None:
            ref2 = New()
            if IsInt(t2):
                o.PushInt(ref2, n2)
            elif IsFloat(t2):
                o.PushFloat(ref2, n2)
            else:
                assert False                
            _2 = True
        o.Stmt(new, '=', head, ref1, ref2)
        if _1:
            o.Cls(ref1)
        if _2:
            o.Cls(ref2)

    o.Cls(ref1, ref2, n1, n2, f1, f2)
    o.Cls(*ty1)
    o.Cls(*ty2)
    _o = Out()
    _o.extend(o1 + o2 + o)
    v2 = {}
    assert type(o_old) is Out
    if _o[0].startswith('long_') and TxMatch(_o, 0, """
            long_$8 = $11;
            long_$9 = long_$8 $12 $14;
            temp[$0] = PyInt_FromLong ( long_$9 ); 
            """, v2):
                TxRepl(_o, 0, """temp[$0] = PyInt_FromLong ( (($11) $12 $14) );""", v2)
                o_old.extend(_o)
                return new
    if _o[0].startswith('if ((Py_ssize_t_'):
        if TxMatch(_o, 0, """
            if ((Py_ssize_t_$8 = $11) == -1) goto label_$15;
            long_$9 =  Py_ssize_t_$8  $12 $14;
            temp[$0] = PyInt_FromLong ( long_$9 ); 
            """, v2):
                TxRepl(_o, 0, """if ((Py_ssize_t_$8 = $11) == -1) goto label_$15;
                       temp[$0] = PyInt_FromLong ( Py_ssize_t_$8 $12 $14 );""", v2)
                o_old.extend(_o)
                return new   
        if TxMatch(_o, 0, """
            if ((Py_ssize_t_$5 = $11) == -1) goto label_$0;
            temp[$1] = PyInt_FromLong ( Py_ssize_t_$5 );
            if (1) {
            long_$8 = PyInt_AS_LONG ( temp[$1] );
            long_$7 = $12 $19 long_$8;
            if ($14) goto label_$15 ;
            temp[$2] = PyInt_FromLong ( long_$7 );
            } else { label_$15 :;
            temp[$3] = PyInt_FromLong ( $12 );
            if ((temp[$2] = PyNumber_$18 ( temp[$3] , temp[$1] )) == 0) goto label_$0;
            CLEARTEMP($3);
            }
            CLEARTEMP($1);""", v2):         
                    TxRepl(_o, 0, """
                        if ((Py_ssize_t_$5 = $11) == -1) goto label_$0;
                        if (1) {
                        long_$8 = Py_ssize_t_$5;
                        long_$7 = $12 $19 long_$8;
                        if ($14) goto label_$15 ;
                        temp[$2] = PyInt_FromLong ( long_$7 );
                        } else { label_$15 :;
                        temp[$1] = PyInt_FromLong ( Py_ssize_t_$5 );
                        temp[$3] = PyInt_FromLong ( $12 );
                        if ((temp[$2] = PyNumber_$18 ( temp[$3] , temp[$1] )) == 0) goto label_$0;
                        CLEARTEMP($3);
                        CLEARTEMP($1);
                        }""", v2)
                    o_old.extend(_o)
                    return new    
        if TxMatch(_o, 0, """
            if ((Py_ssize_t_$5 = PyObject_Size ( GETLOCAL(refs) )) == -1) goto label_$10;
            temp[$0] = PyInt_FromLong ( Py_ssize_t_$5 );
            if (PyInt_CheckExact( $15 )) {
            long_$8 = PyInt_AS_LONG ( $15 );
            long_$9 = PyInt_AS_LONG ( temp[$0] );
            long_$7 = long_$8 $12 long_$9;
            if ($11) goto label_$13 ;
            temp[$1] = PyInt_FromLong ( long_$7 );
            } else if (PyFloat_CheckExact( $15 )) {
            temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($15) $12 (double)PyInt_AS_LONG ( temp[$0] ));
            } else { label_$13 :;
            if ((temp[$1] = PyNumber_$14 ( $15 , temp[$0] )) == 0) goto label_$10;
            }
            CLEARTEMP($0);""", v2):         
                    TxRepl(_o, 0, """
                        if ((Py_ssize_t_$5 = PyObject_Size ( GETLOCAL(refs) )) == -1) goto label_$10;
                        if (PyInt_CheckExact( $15 )) {
                        long_$8 = PyInt_AS_LONG ( $15 );
                        long_$9 = Py_ssize_t_$5;
                        long_$7 = long_$8 $12 long_$9;
                        if ($11) goto label_$13 ;
                        temp[$1] = PyInt_FromLong ( long_$7 );
                        } else if (PyFloat_CheckExact( $15 )) {
                        temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($15) $12 (double)Py_ssize_t_$5);
                        } else { label_$13 :;
                        temp[$0] = PyInt_FromLong ( Py_ssize_t_$5 );
                        if ((temp[$1] = PyNumber_$14 ( $15 , temp[$0] )) == 0) goto label_$10;
                        CLEARTEMP($0);
                        }""", v2)
                    o_old.extend(_o)
                    return new                    
    if _o[0].startswith('temp[') and TxMatch(_o, 0, """
        temp[$0] = PyInt_FromLong ( $11 );
        if (PyInt_CheckExact( $17 )) {
        long_$8 = PyInt_AS_LONG ( temp[$0] );
        long_$9 = PyInt_AS_LONG ( $17 );
        long_$7 = long_$8 $15 long_$9;
        if ($12) goto label_$14 ;
        temp[$1] = PyInt_FromLong ( long_$7 );
        } else if (PyFloat_CheckExact( $17 )) {
        temp[$1] = PyFloat_FromDouble((double)PyInt_AS_LONG ( temp[$0] ) $15 PyFloat_AS_DOUBLE($17));
        } else { label_$14 :;
        if ((temp[$1] = PyNumber_$18 ( temp[$0] , $17 )) == 0) goto label_$10;
        }
        CLEARTEMP($0);""", v2) and v2[11] != ('long_' + v2[7]) and v2[11] != ('long_' + v2[9]):         
                TxRepl(_o, 0, """
                    if (PyInt_CheckExact( $17 )) {
                    long_$8 = $11;
                    long_$9 = PyInt_AS_LONG ( $17 );
                    long_$7 = long_$8 $15 long_$9;
                    if ($12) goto label_$14 ;
                    temp[$1] = PyInt_FromLong ( long_$7 );
                    } else if (PyFloat_CheckExact( $17 )) {
                    temp[$1] = PyFloat_FromDouble((double)($11) $15 PyFloat_AS_DOUBLE($17));
                    } else { label_$14 :;
                    temp[$0] = PyInt_FromLong ( $11 );
                    if ((temp[$1] = PyNumber_$18 ( temp[$0] , $17 )) == 0) goto label_$10;
                    CLEARTEMP($0);
                    }""", v2)
                o_old.extend(_o)
                return new  

 
    if len(o1) == 0 and len(o2) > 0 and 'PyInt_FromLong' in o2[-1]:
        o2_1 = Out()
        o2_1.extend(o2)
        o2_1.extend(o)
        if o2_1[len(o2_1) - (len(o) + 1)].startswith('temp['):
            if TxMatch(o2_1, len(o2_1) - (len(o) + 1), """
                temp[$0] = PyInt_FromLong ( $4 );
                if (PyInt_CheckExact( $11 )) {
                long_$5 = PyInt_AS_LONG ( $11 );
                long_$6 = PyInt_AS_LONG ( temp[$0] );
                long_$2 = long_$5 $15 long_$6;
                if ($12) goto label_$7 ;
                temp[$1] = PyInt_FromLong ( long_$2 );
                } else if (PyFloat_CheckExact( $11 )) {
                temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) $15 (double)PyInt_AS_LONG ( temp[$0] ));
                } else { label_$7 :;
                if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto label_$10;
                }
                CLEARTEMP($0);
                """, v2) and v2[4] != 'long_' + v2[5] and v2[4] != 'long_' + v2[2]:
                    pprint(o2_1)
                    TxRepl(o2_1, 0, """
                        if (PyInt_CheckExact( $11 )) {
                        long_$5 = PyInt_AS_LONG ( $11 );
                        long_$6 = $4;
                        long_$2 = long_$5 $15 long_$6;
                        if ($12) goto label_$7 ;
                        temp[$1] = PyInt_FromLong ( long_$2 );
                        } else if (PyFloat_CheckExact( $11 )) {
                        temp[$1] = PyFloat_FromDouble(PyFloat_AS_DOUBLE($11) $15 (double)($4));
                        } else { label_$7 :;
                        temp[$0] = PyInt_FromLong ( $4 );
                        if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto label_$10;
                        CLEARTEMP($0);
                        }
                        """, v2)
                    pprint(o2_1)
                    assert False
                    o_old.extend(o2_1)
                    return new
            if TxMatch(o2_1, len(o2_1) - (len(o) + 1), """
                temp[$0] = PyInt_FromLong ( $4 );
                if (PyInt_CheckExact( $11 )) {
                long_$5 = PyInt_AS_LONG ( $11 );
                long_$6 = PyInt_AS_LONG ( temp[$0] );
                long_$2 = long_$5 $15 long_$6;
                if ($12) goto label_$7 ;
                temp[$1] = PyInt_FromLong ( long_$2 );
                } else { label_$7 :;
                if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto label_$10;
                }
                CLEARTEMP($0);
                """, v2) and v2[4] != 'long_' + v2[5] and v2[4] != 'long_' + v2[2]:
                    TxRepl(o2_1, 0, """
                        if (PyInt_CheckExact( $11 )) {
                        long_$5 = PyInt_AS_LONG ( $11 );
                        long_$6 = $4;
                        long_$2 = long_$5 $15 long_$6;
                        if ($12) goto label_$7 ;
                        temp[$1] = PyInt_FromLong ( long_$2 );
                        } else { label_$7 :;
                        temp[$0] = PyInt_FromLong ( $4 );
                        if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto label_$10;
                        CLEARTEMP($0);
                        }
                        """, v2)
                    o_old.extend(o2_1)
                    return new
            if TxMatch(o2_1, len(o2_1) - (len(o) + 1), """
                temp[$0] = PyInt_FromLong ( $4 );
                if (1) {
                long_$5 = PyInt_AS_LONG ( $11 );
                long_$6 = PyInt_AS_LONG ( temp[$0] );
                long_$2 = long_$5 $15 long_$6;
                if ($12) goto label_$7 ;
                temp[$1] = PyInt_FromLong ( long_$2 );
                } else { label_$7 :;
                if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto label_$10;
                }
                CLEARTEMP($0);
                """, v2) and v2[4] != 'long_' + v2[5] and v2[4] != 'long_' + v2[2]:
                    TxRepl(o2_1, 0, """
                        if (1) {
                        long_$5 = PyInt_AS_LONG ( $11 );
                        long_$6 = $4;
                        long_$2 = long_$5 $15 long_$6;
                        if ($12) goto label_$7 ;
                        temp[$1] = PyInt_FromLong ( long_$2 );
                        } else { label_$7 :;
                        temp[$0] = PyInt_FromLong ( $4 );
                        if ((temp[$1] = PyNumber_$14 ( $11 , temp[$0] )) == 0) goto label_$10;
                        CLEARTEMP($0);
                        }
                        """, v2)
                    o_old.extend(o2_1)
                    return new    
    if len(o2) == 0 and len(o1) == 5:
        o2_1 = Out()
        o2_1.extend(o1)
        o2_1.extend(o)
        if o2_1[0].startswith('if (') and TxMatch(o2_1, 0, """        
            if ($10) {
            temp[$4] = PyInt_FromLong ( $11 );
            } else {
            if ((temp[$4] = $12) == 0) goto label_$0;
            }
            if (PyInt_CheckExact( temp[$4] )) {
            long_$3 = PyInt_AS_LONG ( temp[$4] );
            long_$2 = long_$3 $17 $13;
            if ($14) goto label_$15 ;
            temp[$5] = PyInt_FromLong ( long_$2 );
            } else { label_$15 :;
            if ((temp[$5] = $16) == 0) goto label_$0;
            }
            CLEARTEMP($4);
                """, v2):
                    TxRepl(o2_1, 0, """
                        if ($10) {
                        long_$3 = $11;
                        long_$2 = long_$3 $17 $13;
                        if ($14) goto label_$15 ;
                        temp[$5] = PyInt_FromLong ( long_$2 );
                        } else { label_$15 :;
                        if ((temp[$4] = $12) == 0) goto label_$0;
                        if ((temp[$5] = $16) == 0) goto label_$0;
                        CLEARTEMP($4);
                        }
                        """, v2)
                    o_old.extend(o2_1)
                    return new 
    if len(o1) == 8 and len(o2) == 8:
        o2_1 = Out()
        o2_1.extend(o1)
        o2_1.extend(o2)
        o2_1.extend(o)
        if o2_1[0].startswith('if (') and TxMatch(o2_1, 0, """
            if ($10) {
            if (($12) goto label_$11;
            temp[$0] = PyInt_FromLong ( $14 );
            } else {
            $16
            if ((temp[$0] = $17) == 0) goto label_$11;
            CLEARTEMP($18);
            if ($10) {
            if ($13) goto label_$11;
            temp[$1] = PyInt_FromLong ( $15 );
            } else {
            $19
            if ((temp[$1] = $9) == 0) goto label_$11;
            CLEARTEMP($8);
            """,  v2):
                    TxRepl(o2_1, 0, """
                        if ($10) {
                        if (($12) goto label_$11;
                        temp[$0] = PyInt_FromLong ( $14 );
                        if ($13) goto label_$11;
                        temp[$1] = PyInt_FromLong ( $15 );
                        } else {
                        $16
                        if ((temp[$0] = $17) == 0) goto label_$11;
                        CLEARTEMP($18);
                        $19
                        if ((temp[$1] = $9) == 0) goto label_$11;
                        CLEARTEMP($8);
                        }
                        """, v2)      
                    o_old.extend(o2_1)
                    return new 
    _o = o1 + o2 + o 
    o_old.extend(_o)
    return new
 
def CanBeFloat(t1, t2):
    if IsFloat(t1) and IsMayBeFloat(t2):
        return True
    if IsFloat(t1) and IsFloat(t2):
        return True
    if IsFloat(t2) and IsMayBeFloat(t1):
        return True
    if IsMayBeFloat(t2) and IsMayBeFloat(t1):
        return True
    if IsNoneOrIntOrFloat(t1) and IsNoneOrIntOrFloat(t2):
        if t1 == Kl_IntUndefSize and t2 == Kl_IntUndefSize:
            return False
        if IsInt(t1) and IsInt(t2):
            return False
        if IsInt(t1) and t2 == Kl_IntUndefSize:
            return False
        if IsInt(t2) and t1 == Kl_IntUndefSize:
            return False
        if (not IsInt(t1) or not IsInt(t2)):
           return True
 
    return False   
   
def CanBeInt(t1, t2):
    if (t1 is None or IsInt(t1) or IsIntUndefSize(t1)) and (t2 is None or IsInt(t2) or IsIntUndefSize(t2)):
           return True
    if type(t1) is tuple and t1[0] == 'MayBe':
        t1 = t1[1]
    if IsListAll(t1) or IsStr(t1) or IsTuple(t1) or IsFloat(t1):
        return False
    if type(t2) is tuple and t2[0] == 'MayBe':
        t2 = t2[1]
    if IsListAll(t2) or IsStr(t2) or IsTuple(t2) or IsFloat(t2):
        return False
    if IsFloat(t1) and IsFloat(t2):
        return False
    if (t1 is None or IsInt(t1) or IsIntUndefSize(t1)) and (t2 is None or IsInt(t2) or IsIntUndefSize(t2)):
           return True

    return False   

def genHalfFloat(it1, o):
    assert type(it1) is tuple
    assert type(o) is Out     
    global arifm_n
    t1 = TypeExpr(it1)
    if it1[0] == 'CONST' and type(it1[1]) is int:
        return repr(float(it1[1]))
    if it1[0] == 'CONST' and type(it1[1]) is float:
        return float_str(it1[1])
    if IsFloat(t1) and IsCVar(it1):
        return CVarName(it1)
    if IsInt(t1) and IsCVar(it1):
        return '((double)' + CVarName(it1) + ')'
    elif it1[0] in arifm_n and IsFloat(t1):
        return GenFloatExpr(it1, o)
    elif it1[0] == '!PyObject_Call' and it1[1][0] == 'CALC_CONST':
        t = it1[1][1]    
        if type(t) is tuple and len(t) == 2:
            t = (ImportedM[t[0]], t[1])
            if t in CFuncFloatOfFloat:
                if it1[2][0] == 'CONST':
                    s0 = repr(float(it1[2][1][0]))
                else:    
                    s0 = genHalfFloat(it1[2][1][0], o)
                s1 = New('double')
                o.Raw(s1, ' = ', CFuncFloatOfFloat[t], ' ( ', s0, ' );')
                o.Cls(s0)
                return s1
        if t in ImportedM:
            t = ImportedM[t]
        else:
            t = None
        if t in CFuncFloatOfFloat:
            if it1[2][0] == 'CONST':
                s0 = repr(float(it1[2][1][0]))
            else:    
                s0 = genHalfFloat(it1[2][1][0], o)
            s1 = New('double')
            o.Raw(s1, ' = ', CFuncFloatOfFloat[t], ' ( ', s0, ' );')
            o.Cls(s0)
            return s1
    ref1 = Expr1(it1, o)
    if IsFloat(t1):
        s1 = New('double')
        o.Stmt(s1, '=', 'PyFloat_AsDouble', ref1)
        o.Cls(ref1)
        return s1    
    if IsInt(t1):
        s1 = New('double')
        o.Raw(s1, ' = (double)PyInt_AsLong ( ', ref1, ' );')
        o.Cls(ref1)
        return s1    
    ref2 = New()
    o.Stmt(ref2, '=', 'PyNumber_Float', ref1)
    o.Cls(ref1)
    s1 = New('double')
    o.Stmt(s1, '=', 'PyFloat_AsDouble', ref2)
    o.Cls(ref2)
    return s1    
    
def GenFloatExpr(it, o):
    assert type(it) is tuple
    assert type(o) is Out     
    global arifm_n

    if it[0] in arifm_n and IsFloat(TypeExpr(it)):
        op = arifm_n[it[0]]
        s1 = genHalfFloat(it[1], o)
        s2 = genHalfFloat(it[2], o)
        new = New('double')
        o.Raw(new, ' = ', s1, ' ', op, ' ', s2, ';')  
        o.Cls(s1, s2)    
        return new  
    Fatal('', it)
    assert False

def not_int_op(ref1,ref2, e1,e2):
    l1 = isconstref(ref1) 
    l2 = isconstref(ref2)
    l1_0 = True
    l2_0 = True 
    if l1:
        l1_0 = type(ref1[1]) is int    
    if l2:
        l2_0 = type(ref2[1]) is int    
    if not IsNoneOrInt(TypeExpr(e1)):
        return True    
    if not IsNoneOrInt(TypeExpr(e2)):
        return True    
    if not l1_0 or not l2_0:
        return True
    return False    

def bin_arg_float(o, ref1, ref2, first, t1, t2, is_eq_op, l1, l2):
    assert not (IsIntUndefSize(t1) and IsIntUndefSize(t2))
    if not first:
        pre = '} else '
    else:
        pre = ''        
    if l1 is None and l2 is None:
        if ( IsInt(t1) or IsFloat(t1) ) and ( IsInt(t2) or IsFloat(t2)):
            o.append(pre + 'if (0) {')
        elif not IsInt(t1) and not IsFloat(t1) and ( IsInt(t2) or is_eq_op or IsFloat(t2)):    
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ')) {')
        elif not IsInt(t2) and not IsFloat(t2) and ( IsInt(t1) or IsFloat(t1)) and not is_eq_op:    
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref2, ')) {')
        elif IsIntUndefSize(t1) and t2 is None:
            o.Stmt(pre + 'if (PyInt_CheckExact(', ref1, ') && PyFloat_CheckExact(', ref2, ')) {')
        elif IsIntUndefSize(t2) and t1 is None:
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ') && PyInt_CheckExact(', ref2, ')) {')
        elif IsIntUndefSize(t1) and IsMayBeFloat(t2):
            o.Stmt(pre + 'if (PyInt_CheckExact(', ref1, ') && PyFloat_CheckExact(', ref2, ')) {')
        elif IsIntUndefSize(t2) and IsMayBeFloat(t1):
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ') && PyInt_CheckExact(', ref2, ')) {')
        else:
            if IsInt(t1) or IsInt(t2) or IsIntUndefSize(t1) or IsIntUndefSize(t2):
                Fatal('Check Intable object for float', t1, t2)
                assert False
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ') && PyFloat_CheckExact(', ref2, ')) {')
    elif l1 is not None and l2 is not None:
            o.append(pre + 'if (1) {')
            pp('Float l1 and l2', l1, l2, t1, t2, ref1, ref2)
    elif l1 is not None :    
        if not IsInt(t2) and not IsFloat(t2) and not is_eq_op:
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref2, ')) {')
        else:        
            o.append(pre + 'if (0) {')
    elif l2 is not None:    
        if not IsInt(t1) and not IsFloat(t1):
            o.Stmt(pre + 'if (PyFloat_CheckExact(', ref1, ')) {')
        else:        
            o.append(pre + 'if (0) {')
    else:
        Fatal('bin_arg_float', ref1, ref2, first)
        assert False
    return None    

type_recode = {'int': 'PyInt_Type','long':'PyLong_Type',\
               'float':'PyFloat_Type', 'bool':'PyBool_Type',\
               'object':'PyBaseObject_Type', 'unicode':'PyUnicode_Type',\
               'complex':'PyComplex_Type'}

def calc_range_1(tupl):
    try:
        li = range(*tupl[1])
        if len(li) <= 256:
            ll = [('CONST', x) for x in li]
            return ('!BUILD_LIST', tuple(ll))
    except:
        pass   
    return None 

def attempt_direct_builtin(nm_builtin, args, tupl):
    assert type(args) is tuple
    assert type(tupl) is tuple
    if nm_builtin == 'range' and tupl[0] == 'CONST':
        li = calc_range_1(tupl)
        if li is not None:
            return li
    if nm_builtin == 'chr'  and len(args) == 1:
        return ('!CHR_BUILTIN', args[0])
    if nm_builtin in type_recode:
        if nm_builtin == 'int' and len(args) == 1:
            return ('!PyNumber_Int', args[0])
        if nm_builtin == 'long' and len(args) == 1:
            return ('!PyNumber_Long', args[0])
        if nm_builtin == 'float' and len(args) == 1:
            return ('!PyNumber_Float', args[0])
        typ = type_recode[nm_builtin]
        if len(args) == 1:
            return  ('!' + typ + '.tp_new', '&' + typ, tupl, 'NULL')
    if nm_builtin == 'dir' and len(args) == 1:
        return ('!PyObject_Dir', args[0])
    if nm_builtin == 'bin' and len(args) == 1:
        return ('!PyNumber_ToBase', args[0], ('CONST', 2))
    if nm_builtin == 'id' and len(args) == 1:
        return ('!PyLong_FromVoidPtr', args[0])
    if nm_builtin == 'set' and len(args) == 0:
        return ('!PySet_New', 'NULL')
    if nm_builtin == 'set' and len(args) == 1:
        return ('!PySet_New', args[0])
    if nm_builtin == 'len' and len(args) == 1:
        t = TypeExpr(args[0])
        if IsList(t):
            return ('!PY_SSIZE_T', ('!PyList_GET_SIZE', args[0]))
        if IsTuple(t):
            return ('!PY_SSIZE_T', ('!PyTuple_GET_SIZE', args[0]))
        if IsDict(t):
            return ('!PY_SSIZE_T', ('!PyDict_Size', args[0]))
        if t == Kl_Set:
            return ('!PY_SSIZE_T', ('!PySet_Size', args[0]))
        if IsStr(t):
            return ('!PY_SSIZE_T', ('!PyString_GET_SIZE', args[0]))
        return ('!PY_SSIZE_T', ('!PyObject_Size', args[0]))
    if nm_builtin == 'repr' and len(args) == 1:
        return ('!PyObject_Repr', args[0])
    if nm_builtin == 'str' and len(args) == 1: # test_compile not pass
        if IsInt(TypeExpr(args[0])):
            return ('!PyInt_Type.tp_str', args[0])
        return ('!PyObject_Str', args[0])
    if nm_builtin == 'bytes' and len(args) == 1:
        return ('!PyObject_Str', args[0])
    if nm_builtin == 'unicode' and len(args) == 1:
        return ('!PyObject_Unicode', args[0])
    if nm_builtin == 'type' and len(args) == 1:
        return ('!PyObject_Type', args[0])
    if nm_builtin == 'dir' and len(args) == 1:
        return ('!PyObject_Dir', args[0])
    if nm_builtin == 'iter' and len(args) == 1:
        return ('!PyObject_GetIter', args[0])
    if nm_builtin == 'hash' and len(args) == 1:
        return ('!PyObject_Hash', args[0])
    if nm_builtin == 'unicode' and len(args) == 1:
        return ('!PyObject_Unicode', args[0])
    if nm_builtin == 'abs' and len(args) == 1:
        return ('!PyNumber_Absolute', args[0])
    if nm_builtin == 'format' and len(args) == 1:
        return ('!PyObject_Format', args[0], 'NULL')
    if nm_builtin == 'format' and len(args) == 2:
        return ('!PyObject_Format', args[0], args[1])
    if nm_builtin == 'tuple' and len(args) == 1:
        if IsList(TypeExpr(args[0])):
            if args[0][0] == '!BUILD_LIST':
                return TupleFromArgs(args[0][1])
            return ('!PyList_AsTuple', args[0])
        return ('!PySequence_Tuple', args[0])
    if nm_builtin == 'list' and len(args) == 1:
        return ('!PySequence_List', args[0])
    if nm_builtin == 'pow' and len(args) == 2:
        return ('!PyNumber_Power', args[0], args[1], 'Py_None')
    if nm_builtin == 'pow' and len(args) == 3:
        return ('!PyNumber_Power', args[0], args[1], args[2])
    if nm_builtin == 'hasattr' and len(args) == 2:
        return ('!BOOLEAN',('!PyObject_HasAttr', args[0], args[1]))
    if nm_builtin == 'isinstance' and len(args) == 2:
        return ('!BOOLEAN',('!PyObject_IsInstance', args[0], args[1]))
    if nm_builtin == 'issubclass' and len(args) == 2:
        return ('!BOOLEAN',('!PyObject_IsSubclass', args[0], args[1]))
    if nm_builtin == 'getattr' and len(args) == 2:
        return ('!PyObject_GetAttr', args[0], args[1])
    return None

def generate_and_or_jumped_stacked(it, o, prevref, is_and, n):
    assert type(it) is tuple
    assert type(o) is Out 
    ## leno = len(o)
    ref1 = GenExpr(it[0], o, prevref)
    assert istempref(prevref)
    if prevref != ref1:
        if n == 0:
            if istempref(ref1):
                Fatal('and_or_jumped_stacked', it)
                assert False
        else:    
            o.CLEAR(prevref)
        o.Raw(prevref, ' = ', ref1, ';')
        if istempref(ref1):
            assert n != 0
            o.Raw(ref1, ' = NULL;')
        else:    
            o.INCREF(prevref)
    if len(it) == 1:
        return ref1
    assert is_and in (True, False)
    or_and = New('int')

    _prevlast1_1 = ConC('if ((', prevref, ' = PyBool_FromLong (')
    _prevlast2_1 = ')) == 0) goto label_0;'    
    __prevlast1_1 = ConC(prevref, ' = PyBool_FromLong ( ')
    __prevlast2_1 = ' );'

    if len(o) >= 1 and \
       o[-1].startswith(_prevlast1_1) and o[-1].endswith(_prevlast2_1):
        intlast = o[-1][len(_prevlast1_1):-len(_prevlast2_1)]
        if is_and:    
            o.Raw(or_and, ' = ', intlast, ';')
        else:    
            intlast = cond_add_sk(intlast)
            o.Raw(or_and, ' = !', intlast, ';')
    elif len(o) >= 1 and \
       o[-1].startswith(__prevlast1_1) and o[-1].endswith(__prevlast2_1):
        intlast = o[-1][len(__prevlast1_1):-len(__prevlast2_1)]
        if is_and:    
            o.Raw(or_and, ' = ', intlast, ';')
        else:    
            intlast = cond_add_sk(intlast)
            o.Raw(or_and, ' = !', intlast, ';')
    else:        
        if is_and:    
            o.Stmt(or_and, '=', 'PyObject_IsTrue', prevref)
        else:    
            o.Stmt(or_and, '=', 'PyObject_Not', prevref)
    o.Stmt('if (', or_and, ') {')
    o.CLEAR(prevref)
    ## leno = len(o)
    generate_and_or_jumped_stacked(it[1:], o, prevref, is_and, n + 1)
    ## print '{{{'
    ## pprint(o[leno:])
    ## print    '}}}'
    o.append('}')
    o.Cls(or_and)
    ## print '============'
    ## pprint(it)
    ## print '----------'
    ## pprint(o[leno:])
    ## print '============'
    return prevref  

def ident_in_expr(tag, expr):
    assert type(tag) is str
    if type(expr) is str:
        if tag == expr:
            return True
    if type(expr) is tuple:
        if len(expr) > 0 and expr[0] == 'CONST':
            return False        
        for r in expr:
            if ident_in_expr(tag, r):
                return True
        return False
    if type(expr) is list:
        for r in expr:
            if ident_in_expr(tag, r):
                return True
        return False
    return False

def tag_in_expr(tag, expr):
    if type(expr) is tuple and len(expr) > 0 and type(expr[0]) is str:
        if expr[0] == tag:
            return True
        if expr[0] == 'CONST':
            return False
        for r in expr:
            if tag_in_expr(tag, r):
                return True
        return False
    if type(expr) is list:
        for r in expr:
            if tag_in_expr(tag, r):
                return True
        return False
    if type(expr) is tuple:
        for r in expr:
            if tag_in_expr(tag, r):
                return True
        return False
    return False

def count_tag_in_expr(tag, expr):
    if type(expr) is tuple and len(expr) > 0 and type(expr[0]) is str:
        if expr[0] == tag:
            return 1
        if expr[0] == 'CONST':
            return 0
        ret = 0
        for r in expr:
            ret += count_tag_in_expr(tag, r)
        return ret
    if type(expr) is list:
        ret = 0
        for r in expr:
            ret += count_tag_in_expr(tag, r)
        return ret
    if type(expr) is tuple:
        ret = 0
        for r in expr:
            ret += count_tag_in_expr(tag, r)
        return ret
    return 0

def expr_in_expr(tag_expr, expr):
    assert type(tag_expr) is tuple
    if type(expr) is tuple and len(expr) > 0:
        if type(expr[0]) is str:
            if expr[0] == 'CONST':
                return False
            if len(expr) == len(tag_expr) and expr == tag_expr:
                return True
        for r in expr:
            if type(r) is tuple:
                if expr_in_expr(tag_expr, r):
                    return True
        return False
    if type(expr) is list:
        for r in expr:
            if expr_in_expr(tag_expr, r):
                return True
        return False
    return False

def count_expr_in_expr(tag_expr, expr):
    assert type(tag_expr) is tuple
    if type(expr) is tuple and len(expr) > 0 and type(expr[0]) is str:
        if expr[0] == 'CONST':
            return 0
        if expr == tag_expr:
            return 1
        ret = 0
        for r in expr:
            ret += count_expr_in_expr(tag_expr, r)
        return ret
    if type(expr) is list:
        ret = 0
        for r in expr:
            ret += count_expr_in_expr(tag_expr, r)
        return ret
    if type(expr) is tuple:
        ret = 0
        for r in expr:
            ret += count_expr_in_expr(tag_expr, r)
        return ret
    return 0

def count_call_expr_in_expr(tag_expr, expr):
    assert type(tag_expr) is tuple
    if type(expr) is tuple and len(expr) > 0 and type(expr[0]) is str:
        if expr[0] == 'CONST':
            return 0
        if expr[0] == '!PyObject_Call' and expr[1] == tag_expr:
            return 1
        ret = 0
        for r in expr:
            ret += count_call_expr_in_expr(tag_expr, r)
        return ret
    if type(expr) is list:
        ret = 0
        for r in expr:
            ret += count_call_expr_in_expr(tag_expr, r)
        return ret
    if type(expr) is tuple:
        ret = 0
        for r in expr:
            ret += count_call_expr_in_expr(tag_expr, r)
        return ret
    return 0

def exprs_in_expr(tag_expr, expr):
    assert type(tag_expr) is dict
##    assert all([type(x) is tuple and len(x) == 2 and type(x[0]) is str and type(x[1]) is str for x in tag_expr])
    if type(expr) is tuple and len(expr) > 0 and type(expr[0]) is str:
        if expr[0] == 'CONST':
            return False
        if len(expr) == 2 and type(expr[1]) is str and expr in tag_expr:
            return True
        for r in expr:
            if exprs_in_expr(tag_expr, r):
                return True
        return False
    if type(expr) is list:
        for r in expr:
            if exprs_in_expr(tag_expr, r):
                return True
        return False
    if type(expr) is tuple:
        for r in expr:
            if exprs_in_expr(tag_expr, r):
                return True
        return False
    return False


def frame_op_in_expr(expr):
    if type(expr) is tuple:
        if len(expr) > 0 and type(expr[0]) is str:
            if expr[0] in ('EXEC_STMT', 'IMPORT_STAR', 'EXEC_STMT_3', 'EXEC_STMT_2', \
                           'EXEC_STMT_1', '(TRY', '(TRY_FINALLY', 'YIELD_STMT', \
                           '!LOAD_BUILTIN', '(WITH'):
                if expr[0].startswith('!'):
                    return len(expr) == 2 and type(expr[1]) is str and expr[1] == 'eval'
                return True
            if expr[0] == 'CONST':
                return False
            for r in expr:
                if frame_op_in_expr(r):
                    return True
            return False
        for r in expr:
            if frame_op_in_expr(r):
                return True
        return False

    if type(expr) is list:
        for r in expr:
            if frame_op_in_expr(r):
                return True
        return False
    return False

def str_tags_in_expr(tag, expr):
    assert type(tag) is frozenset
    if type(expr) is tuple:
        if len(expr) > 0 and type(expr[0]) is str:
            if expr[0] == 'CONST':
                return False
            if expr[0] in tag:
                return True
            for r in expr:
                if str_tags_in_expr(tag, r):
                    return True
            return False
        for r in expr:
            if str_tags_in_expr(tag, r):
                return True
        return False

    if type(expr) is list:
        for r in expr:
            if str_tags_in_expr(tag, r):
                return True
        return False
    return False


def New(type2=None, forcenewg=None):
    if forcenewg is not None:
        assert type(forcenewg) is tuple
        return forcenewg
    if type2 is None:
        return newgen(forcenewg)
    r = new_typed(type2, forcenewg)
    return r

traced_tempgen=[]

def newgen(forcenewg=None):
    global tempgen, traced_tempgen
    if forcenewg is not None:
        assert type(forcenewg) is tuple
        assert not tempgen[forcenewg[1]]
        return forcenewg
    n = None  
        
    for i, f in enumerate(tempgen):
        if f:
            tempgen[i] = not f
            n = ('PY_TEMP',i)
            break
    if n is None:
        tempgen.append(False)
        n = ('PY_TEMP',len(tempgen)-1)
    if len(traced_tempgen) > 0:
        dict_tempgen = traced_tempgen[-1]
        dict_tempgen[n] = True
    assert type(n) is tuple
    return n

def save_tempgen():
    return tempgen[:]

def restore_tempgen(_tempgen):
    tempgen[:] = _tempgen
    
def clearref(o,g, fictive=False):
    global tempgen
    global g_refs2
    if g in g_refs2:
        return
    if type(g) is tuple and type(g[0]) is str and g[0] == 'PY_TEMP' and g[1] < len(tempgen) and g[1] >= 0 and \
       not tempgen[g[1]]:
            if fictive:
                tempgen[g[1]] = True
                return
            tempgen[g[1]] = True
            o.Stmt('CLEARREF', g)   
            
def istempref(g):
    global tempgen
    if type(g) is tuple and len(g) == 2 and type(g[0]) is str and g[0] == 'PY_TEMP':
        i = g[1]
        if i >= 0 and i < len(tempgen):
            return True
    return False    

def reactivate_tempref(s):
    global tempgen
    for i, v in enumerate(tempgen):
        if type(s) is str:
            if s == ('temp[' + str(i).strip() + ']'):
                tempgen[i] = False
                return ('PY_TEMP', i)
        else:
            if s == ('PY_TEMP', i):
                tempgen[i] = False
                return ('PY_TEMP', i)
    pp(s)
    pp(tempgen)
    assert False
    return (None, None)

def isconstref(ref):
    return bool(type(ref) is tuple and len(ref) > 1 and ref[0] == 'CONST')


def typed_to_ctype(i):
    global typed_gen
    return typed_gen[i][1]
    
def new_typed(type_, forcenewg=None):
    global typed_gen
    if forcenewg is not None:
        assert type(forcenewg) is tuple
        assert forcenewg[0] == 'TYPED_TEMP' 
        return forcenewg

    for i, (f, t) in enumerate(typed_gen):
        if f and t == type_:
            typed_gen[i] = (not f, t)
            return ('TYPED_TEMP', i)
    typed_gen.append((False, type_))
    return ('TYPED_TEMP', len(typed_gen)-1)
    
g_typed_stack = []    
    
def clear_typed(g):
    global typed_gen
    if g in g_typed_stack:
        return
    assert g != labl
    if type(g) is tuple and g[0] == 'TYPED_TEMP' and g[1] < len(typed_gen) and g[1] >= 0 and \
       not typed_gen[g[1]][0]:
            typed_gen[g[1]] = (True, typed_gen[g[1]][1])

def is_not_active_typed(s):
    global typed_gen
    for i, v in enumerate(typed_gen):
       if v[0] and s == (v[1] + '_' + str(i).strip()):
           return True
    return False

def reactivate_typed(s):
    global typed_gen
    for i, v in enumerate(typed_gen):
        if s == (v[1] + '_' + str(i).strip()):
            if v[0]:
                typed_gen[i] = (False, v[1])
            return ('TYPED_TEMP', i)
    assert False
    return (None, None)

def istemptyped(g):
    global typed_gen
    if type(g) is tuple and len(g) == 2 and g[0] == 'TYPED_TEMP':
        i = g[1]
        if type(i) is int and i >= 0 and i < len(typed_gen):
            return True
    return False

def list_all_typed():
    global typed_gen
    return [('TYPED_TEMP', i) for i in range(len(typed_gen)) if typed_gen[i][1] != 'label']

def pd(d):
    li = d.items()
    li.sort()
    return repr(li)

def is_tuple_pack_arg(g, d):
    if type(g) is not tuple:
        return False
    if g[0] == 'CALC_CONST' and not IsCType(TypeExpr(g)):
        return True
    if g[0] in ('glob', '_f_locals', 'f->f_locals == 0 ? Py_None : f->f_locals', 'Py_None', 'CONST', '!LOAD_BUILTIN', 'BUILTIN', 'CODEFUNC'):
        return True
    elif g[0] == 'FAST'and not IsCVar(g):
        return True
    elif g[0] == '!LOAD_GLOBAL'and not IsCVar(g):
        if (g == ('!LOAD_GLOBAL', g_co.default_args_nm())):
            return True
        if fast_globals and g[1] not in d_built and\
           (g[1][0] != '_' or build_executable) and not redefined_all  and not global_used_at_generator(g[1]):
            return True
    elif g[0] == '!BINARY_SUBSCR_Int' and g[2][0] == 'CONST' and type(g[2][1]) is int and g[2][1] >= 0:
        t = TypeExpr(g[1])
        if IsTuple(t) and is_tuple_pack_arg(g[1], d):
            v = (tuple, untyped(g[1]))
            if v not in d:
                d[v] = g[2][1]
            else:
                d[v] = max(g[2][1], d[v])
            return True
        if IsList(t) and is_tuple_pack_arg(g[1], d):
            v = (list, untyped(g[1]))
            if v not in d:
                d[v] = g[2][1]
            else:
                d[v] = max(g[2][1], d[v])
            return True
    elif g[0] == '!PyObject_GetAttr' and g[2][0] == 'CONST' and type(g[2][1]) is str:
        t = TypeExpr(g[1])
        if type(t) is tuple and t[0] == T_NEW_CL_INST and is_GETATTR_compiled(t[1], g[2][1]) and is_tuple_pack_arg(g[1], d):    
            return True        
    elif g[0] == 'PY_TYPE' and is_tuple_pack_arg(g[3], d):
        return True
    return False

def get_tuple_pack_arg(g, d):
    assert type(g) is tuple
    if g[0] == 'PY_TYPE':
        return get_tuple_pack_arg(g[3], d)
    if g[0] in ('glob', '_f_locals', 'f->f_locals == 0 ? Py_None : f->f_locals', 'Py_None'):
        return g[0]
    if g[0] == '!LOAD_BUILTIN':
        return get_tuple_pack_arg(('BUILTIN', g[1]), d)
    if g[0] == '!BINARY_SUBSCR_Int':
        assert is_tuple_pack_arg(g[1], d)
        ty = TypeExpr(g[1])
        if ty is None:
            if g[1] in d:
                ty = (d[g[1]][0], None)
            if untyped(g[1]) in d:
                ty = (d[untyped(g[1])][0], None)
        if ty is None:
            unt = untyped(g[1])
            if (tuple, unt) in d:
                vv = get_tuple_pack_arg(g[1], d)
                if vv is None:
                    return None
                return 'PyTuple_GET_ITEM ( ' + vv + ' , ' + str(g[2][1]) + ' )'
            if (list, unt) in d:
                vv = get_tuple_pack_arg(g[1], d)
                if vv is None:
                    return None
                return 'PyList_GET_ITEM ( ' + vv + ' , ' + str(g[2][1]) + ' )'
                
        if type(ty) is tuple:    
            vv = get_tuple_pack_arg(g[1], d)
            if vv is None:
                return None
            if ty[0] == tuple:
                return 'PyTuple_GET_ITEM ( ' + vv + ' , ' + str(g[2][1]) + ' )'
            elif ty[0] == list:
                return 'PyList_GET_ITEM ( ' + vv + ' , ' + str(g[2][1]) + ' )'
        return None
    if g[0] == '!PyObject_GetAttr':
        assert is_tuple_pack_arg(g[1], d) and g[2][0] == 'CONST'
        ty = TypeExpr(g[1])
        if ty is None:
            if g[1] in d:
                ty = (d[g[1]][0], None)
            if untyped(g[1]) in d:
                ty = (d[untyped(g[1])][0], None)
        if type(ty) is tuple and ty[0] == T_NEW_CL_INST and is_GETATTR_compiled(ty[1], g[2][1]):
            vv = get_tuple_pack_arg(g[1], d)
            if vv is None:
                return None
            return GETATTR_compiled(ty[1], vv, g[2][1])
        
    return CVar(g)

def is_GETATTR_compiled(typ, nmattr):
    assert type(typ) is str
    assert type(nmattr) is str
    return typ in compiled_slots and nmattr in compiled_slots[typ]

def GETATTR_compiled(typ, ref_string, nmattr):
    assert type(typ) is str
    assert type(ref_string) is str
    assert type(nmattr) is str
    assert typ in compiled_slots
    assert nmattr in compiled_slots[typ]
    return 'GETATTR('+ typ +', ' + ref_string + ', ' + nmattr + ')'
    
def IsCalcConst(g):
    if g[0] == 'CALC_CONST':
        return True
    return False

def IsNotListCompr(g, t = None):
    if g[0] == '!LIST_COMPR':
        return False
    return True
    
def CVar(g):
    global typed_gen
    ret = ''
    if type(g) is tuple:
        len_g = len(g)
        if len_g == 2 and g[0] == '&' and istempref(g[1]):
            ret = '(temp + ' + str(g[1][1]) + ')'
        elif len_g == 2 and g[0] == '&' and istemptyped(g[1]):
            ret = '&' + CVar(g[1])
        elif istempref(g):
            ret = 'temp[' + str(g[1]) + ']'
        elif istemptyped(g):
            ret = typed_gen[g[1]][1] + '_' + str(g[1])
        elif g[0] == 'CALC_CONST':
            assert g[1] in calculated_const
            if calculated_const[g[1]].is_mnemonic_constant:
                return CVar(calculated_const[g[1]].mnemonic_constant_value)
            elif type(calculated_const[g[1]].nm) is str:
                ret = 'calculated_const_' + calculated_const[g[1]].nm 
            else:
                ret = 'calculated_const_' + str(calculated_const[g[1]].no)
        elif g[0] == 'CONST':
            ret = const_to(g[1])
        elif g[0] == 'BUILTIN':
            ret = load_builtin(g[1])
        elif g[0] == 'CODEFUNC':
            ret = '(PyObject *)code_' + g[1]
        elif g[0] == 'TYPE_CONVERSION':
            ret = g[1] + ' ' +  CVar(g[2])
        elif len(g) == 1:
            ret = g[0]
        elif g[0] == 'FAST':
            assert not g_co.IsCVar(g)
            ret = 'GETLOCAL(' + nmvar_to_loc(g[1]) + ')'
        elif (g == ('!LOAD_GLOBAL', g_co.default_args_nm())):
            add_fast_glob(g[1])
            ret = 'GETSTATIC(' + g[1] + ')'
        elif g[0] == '!LOAD_GLOBAL' and fast_globals and g[1] not in d_built and\
           (g[1][0] != '_' or build_executable) and not redefined_all  and not global_used_at_generator(g[1]):
            add_fast_glob(g[1])
            ret = 'GETSTATIC(' + g[1] + ')'
        elif g[0] == 'LOAD_CLOSURE':
            ret = 'GETFREEVAR(' + nmvar_to_loc(g[1]) + ')'
        elif g[0] == '!PyObject_GetAttr':
            assert g[2][0] == 'CONST'
            ty = TypeExpr(g[1])
            if type(ty) is tuple and ty[0] == T_NEW_CL_INST and is_GETATTR_compiled(ty[1], g[2][1]):
                if vv is not None:
                    ret = GETATTR_compiled(ty[1], CVar(g[1]), g[2][1])        
    elif type(g) is int:
        if g == ((MInt * -1) - 1):
            ret = 'LONG_MIN'
        else:
            ret = str(g)
    elif type(g) is float:
        ret = str(g)
    elif type(g) is bool:
        if g:
            ret = '1'
        else:
            ret = '0'
    elif g is None:
        ret = 'Py_None'
    else:
        assert type(g) is not long
        if type(g) is not str:
            pp(g)
        assert type(g) is str
        ret = g
    if type(ret) is not str:
        pp(ret, g)
    assert type(ret) is str
    if (ret == '' or ret == ' ') and g != ret:
        pprint(g)
        assert False
    return ret

d_noglob = {}
d_pre_generator = frozenset(('!LOAD_GLOBAL', 'CALC_CONST', 'STORE_GLOBAL', 'DELETE_GLOBAL','!LOAD_NAME'))
d_pre_codefunc = frozenset(('!LOAD_NAME',))
 
def clear_noglob():
    global d_noglob
    d_noglob.clear()

def add_noglob(a):
    global d_noglob
    d_noglob[a] = True
    
def collect_noglob(a):
    global d_noglob
    if type(a) is list:
        for x in a:
            collect_noglob(x)
        return
    if type(a) is tuple:
        if len(a) >= 2 and type(a[0]) is str:
            if a[0] == 'CONST':
                return
            if is_can_be_codefunc:
                if a[0] in d_pre_codefunc and g_co.c_name != 'Init_filename':
                    d_noglob[a[1]] = True
                    return
            else:
                if a[0] in d_pre_generator:
                    d_noglob[a[1]] = True
                    return
                
        for x in a:
            if type(x) is tuple:
                collect_noglob(x)
    return

def pass_find_noglob():
    global g_co, is_can_be_codefunc, d_noglob
    
    for g_co, _cmds in seqcode:
        is_can_be_codefunc = current_can_be_codefunc()    
        collect_noglob(g_co.cmds[1])
    for k in d_noglob.keys():
        if type(k) is tuple:
            d_noglob[k[0]] = True
    for k in d_noglob.keys():
        for a,b,c in Iter3(k, 'ModuleAttr', None):
            d_noglob[(k, c)] = True

def global_used_at_generator(nm):
    global d_noglob
    if type(nm) is str:
        return (nm.startswith('__') and nm.endswith('__'))
    return nm in d_noglob 
 
def load_builtin(c):
    global loaded_builtin
    assert c in d_built
    if c in loaded_builtin:
        return 'loaded_builtin[' + str(loaded_builtin.index(c)) + ']'
    loaded_builtin.append(c)    
    return 'loaded_builtin[' + str(loaded_builtin.index(c)) + ']'
 
def generate_builtin(first2, first3):
    if len(loaded_builtin) == 0:
        return
    first2.print_to('static PyObject * loaded_builtin[' + str(len(loaded_builtin)) + '];')
    first3.print_to('static void load_builtin(void){')
    for i, c in enumerate(loaded_builtin):
        first3.print_to(ConC('loaded_builtin[',i,'] = PyDict_GetItemString(bdict, "' + str(c) + '");' ))
        first3.print_to(('if (loaded_builtin[' + str(i) + '] == 0) {printf("no builtin %s\\n");}') %c)
    first3.print_to('}')

def generate_calculated_consts(first2):
    li = [(obj.no, obj.nm, obj) for k, obj in calculated_const.items()]
    li.sort()
    prev_i = -1
    for i, k, obj in li:
        if prev_i == i:
            continue
        if obj.generate and obj.store_calced:
            if IsCType(TypeExpr(('!LOAD_GLOBAL', k))) and not redefined_all and (build_executable and fast_globals):
                continue
            if type(k) is str:
                first2.print_to('static PyObject * calculated_const_' + k + ' = 0;')
            else:
                first2.print_to('// ' + repr(k))
                first2.print_to('static PyObject * calculated_const_' + str(i) + ' = 0;')
        else:
            first2.print_to('// static PyObject * calculated_const_' + str(i) + ' = ' + repr(obj.__dict__))
        prev_i = i

def generate_compiled_slots(first2):
    for k,v in compiled_slots.iteritems():
        for s in v:
            ## if s == '__dict__':
                ## continue
            first2.print_to('int offset_' + k + '_' + s + ' = 0;')

def expand_const():
    const_to(filename)
    for k in _n2c.keys():
        const_to(k)
    i = 0
    while i < len(consts):
        assert type(i) is int
        c,type_c = consts[i]    
        if type(c) is tuple:
            [const_to(x) for x in c if type(x) is not int]
        elif type(c) is frozenset:
            const_to(tuple(c))
        elif type(c) is code_extended:
            if full_pycode or not c.can_be_codefunc():
                const_to(c.co_code)
                const_to(c.co_consts)
                const_to(c.co_lnotab)
            else:   
                const_to("\x00")
                const_to(c.co_consts[:1])    
            const_to(c.co_name)
            const_to(c.co_names)
            const_to(tuple(c.co_varnames))
            const_to(c.co_freevars)
            const_to(c.co_cellvars)
        i += 1    
          
def float_str(c):
    assert type(c) is float
    if hasattr(math, 'isnan') and math.isnan(c):
        if '-' not in str(c):
            return 'Py_NAN'
        else:    
            return '(-(Py_NAN))'
    elif hasattr(math, 'isinf') and math.isinf(c):
        if '-' not in str(c):
            return 'Py_HUGE_VAL'
        else:    
            return '(-Py_HUGE_VAL)'
    return repr(c)
   
def generate_consts(first2, first3):
    const_to(())
    expand_const()

    for i, (c,type_c) in enumerate(consts):
        if type(c) is str: 
            create_chars_const(first2, i, c)
        if type(c) is long:
            if ((-MInt)-1) <= c <= MInt:
                pass
            elif c > 0: 
                c = str(c)
                create_chars_const(first2, i, c)
            else: 
                c = str(-c)
                create_chars_const(first2, i, c)
        if type(c) is unicode:
            s = ''
            for j,code in enumerate(c):
                s += str(ord(code))
                if j < len(c)-1:
                    s += ','
            lenc = len(c)
            if lenc == 0:
                lenc = 1
                s = '0'
            first3.print_to('static wchar_t const_unicode_' + str(i) + \
                        '[' + str(lenc) + '] = {' + s + '};')

    first2.print_to('static PyObject * consts[' + str(len(consts)) + '];')
    first3.print_to('static void init_consts(void){')

               
       
    for i, (c,type_c) in enumerate(consts):
        if type(c) is code_extended or type(c) is types.CodeType:
            first3.print_to('consts[' + str(i) + '] = Py_None;')
        elif type(c) is bool :    
            if c:
                first3.print_to('consts[' + str(i) + '] = Py_True;')
            else:    
                first3.print_to('consts[' + str(i) + '] = Py_False;')
            first3.print_to('Py_INCREF(consts[' + str(i) + ']);')
        elif type(c) is long:
            if c <= 30000 and c >= -30000:
                first3.print_to('consts[' + str(i) + '] = PyLong_FromLong(' + str(c) + ');')
            elif ((-MInt)-1) < c <= MInt:
                first3.print_to('consts[' + str(i) + '] = PyLong_FromLong(' + str(c) + 'l);')
            elif c > 0:    
                if need_str_name(i, c):
                    first3.print_to('consts[' + str(i) + '] = PyLong_FromString(const_string_' + str(i) + ',NULL,10);')
                else:    
                    first3.print_to('consts[' + str(i) + '] = PyLong_FromString(' + generate_chars_literal(c) + ',NULL,10);')
            else:
                if need_str_name(i, -c):
                    first3.print_to('consts[' + str(i) + '] = PyNumber_Negative(PyLong_FromString(const_string_' + str(i) + ',NULL,10));')
                else:    
                    first3.print_to('consts[' + str(i) + '] = PyNumber_Negative(PyLong_FromString(' + generate_chars_literal(-c) + ',NULL,10));')
        elif type(c) is int:
            if type(c * c) is int:
                first3.print_to('consts[' + str(i) + '] = PyInt_FromLong(' + str(c) + ');')
            elif c == ((MInt * -1) - 1):
                first3.print_to('consts[' + str(i) + '] = PyInt_FromLong( (' + str(MInt) + 'l * -1) - 1 );')
            else:
                first3.print_to('consts[' + str(i) + '] = PyInt_FromLong(' + str(c) + 'l);')
        elif type(c) is float:
            first3.print_to('consts[' + str(i) + '] = PyFloat_FromDouble(' + float_str(c) + ');')
        elif type(c) is complex:
            first3.print_to('consts[' + str(i) + '] = PyComplex_FromDoubles(' + float_str(c.real) + ', ' + float_str(c.imag) + ');')
        elif type(c) is str: # and '"' not in c and '\n' not in c:
            if need_str_name(i, c):
                first3.print_to('consts[' + str(i) + '] = PyString_FromStringAndSize(const_string_' + str(i) + ', '+str(len(c))+');')
            else:    
                first3.print_to('consts[' + str(i) + '] = PyString_FromStringAndSize(' + generate_chars_literal(c) + ', '+str(len(c))+');')
        elif type(c) is unicode: # and '"' not in c and '\n' not in c:
            first3.print_to('consts[' + str(i) + '] = PyUnicode_FromWideChar(const_unicode_' + str(i) + ', '+str(len(c))+');')
        elif type(c) is types.EllipsisType:
            first3.print_to('consts[' + str(i) + '] = &_Py_EllipsisObject;')
            first3.print_to('Py_INCREF(consts[' + str(i) + ']);')
        elif c in d_built_inv:
            nm = d_built_inv[c]
            first3.print_to('consts[' + str(i) + '] = ' + load_builtin(nm) + ';')
            first3.print_to('Py_INCREF(consts[' + str(i) + ']);')  
        elif type(c) is tuple:
            pass   
        elif type(c) is frozenset:
            pass   
        else:
            pprint(c)
            Fatal('', type(c), c)
            assert False                           
    for i, (c,type_c) in enumerate(consts):
        if type(c) is tuple:
            li = [const_to(x, True) for x in c]
            if len (li) == 0:
                first3.print_to('consts[' + str(i) + '] = PyTuple_Pack(0);')
                first3.print_to('empty_tuple = consts[' + str(i) + '];')
            else:    
                s = 'consts[' + str(i) + '] = PyTuple_Pack(' + str(len(li)) + ''.join([', ' + str(x) for x in li]) + ');'       
                first3.print_to(s)
        elif type(c) is frozenset:
            s = 'consts[' + str(i) + '] = PyFrozenSet_New(' + const_to(tuple(c)) + ');'       
            first3.print_to(s)

           
    for i, (c,type_c) in enumerate(consts):
        if type(c) is code_extended  or type(c) is types.CodeType:
            if type(c) is types.CodeType:
                c = all_co[c]
            assert type(c) is code_extended
            nm = c.c_name
            co = c  
            assert type(co) is code_extended
              
            if nm == '':
                Fatal('', c)
                assert False
            if not co.can_be_codefunc() or co.no_codefunc or co.can_be_cfunc(): ##co.co_flags & CO_GENERATOR:
                first3.Raw('assert( ', const_to(co.co_consts), '->ob_refcnt >= 1);')
                first3.print_to('consts[' + str(i) + '] = (PyObject *)PyCode_New(' +\
                    str(co.co_argcount) +', ' +\
                    str(co.co_nlocals) +', ' +\
                    str(co.co_stacksize) +', ' +\
                    str(co.co_flags) +', ' +\
                    const_to(co.co_code) +', ' +\
                    const_to(co.co_consts) +', ' +\
                    const_to(co.co_names) +', ' +\
                    const_to(tuple(co.co_varnames)) +', ' +\
                    const_to(co.co_freevars) +', ' +\
                    const_to(co.co_cellvars) +', ' +\
                    const_to(filename) +', ' +\
                    const_to(co.co_name) +', ' +\
                    str(co.co_firstlineno) +', ' +\
                    const_to(co.co_lnotab) +');')
            elif full_pycode:     
                Used('Py2CCode_New')
                first3.Raw('assert( ', const_to(co.co_consts), '->ob_refcnt >= 1);')
                first3.print_to('consts[' + str(i) + '] = (PyObject *)Py2CCode_New(' +\
                    str(co.co_argcount) +', ' +\
                    str(co.co_nlocals) +', ' +\
                    str(max(co.co_stacksize, co.new_stacksize)) +', ' +\
                    str(co.co_flags) +', ' +\
                    const_to(co.co_code) +', ' +\
                    const_to(co.co_consts) +', ' +\
                    const_to(co.co_names) +', ' +\
                    const_to(tuple(co.co_varnames)) +', ' +\
                    const_to(co.co_freevars) +', ' +\
                    const_to(co.co_cellvars) +', ' +\
                    const_to(filename) +', ' +\
                    const_to(c.co_name) +', ' +\
                    str(co.co_firstlineno) +', ' +\
                    const_to(co.co_lnotab) +', codefunc_' + nm +');')
            else:
                Used('Py2CCode_New')
                first3.Raw('assert( ', const_to(co.co_consts[:1]), '->ob_refcnt >= 1);')
                first3.print_to('consts[' + str(i) + '] = (PyObject *)Py2CCode_New(' +\
                    str(co.co_argcount) +', ' +\
                    str(co.co_nlocals) +', ' +\
                    str(max(co.co_stacksize,co.new_stacksize)) +', ' +\
                    str(co.co_flags) +', ' +\
                    const_to("\x00") +', ' +\
                    const_to(co.co_consts[:1]) +', ' +\
                    const_to(co.co_names) +', ' +\
                    const_to(tuple(co.co_varnames)) +', ' +\
                    const_to(co.co_freevars) +', ' +\
                    const_to(co.co_cellvars) +', ' +\
                    const_to(filename) +', ' +\
                    const_to(c.co_name) +', ' +\
                    str(co.co_firstlineno) +', ' +\
                    const_to("\x00") +', codefunc_' + nm +');')


    for c,type_c in consts:
        if type(c) is tuple:
            codes = [(j,c1) for j,c1 in enumerate(c) if type(c1) is code_extended or type(c1) is types.CodeType]
            for j, c1 in codes:
                s1 = const_to(c1)
                s_inc = 'Py_INCREF(' + s1 + ');'
                s2 = const_to(c)
                s_clear = 'Py_DECREF(PyTuple_GET_ITEM(' + s2 + ', ' + str(j) + '));'
                s_set = 'PyTuple_SET_ITEM(' + s2 + ', ' + str(j) + ', ' + s1 + ');'
                first3.print_to(s_inc)
                first3.print_to(s_clear)
                first3.print_to(s_set)

    first3.print_to('}')

visibl = set('-=+_~!@#$%^&*()[]{};:/?.>,< ')
def is_c(c):
    assert type(c) is str
    for _c in c:
        if _c.isalnum() or _c in visibl:
            pass
        else:
            return False
    return True

def is_c_2(c):
    assert type(c) is str
    for _c in c:
        if _c.isalnum() or _c in visibl or _c in '\n\r\t':
            pass
        else:
            return False
    return True

def str_to_c_2(s):
    assert type(s) is str
    s2 = ''
    for c in s:
        if c.isalnum() or c in visibl:
            s2 += c
        elif c == '\n':
            s2 += '\\n'    
        elif c == '\r':
            s2 += '\\r'    
        elif c == '\t':
            s2 += '\\t'
        else:
            assert False
    return s2                

def generate_chars_literal(c):
    if type(c) is int:
        return '"' + str(c) + '"'
    if type(c) is long:
        return '"' + str(c) + 'l"'
    assert type(c) is str
    if is_c(c):
        return '"' + c + '"'
    elif is_c_2(c):
        return '"' + str_to_c_2(c) + '"'
    else:            
        return Str_for_C(c)
    
def need_str_name(i, c):
    if i in predeclared_chars:
        return True
    if type(c) is int or type(c) is long:
        return False
    assert type(c) is str
    if is_c(c) or is_c_2(c):
        return False
    return True
    
def create_chars_const(first2, i, c):
    assert type(c) is str
    if is_c(c):
        if i in predeclared_chars:
            first2.print_to('static const char const_string_' + str(i) + \
                    '[' + str(len(c)+1) + '] = "' + c + '";')
    elif is_c_2(c):
        if i in predeclared_chars:
            first2.print_to('static const char const_string_' + str(i) + \
                    '[' + str(len(c)+1) + '] = "' + str_to_c_2(c) + '";')
    else:     
        s = ','.join([str(ord(code)) for code in c])
        first2.print_to('static const char const_string_' + str(i) + \
                '[' + str(len(c)+1) + '] = {' + s + ',0};')

def print_to(c_f,v):
    pp_out( c_f, v)

def index_const_to(c):
    global consts
    global consts_dict
    
    const_to(c)
    c_ = c,const_type(c)    
    if c_ in consts_dict:
        i = consts_dict[c_]
        return i
    Fatal('',c)
    assert False
    return -1
    
def const_to(c, final = False):
    global consts
    global consts_dict
    
    if type(c) is code_extended:
        return const_to(c.co_original)
    if type(c) is tuple and len(c) > 0 and type(c[0]) is tuple and len(c[0]) > 0 and c[0][0] == '!':
        Fatal('', c)
        assert False
    if c is None:
        return 'Py_None'
    c_ = c,const_type(c)    
    if c_ in consts_dict:
        i = consts_dict[c_]
        return 'consts[' + str(i) + ']'
    if type(c) is tuple:
        [const_to(x) for x in c if type(x) is not int or x == ((MInt * -1) - 1)]
    if type(c_[0]) is float:
        if hasattr(math, 'isinf') and  math.isinf(c_[0]):
            for i, (cc, cc_typ) in enumerate(consts):
                if type(cc) is float:
                    if math.isinf(cc) and str(cc) == str(c_[0]):
                        return 'consts[' + str(i) + ']'
        if hasattr(math, 'isnan') and  math.isnan(c_[0]):
            for i, (cc, cc_typ) in enumerate(consts):
                if type(cc) is float:
                    if math.isnan(cc) and str(cc) == str(c_[0]):
                        return 'consts[' + str(i) + ']'
    if final and type(c) is int and c != ((MInt * -1) - 1):
        return 'PyInt_FromLong ( ' + str(c) + ' )'
    consts.append(c_)   
    consts_dict[c_] = len(consts) - 1 
    return 'consts[' + str(len(consts)-1) + ']'

def const_type(c):
    if type(c) is tuple:
        return tuple([const_type(x) for x in c])
    if type(c) in (float, complex):
        return type(c) , repr(c)
    return type(c)
 
def pregenerate_code_objects():
    for co in _n2c.values():
        assert type(co) is code_extended
        if full_pycode or not co.can_be_codefunc(): ##co.co_flags & CO_GENERATOR:
            const_to(co.co_code)
            const_to(co.co_consts)
            const_to(co.co_lnotab)
        else:
            const_to(co.co_consts[:1])    
        const_to(co.co_name)
        const_to(co.co_names)
        const_to(tuple(co.co_varnames))
        const_to(co.co_freevars)
        const_to(co.co_cellvars)
        const_to(co)
        
def ArgIsConstNotZero(a, t = None):
    if a[0] == 'CONST' and a[1] != 0:
        return True
    return False

def ArgIsConst2(a, t = None):
    if a[0] == 'CONST' and a[1] == 2:
        return True
    return False

## def ArgIsConstInSlots_(a, t = None):
    ## assert False
    ## if a[0] == 'CONST':
        ## if a[1] != '__dict__':
            ## for k,v in compiled_slots.iteritems():
                ## if a[1] in v:
                    ## return True

    ## return False

def ArgIsConstNotInSlots_(a, t = None):
    if a[0] == 'CONST' and not a[1].startswith('__') and a[1] not in inverted_compiled_slots:
        return True
    return False

def ArgIsConst_(a, t = None):
    if a[0] == 'CONST':
        return True
    return False

def ArgIsInCodeFunc_(a, t = None):
    return is_current != IS_DIRECT

def ArgIsCompiledSlots_(a, t = None):

    if t is None:
        t = TypeExpr(a)
    if type(t) is tuple and t[1] in compiled_slots:
        return True
    return False

def ArgIsConst_TuplStr_(a, t = None):
    if a[0] == 'CONST' and type(a[1]) is tuple and len(a[1]) > 0:
        return all([type(x) is str for x in a[1]])
    return False

def ArgIsConst_TuplChar_(a, t = None):
    if a[0] == 'CONST' and type(a[1]) is tuple and len(a[1]) > 0:
        return all([type(x) is str and len(x) == 1 for x in a[1]])
    return False

def ArgIsConst_TuplInt_(a, t = None):
    if a[0] == 'CONST' and type(a[1]) is tuple and len(a[1]) > 0:
        return all([type(x) is int for x in a[1]])
    return False

def ArgIsConstFrom1To31(a, t = None):
    if a[0] == 'CONST' and 1 <= a[1] <= 31:
        return True
    return False

def ArgIsConstCardinal(a, t = None):
    if a[0] == 'CONST' and a[1] >= 0:
        return True
    return False

def ArgIsDerivedFromList(a, t = None):
    return IsListAll(TypeExpr(a))

def ArgIsCalcConst(a, t = None):
    if type(a) is tuple and a[0] == 'CALC_CONST':
        return True
    return False

def ArgNotIsCVar(a, t = None):
    return not ArgIsCVar(a, t)

## def ArgNotIsCVar1(a, t = None):
    ## return True

def ArgIsCVar(a, t = None):
    a0 = a[0]
    assert type(a0) is str
    if a0 == 'PY_TYPE':
        a = a[3]
    if not IsC(t):
        return False
    if a0 == 'FAST':
        return IsCVar(a)
    if a0 == 'CONST':
        return False
    if a0 == '!@PyInt_FromSsize_t':
        return ArgIsCVar(a[2], TypeExpr(a[2]))
    if a0 == '!PY_SSIZE_T':
        return True
    if a0 in ('!PyNumber_Subtract', '!PyNumber_Add', '!CALL_CALC_CONST', 
                '!PyNumber_Negative', '!PyNumber_Multiply', '!PyNumber_Divide', 
                '!PyNumber_And', '!PyNumber_Or', '!PyDict_Contains', '!PyObject_HasAttr',
                '!PyObject_RichCompare(', '!AND_JUMP', '!OR_JUMP', '!1NOT', 
                '!PySequence_Contains', '!PySequence_Contains(', '!PyObject_IsInstance', 
                '!PyObject_IsSubclass', '!PyObject_Size', '!PyObject_IsTrue', 
                '!PyObject_Hash', '!PyNumber_Xor', '!PyNumber_Or', '!PyNumber_And',
                '!PyNumber_Rshift', '!PyNumber_Remainder', '!PyObject_RichCompare'):    
        return True
    if a0 == '!LOAD_GLOBAL':
        return IsCVar(a)
    if a0 == '!BINARY_SUBSCR_Int':
        if IsStr(TypeExpr(a[1])) and IsInt(TypeExpr(a[2])):
            return True
        return False
    if a0.startswith('!_PyString_'):
        return True
    if a0 == '!BOOLEAN':
        a = a[1]
        if a0 in ('!_EQ_', '!_NEQ_', '!AND_JUMP', '!OR_JUMP', '!AND_BOOLEAN', 
                    '!OR_BOOLEAN', '!PyDict_Contains', '!PyObject_HasAttr',
                    '!PySequence_Contains', '!PySequence_Contains(', 
                    '!PyObject_IsSubclass', '!PyObject_IsInstance',
                    '!PyObject_RichCompare', '!PyObject_RichCompare(',
                    '!SSIZE_T==', '!SSIZE_T!=', '!SSIZE_T>=', '!SSIZE_T<=',
                    '!SSIZE_T<', '!SSIZE_T>') or a0.startswith('!c_Py_'):
            return True
    if a0 in ('!PyObject_GetAttr',):
        if IsBool(t) and t[1] is not None:
            return True
        return False
    if a0 == '!from_ceval_BINARY_SUBSCR' and IsStr(TypeExpr(a[1])) and IsInt(TypeExpr(a[2])):
        return True
    ## a_ = a
    
    
    ## head, a, t = reorg_before(a, t)  
    ## if head in ('PyObject_IsTrue', 'ord', 'cmp', 'callable'):
        ## return True
    return True
  
def ArgIsStrConsted(a, t = None):
    t = TypeExpr(a)
    if IsStr(t) and type(t[1]) is str:
        return True
    return False

def CmpEqTypeStr(it1, it2, t1, t2):
    assert IsStr(t1) and type(t1[1]) is str and IsStr(t2) and type(t2[1]) is str
    if t1[1] == t2[1]:
        return '1'
    else:
        return '0'

def CmpNeTypeStr(it1, it2, t1, t2):
    assert IsStr(t1) and type(t1[1]) is str and IsStr(t2) and type(t2[1]) is str
    if t1[1] != t2[1]:
        return '1'
    else:
        return '0'
        




def ConstIntToConstChar(a,b):
    assert len(a) == 1 and a[0][0] == 'CONST' 
    a2 = a[0][1]
    assert type(a2) is int
    c = chr(a2)
    c = repr(c)
    assert c[0] == "'"
    return c


Kl_C = ('C', None)
Kl_O = ('O', None)
Kl_ProbablyInt = ('ProbablyInt', None)
Kl_OString = ('OString', None)

linear_type_rule = [

("1NOT",               Kl_Boolean, None,  None, None,                   Kl_Boolean, "!({L1})"),
("1NOT",               Kl_Int, None,      None, None,                   Kl_Boolean, "({L1} == 0)"),

("PySequence_Contains",Kl_Char, None,   Kl_Char, None,                  Kl_Boolean,  "({L1} == {L2})"),

("PySequence_Contains",Kl_String, None,   Kl_Char, None,                Kl_Boolean,  "(memchr(PyString_AS_STRING({L1}), {L2}, PyString_GET_SIZE({L1})) != NULL)"),
("PySequence_Contains", Kl_String,None,   Kl_String, None,              Kl_Boolean,  "(fastsearch(PyString_AS_STRING({L1}), PyString_GET_SIZE({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2}), -1, FAST_SEARCH) >= 0)", 'fastsearch'),

("_PyString_StartSwith", Kl_String, None, Kl_Char, None,                Kl_Boolean,  "(PyString_GET_SIZE({L1}) >= 1 && *PyString_AS_STRING({L1}) == {L2})"),
("_PyString_StartSwith", Kl_String, None, Kl_String, None,              Kl_Boolean,  "(PyString_GET_SIZE({L1}) >= PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2})))"),
("M:startswith",         [(Kl_String, None), (Kl_String, None), (Kl_Cardinal, None)],
                                                                        Kl_Boolean,  "((PyString_GET_SIZE({L1}) - {L3}) >= PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1}) + {L3}, PyString_AS_STRING({L2}), PyString_GET_SIZE({L2})))"),
("M:startswith",         ('MayBe', Kl_String), None, Kl_String, None,   Kl_Boolean,  "(PyString_GET_SIZE({L1}) >= PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2})))", None, ('{L2} == Py_None', 'PyErr_Format(PyExc_AttributeError, "''NoneType'' object has no attribute ''startswith''");')),
("M:startswith",         Kl_Tuple, None,  Kl_O, None,                   Kl_None,     "Py_None", None, ('1', 'PyErr_Format(PyExc_AttributeError, "''tuple'' object has no attribute ''startswith''");')),
("M:startswith",         Kl_List, None,   Kl_O, None,                   Kl_None,     "Py_None", None, ('1', 'PyErr_Format(PyExc_AttributeError, "''list'' object has no attribute ''startswith''");')),

("_PyString_EndSwith", Kl_String, None,   Kl_Char, None,                Kl_Boolean,  "(PyString_GET_SIZE({L1}) >= 1 && PyString_AS_STRING({L1})[PyString_GET_SIZE({L1})-1] == {L2})"),
("_PyString_EndSwith", Kl_String, None,   Kl_String, None,              Kl_Boolean,  "(PyString_GET_SIZE({L1}) >= PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1})+(PyString_GET_SIZE({L1})-PyString_GET_SIZE({L2})), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2})))"),

("_PyString_Count",    Kl_String, None,   Kl_Char, None,                Kl_Cardinal,  ["{", "char _for_cnt[1];", "_for_cnt[0] = {L2};", "{LI} = fastsearch(PyString_AS_STRING({L1}), PyString_GET_SIZE({L1}), _for_cnt, 1, -1, FAST_COUNT);", "if ({LI} == -1) {LI} = 0;", "}", "{LI}"], 'fastsearch'),
("_PyString_Count",    Kl_String, None,   Kl_String, None,              Kl_Cardinal,  ["{LI} = fastsearch(PyString_AS_STRING({L1}), PyString_GET_SIZE({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2}), -1, FAST_COUNT);", "if ({LI} == -1) {LI} = 0;", "{LI}"], 'fastsearch'),
("_PyString_Count",    [(Kl_String, None), (Kl_String, None), (Kl_Int, None)],  
                                                                        Kl_Cardinal,  ["{LI} = fastsearch_slice1(PyString_AS_STRING({L1}), PyString_GET_SIZE({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2}), {L3}, -1, FAST_COUNT);", 
                                                                                       "if ({LI} == -1) {LI} = 0;", 
                                                                                       "{LI}"], 'fastsearch_slice1'),

("_PyString_Find",     Kl_String, None,   Kl_String, None,              Kl_Int,       "fastsearch(PyString_AS_STRING({L1}), PyString_GET_SIZE({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2}), -1, FAST_SEARCH)", 'fastsearch'),
("_PyString_Find",     [(Kl_String, None),  (Kl_String, None), (Kl_Int, None)],
                                                                        Kl_Int,       "fastsearch_slice1(PyString_AS_STRING({L1}), PyString_GET_SIZE({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2}), {L3}, -1, FAST_SEARCH)", 'fastsearch_slice1'),
("_PyString_RFind",    Kl_String, None,   Kl_String, None,              Kl_Int,       "fastsearch(PyString_AS_STRING({L1}), PyString_GET_SIZE({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2}), -1, FAST_RSEARCH)", 'fastsearch'),
("_PyString_RFind",    [(Kl_String, None),  (Kl_String, None), (Kl_Int, None)],
                                                                        Kl_Int,       "fastsearch_slice1(PyString_AS_STRING({L1}), PyString_GET_SIZE({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2}), {L3}, -1, FAST_RSEARCH)", 'fastsearch_slice1'),

("_PyString_Index",    Kl_String, None,   Kl_String, None,              Kl_Int,       ["{LI} = fastsearch(PyString_AS_STRING({L1}), PyString_GET_SIZE({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2}), -1, FAST_SEARCH);",
                                                                                       "if ({LI} == -1) goto {LE};",
                                                                                       "{LI}"], 'fastsearch', (None, 'PyErr_SetString(PyExc_ValueError, "substring not found");')),
("_PyString_Index",    [(Kl_String, None),  (Kl_String, None), (Kl_Int, None)],
                                                                        Kl_Int,       ["{LI} = fastsearch_slice1(PyString_AS_STRING({L1}), PyString_GET_SIZE({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2}), {L3}, -1, FAST_SEARCH);",
                                                                                       "if ({LI} == -1) goto {LE};",
                                                                                       "{LI}"], 'fastsearch_slice1', (None, 'PyErr_SetString(PyExc_ValueError, "substring not found");')),
("_PyString_RIndex",   Kl_String, None,   Kl_String, None,              Kl_Int,       ["{LI} = fastsearch(PyString_AS_STRING({L1}), PyString_GET_SIZE({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2}), -1, FAST_RSEARCH);",
                                                                                       "if ({LI} == -1) goto {LE};",
                                                                                       "{LI}"], 'fastsearch', (None, 'PyErr_SetString(PyExc_ValueError, "substring not found");')),
("_PyString_RIndex",   [(Kl_String, None),  (Kl_String, None), (Kl_Int, None)],
                                                                        Kl_Int,       ["{LI} = fastsearch_slice1(PyString_AS_STRING({L1}), PyString_GET_SIZE({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2}), {L3}, -1, FAST_RSEARCH);",
                                                                                       "if ({LI} == -1) goto {LE};",
                                                                                       "{LI}"], 'fastsearch_slice1', (None, 'PyErr_SetString(PyExc_ValueError, "substring not found");')),

("M:strip",            [(Kl_String, None)],                            Kl_String,     ["{LR} = _PyString_Strip((PyStringObject *){L1});",
                                                                                       "if ({LR} == 0) goto L0;",
                                                                                       "{LR}"], '_PyString_Strip'),

("M:replace",          [(Kl_String, None), (Kl_String, None), (Kl_String, None)], Kl_String,
                                                                                      ["if (({LR} = (PyObject *)_PyString_Replace((PyStringObject *){L1}, PyString_AS_STRING({L2}), PyString_GET_SIZE({L2}), PyString_AS_STRING({L3}), PyString_GET_SIZE({L3}), PY_SSIZE_T_MAX)) == 0) goto L0;",
                                                                                       "{LR}"], '_PyString_Replace'),
('PyEval_CallObject',  Kl_O, None, Kl_Tuple, None,       (types.ModuleType, None),    ["if (({LR} = PyEval_CallObject ( {L1} , {L2} )) == 0) goto L0;",
                                                                                       "{LR}"]),
("==,==,==",           [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None), (Kl_Int, None)], 
                                                                          Kl_Boolean,  "({L1} == {L2} && {L2} == {L3} && {L3} == {L4})"),
("==,==",              [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} == {L2} && {L2} == {L3})"),
(">=,>=",              [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} >= {L2} && {L2} >= {L3})"),
("=,>=",               [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} == {L2} && {L2} >= {L3})"),
("==,>=",              [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} == {L2} && {L2} >= {L3})"),
(">,>",                [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} > {L2} && {L2} > {L3})"),
(">,>=",               [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} > {L2} && {L2} >= {L3})"),
(">=,>",               [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} >= {L2} && {L2} > {L3})"),
("!=,!=",              [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} != {L2} && {L2} != {L3})"),
("=,!=",               [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} == {L2} && {L2} != {L3})"),
("<=,<=",              [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} <= {L2} && {L2} <= {L3})"),
("<,<",                [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} < {L2} && {L2} < {L3})"),
("<,<=",               [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} < {L2} && {L2} <= {L3})"),
("<=,>",               [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} <= {L2} && {L2} > {L3})"),
("<=,<",               [(Kl_Int, None),  (Kl_Int, None), (Kl_Int, None)], Kl_Boolean,  "({L1} <= {L2} && {L2} < {L3})"),

("==,==,==",           [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None), (Kl_Float, None)], 
                                                                          Kl_Boolean,  "({L1} == {L2} && {L2} == {L3} && {L3} == {L4})"),
("==,==",              [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} == {L2} && {L2} == {L3})"),
(">=,>=",              [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} >= {L2} && {L2} >= {L3})"),
("=,>=",               [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} == {L2} && {L2} >= {L3})"),
("==,>=",              [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} == {L2} && {L2} >= {L3})"),
(">,>",                [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} > {L2} && {L2} > {L3})"),
(">,>=",               [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} > {L2} && {L2} >= {L3})"),
(">=,>",               [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} >= {L2} && {L2} > {L3})"),
("!=,!=",              [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} != {L2} && {L2} != {L3})"),
("=,!=",               [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} == {L2} && {L2} != {L3})"),
("<=,<=",              [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} <= {L2} && {L2} <= {L3})"),
("<,<",                [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} < {L2} && {L2} < {L3})"),
("<,<=",               [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} < {L2} && {L2} <= {L3})"),
("<=,>",               [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} <= {L2} && {L2} > {L3})"),
("<=,<",               [(Kl_Float, None),  (Kl_Float, None), (Kl_Float, None)], Kl_Boolean,  "({L1} <= {L2} && {L2} < {L3})"),

("==,==",              [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) == ((unsigned char){L2}) && ((unsigned char){L2}) == ((unsigned char){L3}))"),
(">=,>=",              [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) >= ((unsigned char){L2}) && ((unsigned char){L2}) >= ((unsigned char){L3}))"),
("=,>=",               [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) == ((unsigned char){L2}) && ((unsigned char){L2}) >= ((unsigned char){L3}))"),
("==,>=",              [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) == ((unsigned char){L2}) && ((unsigned char){L2}) >= ((unsigned char){L3}))"),
(">,>",                [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) > ((unsigned char){L2}) && ((unsigned char){L2}) > ((unsigned char){L3}))"),
(">,>=",               [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) > ((unsigned char){L2}) && ((unsigned char){L2}) >= ((unsigned char){L3}))"),
(">=,>",               [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) >= ((unsigned char){L2}) && ((unsigned char){L2}) > ((unsigned char){L3}))"),
("!=,!=",              [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) != ((unsigned char){L2}) && ((unsigned char){L2}) != ((unsigned char){L3}))"),
("=,!=",               [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) == ((unsigned char){L2}) && ((unsigned char){L2}) != ((unsigned char){L3}))"),
("<=,<=",              [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) <= ((unsigned char){L2}) && ((unsigned char){L2}) <= ((unsigned char){L3}))"),
("<,<",                [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) < ((unsigned char){L2}) && ((unsigned char){L2}) < ((unsigned char){L3}))"),
("<,<=",               [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) < ((unsigned char){L2}) && ((unsigned char){L2}) <= ((unsigned char){L3}))"),
("<=,<",               [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) <= ((unsigned char){L2}) && ((unsigned char){L2}) < ((unsigned char){L3}))"),
("<=,>",               [(Kl_Char, None),  (Kl_Char, None), (Kl_Char, None)], Kl_Boolean,  "(((unsigned char){L1}) <= ((unsigned char){L2}) && ((unsigned char){L2}) > ((unsigned char){L3}))"),

("<=,<=",              [(Kl_Char, None),  (Kl_String, None), (Kl_Char, None)], 
                                                                          Kl_Boolean,  ["if ( PyString_GET_SIZE({L2}) == 1 ) {",
                                                                                        "{LB} = (((unsigned char){L1}) <= ((unsigned char)*PyString_AS_STRING({L2})) && ((unsigned char)*PyString_AS_STRING({L2})) <= ((unsigned char){L3}));",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_LE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),
("<=,<=",              [(Kl_Char, None),  (Kl_Undefined, None), (Kl_Char, None)], 
                                                                          Kl_Boolean,  ["if ( PyString_CheckExact({L2}) && PyString_GET_SIZE({L2}) == 1 ) {",
                                                                                        "{LB} = (((unsigned char){L1}) <= ((unsigned char)*PyString_AS_STRING({L2})) && ((unsigned char)*PyString_AS_STRING({L2})) <= ((unsigned char){L3}));",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_LE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),

("==,==",              [(Kl_Int, None        ),  (Kl_ProbablyInt, None), (Kl_Int, None        )], 
                                                                          Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                        "{LB} = ({L1} == PyInt_AS_LONG({L2}) && PyInt_AS_LONG({L2}) == {L3});",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_EQ )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),
("==,>=",              [(Kl_Int, None        ),  (Kl_ProbablyInt, None), (Kl_Int, None        )], 
                                                                          Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                        "{LB} = ({L1} == PyInt_AS_LONG({L2}) && PyInt_AS_LONG({L2}) >= {L3});",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_GE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),

("<=,<=",              [((int, ((-MInt)-1, (-MInt)-1)), None        ),  (Kl_ProbablyInt, None), ((int, (MInt, MInt)), None        )], 
                                                                          Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                        "{LB} = 1;",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_LE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),

("<=,<=",              [(Kl_Int, None        ),  (Kl_ProbablyInt, None), (Kl_Int, None        )], 
                                                                          Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                        "{LB} = ({L1} <= PyInt_AS_LONG({L2}) && PyInt_AS_LONG({L2}) <= {L3});",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_LE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),
("<=,<=",              [(Kl_Int, None        ),  (Kl_O, None), (Kl_Int, None        )], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_LE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),

(">=,>=",              [(Kl_Int, None        ),  (Kl_O, None), (Kl_Int, None         )], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_GE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_GE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),

("<=,<",               [(Kl_Int, None        ),  (Kl_ProbablyInt, None), (Kl_Int, None        )], 
                                                                          Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                        "{LB} = ({L1} <= PyInt_AS_LONG({L2}) && PyInt_AS_LONG({L2}) < {L3});",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_LT )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),

("<=,<",               [(Kl_Float, None        ),  (Kl_Undefined, None), (Kl_Float, None        )], 
                                                                          Kl_Boolean,  ["if ( PyFloat_CheckExact({L2}) ) {",
                                                                                        "{LB} = ({L1} <= PyFloat_AS_DOUBLE({L2}) && PyFloat_AS_DOUBLE({L2}) < {L3});",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_LT )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),

("<=,<",               [(Kl_Int, None        ),  (Kl_ProbablyInt, None), (Kl_ProbablyInt, None)], 
                                                                          Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) && PyInt_CheckExact({L2}) ) {",
                                                                                        "{LB} = ({L1} <= PyInt_AS_LONG({L2}) && PyInt_AS_LONG({L2}) < PyInt_AS_LONG({L3}));",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_LT )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),

("<=,<",               [(Kl_Int, None        ),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_LT )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),

("<,<",                [(Kl_Int, None        ),  (Kl_ProbablyInt, None), (Kl_Int, None        )], 
                                                                          Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                        "{LB} = ({L1} < PyInt_AS_LONG({L2}) && PyInt_AS_LONG({L2}) < {L3});",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LT )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_LT )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),
("<,<",                [(Kl_Float, None        ),  (Kl_Undefined, None), (Kl_Float, None        )], 
                                                                          Kl_Boolean,  ["if ( PyFloat_CheckExact({L2}) ) {",
                                                                                        "{LB} = ({L1} < PyFloat_AS_DOUBLE({L2}) && PyFloat_AS_DOUBLE({L2}) < {L3});",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LT )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_LT )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),

("<,<=",                [(Kl_Int, None        ),  (Kl_ProbablyInt, None), (Kl_Int, None        )], 
                                                                          Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                        "{LB} = ({L1} < PyInt_AS_LONG({L2}) && PyInt_AS_LONG({L2}) <= {L3});",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LT )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_LE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),
("<,<=",                [(Kl_Int, None        ),  (Kl_O, None), (Kl_Int, None        )], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LT )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_LE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
                                                                                        
("==,==",              [(Kl_ProbablyInt, None),  (Kl_ProbablyInt, None), (Kl_Int, None        )], 
                                                                          Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                        "{LB} = (PyInt_AS_LONG({L1}) == PyInt_AS_LONG({L2}) && PyInt_AS_LONG({L2}) == {L3});",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_EQ )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),

("==,>=",              [(Kl_ProbablyInt, None),  (Kl_ProbablyInt, None), (Kl_Int, None        )], 
                                                                          Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                        "{LB} = (PyInt_AS_LONG({L1}) == PyInt_AS_LONG({L2}) && PyInt_AS_LONG({L2}) >= {L3});",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L3} , Py_GE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),

("==,==",              [(Kl_Undefined, None),  (Kl_Undefined, None), (Kl_String, None)], 
                                                                          Kl_Boolean,  ["if ( PyString_CheckExact({L1}) && PyString_CheckExact({L1}) ) {",
                                                                                        "{LB} = PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && PyString_GET_SIZE({L2}) == PyString_GET_SIZE({L3}) && (memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L1})) == 0) && (memcmp(PyString_AS_STRING({L2}) ,PyString_AS_STRING({L3}) , PyString_GET_SIZE({L3})) == 0);",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_EQ )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),

("==,==",              [(Kl_Undefined, None),  (Kl_Char, None        ), (Kl_Undefined, None)], 
                                                                          Kl_Boolean,  ["if ( PyString_CheckExact({L1}) && PyString_CheckExact({L3}) ) {",
                                                                                        "{LB} = PyString_GET_SIZE({L1}) == 1 && 1 == PyString_GET_SIZE({L3}) && *PyString_AS_STRING({L1}) == {L2} && {L2} == *PyString_AS_STRING({L3});",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_EQ )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( O{L2} , {L3} , Py_EQ )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),
("==,==",              [(Kl_Undefined, None),  (Kl_String, None        ), (Kl_Undefined, None)], 
                                                                          Kl_Boolean,  ["if ( PyString_CheckExact({L1}) && PyString_CheckExact({L3}) ) {",
                                                                                        "{LB} = PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && PyString_GET_SIZE({L2}) == PyString_GET_SIZE({L3}) && (memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L1})) == 0) && (memcmp(PyString_AS_STRING({L2}) ,PyString_AS_STRING({L3}) , PyString_GET_SIZE({L2})) == 0);",
                                                                                        "} else {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_EQ )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),

("is,is,is",           [(Kl_O, None),  (Kl_O, None), (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,   "({L1} == {L2} && {L2} == {L3} && {L3} == {L4})"),
("is,is",              [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,   "({L1} == {L2} && {L2} == {L3})"),
("is not,is not",      [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,   "({L1} != {L2} && {L2} != {L3})"),

("==,==",              [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_EQ )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
("!=,!=",              [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_NE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),

(">,<",              [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GT )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_LT )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
("<,>",              [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_GT )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
("==,!=",              [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_NE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
("=,!=",               [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_NE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
("<=,<=",               [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_LE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
("<=,<",                [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_LT )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
("<,<",                 [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_LT )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
("<,<=",                 [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_LE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
(">,>=",                 [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GT )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_GE )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
("==,==,==",           [(Kl_O, None),  (Kl_O, None), (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L2} , {L3} , Py_EQ )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PyObject_RichCompareBool ( {L3} , {L4} , Py_EQ )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "}",
                                                                                        "{LB}"]),
("in,in",                 [(Kl_O, None),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PySequence_Contains ( {L2} , {L1} )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PySequence_Contains ( {L3} , {L2} )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
("in,in",                 [(Kl_C, None        ),  (Kl_O, None), (Kl_O, None)], 
                                                                          Kl_Boolean,  ["if (({LB} = PySequence_Contains ( {L2} , O{L1} )) == -1) goto L0;", 
                                                                                        "if ({LB}) {",
                                                                                        "if (({LB} = PySequence_Contains ( {L3} , {L2} )) == -1) goto L0;", 
                                                                                        "}",
                                                                                        "{LB}"]),
                                                                                        
('COND_EXPR',           [((bool, True), None), (Kl_Int, None), (Kl_Int, None)],
                                                                        Kl_Int, ["S{L2}", "{L2}"]),
('COND_EXPR',           [((bool, False), None), (Kl_Int, None), (Kl_Int, None)],
                                                                        Kl_Int, ["S{L3}", "{L3}"]),
('COND_EXPR',           [(Kl_Boolean, None), (Kl_Int, None), (Kl_Int, None)],
                                                                        Kl_Int, ["S{L1}", 
                                                                                 "if ({L1}) {", 
                                                                                 "S{L2}",
                                                                                 "{LI} = {L2};", 
                                                                                 "} else {", 
                                                                                 "S{L3}",
                                                                                 "{LI} = {L3};",
                                                                                 "}",
                                                                                 "{LI}"]), 
('COND_EXPR',           [(Kl_Boolean, None), (Kl_Boolean, None), (Kl_Boolean, None)],
                                                                        Kl_Boolean, ["S{L1}", 
                                                                                 "if ({L1}) {", 
                                                                                 "S{L2}",
                                                                                 "{LB} = {L2};", 
                                                                                 "} else {", 
                                                                                 "S{L3}",
                                                                                 "{LB} = {L3};",
                                                                                 "}",
                                                                                 "{LB}"]), 
('COND_EXPR',           [(Kl_List, None), (Kl_Int, None), (Kl_Int, None)],
                                                                        Kl_Int, ["S{L1}", 
                                                                                 "if (PyList_GET_SIZE({L1}) > 0) {", 
                                                                                 "S{L2}",
                                                                                 "{LI} = {L2};", 
                                                                                 "} else {", 
                                                                                 "S{L3}",
                                                                                 "{LI} = {L3};",
                                                                                 "}",
                                                                                 "{LI}"]),
('COND_EXPR',           [(Kl_Boolean, None), (Kl_Char, None), (Kl_Char, None)],
                                                                        Kl_Char, ["S{L1}", 
                                                                                 "if ({L1}) {", 
                                                                                 "S{L2}",
                                                                                 "{LC} = {L2};", 
                                                                                 "} else {", 
                                                                                 "S{L3}",
                                                                                 "{LC} = {L3};",
                                                                                 "}",
                                                                                 "{LC}"]), 
('COND_EXPR',           [(Kl_Boolean, None), (Kl_O, None), (Kl_O, None)],
                                                                        Kl_O,    ["S{L1}", 
                                                                                 "if ({L1}) {", 
                                                                                 "S{L2}",
                                                                                 "{LR} = {L2};", 
                                                                                 "} else {", 
                                                                                 "S{L3}",
                                                                                 "{LR} = {L3};",
                                                                                 "}",
                                                                                 "Py_INCREF({LR});",
                                                                                 "{LR}"]), 
                                                                        
("callable",           [(Kl_Function, None)],                           Kl_Boolean,  "1"),
("callable",           [(Kl_C, None)],                                  Kl_Boolean,  "0"),
("callable",           [(Kl_O, None)],                                  Kl_Boolean,  "PyCallable_Check({L1})"),

("PyObject_Size",      Kl_Tuple, None,    None, None,                   Kl_Cardinal, "PyTuple_GET_SIZE( {L1} )"),
("PyObject_Size",      Kl_List, IsNotListCompr, None, None,             Kl_Cardinal, "PyList_GET_SIZE( {L1} )"),
("PyObject_Size",      Kl_NewInst, ArgIsDerivedFromList, None, None,    Kl_Cardinal, "PyList_GET_SIZE( {L1} )"),
("PyObject_Size",      Kl_Dict, None,     None, None,                   Kl_Cardinal, "PyDict_Size( {L1} )"),
("PyObject_Size",      Kl_Set, None,     None, None,                    Kl_Cardinal, "PySet_Size( {L1} )"),
("PyObject_Size",      Kl_FrozenSet, None,     None, None,              Kl_Cardinal, "PySet_Size( {L1} )"),
("PyObject_Size",      Kl_Unicode, None,  None, None,                   Kl_Cardinal, "PyUnicode_GET_SIZE( {L1} )"),
("PyObject_Size",      Kl_Char, None,   None, None,                     Kl_Cardinal, "1"),
("PyObject_Size",      Kl_String, None,   None, None,                   Kl_Cardinal, "PyString_GET_SIZE( {L1} )"),

("PyObject_Size",      Kl_Tuple, None,    None, None,                   Kl_Boolean, "(PyTuple_GET_SIZE( {L1} ) > 0)"),
("PyObject_Size",      Kl_List, IsNotListCompr, None, None,             Kl_Boolean, "(PyList_GET_SIZE( {L1} ) > 0)"),
("PyObject_Size",      Kl_NewInst, ArgIsDerivedFromList, None, None,    Kl_Boolean, "(PyList_GET_SIZE( {L1} ) > 0)"),
("PyObject_Size",      Kl_Dict, None,     None, None,                   Kl_Boolean, "(PyDict_Size( {L1} ) > 0)"),
("PyObject_Size",      Kl_Set, None,     None, None,                    Kl_Boolean, "(PySet_Size( {L1} ) > 0)"),
("PyObject_Size",      Kl_FrozenSet, None,     None, None,              Kl_Boolean, "(PySet_Size( {L1} ) > 0)"),
("PyObject_Size",      Kl_Unicode, None,  None, None,                   Kl_Boolean, "(PyUnicode_GET_SIZE( {L1} ) > 0)"),
("PyObject_Size",      Kl_Char, None,   None, None,                     Kl_Boolean, "1"),
("PyObject_Size",      Kl_String, None,   None, None,                   Kl_Boolean, "(PyString_GET_SIZE( {L1} ) > 0)"),

("PyObject_Size",      Kl_Tuple, None,    None, None,                   Kl_Int, "PyTuple_GET_SIZE( {L1} )"),
("PyObject_Size",      Kl_String, None,   None, None,                   Kl_Int, "PyString_GET_SIZE( {L1} )"),
("PyObject_Size",      Kl_NewInst, ArgIsDerivedFromList, None, None,    Kl_Int, "PyList_GET_SIZE( {L1} )"),

("PyObject_Size",      Kl_O, None,   None, None,                        Kl_Cardinal, ["if (({LI} = PyObject_Size( {L1} )) == -1) goto L0;", "{LI}"]),

("PyObject_Size",      Kl_O, None,   None, None,                        Kl_Boolean, ["if (({LI} = PyObject_Size( {L1} )) == -1) goto L0;", "({LI} != 0)"]),

("PyObject_Size",      Kl_O, None,   None, None,                        Kl_Int,     ["if (({LI} = PyObject_Size( {L1} )) == -1) goto L0;", "{LI}"]),

("PyTuple_GET_SIZE",   Kl_Tuple, None,    None, None,                   Kl_Cardinal, "PyTuple_GET_SIZE( {L1} )"),
("PyList_GET_SIZE",    Kl_List, IsNotListCompr,  None, None,            Kl_Cardinal, "PyList_GET_SIZE( {L1} )"),
("PyDict_Size",        Kl_Dict, None,     None, None,                   Kl_Cardinal, "PyDict_Size( {L1} )"),
("PyUnicode_GET_SIZE", Kl_Unicode, None,  None, None,                   Kl_Cardinal, "PyUnicode_GET_SIZE( {L1} )"),
("PyString_GET_SIZE",  Kl_Char, None,   None, None,                     Kl_Cardinal, "1"),
("PyString_GET_SIZE",  Kl_String, None,   None, None,                   Kl_Cardinal, "PyString_GET_SIZE( {L1} )"),
("PySet_Size",         Kl_Set, None,     None, None,                    Kl_Cardinal, "PySet_Size( {L1} )"),
("PySet_Size",         Kl_FrozenSet, None,     None, None,              Kl_Cardinal, "PySet_Size( {L1} )"),

("_EQ_",               Kl_Int, None,      Kl_None, None,                Kl_Boolean, "0"),
("_NEQ_",              Kl_Int, None,      Kl_None, None,                Kl_Boolean, "1"),
("_EQ_",               Kl_Boolean, None,  Kl_None, None,                Kl_Boolean, "0"),
("_NEQ_",              Kl_Boolean, None,  Kl_None, None,                Kl_Boolean, "1"),
("_EQ_",               Kl_Float, None,    Kl_None, None,                Kl_Boolean, "0"),
("_NEQ_",              Kl_Float, None,    Kl_None, None,                Kl_Boolean, "1"),
("_EQ_",               Kl_String, None,   Kl_None, None,                Kl_Boolean, "0"),
("_NEQ_",              Kl_String, None,   Kl_None, None,                Kl_Boolean, "1"),
("_EQ_",               Kl_String, None,   (bool, True), None,           Kl_Boolean, "0"),
("_NEQ_",              Kl_String, None,   (bool, True), None,           Kl_Boolean, "1"),
("_EQ_",               Kl_String, None,   (bool, False), None,          Kl_Boolean, "0"),
("_NEQ_",              Kl_String, None,   (bool, False), None,          Kl_Boolean, "1"),

("_EQ_",               Kl_List, None,     Kl_None, None,                Kl_Boolean, "0"),
("_NEQ_",              Kl_List, None,     Kl_None, None,                Kl_Boolean, "1"),
("_EQ_",               Kl_Tuple, None,    Kl_None, None,                Kl_Boolean, "0"),
("_NEQ_",              Kl_Tuple, None,    Kl_None, None,                Kl_Boolean, "1"),
("_EQ_",               Kl_Dict, None,     Kl_None, None,                Kl_Boolean, "0"),
("_NEQ_",              Kl_Dict, None,     Kl_None, None,                Kl_Boolean, "1"),
("_EQ_",               Kl_Set, None,      Kl_None, None,                Kl_Boolean, "0"),
("_NEQ_",              Kl_Set, None,      Kl_None, None,                Kl_Boolean, "1"),
## ("_EQ_",               Kl_Sequence, None, Kl_None, None,                Kl_Boolean, "0"),
## ("_NEQ_",              Kl_Sequence, None, Kl_None, None,                Kl_Boolean, "1"),

("_EQ_",               Kl_String, None,   Kl_Boolean, None,             Kl_Boolean, "0"),
("_NEQ_",              Kl_String, None,   Kl_Boolean, None,             Kl_Boolean, "1"),

("_EQ_",               Kl_MayBe, None,    Kl_None, ('CONST', None),     Kl_Boolean, "({L1} == Py_None)"),
("_NEQ_",              Kl_MayBe, None,    Kl_None, ('CONST', None),     Kl_Boolean, "({L1} != Py_None)"),

## ("_EQ_",               Kl_Undefined, None,Kl_None, None,                Kl_Boolean, "({L1} == {L2})"),
## ("_NEQ_",              Kl_Undefined, None,Kl_None, None,                Kl_Boolean, "({L1} != {L2})"),

("_EQ_",               Kl_Undefined, None,(bool, True), None,           Kl_Boolean, "({L1} == (PyObject *)Py_True)"),
("_NEQ_",              Kl_Undefined, None,(bool, True), None,           Kl_Boolean, "({L1} != (PyObject *)Py_True)"),
("_EQ_",               Kl_Undefined, None,(bool, False), None,           Kl_Boolean, "({L1} == (PyObject *)Py_False)"),
("_NEQ_",              Kl_Undefined, None,(bool, False), None,           Kl_Boolean, "({L1} != (PyObject *)Py_False)"),

("_EQ_",               (type, ('MayBe', Kl_Tuple)), '!PyObject_Type',    Kl_Type, ('!LOAD_BUILTIN', 'tuple'),     Kl_Boolean, "({L1} != Py_None)"),
("_EQ_",               (type, ('MayBe', Kl_List)), '!PyObject_Type',     Kl_Type, ('!LOAD_BUILTIN', 'list'),     Kl_Boolean, "({L1} != Py_None)"),
("_EQ_",               (type, ('MayBe', Kl_String)), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'str'),     Kl_Boolean, "({L1} != Py_None)"),

("_EQ_",               (type, Kl_Int), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'int'), Kl_Boolean, "1"),
("_NEQ_",              (type, Kl_Int), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'int'), Kl_Boolean, "0"),
("_EQ_",               (type, Kl_String), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'str'), Kl_Boolean, "1"),
("_NEQ_",              (type, Kl_String), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'str'), Kl_Boolean, "0"),

("_EQ_",               (type, Kl_Tuple), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'tuple'), Kl_Boolean, "1"),
("_NEQ_",              (type, Kl_Tuple), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'tuple'), Kl_Boolean, "0"),

("_EQ_",               (type, Kl_List), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'list'), Kl_Boolean, "1"),
("_NEQ_",              (type, Kl_List), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'list'), Kl_Boolean, "0"),

("_EQ_",               (type, Kl_Undefined), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'str'), Kl_Boolean, "PyString_CheckExact({L1})"),
("_NEQ_",              (type, Kl_Undefined), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'str'), Kl_Boolean, "(!PyString_CheckExact({L1}))"),


("_EQ_",               (type, Kl_Undefined), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'tuple'), Kl_Boolean, "PyTuple_CheckExact({L1})"),
("_NEQ_",              (type, Kl_Undefined), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'tuple'), Kl_Boolean, "(!PyTuple_CheckExact({L1}))"),

("_EQ_",               (type, Kl_Undefined), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'list'), Kl_Boolean, "PyList_CheckExact({L1})"),
("_NEQ_",              (type, Kl_Undefined), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'list'), Kl_Boolean, "(!PyList_CheckExact({L1}))"),

("_EQ_",               (type, Kl_ProbablyInt), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'int'), Kl_Boolean, "PyInt_CheckExact({L1})"),
("_NEQ_",              (type, Kl_ProbablyInt), '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'int'), Kl_Boolean, "(!PyInt_CheckExact({L1}))"),
                                                                        
("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'int'), Kl_Boolean, "PyInt_CheckExact({L1})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'int'), Kl_Boolean, "(!PyInt_CheckExact({L1}))"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'list'), Kl_Boolean, "PyList_CheckExact({L1})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'list'), Kl_Boolean, "(!PyList_CheckExact({L1}))"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'tuple'), Kl_Boolean, "PyTuple_CheckExact({L1})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'tuple'), Kl_Boolean, "(!PyTuple_CheckExact({L1}))"),
("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'str'), Kl_Boolean, "PyString_CheckExact({L1})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'str'), Kl_Boolean, "(!PyString_CheckExact({L1}))"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'dict'), Kl_Boolean, "PyDict_CheckExact({L1})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'dict'), Kl_Boolean, "(!PyDict_CheckExact({L1}))"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'float'), Kl_Boolean, "PyFloat_CheckExact({L1})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'float'), Kl_Boolean, "(!PyFloat_CheckExact({L1}))"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'bool'), Kl_Boolean, "PyBool_Check({L1})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'bool'), Kl_Boolean, "(!PyBool_Check({L1}))"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'long'), Kl_Boolean, "PyLong_CheckExact({L1})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'long'), Kl_Boolean, "(!PyLong_CheckExact({L1}))"),


("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'set'), Kl_Boolean, "(PyAnySet_CheckExact({L1}) && !PyFrozenSet_CheckExact({L1}))"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'set'), Kl_Boolean, "(!PyAnySet_CheckExact({L1}) || PyFrozenSet_CheckExact({L1}))"),
("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'frozenset'), Kl_Boolean, "PyFrozenSet_CheckExact({L1})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'frozenset'), Kl_Boolean, "(!PyFrozenSet_CheckExact({L1}))"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'type'), Kl_Boolean, "PyType_CheckExact({L1})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'type'), Kl_Boolean, "(!PyType_CheckExact({L1}))"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'complex'), Kl_Boolean, "PyComplex_CheckExact({L1})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'complex'), Kl_Boolean, "(!PyComplex_CheckExact({L1}))"),


("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'int'), Kl_Boolean, "PyInt_CheckExact({L1})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'int'), Kl_Boolean, "(!PyInt_CheckExact({L1}))"),

("Py_EQ",              Kl_Type, ('!LOAD_BUILTIN', 'bool'), Kl_Type, '!PyObject_Type', Kl_Boolean,  "PyBool_Check({L2})"),
("Py_NE",              Kl_Type, ('!LOAD_BUILTIN', 'bool'), Kl_Type, '!PyObject_Type', Kl_Boolean, "(!PyBool_Check({L2}))"),
                                                                        
("Py_EQ",              Kl_Type, ('!LOAD_BUILTIN', 'tuple'), Kl_Type, '!PyObject_Type', Kl_Boolean,  "PyTuple_CheckExact({L2})"),
("Py_NE",              Kl_Type, ('!LOAD_BUILTIN', 'tuple'), Kl_Type, '!PyObject_Type', Kl_Boolean, "(!PyTuple_CheckExact({L2}))"),

("Py_EQ",              Kl_Type, ('!LOAD_BUILTIN', 'list'), Kl_Type, '!PyObject_Type', Kl_Boolean,  "PyList_CheckExact({L2})"),
("Py_NE",              Kl_Type, ('!LOAD_BUILTIN', 'list'), Kl_Type, '!PyObject_Type', Kl_Boolean, "(!PyList_CheckExact({L2}))"),
                                                                        
("Py_EQ",              Kl_Type, ('!LOAD_BUILTIN', 'int'), Kl_Type, '!PyObject_Type', Kl_Boolean,  "PyInt_CheckExact({L2})"),
("Py_NE",              Kl_Type, ('!LOAD_BUILTIN', 'int'), Kl_Type, '!PyObject_Type', Kl_Boolean, "(!PyInt_CheckExact({L2}))"),

("Py_EQ",              Kl_Type, ('!LOAD_BUILTIN', 'long'), Kl_Type, '!PyObject_Type', Kl_Boolean,  "PyLong_CheckExact({L2})"),
("Py_NE",              Kl_Type, ('!LOAD_BUILTIN', 'long'), Kl_Type, '!PyObject_Type', Kl_Boolean, "(!PyLong_CheckExact({L2}))"),

("Py_EQ",              Kl_Type, ('!LOAD_BUILTIN', 'str'), Kl_Type, '!PyObject_Type', Kl_Boolean,  "PyString_CheckExact({L2})"),
("Py_NE",              Kl_Type, ('!LOAD_BUILTIN', 'str'), Kl_Type, '!PyObject_Type', Kl_Boolean, "(!PyString_CheckExact({L2}))"),

("Py_EQ",              Kl_Type, ('!LOAD_BUILTIN', 'float'), Kl_Type, '!PyObject_Type', Kl_Boolean, "PyFloat_CheckExact({L2})"),
("Py_NE",              Kl_Type, ('!LOAD_BUILTIN', 'float'), Kl_Type, '!PyObject_Type', Kl_Boolean, "(!PyFloat_CheckExact({L2}))"),                                                                        

("Py_EQ",              Kl_Type, ('!LOAD_BUILTIN', 'complex'), Kl_Type, '!PyObject_Type', Kl_Boolean, "PyComplex_CheckExact({L2})"),
("Py_NE",              Kl_Type, ('!LOAD_BUILTIN', 'complex'), Kl_Type, '!PyObject_Type', Kl_Boolean, "(!PyComplex_CheckExact({L2}))"),                                                                        
                                                                        
("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'list'), Kl_Boolean, "PyList_CheckExact({L1})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'list'), Kl_Boolean, "(!PyList_CheckExact({L1}))"),

("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'tuple'), Kl_Boolean, "PyTuple_CheckExact({L1})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'tuple'), Kl_Boolean, "(!PyTuple_CheckExact({L1}))"),
("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'str'), Kl_Boolean, "PyString_CheckExact({L1})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'str'), Kl_Boolean, "(!PyString_CheckExact({L1}))"),

("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'dict'), Kl_Boolean, "PyDict_CheckExact({L1})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'dict'), Kl_Boolean, "(!PyDict_CheckExact({L1}))"),

("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'float'), Kl_Boolean, "PyFloat_CheckExact({L1})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'float'), Kl_Boolean, "(!PyFloat_CheckExact({L1}))"),

("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'bool'), Kl_Boolean, "PyBool_Check({L1})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'bool'), Kl_Boolean, "(!PyBool_Check({L1}))"),

("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'long'), Kl_Boolean, "PyLong_CheckExact({L1})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'long'), Kl_Boolean, "(!PyLong_CheckExact({L1}))"),


("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'set'), Kl_Boolean, "(PyAnySet_CheckExact({L1}) && !PyFrozenSet_CheckExact({L1}))"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'set'), Kl_Boolean, "(!PyAnySet_CheckExact({L1}) || PyFrozenSet_CheckExact({L1}))"),
("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'frozenset'), Kl_Boolean, "PyFrozenSet_CheckExact({L1})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'frozenset'), Kl_Boolean, "(!PyFrozenSet_CheckExact({L1}))"),

("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'type'), Kl_Boolean, "PyType_CheckExact({L1})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'type'), Kl_Boolean, "(!PyType_CheckExact({L1}))"),

("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'complex'), Kl_Boolean, "PyComplex_CheckExact({L1})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ('!LOAD_BUILTIN', 'complex'), Kl_Boolean, "(!PyComplex_CheckExact({L1}))"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, '!PyObject_Type', Kl_Boolean, "(Py_TYPE({L1}) == Py_TYPE({L2}))"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, '!PyObject_Type', Kl_Boolean, "(Py_TYPE({L1}) != Py_TYPE({L2}))"),

("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, '!PyObject_Type', Kl_Boolean, "(Py_TYPE({L1}) == Py_TYPE({L2}))"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, '!PyObject_Type', Kl_Boolean, "(Py_TYPE({L1}) != Py_TYPE({L2}))"),






("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_NewType, ArgIsCalcConst, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) == (PyObject *){L2})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_NewType, ArgIsCalcConst, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) != (PyObject *){L2})"),

("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_NewType, ArgIsCalcConst, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) == (PyObject *){L2})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_NewType, ArgIsCalcConst, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) != (PyObject *){L2})"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_OldType, ArgIsCalcConst, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) == (PyObject *){L2})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_OldType, ArgIsCalcConst, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) != (PyObject *){L2})"),

("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_OldType, ArgIsCalcConst, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) == (PyObject *){L2})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_OldType, ArgIsCalcConst, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) != (PyObject *){L2})"),

("_EQ_",               Kl_NewType, ArgIsCalcConst,     Kl_Type, '!PyObject_Type', Kl_Boolean, "((PyObject *){L1} == (PyObject *)Py_TYPE({L2}))"),
("_NEQ_",              Kl_NewType, ArgIsCalcConst,     Kl_Type, '!PyObject_Type', Kl_Boolean, "((PyObject *){L1} != (PyObject *)Py_TYPE({L2}))"),

("Py_EQ",              Kl_NewType, ArgIsCalcConst,     Kl_Type, '!PyObject_Type', Kl_Boolean, "((PyObject *){L1} == (PyObject *)Py_TYPE({L2}))"),
("Py_NE",              Kl_NewType, ArgIsCalcConst,     Kl_Type, '!PyObject_Type', Kl_Boolean, "((PyObject *){L1} != (PyObject *)Py_TYPE({L2}))"),

("_EQ_",               Kl_OldType, ArgIsCalcConst,     Kl_Type, '!PyObject_Type', Kl_Boolean, "((PyObject *){L1} == (PyObject *)Py_TYPE({L2}))"),
("_NEQ_",              Kl_OldType, ArgIsCalcConst,     Kl_Type, '!PyObject_Type', Kl_Boolean, "((PyObject *){L1} != (PyObject *)Py_TYPE({L2}))"),

("Py_EQ",              Kl_OldType, ArgIsCalcConst,     Kl_Type, '!PyObject_Type', Kl_Boolean, "((PyObject *){L1} == (PyObject *)Py_TYPE({L2}))"),
("Py_NE",              Kl_OldType, ArgIsCalcConst,     Kl_Type, '!PyObject_Type', Kl_Boolean, "((PyObject *){L1} != (PyObject *)Py_TYPE({L2}))"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, ArgIsCalcConst, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) == (PyObject *){L2})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, ArgIsCalcConst, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) != (PyObject *){L2})"),

("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, ArgIsCalcConst, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) == (PyObject *){L2})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, ArgIsCalcConst, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) != (PyObject *){L2})"),


("_EQ_",               Kl_Type, ArgIsCalcConst,     Kl_Type, '!PyObject_Type', Kl_Boolean, "((PyObject *){L1} == (PyObject *)Py_TYPE({L2}))"),
("_NEQ_",              Kl_Type, ArgIsCalcConst,     Kl_Type, '!PyObject_Type', Kl_Boolean, "((PyObject *){L1} != (PyObject *)Py_TYPE({L2}))"),

("Py_EQ",              Kl_Type, ArgIsCalcConst,     Kl_Type, '!PyObject_Type', Kl_Boolean, "((PyObject *){L1} == (PyObject *)Py_TYPE({L2}))"),
("Py_NE",              Kl_Type, ArgIsCalcConst,     Kl_Type, '!PyObject_Type', Kl_Boolean, "((PyObject *){L1} != (PyObject *)Py_TYPE({L2}))"),


("_EQ_",               Kl_Type, None,   Kl_Type, ArgIsCalcConst, Kl_Boolean, "((PyObject *){L1} == (PyObject *){L2})"),
("_NEQ_",              Kl_Type, None,   Kl_Type, ArgIsCalcConst, Kl_Boolean, "((PyObject *){L1} != (PyObject *){L2})"),

("Py_EQ",              Kl_Type, None,   Kl_Type, ArgIsCalcConst, Kl_Boolean, "((PyObject *){L1} == (PyObject *){L2})"),
("Py_NE",              Kl_Type, None,   Kl_Type, ArgIsCalcConst, Kl_Boolean, "((PyObject *){L1} != (PyObject *){L2})"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Type, None, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) == (PyObject *){L2})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Type, None, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) != (PyObject *){L2})"),

("Py_EQ",              Kl_Type, '!PyObject_Type',   Kl_Type, None, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) == (PyObject *){L2})"),
("Py_NE",              Kl_Type, '!PyObject_Type',   Kl_Type, None, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) != (PyObject *){L2})"),

("_EQ_",               Kl_Type, '!PyObject_Type',   Kl_Undefined, None, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) == (PyObject *){L2})"),
("_NEQ_",              Kl_Type, '!PyObject_Type',   Kl_Undefined, None, Kl_Boolean, "((PyObject *)Py_TYPE({L1}) != (PyObject *){L2})"),

("_EQ_",               Kl_Type, None,     Kl_Type, None,                Kl_Boolean, "((PyObject *){L1} == (PyObject *){L2})"),
("_NEQ_",              Kl_Type, None,     Kl_Type, None,                Kl_Boolean, "((PyObject *){L1} != (PyObject *){L2})"),

("_EQ_",               Kl_Int, None,      Kl_Int, None,                 Kl_Boolean, "({L1} == {L2})"),
("_NEQ_",              Kl_Int, None,      Kl_Int, None,                 Kl_Boolean, "({L1} != {L2})"),

("_EQ_",               Kl_Boolean, None,  (bool, True), None,           Kl_Boolean, "({L1})"),
("_NEQ_",              Kl_Boolean, None,  (bool, True), None,           Kl_Boolean, "!({L1})"),
("_EQ_",               Kl_Boolean, None,  (bool, False), None,          Kl_Boolean, "!({L1})"),
("_NEQ_",              Kl_Boolean, None,  (bool, False), None,          Kl_Boolean, "({L1})"),

("_EQ_",               ('MayBe', Kl_Boolean), None,  (bool, True), None,      Kl_Boolean, "({L1} == Py_True)"),
("_NEQ_",              ('MayBe', Kl_Boolean), None,  (bool, True), None,      Kl_Boolean, "({L1} != Py_True)"),
("_EQ_",               ('MayBe', Kl_Boolean), None,  (bool, False), None,     Kl_Boolean, "({L1} == Py_False)"),
("_NEQ_",              ('MayBe', Kl_Boolean), None,  (bool, False), None,     Kl_Boolean, "({L1} != Py_False)"),

("_EQ_",               Kl_Boolean, None,  Kl_Boolean, None,             Kl_Boolean, "({L1} == {L2})"),
("_NEQ_",              Kl_Boolean, None,  Kl_Boolean, None,             Kl_Boolean, "({L1} != {L2})"),

("_EQ_",               Kl_None, None,     Kl_None, None,                Kl_Boolean, "1"),
("_NEQ_",              Kl_None, None,     Kl_None, None,                Kl_Boolean, "0"),

("_EQ_",               Kl_None, None,     Kl_O, None,                   Kl_Boolean, "({L2} == Py_None)"),
("_NEQ_",              Kl_None, None,     Kl_O, None,                   Kl_Boolean, "({L2} != Py_None)"),

("_EQ_",               Kl_O, None,        Kl_None, None,                Kl_Boolean, "({L1} == Py_None)"),
("_NEQ_",              Kl_O, None,        Kl_None, None,                Kl_Boolean, "({L1} != Py_None)"),

("_EQ_",               Kl_O, None,        Kl_O, None,                   Kl_Boolean, "({L1} == {L2})"),
("_NEQ_",              Kl_O, None,        Kl_O, None,                   Kl_Boolean, "({L1} != {L2})"),

("Py_EQ",              Kl_Int, None,      Kl_Int, None,                 Kl_Boolean, "({L1} == {L2})"),
("Py_NE",              Kl_Int, None,      Kl_Int, None,                 Kl_Boolean, "({L1} != {L2})"),
("Py_GT",              Kl_Int, None,      Kl_Int, None,                 Kl_Boolean, "({L1} > {L2})"),
("Py_GE",              Kl_Int, None,      Kl_Int, None,                 Kl_Boolean, "({L1} >= {L2})"),
("Py_LT",              Kl_Int, None,      Kl_Int, None,                 Kl_Boolean, "({L1} < {L2})"),
("Py_LE",              Kl_Int, None,      Kl_Int, None,                 Kl_Boolean, "({L1} <= {L2})"),


("Py_EQ",              Kl_ProbablyInt, None,    Kl_IntUndefSize, None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) == PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_NE",              Kl_ProbablyInt, None,    Kl_IntUndefSize, None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) != PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE)) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_GT",              Kl_ProbablyInt, None,    Kl_IntUndefSize, None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) > PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GT )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_GE",              Kl_ProbablyInt, None,    Kl_IntUndefSize, None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) >= PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GE )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_LT",              Kl_ProbablyInt, None,    Kl_IntUndefSize, None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) < PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),                                                                                                                                                                            
("Py_LE",              Kl_ProbablyInt, None,    Kl_IntUndefSize, None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) <= PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]), 



("Py_EQ",              Kl_IntUndefSize, None,    Kl_ProbablyInt, None,  Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) == PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_NE",              Kl_IntUndefSize, None,    Kl_ProbablyInt, None,  Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) != PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE)) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_GT",              Kl_IntUndefSize, None,    Kl_ProbablyInt, None,  Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) > PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GT )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_GE",              Kl_IntUndefSize, None,    Kl_ProbablyInt, None,  Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) >= PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GE )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_LT",              Kl_IntUndefSize, None,    Kl_ProbablyInt, None,  Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) < PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),                                                                                                                                                                            
("Py_LE",              Kl_IntUndefSize, None,    Kl_ProbablyInt, None,  Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) <= PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]), 

("Py_EQ",             Kl_None, None,            Kl_ProbablyInt, None,  Kl_Boolean,   ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                      "{LB}"]),
("Py_EQ",             Kl_ProbablyInt, None,     Kl_None, None,         Kl_Boolean,   ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                      "{LB}"]),

("Py_EQ",   ('MayBe', Kl_IntUndefSize), None,    Kl_ProbablyInt, None,  Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) == PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_NE",   ('MayBe', Kl_IntUndefSize), None,    Kl_ProbablyInt, None,  Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) != PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE)) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_GT",   ('MayBe', Kl_IntUndefSize), None,    Kl_ProbablyInt, None,  Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) > PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GT )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_GE",   ('MayBe', Kl_IntUndefSize), None,    Kl_ProbablyInt, None,  Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) >= PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GE )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_LT",   ('MayBe', Kl_IntUndefSize), None,    Kl_ProbablyInt, None,  Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) < PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),                                                                                                                                                                            
("Py_LE",   ('MayBe', Kl_IntUndefSize), None,    Kl_ProbablyInt, None,  Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) && PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) <= PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]), 

("Py_EQ",              Kl_Tuple, None,      Kl_Undefined, None,           Kl_Boolean, "(PyIF(PyTuple_CheckExact({L2}),  PyTuple_GET_SIZE({L1}) == PyTuple_GET_SIZE({L2}), {L2} != Py_None) && PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ ))"),
("Py_NE",              Kl_Tuple, None,      Kl_Undefined, None,           Kl_Boolean, "(PyIF(PyTuple_CheckExact({L2}),  PyTuple_GET_SIZE({L1}) != PyTuple_GET_SIZE({L2}), {L2} == Py_None) || PyObject_RichCompareBool ( {L1} , {L2} , Py_NE ))"),
("Py_GT",              Kl_Tuple, None,      Kl_Undefined, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GT )) == -1) goto L0;", "{LB}"]),
("Py_GE",              Kl_Tuple, None,      Kl_Undefined, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GE )) == -1) goto L0;", "{LB}"]),
("Py_LT",              Kl_Tuple, None,      Kl_Undefined, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", "{LB}"]),
("Py_LE",              Kl_Tuple, None,      Kl_Undefined, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LE )) == -1) goto L0;", "{LB}"]),

("Py_EQ",              Kl_Undefined, None,  Kl_TupleOne, None,            Kl_Boolean, ["if (PyTuple_CheckExact({L1})) {",
                                                                                       "if (PyTuple_GET_SIZE({L1}) == 1) {", 
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 0 ) , PyTuple_GET_ITEM ( {L2} , 0 ) , Py_EQ );", 
                                                                                       "} else {", 
                                                                                       "{LB} = 0;", 
                                                                                       "}", 
                                                                                       "} else {",
                                                                                       "{LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ );", 
                                                                                       "}",
                                                                                       "if ({LB} == -1) goto L0;", 
                                                                                       "{LB}"]),
("Py_NE",              Kl_Undefined, None,  Kl_TupleOne, None,            Kl_Boolean, ["if (PyTuple_CheckExact({L1})) {",
                                                                                       "if (PyTuple_GET_SIZE({L1}) == 1) {", 
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 0 ) , PyTuple_GET_ITEM ( {L2} , 0 ) , Py_NE );", 
                                                                                       "} else {", 
                                                                                       "{LB} = 1;", 
                                                                                       "}", 
                                                                                       "} else {",
                                                                                       "{LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE );", 
                                                                                       "}",
                                                                                       "if ({LB} == -1) goto L0;", 
                                                                                       "{LB}"]),

("Py_EQ",              Kl_Tuple, None,      Kl_TupleOne, None,            Kl_Boolean, ["if (PyTuple_GET_SIZE({L1}) == 1) {", 
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 0 ) , PyTuple_GET_ITEM ( {L2} , 0 ) , Py_EQ );", 
                                                                                       "if ({LB} == -1) goto L0;",
                                                                                       "} else {", 
                                                                                       "{LB} = 0;", 
                                                                                       "}", 
                                                                                       "{LB}"]),
("Py_NE",              Kl_Tuple, None,      Kl_TupleOne, None,            Kl_Boolean, ["if (PyTuple_GET_SIZE({L1}) == 1) {", 
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 0 ) , PyTuple_GET_ITEM ( {L2} , 0 ) , Py_NE );", 
                                                                                       "if ({LB} == -1) goto L0;",
                                                                                       "} else {", 
                                                                                       "{LB} = 1;", 
                                                                                       "}",
                                                                                       "{LB}"]),

("Py_EQ",              Kl_Tuple, None,      Kl_TuplePair, None,           Kl_Boolean, ["if (PyTuple_GET_SIZE({L1}) == 2) {", 
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 0 ) , PyTuple_GET_ITEM ( {L2} , 0 ) , Py_EQ );", 
                                                                                       "if ({LB} == -1) goto L0;",
                                                                                       "if ({LB}) {",
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 1 ) , PyTuple_GET_ITEM ( {L2} , 1 ) , Py_EQ );", 
                                                                                       "if ({LB} == -1) goto L0;",
                                                                                       "}",
                                                                                       "} else {", 
                                                                                       "{LB} = 0;", 
                                                                                       "}", 
                                                                                       "{LB}"]),
("Py_NE",              Kl_Tuple, None,      Kl_TuplePair, None,           Kl_Boolean, ["if (PyTuple_GET_SIZE({L1}) == 2) {", 
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 0 ) , PyTuple_GET_ITEM ( {L2} , 0 ) , Py_NE );", 
                                                                                       "if ({LB} == -1) goto L0;",
                                                                                       "if (!{LB}) {",
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 1 ) , PyTuple_GET_ITEM ( {L2} , 1 ) , Py_NE );", 
                                                                                       "if ({LB} == -1) goto L0;",
                                                                                       "}",
                                                                                       "} else {", 
                                                                                       "{LB} = 1;", 
                                                                                       "}", 
                                                                                       "{LB}"]),

("Py_EQ",              Kl_Tuple, None,      Kl_TupleThree, None,          Kl_Boolean, ["if (PyTuple_GET_SIZE({L1}) == 3) {", 
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 0 ) , PyTuple_GET_ITEM ( {L2} , 0 ) , Py_EQ );", 
                                                                                       "if ({LB} == -1) goto L0;",
                                                                                       "if ({LB}) {",
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 1 ) , PyTuple_GET_ITEM ( {L2} , 1 ) , Py_EQ );", 
                                                                                       "if ({LB} == -1) goto L0;",
                                                                                       "if ({LB}) {",
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 2 ) , PyTuple_GET_ITEM ( {L2} , 2 ) , Py_EQ );", 
                                                                                       "if ({LB} == -1) goto L0;",
                                                                                       "}",
                                                                                       "}",
                                                                                       "} else {", 
                                                                                       "{LB} = 0;", 
                                                                                       "}", 
                                                                                       "{LB}"]),
("Py_NE",              Kl_Tuple, None,      Kl_TupleThree, None,          Kl_Boolean, ["if (PyTuple_GET_SIZE({L1}) == 3) {", 
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 0 ) , PyTuple_GET_ITEM ( {L2} , 0 ) , Py_NE );", 
                                                                                       "if ({LB} == -1) goto L0;",
                                                                                       "if (!{LB}) {",
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 1 ) , PyTuple_GET_ITEM ( {L2} , 1 ) , Py_NE );", 
                                                                                       "if ({LB} == -1) goto L0;",
                                                                                       "if (!{LB}) {",
                                                                                       "{LB} = PyObject_RichCompareBool ( PyTuple_GET_ITEM ( {L1} , 2 ) , PyTuple_GET_ITEM ( {L2} , 2 ) , Py_NE );", 
                                                                                       "if ({LB} == -1) goto L0;",
                                                                                       "}",
                                                                                       "}",
                                                                                       "} else {", 
                                                                                       "{LB} = 1;", 
                                                                                       "}", 
                                                                                       "{LB}"]),

("Py_EQ",              Kl_Tuple, None,      Kl_Tuple, None,               Kl_Boolean, ["if (PyTuple_GET_SIZE({L1}) == PyTuple_GET_SIZE({L2})) {", 
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;",
                                                                                       "} else {", 
                                                                                       "{LB} = 0;", 
                                                                                       "}", 
                                                                                       "{LB}"]),
("Py_NE",              Kl_Tuple, None,      Kl_Tuple, None,               Kl_Boolean, ["if (PyTuple_GET_SIZE({L1}) == PyTuple_GET_SIZE({L2})) {", 
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;",
                                                                                       "} else {", 
                                                                                       "{LB} = 1;", 
                                                                                       "}", 
                                                                                       "{LB}"]),

("Py_GT",              Kl_Tuple, None,      Kl_Tuple, None,               Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GT )) == -1) goto L0;", "{LB}"]),
("Py_GE",              Kl_Tuple, None,      Kl_Tuple, None,               Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GE )) == -1) goto L0;", "{LB}"]),
("Py_LT",              Kl_Tuple, None,      Kl_Tuple, None,               Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", "{LB}"]),
("Py_LE",              Kl_Tuple, None,      Kl_Tuple, None,               Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LE )) == -1) goto L0;", "{LB}"]),

("Py_EQ",              Kl_List, None,      Kl_List, None,                 Kl_Boolean, ["if (PyList_GET_SIZE({L1}) == PyList_GET_SIZE({L2})) {", 
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;",
                                                                                       "} else {", 
                                                                                       "{LB} = 0;", 
                                                                                       "}", 
                                                                                       "{LB}"]),
("Py_NE",              Kl_List, None,       Kl_List, None,                Kl_Boolean, ["if (PyList_GET_SIZE({L1}) == PyList_GET_SIZE({L2})) {", 
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;",
                                                                                       "} else {", 
                                                                                       "{LB} = 1;", 
                                                                                       "}", 
                                                                                       "{LB}"]),

("Py_GT",              Kl_List, None,       Kl_List, None,               Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GT )) == -1) goto L0;", "{LB}"]),
("Py_GE",              Kl_List, None,       Kl_List, None,               Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GE )) == -1) goto L0;", "{LB}"]),
("Py_LT",              Kl_List, None,       Kl_List, None,               Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", "{LB}"]),
("Py_LE",              Kl_List, None,       Kl_List, None,               Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LE )) == -1) goto L0;", "{LB}"]),

("Py_EQ",              Kl_Long, None,       Kl_Int, None,                Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_EQ )) == -1) goto L0;", "{LB}"]),
("Py_NE",              Kl_Long, None,       Kl_Int, None,                Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_NE )) == -1) goto L0;", "{LB}"]),
("Py_GT",              Kl_Long, None,       Kl_Int, None,                Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_GT )) == -1) goto L0;", "{LB}"]),
("Py_GE",              Kl_Long, None,       Kl_Int, None,                Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_GE )) == -1) goto L0;", "{LB}"]),
("Py_LT",              Kl_Long, None,       Kl_Int, None,                Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_LT )) == -1) goto L0;", "{LB}"]),
("Py_LE",              Kl_Long, None,       Kl_Int, None,                Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_LE )) == -1) goto L0;", "{LB}"]),

("Py_EQ",              Kl_ProbablyInt, None,    Kl_Int, None        ,   Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) == {L2};",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_EQ )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_NE",              Kl_ProbablyInt, None,    Kl_Int, None        ,   Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) != {L2};",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_NE)) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_GT",              Kl_ProbablyInt, None,    Kl_Int, None        ,   Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) > {L2};",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_GT )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_GE",              Kl_ProbablyInt, None,    (int, (((-MInt) - 1), ((-MInt) - 1))), 
                                                        None,           Kl_Boolean,  ["if (({LB} = (PyInt_CheckExact( {L1} ) ? 1 : PyObject_RichCompareBool ( {L1} , O{L2} , Py_GE ))) == -1) goto L0;", 
                                                                                      "{LB}"]),

("Py_GE",              Kl_ProbablyInt, None,    Kl_Int, None        ,   Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) >= {L2};",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_GE )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_LT",              Kl_ProbablyInt, None,    Kl_Int, None        ,   Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) < {L2};",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_LT )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),                                                                                                                                                                            
("Py_LE",              Kl_ProbablyInt, None,    Kl_Int, None        ,   Kl_Boolean,  ["if ( PyInt_CheckExact({L1}) ) {",
                                                                                      "{LB} = PyInt_AS_LONG({L1}) <= {L2};",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_LE )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]), 
 
("Py_EQ",              Kl_Int, None        ,    Kl_ProbablyInt, None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = {L1} == PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_NE",              Kl_Int, None        ,    Kl_ProbablyInt, None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = {L1} != PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_NE)) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_GT",              Kl_Int, None        ,    Kl_ProbablyInt, None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = {L1} > PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_GT )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),

("Py_GE",              Kl_Int, None        ,    Kl_ProbablyInt, None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = {L1} >= PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_GE )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_LT",              Kl_Int, None        ,    Kl_ProbablyInt, None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = {L1} < PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LT )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),                                                                                                                                                                            
("Py_LE",              Kl_Int, None        ,    Kl_ProbablyInt, None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = {L1} <= PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LE )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]), 

("Py_EQ",              Kl_Int, None ,           ('MayBe', Kl_Int), None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = {L1} == PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "{LB} = 0;",
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_NE",              Kl_Int, None ,           ('MayBe', Kl_Int), None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = {L1} != PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "{LB} = 1;",
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_GT",              Kl_Int, None ,           ('MayBe', Kl_Int), None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = {L1} > PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "{LB} = 1;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_GE",              Kl_Int, None ,           ('MayBe', Kl_Int), None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = {L1} >= PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "{LB} = 1;",
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_LT",              Kl_Int, None ,           ('MayBe', Kl_Int), None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = {L1} < PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "{LB} = 0;",
                                                                                      "}",
                                                                                      "{LB}"]),                                                                                                                                                                            
("Py_LE",              Kl_Int, None ,           ('MayBe', Kl_Int), None,   Kl_Boolean,  ["if ( PyInt_CheckExact({L2}) ) {",
                                                                                      "{LB} = {L1} <= PyInt_AS_LONG({L2});",
                                                                                      "} else {",
                                                                                      "{LB} = 0;",
                                                                                      "}",
                                                                                      "{LB}"]), 
                                                                                      
("Py_EQ",              Kl_Undefined, None,    Kl_Float, None        ,   Kl_Boolean,  ["if ( PyFloat_CheckExact({L1}) ) {",
                                                                                      "{LB} = PyFloat_AS_DOUBLE({L1}) == {L2};",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_EQ )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_NE",              Kl_Undefined, None,    Kl_Float, None        ,   Kl_Boolean,  ["if ( PyFloat_CheckExact({L1}) ) {",
                                                                                      "{LB} = PyFloat_AS_DOUBLE({L1}) != {L2};",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_NE)) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_GT",              Kl_Undefined, None,    Kl_Float, None        ,   Kl_Boolean,  ["if ( PyFloat_CheckExact({L1}) ) {",
                                                                                      "{LB} = PyFloat_AS_DOUBLE({L1}) > {L2};",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_GT )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),

("Py_GE",              Kl_Undefined, None,    Kl_Float, None        ,   Kl_Boolean,  ["if ( PyFloat_CheckExact({L1}) ) {",
                                                                                      "{LB} = PyFloat_AS_DOUBLE({L1}) >= {L2};",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_GE )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_LT",              Kl_Undefined, None,    Kl_Float, None        ,   Kl_Boolean,  ["if ( PyFloat_CheckExact({L1}) ) {",
                                                                                      "{LB} = PyFloat_AS_DOUBLE({L1}) < {L2};",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_LT )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]),                                                                                                                                                                            
("Py_LE",              Kl_Undefined, None,    Kl_Float, None        ,   Kl_Boolean,  ["if ( PyFloat_CheckExact({L1}) ) {",
                                                                                      "{LB} = PyFloat_AS_DOUBLE({L1}) <= {L2};",
                                                                                      "} else {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_LE )) == -1) goto L0;", 
                                                                                      "}",
                                                                                      "{LB}"]), 

("Py_EQ",              Kl_Undefined, None,    Kl_Undefined, None,     Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", "{LB}"]),
("Py_NE",              Kl_Undefined, None,    Kl_Undefined, None,     Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;", "{LB}"]),
("Py_GT",              Kl_Undefined, None,    Kl_Undefined, None,     Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GT )) == -1) goto L0;", "{LB}"]),
("Py_GE",              Kl_Undefined, None,    Kl_Undefined, None,     Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GE )) == -1) goto L0;", "{LB}"]),
("Py_LT",              Kl_Undefined, None,    Kl_Undefined, None,     Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", "{LB}"]),
("Py_LE",              Kl_Undefined, None,    Kl_Undefined, None,     Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LE )) == -1) goto L0;", "{LB}"]),

("Py_EQ",              Kl_Undefined, None,    Kl_Tuple, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", "{LB}"]),
("Py_NE",              Kl_Undefined, None,    Kl_Tuple, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;", "{LB}"]),
("Py_GT",              Kl_Undefined, None,    Kl_Tuple, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GT )) == -1) goto L0;", "{LB}"]),
("Py_GE",              Kl_Undefined, None,    Kl_Tuple, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GE )) == -1) goto L0;", "{LB}"]),
("Py_LT",              Kl_Undefined, None,    Kl_Tuple, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", "{LB}"]),
("Py_LE",              Kl_Undefined, None,    Kl_Tuple, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LE )) == -1) goto L0;", "{LB}"]),
 
("Py_EQ",              Kl_Float, None,    Kl_Int, None,                 Kl_Boolean, "({L1} == {L2})"),
("Py_NE",              Kl_Float, None,    Kl_Int, None,                 Kl_Boolean, "({L1} != {L2})"),
("Py_GT",              Kl_Float, None,    Kl_Int, None,                 Kl_Boolean, "({L1} > {L2})"),
("Py_GE",              Kl_Float, None,    Kl_Int, None,                 Kl_Boolean, "({L1} >= {L2})"),
("Py_LT",              Kl_Float, None,    Kl_Int, None,                 Kl_Boolean, "({L1} < {L2})"),
("Py_LE",              Kl_Float, None,    Kl_Int, None,                 Kl_Boolean, "({L1} <= {L2})"),

("Py_EQ",              Kl_Int, None,      Kl_Float, None,               Kl_Boolean, "({L1} == {L2})"),
("Py_NE",              Kl_Int, None,      Kl_Float, None,               Kl_Boolean, "({L1} != {L2})"),
("Py_GT",              Kl_Int, None,      Kl_Float, None,               Kl_Boolean, "({L1} > {L2})"),
("Py_GE",              Kl_Int, None,      Kl_Float, None,               Kl_Boolean, "({L1} >= {L2})"),
("Py_LT",              Kl_Int, None,      Kl_Float, None,               Kl_Boolean, "({L1} < {L2})"),
("Py_LE",              Kl_Int, None,      Kl_Float, None,               Kl_Boolean, "({L1} <= {L2})"),

("Py_EQ",              Kl_Float, None,    Kl_Float, None,               Kl_Boolean, "({L1} == {L2})"),
("Py_NE",              Kl_Float, None,    Kl_Float, None,               Kl_Boolean, "({L1} != {L2})"),
("Py_GT",              Kl_Float, None,    Kl_Float, None,               Kl_Boolean, "({L1} > {L2})"),
("Py_GE",              Kl_Float, None,    Kl_Float, None,               Kl_Boolean, "({L1} >= {L2})"),
("Py_LT",              Kl_Float, None,    Kl_Float, None,               Kl_Boolean, "({L1} < {L2})"),
("Py_LE",              Kl_Float, None,    Kl_Float, None,               Kl_Boolean, "({L1} <= {L2})"),

("Py_EQ",              Kl_Char, None,     Kl_Char, None,                Kl_Boolean, "({L1} == {L2})"),
("Py_NE",              Kl_Char, None,     Kl_Char, None,                Kl_Boolean, "({L1} != {L2})"),
("Py_GT",              Kl_Char, None,     Kl_Char, None,                Kl_Boolean, "({L1} > {L2})"),
("Py_GE",              Kl_Char, None,     Kl_Char, None,                Kl_Boolean, "({L1} >= {L2})"),
("Py_LT",              Kl_Char, None,     Kl_Char, None,                Kl_Boolean, "({L1} < {L2})"),
("Py_LE",              Kl_Char, None,     Kl_Char, None,                Kl_Boolean, "({L1} <= {L2})"),

("Py_EQ",              Kl_Boolean, None,  Kl_Boolean, None,  Kl_Boolean, "({L1} == {L2})"),
("Py_EQ",              Kl_Boolean, None,  ('MayBe', Kl_Boolean), None,  Kl_Boolean, "({L2} != Py_None && {L1} == PyObject_IsTrue({L2}))")
]
if True:
    linear_type_rule.extend([
("M:index",            [(Kl_List, None), (Kl_O, None)],                   Kl_Int,     ["{LI} = _PyList_Index((PyListObject *){L1}, {L2});",
                                                                                       "if ({LI} == -1) goto L0;",
                                                                                       "{LI}"], '_PyList_Index'),
("M:isnan",            New_Kl_Module('math'), None, Kl_Float, None,     Kl_Boolean, "((long)Py_IS_NAN({L2}) != 0)"),
("M:isinf",            New_Kl_Module('math'), None, Kl_Float, None,     Kl_Boolean, "((long)Py_IS_INFINITY({L2}) != 0)"),
                             
("M:exc_info",         New_Kl_Module('sys'), ArgIsInCodeFunc_,  None, None, Kl_Tuple,   ["if (({LR} = PyTuple_Pack(3, tstate->exc_type != NULL ? tstate->exc_type : Py_None, tstate->exc_value != NULL ? tstate->exc_value : Py_None, tstate->exc_traceback != NULL ? tstate->exc_traceback : Py_None)) == 0) goto L0;",
                                                                                     "{LR}"])])
linear_type_rule.extend([                                                                                     
("M:add",              Kl_Set, None,  Kl_O, None,                       Kl_None,   ["if (PySet_Add({L1}, {L2}) == -1) goto L0;",
                                                                                     "Py_None"]),
("M:copy",             Kl_Set, None,  None, None,                       Kl_Set,    ["if (({LR} = PySet_New({L1})) == 0) goto L0;",
                                                                                     "{LR}"]),
("M:remove",           Kl_Set, None,  Kl_O, None,                       Kl_None,   ["if (PySet_Discard({L1}, {L2}) == -1) goto L0;",
                                                                                     "Py_None"]),
("M:clear",            Kl_Set, None,  None, None,                       Kl_None,   ["if (PySet_Clear({L1}) == -1) goto L0;",
                                                                                     "Py_None"]),
("M:clear",            Kl_Dict, None,  None, None,            Kl_None,   ["PyDict_Clear({L1};",
                                                                                     "Py_None"]),
("M:clear",            ('MayBe',Kl_Dict), None,  None, None,            Kl_None,   ["PyDict_Clear({L1});",
                                                                                     "Py_None"], None, ('{L1} == Py_None', 'PyErr_Format(PyExc_AttributeError, "''NoneType'' object has no attribute ''clear''");')),

("M:fromkeys",         (type, Kl_Dict), None,  Kl_List, None,           Kl_Dict,   ["if (({LR} = PyDict_New()) == 0) goto L0;",
                                                                                    "for ({LI} = 0; {LI} < PyList_GET_SIZE({L2}); {LI}++) {"
                                                                                    "if (PyDict_SetItem({LR}, PyList_GET_ITEM({L2}, {LI}), Py_None) == -1) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("PyDict_New",         [],                                              Kl_Dict,   ["if (({LR} = PyDict_New()) == 0) goto L0;",
                                                                                    "{LR}"]),

("frozenset",          Kl_Tuple, None, None, None,                      Kl_FrozenSet, ["if (({LR} = PyFrozenSet_New({L1})) == 0) goto L0;",
                                                                                       "{LR}"]),
("frozenset",          Kl_List, None, None, None,                       Kl_FrozenSet, ["if (({LR} = PyFrozenSet_New({L1})) == 0) goto L0;",
                                                                                       "{LR}"]),
("dict",               Kl_Dict, None, None, None,                       Kl_Dict, ["if (({LR} = PyDict_Copy({L1})) == 0) goto L0;",
                                                                                       "{LR}"]),
("dict",               Kl_List, None, None, None,                       Kl_Dict, ["if (({LR} = PyDict_New()) == 0) goto L0;",
                                                                                    "if (PyDict_MergeFromSeq2( {LR} , {L1} , 1) == -1) goto L0;",
                                                                                       "{LR}"]),
("divmod",             Kl_O, None, Kl_O, None,                          Kl_Tuple, ["if (({LR} = PyNumber_Divmod({L1}, {L2})) == 0) goto L0;",
                                                                                       "{LR}"]),
("M:update",           Kl_Dict, None, Kl_Dict, None,                    Kl_None,   ["if (PyDict_Update({L1}, {L2}) == -1) goto L0;",
                                                                                     "Py_None"]),
("M:iterkeys",         Kl_Dict, None, None, None,                  Kl_Generator,   ["if (_PyDict_IterKeys == 0) _PyDict_Get_Iterators();",
                                                                                    "if (({LR} = (*_PyDict_IterKeys)({L1}, 0)) == 0) goto L0;",
                                                                                    "{LR}"], "_PyDict_Iterators"),
("M:iteritems",        Kl_Dict, None, None, None,                  Kl_Generator,   ["if (_PyDict_IterItems == 0) _PyDict_Get_Iterators();",
                                                                                    "if (({LR} = (*_PyDict_IterItems)({L1}, 0)) == 0) goto L0;",
                                                                                    "{LR}"], "_PyDict_Iterators"),
("M:itervalues",       Kl_Dict, None, None, None,                  Kl_Generator,   ["if (_PyDict_IterValues == 0) _PyDict_Get_Iterators();",
                                                                                    "if (({LR} = (*_PyDict_IterValues)({L1}, 0)) == 0) goto L0;",
                                                                                    "{LR}"], "_PyDict_Iterators"),
("M:join",             Kl_Char, None, Kl_List, None,               Kl_Undefined,   ["if (({LR} = _PyString_Join(O{L1}, {L2})) == 0) goto L0;",
                                                                                       "{LR}"]),

("M:join",             Kl_String, None, Kl_List, None,             Kl_Undefined,   ["if (({LR} = _PyString_Join({L1}, {L2})) == 0) goto L0;",
                                                                                       "{LR}"]),
  
("_EQ_",               (bool, True), None, Kl_Boolean, None,            Kl_Boolean, "{L2}"),
##("_EQ_",               Kl_Boolean, None,  (bool, True), None,           Kl_Boolean, "{L1}"),
("_EQ_",               (bool, False), None, Kl_Boolean, None,           Kl_Boolean, "(!{L2})"),
##("_EQ_",               Kl_Boolean, None,  (bool, False), None,          Kl_Boolean, "(!{L1})"),

("_EQ_",               New_Kl_Module(None), None, Kl_None, None,        Kl_Boolean, "({L1} == Py_None)"),
("_NEQ_",              New_Kl_Module(None), None, Kl_None, None,        Kl_Boolean, "({L1} != Py_None)"),
("_EQ_",               Kl_Undefined, None,Kl_None, None,                Kl_Boolean, "({L1} == Py_None)"),
("_NEQ_",              Kl_Undefined, None,Kl_None, None,                Kl_Boolean, "({L1} != Py_None)"),
("_EQ_",               Kl_O, None,   Kl_Boolean, None  ,                Kl_Boolean, "({L1} == O{L2})"),
("_NEQ_",              Kl_O, None,   Kl_Boolean, None  ,                Kl_Boolean, "({L1} != O{L2})"),

("Py_GT",              (bool, True), None, Kl_Boolean, None,            Kl_Boolean, "(!{L2})"),
("Py_GT",              Kl_Boolean, None,  (bool, True), None,           Kl_Boolean, "0"),
("Py_GT",              (bool, False), None, Kl_Boolean, None,           Kl_Boolean, "0"),
("Py_GT",              Kl_Boolean, None,  (bool, False), None,          Kl_Boolean, "(!{L2})"),

("Py_GE",              (bool, True), None, Kl_Boolean, None,            Kl_Boolean, "1"),
("Py_GE",              Kl_Boolean, None,  (bool, True), None,           Kl_Boolean, "{L1}"),
("Py_GE",              (bool, False), None, Kl_Boolean, None,           Kl_Boolean, "(!{L2})"),
("Py_GE",              Kl_Boolean, None,  (bool, False), None,          Kl_Boolean, "1"),

("Py_LT",              (bool, True), None, Kl_Boolean, None,            Kl_Boolean, "0"),
("Py_LT",              Kl_Boolean, None,  (bool, True), None,           Kl_Boolean, "(!{L1})"),
("Py_LT",              (bool, False), None, Kl_Boolean, None,           Kl_Boolean, "{L2}"),
("Py_LT",              Kl_Boolean, None,  (bool, False), None,          Kl_Boolean, "0"),

("Py_LE",              (bool, True), None, Kl_Boolean, None,            Kl_Boolean, "{L2}"),
("Py_LE",              Kl_Boolean, None,  (bool, True), None,           Kl_Boolean, "1"),
("Py_LE",              (bool, False), None, Kl_Boolean, None,           Kl_Boolean, "1"),
("Py_LE",              Kl_Boolean, None,  (bool, False), None,          Kl_Boolean, "{!L1}"),

("Py_EQ",              (bool, True), None, Kl_Boolean, None,            Kl_Boolean, "{L2}"),
("Py_EQ",              Kl_Boolean, None,  (bool, True), None,           Kl_Boolean, "{L1}"),
("Py_EQ",              (bool, False), None, Kl_Boolean, None,           Kl_Boolean, "(!{L2})"),
("Py_EQ",              Kl_Boolean, None,  (bool, False), None,          Kl_Boolean, "(!{L1})"),

("Py_EQ",              (bool, True), None, (bool, True), None,          Kl_Boolean, "1"),
("Py_EQ",              (bool, False), None, (bool, False), None,        Kl_Boolean, "1"),
("Py_NE",              (bool, True), None, (bool, True), None,          Kl_Boolean, "0"),
("Py_NE",              (bool, False), None, (bool, False), None,        Kl_Boolean, "0"),

("Py_EQ",              (bool, True), None, (bool, False), None,         Kl_Boolean, "0"),
("Py_EQ",              (bool, False), None, (bool, True), None,         Kl_Boolean, "0"),
("Py_NE",              (bool, True), None, (bool, False), None,         Kl_Boolean, "1"),
("Py_NE",              (bool, False), None, (bool, True), None,         Kl_Boolean, "1"),

("Py_NE",              (bool, True), None, Kl_Boolean, None,            Kl_Boolean, "(!{L2})"),
("Py_NE",              Kl_Boolean, None,  (bool, True), None,           Kl_Boolean, "(!{L1})"),
("Py_NE",              (bool, False), None, Kl_Boolean, None,           Kl_Boolean, "{L2}"),
("Py_NE",              Kl_Boolean, None,  (bool, False), None,          Kl_Boolean, "{L1}"),

##("Py_EQ",              Kl_Boolean, None,  Kl_Boolean, None,             Kl_Boolean, "({L1} == {L2})"),
("Py_NE",              Kl_Boolean, None,  Kl_Boolean, None,             Kl_Boolean, "({L1} != {L2})"),
("Py_GT",              Kl_Boolean, None,  Kl_Boolean, None,             Kl_Boolean, "({L1} > {L2})"),
("Py_GE",              Kl_Boolean, None,  Kl_Boolean, None,             Kl_Boolean, "({L1} >= {L2})"),
("Py_LT",              Kl_Boolean, None,  Kl_Boolean, None,             Kl_Boolean, "({L1} < {L2})"),
("Py_LE",              Kl_Boolean, None,  Kl_Boolean, None,             Kl_Boolean, "({L1} <= {L2})"),  


("Py_EQ",              Kl_Undefined, None,   (bool, True), None,        Kl_Boolean, ["if ({L1} == Py_True) {",
                                                                                    "{LB} = 1;",
                                                                                    "} else {",
                                                                                    "if (({LB} = PyObject_RichCompareBool ( {L1} , Py_True , Py_EQ )) == -1) goto L0;",  
                                                                                    "}",
                                                                                    "{LB}"]),
("Py_NE",              Kl_Undefined, None,   (bool, True), None,        Kl_Boolean, ["if ({L1} == Py_False) {",
                                                                                    "{LB} = 1;",
                                                                                    "} else {",
                                                                                    "if (({LB} = PyObject_RichCompareBool ( {L1} , Py_True , Py_NE )) == -1) goto L0;",  
                                                                                    "}",
                                                                                    "{LB}"]),
("Py_EQ",              Kl_Undefined, None,   (bool, False), None,      Kl_Boolean, ["if ({L1} == Py_False) {",
                                                                                    "{LB} = 1;",
                                                                                    "} else {",
                                                                                    "if (({LB} = PyObject_RichCompareBool ( {L1} , Py_False , Py_EQ )) == -1) goto L0;",  
                                                                                    "}",
                                                                                    "{LB}"]),
("Py_NE",              Kl_Undefined, None,   (bool, False), None,      Kl_Boolean, ["if ({L1} == Py_True) {",
                                                                                    "{LB} = 1;",
                                                                                    "} else {",
                                                                                    "if (({LB} = PyObject_RichCompareBool ( {L1} , Py_False , Py_NE )) == -1) goto L0;",  
                                                                                    "}",
                                                                                    "{LB}"]),

("Py_NE",              Kl_String, None,   Kl_Char, None,                Kl_Boolean, "(PyString_GET_SIZE({L1}) != 1 || *PyString_AS_STRING({L1}) != {L2})"),
("Py_EQ",              Kl_String, None,   Kl_Char, None,                Kl_Boolean, "(PyString_GET_SIZE({L1}) == 1 && *PyString_AS_STRING({L1}) == {L2})"),

("Py_EQ",              Kl_Char, None,     Kl_String, None,              Kl_Boolean, "(PyString_GET_SIZE({L2}) == 1 && *PyString_AS_STRING({L2}) == {L1})"),
("Py_NE",              Kl_Char, None,     Kl_String, None,              Kl_Boolean, "(PyString_GET_SIZE({L2}) != 1 || *PyString_AS_STRING({L2}) != {L1})"),

("Py_EQ",              Kl_Undefined, None,  Kl_Char, None        ,        Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) == 1 && *PyString_AS_STRING({L1}) == {L2});", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_EQ )) == -1) goto L0;",  
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_NE",              Kl_Undefined, None,  Kl_Char, None        ,        Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) != 1 || *PyString_AS_STRING({L1}) != {L2});", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_NE )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),

("Py_GE",              Kl_Undefined, None,  Kl_Char, None        ,        Kl_Boolean, ["if (PyString_CheckExact({L1}) && PyString_GET_SIZE({L1}) == 1) {",
                                                                                       "{LB} = *PyString_AS_STRING({L1}) >= {L2};", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_GE )) == -1) goto L0;",  
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_LE",              Kl_Undefined, None,  Kl_Char, None        ,         Kl_Boolean, ["if (PyString_CheckExact({L1}) && PyString_GET_SIZE({L1}) == 1) {",
                                                                                       "{LB} = *PyString_AS_STRING({L1}) <= {L2};", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_LE )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_GT",              Kl_Undefined, None,  Kl_Char, None        ,        Kl_Boolean, ["if (PyString_CheckExact({L1}) && PyString_GET_SIZE({L1}) == 1) {",
                                                                                       "{LB} = *PyString_AS_STRING({L1}) > {L2};", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_GT )) == -1) goto L0;",  
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_LT",              Kl_Undefined, None,  Kl_Char, None        ,        Kl_Boolean, ["if (PyString_CheckExact({L1}) && PyString_GET_SIZE({L1}) == 1) {",
                                                                                       "{LB} = *PyString_AS_STRING({L1}) < {L2};", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_LT )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),

("Py_EQ",              Kl_Undefined, None,   Kl_String, None,             Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && 0 == memcmp( PyString_AS_STRING({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2})));",
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_NE",              Kl_Undefined, None,   Kl_String, None,             Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) != PyString_GET_SIZE({L2}) || 0 != memcmp( PyString_AS_STRING({L1}), PyString_AS_STRING({L2}), PyString_GET_SIZE({L2})));",
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_GT",              Kl_Undefined, None,   Kl_String, None,             Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GT )) == -1) goto L0;", "{LB}"]),
("Py_GE",              Kl_Undefined, None,   Kl_String, None,             Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GE )) == -1) goto L0;", "{LB}"]),
("Py_LT",              Kl_Undefined, None,   Kl_String, None,             Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", "{LB}"]),
("Py_LE",              Kl_Undefined, None,   Kl_String, None,             Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LE )) == -1) goto L0;", "{LB}"]),

("Py_EQ",              Kl_Char, None        , Kl_Undefined, None,         Kl_Boolean, ["if (PyString_CheckExact({L2})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L2}) == 1 && *PyString_AS_STRING({L2}) == {L1});", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L1} , Py_EQ )) == -1) goto L0;",  
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_NE",              Kl_Char, None        , Kl_Undefined, None,         Kl_Boolean, ["if (PyString_CheckExact({L2})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L2}) != 1 || *PyString_AS_STRING({L2}) != {L1});", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L1} , Py_NE )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),

("Py_GE",              Kl_Char, None        , Kl_Undefined, None,         Kl_Boolean, ["if (PyString_CheckExact({L2}) && PyString_GET_SIZE({L2}) == 1) {",
                                                                                       "{LB} = *PyString_AS_STRING({L2}) >= {L1};", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L1} , Py_GE )) == -1) goto L0;",  
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_LE",              Kl_Char, None        , Kl_Undefined, None,          Kl_Boolean, ["if (PyString_CheckExact({L2}) && PyString_GET_SIZE({L2}) == 1) {",
                                                                                       "{LB} = *PyString_AS_STRING({L2}) <= {L1};", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L1} , Py_LE )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_GT",              Kl_Char, None        , Kl_Undefined, None,         Kl_Boolean, ["if (PyString_CheckExact({L2}) && PyString_GET_SIZE({L2}) == 1) {",
                                                                                       "{LB} = *PyString_AS_STRING({L2}) > {L1};", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L1} , Py_GT )) == -1) goto L0;",  
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_LT",              Kl_Char, None        , Kl_Undefined, None,         Kl_Boolean, ["if (PyString_CheckExact({L2}) && PyString_GET_SIZE({L2}) == 1) {",
                                                                                       "{LB} = *PyString_AS_STRING({L2}) < {L1};", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L2} , O{L1} , Py_LT )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),

("Py_EQ",              Kl_String, None,   (str, ''), None,               Kl_Boolean, "(PyString_GET_SIZE({L1}) == 0)"),
("Py_NE",              Kl_String, None,   (str, ''), None,               Kl_Boolean, "(PyString_GET_SIZE({L1}) != 0)"),
("Py_EQ",              (str, ''), None,   Kl_String, None,               Kl_Boolean, "(PyString_GET_SIZE({L2}) == 0)"),
("Py_NE",              (str, ''), None,   Kl_String, None,               Kl_Boolean, "(PyString_GET_SIZE({L2}) != 0)"),

("Py_EQ",              Kl_String, None,   Kl_String, ArgIsConst_,        Kl_Boolean, Gen_Patt_EqStr),

("Py_EQ",              Kl_String, None,  Kl_String, None,       Kl_Boolean, "(PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L1})))"),
("Py_NE",              Kl_String, None,  Kl_String, None,       Kl_Boolean, "(PyString_GET_SIZE({L1}) != PyString_GET_SIZE({L2}) || memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L1})) != 0)"),

("Py_EQ",              ('MayBe', Kl_Char), None,  Kl_Char, None        ,  Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = *PyString_AS_STRING({L1}) == {L2};", 
                                                                                       "} else {",
                                                                                       "{LB} = 0;",
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_NE",              ('MayBe', Kl_Char), None,  Kl_Char, None        ,  Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = *PyString_AS_STRING({L1}) != {L2};", 
                                                                                       "} else {",
                                                                                       "{LB} = 1;",
                                                                                       "}",
                                                                                       "{LB}"]),

("Py_EQ",              ('MayBe', Kl_String), None,  Kl_Char, None        , Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) == 1 && *PyString_AS_STRING({L1}) == {L2});", 
                                                                                       "} else {",
                                                                                       "{LB} = 0;",
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_NE",              ('MayBe', Kl_String), None,  Kl_Char, None        , Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) != 1 || *PyString_AS_STRING({L1}) != {L2});", 
                                                                                       "} else {",
                                                                                       "{LB} = 1;",
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_EQ",              ('MayBe', Kl_String), None,  Kl_String, None,      Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L1})));", 
                                                                                       "} else {",
                                                                                       "{LB} = 0;",
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_NE",              ('MayBe', Kl_String), None,  Kl_String, None,      Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) != PyString_GET_SIZE({L2}) || memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L1})) != 0);", 
                                                                                       "} else {",
                                                                                       "{LB} = 1;",
                                                                                       "}",
                                                                                       "{LB}"]),


 
##("Py_EQ",              Kl_String, None,   Kl_String, ArgIsConst_,        Kl_Boolean, "(PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L2})))"),

("Py_EQ",              Kl_String, None,   ('MayBe', Kl_String), None,   Kl_Boolean, "({L2} != Py_None && PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L1})))"),
("Py_NE",              Kl_String, None,   ('MayBe', Kl_String), None,   Kl_Boolean, "({L2} == Py_None || PyString_GET_SIZE({L1}) != PyString_GET_SIZE({L2}) || memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L1})) != 0)"),

("Py_EQ",              Kl_String, None,   Kl_None, None,                 Kl_Boolean, "0"),
("Py_NE",              Kl_String, None,   Kl_None, None,                 Kl_Boolean, "1"),

("Py_EQ",              Kl_None, None,     Kl_String, None,               Kl_Boolean, "0"),
("Py_NE",              Kl_None, None,     Kl_String, None,               Kl_Boolean, "1"),

("Py_EQ",              Kl_None, None,     Kl_Undefined, None,            Kl_Boolean, ["{LB} = Py_None == {L2};"
                                                                                      "if (!{LB}) {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( Py_None , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                       "}",
                                                                                      "{LB}"]),
("Py_NE",              Kl_None, None,     Kl_Undefined, None,            Kl_Boolean, ["{LB} = Py_None == {L2};"
                                                                                      "if (!{LB}) {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( Py_None , {L2} , Py_NE )) == -1) goto L0;", 
                                                                                      "} else {",
                                                                                      "{LB} = !{LB};",
                                                                                       "}",
                                                                                      "{LB}"]),
("Py_EQ",              Kl_Undefined, None,     Kl_None, None,            Kl_Boolean, ["{LB} = Py_None == {L1};"
                                                                                      "if (!{LB}) {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , Py_None , Py_EQ )) == -1) goto L0;", 
                                                                                       "}",
                                                                                      "{LB}"]),
("Py_NE",              Kl_Undefined, None,     Kl_None, None,            Kl_Boolean, ["{LB} = Py_None == {L1};"
                                                                                      "if (!{LB}) {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , Py_None , Py_NE )) == -1) goto L0;", 
                                                                                      "} else {",
                                                                                      "{LB} = !{LB};",
                                                                                       "}",
                                                                                      "{LB}"]),


("Py_EQ",              Kl_Undefined, None,  (str, ''), None        ,     Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) == 0);", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_NE",              Kl_Undefined, None,  (str, ''), None        ,     Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) != 0);", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),

("Py_EQ",              Kl_Undefined, None,  Kl_OString, None,            Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L2})));", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_NE",              Kl_Undefined, None,  Kl_OString, None,            Kl_Boolean, ["if (PyString_CheckExact({L1})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) != PyString_GET_SIZE({L2}) || memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L2})) != 0);", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_EQ",              Kl_OString, None,  Kl_Undefined, None,            Kl_Boolean, ["if (PyString_CheckExact({L2})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L2})));", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_NE",              Kl_OString, None,  Kl_Undefined, None,            Kl_Boolean, ["if (PyString_CheckExact({L2})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) != PyString_GET_SIZE({L2}) || memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L2})) != 0);", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),

("Py_EQ",              Kl_Undefined, None,  ('MayBe', Kl_String), None,            Kl_Boolean, ["if (PyString_CheckExact({L1}) && PyString_CheckExact({L2})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L2})));", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_NE",              Kl_Undefined, None,  ('MayBe', Kl_String), None,            Kl_Boolean, ["if (PyString_CheckExact({L1}) && PyString_CheckExact({L2})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) != PyString_GET_SIZE({L2}) || memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L2})) != 0);", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_EQ",              ('MayBe', Kl_String), None,  Kl_Undefined, None,            Kl_Boolean, ["if (PyString_CheckExact({L2}) && PyString_CheckExact({L2})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) == PyString_GET_SIZE({L2}) && !memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L2})));", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),
("Py_NE",              ('MayBe', Kl_String), None,  Kl_Undefined, None,            Kl_Boolean, ["if (PyString_CheckExact({L2}) && PyString_CheckExact({L2})) {",
                                                                                       "{LB} = (PyString_GET_SIZE({L1}) != PyString_GET_SIZE({L2}) || memcmp(PyString_AS_STRING({L1}) ,PyString_AS_STRING({L2}) , PyString_GET_SIZE({L2})) != 0);", 
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),


("Py_EQ",              Kl_Type, None,      Kl_Type, None,                Kl_Boolean, "({L1} == {L2})"),
("Py_NE",              Kl_Type, None,      Kl_Type, None,                Kl_Boolean, "({L1} != {L2})"),

("Py_EQ",              (frozenset, None), None, (frozenset, None), None, Kl_Boolean, ["if (PySet_GET_SIZE({L1}) == PySet_GET_SIZE({L2})) {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                      "} else {",
                                                                                      "{LB} = 0;",
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_NE",              (frozenset, None), None, (frozenset, None), None, Kl_Boolean, ["if (PySet_GET_SIZE({L1}) == PySet_GET_SIZE({L2})) {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;", 
                                                                                      "} else {",
                                                                                      "{LB} = 1;",
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_EQ",              (set, None), None,          (set, None), None,    Kl_Boolean, ["if (PySet_GET_SIZE({L1}) == PySet_GET_SIZE({L2})) {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", 
                                                                                      "} else {",
                                                                                      "{LB} = 0;",
                                                                                      "}",
                                                                                      "{LB}"]),
("Py_NE",              (set, None), None,          (set, None), None,    Kl_Boolean, ["if (PySet_GET_SIZE({L1}) == PySet_GET_SIZE({L2})) {",
                                                                                      "if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;", 
                                                                                      "} else {",
                                                                                      "{LB} = 1;",
                                                                                      "}",
                                                                                      "{LB}"]),


("Py_EQ",              Kl_String, ArgIsStrConsted, Kl_String, ArgIsStrConsted, Kl_Boolean, CmpEqTypeStr),
("Py_NE",              Kl_String, ArgIsStrConsted, Kl_String, ArgIsStrConsted, Kl_Boolean, CmpNeTypeStr),

## ("Py_EQ",              Kl_C, ArgNotIsCVar,        Kl_O, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_EQ )) == -1) goto L0;", "{LB}"]),
## ("Py_NE",              Kl_C, ArgNotIsCVar,        Kl_O, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_NE )) == -1) goto L0;", "{LB}"]),
## ("Py_GT",              Kl_C, ArgNotIsCVar,        Kl_O, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_GT )) == -1) goto L0;", "{LB}"]),
## ("Py_GE",              Kl_C, ArgNotIsCVar,        Kl_O, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_GE )) == -1) goto L0;", "{LB}"]),
## ("Py_LT",              Kl_C, ArgNotIsCVar,        Kl_O, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LT )) == -1) goto L0;", "{LB}"]),
## ("Py_LE",              Kl_C, ArgNotIsCVar,        Kl_O, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LE )) == -1) goto L0;", "{LB}"]),

## ("Py_EQ",              Kl_O, None,        Kl_C, ArgNotIsCVar,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_EQ )) == -1) goto L0;", "{LB}"]),
## ("Py_NE",              Kl_O, None,        Kl_C, ArgNotIsCVar,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_NE )) == -1) goto L0;", "{LB}"]),
## ("Py_GT",              Kl_O, None,        Kl_C, ArgNotIsCVar,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_GT )) == -1) goto L0;", "{LB}"]),
## ("Py_GE",              Kl_O, None,        Kl_C, ArgNotIsCVar,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_GE )) == -1) goto L0;", "{LB}"]),
## ("Py_LT",              Kl_O, None,        Kl_C, ArgNotIsCVar,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_LT )) == -1) goto L0;", "{LB}"]),
## ("Py_LE",              Kl_O, None,        Kl_C, ArgNotIsCVar,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_LE )) == -1) goto L0;", "{LB}"]),

("Py_EQ",              Kl_C, None,                Kl_O, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_EQ )) == -1) goto L0;", "{LB}"]),
("Py_NE",              Kl_C, None,                Kl_O, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_NE )) == -1) goto L0;", "{LB}"]),
("Py_GT",              Kl_C, None,                Kl_O, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_GT )) == -1) goto L0;", "{LB}"]),
("Py_GE",              Kl_C, None,                Kl_O, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_GE )) == -1) goto L0;", "{LB}"]),
("Py_LT",              Kl_C, None,                Kl_O, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LT )) == -1) goto L0;", "{LB}"]),
("Py_LE",              Kl_C, None,                Kl_O, None,           Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( O{L1} , {L2} , Py_LE )) == -1) goto L0;", "{LB}"]),

("Py_EQ",              Kl_O, None,        Kl_C, None,                   Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_EQ )) == -1) goto L0;", "{LB}"]),
("Py_NE",              Kl_O, None,        Kl_C, None,                   Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_NE )) == -1) goto L0;", "{LB}"]),
("Py_GT",              Kl_O, None,        Kl_C, None,                   Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_GT )) == -1) goto L0;", "{LB}"]),
("Py_GE",              Kl_O, None,        Kl_C, None,                   Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_GE )) == -1) goto L0;", "{LB}"]),
("Py_LT",              Kl_O, None,        Kl_C, None,                   Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_LT )) == -1) goto L0;", "{LB}"]),
("Py_LE",              Kl_O, None,        Kl_C, None,                   Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , O{L2} , Py_LE )) == -1) goto L0;", "{LB}"]),


("Py_EQ",              Kl_O, None,        Kl_O, None,                   Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_EQ )) == -1) goto L0;", "{LB}"]),
("Py_NE",              Kl_O, None,        Kl_O, None,                   Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_NE )) == -1) goto L0;", "{LB}"]),
("Py_GT",              Kl_O, None,        Kl_O, None,                   Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GT )) == -1) goto L0;", "{LB}"]),
("Py_GE",              Kl_O, None,        Kl_O, None,                   Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_GE )) == -1) goto L0;", "{LB}"]),
("Py_LT",              Kl_O, None,        Kl_O, None,                   Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LT )) == -1) goto L0;", "{LB}"]),
("Py_LE",              Kl_O, None,        Kl_O, None,                   Kl_Boolean, ["if (({LB} = PyObject_RichCompareBool ( {L1} , {L2} , Py_LE )) == -1) goto L0;", "{LB}"]),

("Py_EQ",              Kl_Undefined, None,        Kl_O, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( {L1} , {L2} , Py_EQ )) == 0) goto L0;", "{LR}"]),
("Py_NE",              Kl_Undefined, None,        Kl_O, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( {L1} , {L2} , Py_NE )) == 0) goto L0;", "{LR}"]),
("Py_GT",              Kl_Undefined, None,        Kl_O, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( {L1} , {L2} , Py_GT )) == 0) goto L0;", "{LR}"]),
("Py_GE",              Kl_Undefined, None,        Kl_O, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( {L1} , {L2} , Py_GE )) == 0) goto L0;", "{LR}"]),
("Py_LT",              Kl_Undefined, None,        Kl_O, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( {L1} , {L2} , Py_LT )) == 0) goto L0;", "{LR}"]),
("Py_LE",              Kl_Undefined, None,        Kl_O, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( {L1} , {L2} , Py_LE )) == 0) goto L0;", "{LR}"]),

("Py_EQ",              Kl_Undefined, None,        Kl_C, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( {L1} , O{L2} , Py_EQ )) == 0) goto L0;", "{LR}"]),
("Py_NE",              Kl_Undefined, None,        Kl_C, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( {L1} , O{L2} , Py_NE )) == 0) goto L0;", "{LR}"]),
("Py_GT",              Kl_Undefined, None,        Kl_C, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( {L1} , O{L2} , Py_GT )) == 0) goto L0;", "{LR}"]),
("Py_GE",              Kl_Undefined, None,        Kl_C, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( {L1} , O{L2} , Py_GE )) == 0) goto L0;", "{LR}"]),
("Py_LT",              Kl_Undefined, None,        Kl_C, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( {L1} , O{L2} , Py_LT )) == 0) goto L0;", "{LR}"]),
("Py_LE",              Kl_Undefined, None,        Kl_C, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( {L1} , O{L2} , Py_LE )) == 0) goto L0;", "{LR}"]),

("Py_EQ",              Kl_C, None,        Kl_Undefined, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( O{L1} , {L2} , Py_EQ )) == 0) goto L0;", "{LR}"]),
("Py_NE",              Kl_C, None,        Kl_Undefined, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( O{L1} , {L2} , Py_NE )) == 0) goto L0;", "{LR}"]),
("Py_GT",              Kl_C, None,        Kl_Undefined, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( O{L1} , {L2} , Py_GT )) == 0) goto L0;", "{LR}"]),
("Py_GE",              Kl_C, None,        Kl_Undefined, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( O{L1} , {L2} , Py_GE )) == 0) goto L0;", "{LR}"]),
("Py_LT",              Kl_C, None,        Kl_Undefined, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( O{L1} , {L2} , Py_LT )) == 0) goto L0;", "{LR}"]),
("Py_LE",              Kl_C, None,        Kl_Undefined, None,         Kl_Undefined, ["if (({LR} = PyObject_RichCompare ( O{L1} , {L2} , Py_LE )) == 0) goto L0;", "{LR}"]),

("PyObject_HasAttr",   Kl_C, ArgNotIsCVar,Kl_String, None,              Kl_Boolean, "PyObject_HasAttr ( O{L1} , {L2} )"),  
("PyObject_HasAttr",   Kl_C, None,        Kl_String, None,              Kl_Boolean, ["if (({LB} = PyObject_HasAttr ( O{L1} , {L2} )) == -1) goto L0;", "{LB}"]),  
("PyObject_HasAttr",   Kl_All, None,      Kl_All, None,                 Kl_Boolean, "PyObject_HasAttr ( {L1} , {L2} )"),  


("BINARY_SUBSCR_Int",  (tuple, 10), None,  (int, (0,9)), None,          Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 9), None,   (int, (0,8)), None,          Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 8), None,   (int, (0,7)), None,          Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 7), None,   (int, (0,6)), None,          Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 6), None,   (int, (0,5)), None,          Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 5), None,   (int, (0,4)), None,          Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 4), None,   (int, (0,3)), None,          Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 3), None,   (int, (0,2)), None,          Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 2), None,   (int, (0,1)), None,          Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (0,0)), None,          Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),

("BINARY_SUBSCR_Int",  (tuple, 10), None,  (int, (-10,-1)), None,       Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 9), None,   (int, (-9,-1)), None,        Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 8), None,   (int, (-8,-1)), None,        Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 7), None,   (int, (-7,-1)), None,        Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 6), None,   (int, (-6,-1)), None,        Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 5), None,   (int, (-5,-1)), None,        Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 4), None,   (int, (-4,-1)), None,        Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 3), None,   (int, (-3,-1)), None,        Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 2), None,   (int, (-2,-1)), None,        Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (-1,-1)), None,        Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),

("BINARY_SUBSCR_Int",  Kl_Tuple, None,     Kl_Cardinal, None,           Kl_Int, "PyInt_AS_LONG( PyTuple_GET_ITEM ( {L1}, {L2} ) )", ('PyTuple_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "tuple index out of range")')),


("BINARY_SUBSCR_Int",  (tuple, 10), None,  (int, (0,9)), None,          Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 9), None,   (int, (0,8)), None,          Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 8), None,   (int, (0,7)), None,          Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 7), None,   (int, (0,6)), None,          Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 6), None,   (int, (0,5)), None,          Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 5), None,   (int, (0,4)), None,          Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 4), None,   (int, (0,3)), None,          Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 3), None,   (int, (0,2)), None,          Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 2), None,   (int, (0,1)), None,          Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (0,0)), None,          Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),

("BINARY_SUBSCR_Int",  (tuple, 10), None,  (int, (-10,-1)), None,       Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 9), None,   (int, (-9,-1)), None,        Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 8), None,   (int, (-8,-1)), None,        Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 7), None,   (int, (-7,-1)), None,        Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 6), None,   (int, (-6,-1)), None,        Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 5), None,   (int, (-5,-1)), None,        Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 4), None,   (int, (-4,-1)), None,        Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 3), None,   (int, (-3,-1)), None,        Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 2), None,   (int, (-2,-1)), None,        Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (-1,-1)), None,        Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),

("BINARY_SUBSCR_Int",  Kl_Tuple, None,     Kl_Cardinal, None,           Kl_Float, "PyFloat_AS_DOUBLE( PyTuple_GET_ITEM ( {L1}, {L2} ) )", ('PyTuple_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "tuple index out of range")')),

("BINARY_SUBSCR_Int",  (tuple, 10), None,  (int, (-10,-1)), None,       Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 9), None,   (int, (-9,-1)), None,        Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 8), None,   (int, (-8,-1)), None,        Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 7), None,   (int, (-7,-1)), None,        Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 6), None,   (int, (-6,-1)), None,        Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 5), None,   (int, (-5,-1)), None,        Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 4), None,   (int, (-4,-1)), None,        Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 3), None,   (int, (-3,-1)), None,        Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 2), None,   (int, (-2,-1)), None,        Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (-1,-1)), None,        Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} ) )"),

("BINARY_SUBSCR_Int",  (tuple, 10), None,  (int, (0,9)), None,          Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 9), None,   (int, (0,8)), None,          Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 8), None,   (int, (0,7)), None,          Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 7), None,   (int, (0,6)), None,          Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 6), None,   (int, (0,5)), None,          Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 5), None,   (int, (0,4)), None,          Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 4), None,   (int, (0,3)), None,          Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 3), None,   (int, (0,2)), None,          Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 2), None,   (int, (0,1)), None,          Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (0,0)), None,          Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, {L2} ) )"),

("BINARY_SUBSCR_Int",  Kl_Tuple, None,     Kl_Cardinal, None,           Kl_Char, "*PyString_AS_STRING ( PyTuple_GET_ITEM ( {L1}, {L2} ) )", ('PyTuple_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "tuple index out of range")')),

("BINARY_SUBSCR_Int",  (tuple, 10), None,  (int, (-10,-1)), None,       Kl_String, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 9), None,   (int, (-9,-1)), None,        Kl_String, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 8), None,   (int, (-8,-1)), None,        Kl_String, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 7), None,   (int, (-7,-1)), None,        Kl_String, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 6), None,   (int, (-6,-1)), None,        Kl_String, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 5), None,   (int, (-5,-1)), None,        Kl_String, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 4), None,   (int, (-4,-1)), None,        Kl_String, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 3), None,   (int, (-3,-1)), None,        Kl_String, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 2), None,   (int, (-2,-1)), None,        Kl_String, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (-1,-1)), None,        Kl_String, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),

("BINARY_SUBSCR_Int",  (tuple, 10), None,  (int, (0,9)), None,          Kl_String, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 9), None,   (int, (0,8)), None,          Kl_String, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 8), None,   (int, (0,7)), None,          Kl_String, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 7), None,   (int, (0,6)), None,          Kl_String, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 6), None,   (int, (0,5)), None,          Kl_String, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 5), None,   (int, (0,4)), None,          Kl_String, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 4), None,   (int, (0,3)), None,          Kl_String, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 3), None,   (int, (0,2)), None,          Kl_String, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 2), None,   (int, (0,1)), None,          Kl_String, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (0,0)), None,          Kl_String, "PyTuple_GET_ITEM ( {L1}, {L2} )"),

("BINARY_SUBSCR_Int",  Kl_Tuple, None,     Kl_Cardinal, None,           Kl_String, "PyTuple_GET_ITEM ( {L1}, {L2} )", ('PyTuple_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "tuple index out of range")')),

("BINARY_SUBSCR_Int",  (tuple, 10), None,  (int, (-10,-1)), None,       Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 9), None,   (int, (-9,-1)), None,        Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 8), None,   (int, (-8,-1)), None,        Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 7), None,   (int, (-7,-1)), None,        Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 6), None,   (int, (-6,-1)), None,        Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 5), None,   (int, (-5,-1)), None,        Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 4), None,   (int, (-4,-1)), None,        Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 3), None,   (int, (-3,-1)), None,        Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 2), None,   (int, (-2,-1)), None,        Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (-1,-1)), None,        Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),

("BINARY_SUBSCR_Int",  (tuple, 10), None,  (int, (0,9)), None,          Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 9), None,   (int, (0,8)), None,          Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 8), None,   (int, (0,7)), None,          Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 7), None,   (int, (0,6)), None,          Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 6), None,   (int, (0,5)), None,          Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 5), None,   (int, (0,4)), None,          Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 4), None,   (int, (0,3)), None,          Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 3), None,   (int, (0,2)), None,          Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 2), None,   (int, (0,1)), None,          Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (0,0)), None,          Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, {L2} )"),

#("BINARY_SUBSCR_Int",  Kl_Tuple, None,     Kl_Cardinal, None,           Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, {L2} )", ('PyTuple_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "tuple index out of range")')),

("BINARY_SUBSCR_Int",  (tuple, 10), None,  (int, (-10,-1)), None,       Kl_Type, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 9), None,   (int, (-9,-1)), None,        Kl_Type, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 8), None,   (int, (-8,-1)), None,        Kl_Type, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 7), None,   (int, (-7,-1)), None,        Kl_Type, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 6), None,   (int, (-6,-1)), None,        Kl_Type, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 5), None,   (int, (-5,-1)), None,        Kl_Type, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 4), None,   (int, (-4,-1)), None,        Kl_Type, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 3), None,   (int, (-3,-1)), None,        Kl_Type, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 2), None,   (int, (-2,-1)), None,        Kl_Type, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (-1,-1)), None,        Kl_Type, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),

("BINARY_SUBSCR_Int",  (tuple, 10), None,  (int, (0,9)), None,          Kl_Type, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 9), None,   (int, (0,8)), None,          Kl_Type, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 8), None,   (int, (0,7)), None,          Kl_Type, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 7), None,   (int, (0,6)), None,          Kl_Type, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 6), None,   (int, (0,5)), None,          Kl_Type, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 5), None,   (int, (0,4)), None,          Kl_Type, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 4), None,   (int, (0,3)), None,          Kl_Type, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 3), None,   (int, (0,2)), None,          Kl_Type, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 2), None,   (int, (0,1)), None,          Kl_Type, "PyTuple_GET_ITEM ( {L1}, {L2} )"),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (0,0)), None,          Kl_Type, "PyTuple_GET_ITEM ( {L1}, {L2} )"),

("BINARY_SUBSCR_Int",  Kl_Tuple, None,     Kl_Cardinal, None,           Kl_Type, "PyTuple_GET_ITEM ( {L1}, {L2} )", ('PyTuple_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "tuple index out of range")')),
("BINARY_SUBSCR_Int",  Kl_Tuple, None,     Kl_Cardinal, None,           Kl_O,    ["{LR} = PyTuple_GET_ITEM ( {L1}, {L2} );",
                                                                                  "Py_INCREF({LR});",
                                                                                  "{LR}"], ('PyTuple_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "tuple index out of range")')),
("BINARY_SUBSCR_Int",  (tuple, 1), None,   (int, (-1,-1)), None,        Kl_O, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )"),
("BINARY_SUBSCR_Int",  Kl_Tuple, None,      (int, (-MInt, -1)), None,  Kl_O,  "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )", ('({L2} + PyTuple_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),

("BINARY_SUBSCR_Int",  Kl_List, None,      Kl_Cardinal, None,           Kl_Int,   "PyInt_AS_LONG( PyList_GET_ITEM ( {L1}, {L2} ) )", ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("BINARY_SUBSCR_Int",  Kl_List, None,      Kl_Cardinal, None,           Kl_Float, "PyFloat_AS_DOUBLE( PyList_GET_ITEM ( {L1}, {L2} ) )", ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("BINARY_SUBSCR_Int",  Kl_List, None,      Kl_Cardinal, None,           Kl_Char,  "*PyString_AS_STRING ( PyList_GET_ITEM ( {L1}, {L2} ) )", ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("BINARY_SUBSCR_Int",  Kl_List, None,      Kl_Cardinal, None,           Kl_String,"PyList_GET_ITEM ( {L1}, {L2} )", ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("BINARY_SUBSCR_Int",  Kl_List, None,      Kl_Cardinal, None,           Kl_Type,  "PyList_GET_ITEM ( {L1}, {L2} )", ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("BINARY_SUBSCR_Int",  Kl_List, None,      Kl_Cardinal, None,           Kl_O,    ["{LR} = PyList_GET_ITEM ( {L1}, {L2} );",
                                                                                  "Py_INCREF({LR});",
                                                                                  "{LR}"], ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
#("BINARY_SUBSCR_Int",  Kl_List, None,      Kl_Cardinal, None,           Kl_List,  "PyList_GET_ITEM ( {L1}, {L2} )", ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),

("BINARY_SUBSCR_Int",  Kl_List, None,      (int, (-MInt, -1)), None,  Kl_Int,   "PyInt_AS_LONG( PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} ) )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("BINARY_SUBSCR_Int",  Kl_List, None,      (int, (-MInt, -1)), None,  Kl_Float, "PyFloat_AS_DOUBLE( PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} ) )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("BINARY_SUBSCR_Int",  Kl_List, None,      (int, (-MInt, -1)), None,  Kl_Char,  "*PyString_AS_STRING ( PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} ) )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
#("BINARY_SUBSCR_Int",  Kl_List, None,      (int, (-MInt, -1)), None,  Kl_String,"PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("BINARY_SUBSCR_Int",  Kl_List, None,      (int, (-MInt, -1)), None,  Kl_Type,  "PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("BINARY_SUBSCR_Int",  Kl_List, None,      (int, (-MInt, -1)), None,  Kl_O,     "PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
#("BINARY_SUBSCR_Int",  Kl_List, None,      (int, (-MInt, -1)), None,  Kl_List,  "PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),

("BINARY_SUBSCR_Int",  Kl_NewInst, ArgIsDerivedFromList,      Kl_Cardinal, None,           Kl_String, "PyList_GET_ITEM ( {L1}, {L2} )", ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("BINARY_SUBSCR_Int",  Kl_NewInst, ArgIsDerivedFromList,      (int, (-MInt, -1)), None,  Kl_String, "PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),

("BINARY_SUBSCR_Int",  Kl_List, None, Kl_Int, None,                             Kl_O, ["{LI} = {L2};",
                                                                                   "if ({LI} < 0) {LI} += PyList_GET_SIZE({L1});",
                                                                                   "if ({LI} < 0 || {LI} >= PyList_GET_SIZE({L1})) goto {LE};",
                                                                                   "{LR} = PyList_GET_ITEM ( {L1}, {LI} );",
                                                                                   "Py_INCREF({LR});",
                                                                                  "{LR}"], None, (None, 'PyErr_SetString(PyExc_IndexError, "list index out of range");')),

("BINARY_SUBSCR_Int",  Kl_Undefined, None,     Kl_Cardinal, ArgIsConst_,     Kl_Int, ["if (({LR} = _c_BINARY_SUBSCR_Int ( {L1} , {L2} , O{L2} )) == 0) goto L0;",
                                                                                     "PyInt_AS_LONG( {LR} )"], '_c_BINARY_SUBSCR_Int'),
("BINARY_SUBSCR_Int",  Kl_Undefined, None,     Kl_Int, ArgIsConst_,       Kl_String, ["if (({LR} = _c_BINARY_SUBSCR_Int ( {L1} , {L2} , O{L2} )) == 0) goto L0;",
                                                                                     "{LR}"], '_c_BINARY_SUBSCR_Int'),
("BINARY_SUBSCR_Int",  Kl_Undefined, None,     Kl_Int, ArgIsConst_,     Kl_O, ["if (({LR} = _c_BINARY_SUBSCR_Int ( {L1} , {L2} , O{L2} )) == 0) goto L0;",
                                                                                     "{LR}"], '_c_BINARY_SUBSCR_Int'),
("BINARY_SUBSCR_Int",  Kl_Undefined, None,     Kl_Int, None,           Kl_O, ["if (({LR} = __c_BINARY_SUBSCR_Int ( {L1} , {L2} )) == 0) goto L0;",
                                                                                     "{LR}"], '__c_BINARY_SUBSCR_Int'),
("BINARY_SUBSCR_Int",  Kl_Dict, None,     Kl_Int, ArgIsConst_,     Kl_String, ["if (({LR} = PyDict_GetItem ( {L1} , O{L2} )) == 0) goto L0;",
                                                                               "Py_INCREF({LR});",                                                                               
                                                                               "{LR}"]), 
("BINARY_SUBSCR_Int",  Kl_Dict, None,     Kl_Int, ArgIsConst_,  Kl_O,         ["if (({LR} = PyDict_GetItem ( {L1} , O{L2} )) == 0) goto L0;",
                                                                               "Py_INCREF({LR});",                                                                               
                                                                               "{LR}"]), 
("PyDict_GetItem",     Kl_Dict, None,     Kl_O, ArgIsConst_,    Kl_Undefined, ["if (({LR} = PyDict_GetItem ( {L1} , {L2} )) == 0) goto L0;",
                                                                               "Py_INCREF({LR});",                                                                               
                                                                               "{LR}"]), 
("from_ceval_BINARY_SUBSCR", Kl_Dict, None,     Kl_O, None,     Kl_O,         ["if (({LR} = PyDict_GetItem ( {L1} , {L2} )) == 0) goto L0;",
                                                                               "Py_INCREF({LR});",                                                                               
                                                                               "{LR}"]), 
("from_ceval_BINARY_SUBSCR", Kl_Dict, None,     Kl_O, None,     Kl_Float,     ["if (({LR} = PyDict_GetItem ( {L1} , {L2} )) == 0) goto L0;",
                                                                               "Py_INCREF({LR});",                                                                               
                                                                               "PyFloat_AS_DOUBLE( {LR} )"]), 
("from_ceval_BINARY_SUBSCR", Kl_Dict, None,     Kl_O, None,     Kl_Int,       ["if (({LR} = PyDict_GetItem ( {L1} , {L2} )) == 0) goto L0;",
                                                                               "Py_INCREF({LR});",                                                                               
                                                                               "PyInt_AS_LONG( {LR} )"]), 
("from_ceval_BINARY_SUBSCR", Kl_Dict, None,     Kl_C, None,     Kl_Undefined, ["if (({LR} = PyDict_GetItem ( {L1} , O{L2} )) == 0) goto L0;",
                                                                               "Py_INCREF({LR});",                                                                               
                                                                               "{LR}"]), 


("from_ceval_BINARY_SUBSCR",  Kl_NewInst, ArgIsDerivedFromList,      Kl_Cardinal, None,               Kl_O, "PyList_GET_ITEM ( {L1}, {L2} )", ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("from_ceval_BINARY_SUBSCR",  Kl_NewInst, ArgIsDerivedFromList,      (int, (-MInt, -1)), None,  Kl_O, "PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("BINARY_SUBSCR_Int",         Kl_NewInst, ArgIsDerivedFromList,      Kl_Cardinal, None,               Kl_O, "PyList_GET_ITEM ( {L1}, {L2} )", ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("BINARY_SUBSCR_Int",         Kl_NewInst, ArgIsDerivedFromList,      (int, (-MInt, -1)), None,  Kl_O, "PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),

 
("BINARY_SUBSCR_Int",  Kl_Char, None,     Int(-1,0), None,              Kl_Char, "{L1}"),
("BINARY_SUBSCR_Int",  Kl_Char, None,     Kl_Int, None,                 Kl_Char, "{L1}", ('{L2} == -1 || {L2} == 0', 'PyErr_SetString(PyExc_IndexError, "string index out of range")')),
("BINARY_SUBSCR_Int",  Kl_String, None,   Int(0,0), None,               Kl_Char, "*PyString_AS_STRING({L1})", ('PyString_GET_SIZE({L1}) == 0', 'PyErr_SetString(PyExc_IndexError, "string index out of range")')),
("BINARY_SUBSCR_Int",  Kl_String, None,   Int(-1,-1), None,             Kl_Char, "PyString_AS_STRING({L1})[PyString_GET_SIZE({L1})-1]", ('PyString_GET_SIZE({L1}) == 0', 'PyErr_SetString(PyExc_IndexError, "string index out of range")')),
("BINARY_SUBSCR_Int",  Kl_String, None,   Kl_Cardinal, None,            Kl_Char, "PyString_AS_STRING({L1})[{L2}]", ('PyString_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "string index out of range")')),

("from_ceval_BINARY_SUBSCR",  Kl_List, None,      Kl_Cardinal, None,               Kl_String, "PyList_GET_ITEM ( {L1}, {L2} )", ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("from_ceval_BINARY_SUBSCR",  Kl_List, None,      (int, (-MInt, -1)), None,  Kl_String, "PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),

("from_ceval_BINARY_SUBSCR",  Kl_List, None,      Kl_Cardinal, None,               Kl_Type, "PyList_GET_ITEM ( {L1}, {L2} )", ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("from_ceval_BINARY_SUBSCR",  Kl_List, None,      (int, (-MInt, -1)), None,  Kl_Type, "PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),

("from_ceval_BINARY_SUBSCR",  Kl_List, None,      Kl_Cardinal, None,               Kl_Tuple, "PyList_GET_ITEM ( {L1}, {L2} )", ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("from_ceval_BINARY_SUBSCR",  Kl_List, None,      (int, (-MInt, -1)), None,  Kl_Tuple, "PyList_GET_ITEM ( {L1}, PyList_GET_SIZE({L1}) + {L2} )", ('({L2} + PyList_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),

("from_ceval_BINARY_SUBSCR",  Kl_List, None,      Kl_Cardinal, None,           Kl_O,    ["{LR} = PyList_GET_ITEM ( {L1}, {L2} );",
                                                                                  "Py_INCREF({LR});",
                                                                                  "{LR}"], ('PyList_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("from_ceval_BINARY_SUBSCR",  Kl_List, None,      Kl_Int, None,             Kl_O, ["{LI} = {L2};",
                                                                                   "if ({LI} < 0) {LI} += PyList_GET_SIZE({L1});",
                                                                                   "if ({LI} < 0 || {LI} >= PyList_GET_SIZE({L1})) goto {LE};",
                                                                                   "{LR} = PyList_GET_ITEM ( {L1}, {LI} );",
                                                                                  "Py_INCREF({LR});",
                                                                                  "{LR}"], None, (None, 'PyErr_SetString(PyExc_IndexError, "list index out of range");')),
("from_ceval_BINARY_SUBSCR",  Kl_NewInst, ArgIsDerivedFromList, Kl_Undefined, None,       Kl_O, ["if (PyInt_CheckExact({L2})) {",
                                                                                   "{LI} = PyInt_AS_LONG({L2});",
                                                                                   "if ({LI} < 0) {LI} += PyList_GET_SIZE({L1});",
                                                                                   "if ({LI} < 0 || {LI} >= PyList_GET_SIZE({L1})) goto {LE};",
                                                                                   "{LR} = PyList_GET_ITEM ( {L1}, {LI} );",
                                                                                  "Py_INCREF({LR});",
                                                                                  "} else {",
                                                                                  "if (({LR} = PyObject_GetItem ( {L1} , {L2} )) == 0) goto L0;",
                                                                                  "}",
                                                                                  "{LR}"], None, (None, 'PyErr_SetString(PyExc_IndexError, "list index out of range");')),

("from_ceval_BINARY_SUBSCR",  Kl_List, None,      Kl_Undefined, None,       Kl_O, ["if (PyInt_CheckExact({L2})) {",
                                                                                   "{LI} = PyInt_AS_LONG({L2});",
                                                                                   "if ({LI} < 0) {LI} += PyList_GET_SIZE({L1});",
                                                                                   "if ({LI} < 0 || {LI} >= PyList_GET_SIZE({L1})) goto {LE};",
                                                                                   "{LR} = PyList_GET_ITEM ( {L1}, {LI} );",
                                                                                  "Py_INCREF({LR});",
                                                                                  "} else {",
                                                                                  "if (({LR} = PyObject_GetItem ( {L1} , {L2} )) == 0) goto L0;",
                                                                                  "}",
                                                                                  "{LR}"], None, (None, 'PyErr_SetString(PyExc_IndexError, "list index out of range");')),
("from_ceval_BINARY_SUBSCR",  Kl_NewInst, ArgIsDerivedFromList, Kl_Int, None, Kl_O, ["{LI} = {L2};",
                                                                                   "if ({LI} < 0) {LI} += PyList_GET_SIZE({L1});",
                                                                                   "if ({LI} < 0 || {LI} >= PyList_GET_SIZE({L1})) goto {LE};",
                                                                                   "{LR} = PyList_GET_ITEM ( {L1}, {LI} );",
                                                                                   "Py_INCREF({LR});",
                                                                                  "{LR}"], None, (None, 'PyErr_SetString(PyExc_IndexError, "list index out of range");')),

("from_ceval_BINARY_SUBSCR",  Kl_NewInst, ArgIsDerivedFromList, Kl_IntUndefSize, None, Kl_O, ["if (PyInt_CheckExact({L2})) {",
                                                                                   "{LI} = PyInt_AS_LONG({L2});",
                                                                                   "if ({LI} < 0) {LI} += PyList_GET_SIZE({L1});",
                                                                                   "if ({LI} < 0 || {LI} >= PyList_GET_SIZE({L1})) goto {LE};",
                                                                                   "{LR} = PyList_GET_ITEM ( {L1}, {LI} );",
                                                                                  "Py_INCREF({LR});",
                                                                                  "} else {",
                                                                                  "if (({LR} = PyObject_GetItem ( {L1} , {L2} )) == 0) goto L0;",
                                                                                  "}",
                                                                                  "{LR}"], None, (None, 'PyErr_SetString(PyExc_IndexError, "list index out of range");')),

("from_ceval_BINARY_SUBSCR",  Kl_List, None,      Kl_IntUndefSize, None,       Kl_O, ["if (PyInt_CheckExact({L2})) {",
                                                                                   "{LI} = PyInt_AS_LONG({L2});",
                                                                                   "if ({LI} < 0) {LI} += PyList_GET_SIZE({L1});",
                                                                                   "if ({LI} < 0 || {LI} >= PyList_GET_SIZE({L1})) goto {LE};",
                                                                                   "{LR} = PyList_GET_ITEM ( {L1}, {LI} );",
                                                                                  "Py_INCREF({LR});",
                                                                                  "} else {",
                                                                                  "if (({LR} = PyObject_GetItem ( {L1} , {L2} )) == 0) goto L0;",
                                                                                  "}",
                                                                                  "{LR}"], None, (None, 'PyErr_SetString(PyExc_IndexError, "list index out of range");')),

("from_ceval_BINARY_SUBSCR",  Kl_Tuple, None,      Kl_Cardinal, None,               Kl_String, "PyTuple_GET_ITEM ( {L1}, {L2} )", ('PyTuple_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("from_ceval_BINARY_SUBSCR",  Kl_Tuple, None,      (int, (-MInt, -1)), None,  Kl_String, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )", ('({L2} + PyTuple_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),

("from_ceval_BINARY_SUBSCR",  Kl_Tuple, None,      Kl_Cardinal, None,               Kl_Type, "PyTuple_GET_ITEM ( {L1}, {L2} )", ('PyTuple_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("from_ceval_BINARY_SUBSCR",  Kl_Tuple, None,      (int, (-MInt, -1)), None,  Kl_Type, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )", ('({L2} + PyTuple_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),

("from_ceval_BINARY_SUBSCR",  Kl_Tuple, None,      Kl_Cardinal, None,               Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, {L2} )", ('PyTuple_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),
("from_ceval_BINARY_SUBSCR",  Kl_Tuple, None,      (int, (-MInt, -1)), None,  Kl_Tuple, "PyTuple_GET_ITEM ( {L1}, PyTuple_GET_SIZE({L1}) + {L2} )", ('({L2} + PyTuple_GET_SIZE({L1})) >= 0', 'PyErr_SetString(PyExc_IndexError, "list index out of range")')),

("from_ceval_BINARY_SUBSCR",  Kl_Tuple, None,     Kl_Cardinal, None,           Kl_O,    ["{LR} = PyTuple_GET_ITEM ( {L1}, {L2} );",
                                                                                  "Py_INCREF({LR});",
                                                                                  "{LR}"], ('PyTuple_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "tuple index out of range")')),
("from_ceval_BINARY_SUBSCR",  Kl_Tuple, None,      Kl_Undefined, None,       Kl_O, ["if (PyInt_CheckExact({L2})) {",
                                                                                   "{LI} = PyInt_AS_LONG({L2});",
                                                                                   "if ({LI} < 0) {LI} += PyTuple_GET_SIZE({L1});",
                                                                                   "if ({LI} < 0 || {LI} >= PyTuple_GET_SIZE({L1})) goto {LE};",
                                                                                   "{LR} = PyTuple_GET_ITEM ( {L1}, {LI} );",
                                                                                  "Py_INCREF({LR});",
                                                                                  "} else {",
                                                                                  "if (({LR} = PyObject_GetItem ( {L1} , {L2} )) == 0) goto L0;",
                                                                                  "}",
                                                                                  "{LR}"], None, (None, 'PyErr_SetString(PyExc_IndexError, "list index out of range");')),
("from_ceval_BINARY_SUBSCR",  Kl_Tuple, None,      Kl_IntUndefSize, None,       Kl_O, ["if (PyInt_CheckExact({L2})) {",
                                                                                   "{LI} = PyInt_AS_LONG({L2});",
                                                                                   "if ({LI} < 0) {LI} += PyTuple_GET_SIZE({L1});",
                                                                                   "if ({LI} < 0 || {LI} >= PyTuple_GET_SIZE({L1})) goto {LE};",
                                                                                   "{LR} = PyTuple_GET_ITEM ( {L1}, {LI} );",
                                                                                  "Py_INCREF({LR});",
                                                                                  "} else {",
                                                                                  "if (({LR} = PyObject_GetItem ( {L1} , {L2} )) == 0) goto L0;",
                                                                                  "}",
                                                                                  "{LR}"], None, (None, 'PyErr_SetString(PyExc_IndexError, "list index out of range");')),

("from_ceval_BINARY_SUBSCR", Kl_String, None, Int(0,0), None,           Kl_Char, "*PyString_AS_STRING({L1})", ('PyString_GET_SIZE({L1}) == 0', 'PyErr_SetString(PyExc_IndexError, "string index out of range")')),
("from_ceval_BINARY_SUBSCR", Kl_String, None, Int(-1,-1), None,         Kl_Char, "PyString_AS_STRING({L1})[PyString_GET_SIZE({L1})-1]", ('PyString_GET_SIZE({L1}) == 0', 'PyErr_SetString(PyExc_IndexError, "string index out of range")')),
("from_ceval_BINARY_SUBSCR", Kl_String, None, Int((-MInt)-1,-1), None,  Kl_Char, "PyString_AS_STRING({L1})[PyString_GET_SIZE({L1})+{L2}]", ('(PyString_GET_SIZE({L1}) + {L2}) <= 0', 'PyErr_SetString(PyExc_IndexError, "string index out of range")')),
("from_ceval_BINARY_SUBSCR", Kl_String, None, Kl_Cardinal, None,        Kl_Char, "PyString_AS_STRING({L1})[{L2}]", ('PyString_GET_SIZE({L1}) < {L2}', 'PyErr_SetString(PyExc_IndexError, "string index out of range")')),
("from_ceval_BINARY_SUBSCR", Kl_String, None, Kl_Int, None,             Kl_Char,"PyString_AS_STRING({L1})[PyIF({L2} >= 0,{L2},PyString_GET_SIZE({L1})+{L2})]", ('((PyString_GET_SIZE({L1}) > {L2}) && ({L2} >= -PyString_GET_SIZE({L1})))', 'PyErr_SetString(PyExc_IndexError, "string index out of range")')),

("from_ceval_BINARY_SUBSCR",  Kl_Undefined, None,     Kl_Int, None,     Kl_O, ["if (({LR} = __c_BINARY_SUBSCR_Int ( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"], '__c_BINARY_SUBSCR_Int'),
("from_ceval_BINARY_SUBSCR",  Kl_Undefined, None, Kl_IntUndefSize, None,Kl_String, ["if (PyInt_CheckExact({L2})) {",
                                                                                    "if (({LR} = _c_BINARY_SUBSCR_Int ( {L1} , PyInt_AS_LONG({L2}) , {L2} )) == 0) goto L0;",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyObject_GetItem ( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"], '_c_BINARY_SUBSCR_Int'),
("from_ceval_BINARY_SUBSCR",  Kl_Undefined, None,     Kl_O, None, Kl_O, ["if (({LR} = PyObject_GetItem ( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
('PySequence_GetSlice', [(Kl_Undefined, None), (Kl_Cardinal, None), ((int, (sys.maxsize, sys.maxsize)), None)], Kl_O, ["if (({LR} = Py2C_GetSlice( {L1} , {L2} , PY_SSIZE_T_MAX )) == 0) goto L0;",
                                                                                              "{LR}"], 'Py2C_GetSlice'),
('PySequence_GetSlice', [(Kl_Undefined, None), (Kl_Cardinal, None), (Kl_Cardinal, None)], Kl_O, ["if (({LR} = Py2C_GetSlice( {L1} , {L2} , {L3} )) == 0) goto L0;",
                                                                                              "{LR}"], 'Py2C_GetSlice'),
('PySequence_GetSlice', [(Kl_Undefined, None), (Kl_Cardinal, None), ((int,(-sys.maxsize,-1)), None)], Kl_Undefined, ["if (({LR} = PySequence_GetSlice( {L1} , {L2} , {L3} )) == 0) goto L0;",
                                                                                              "{LR}"]),

('PySequence_GetSlice', [(Kl_String, None), ((int, (0,0)), ArgIsConst_), ((int, (sys.maxsize, sys.maxsize)), ArgIsConst_)], Kl_String, "{L1}"),
('PySequence_GetSlice', [(Kl_String, None), (Kl_Cardinal, ArgIsConst_), ((int, (sys.maxsize, sys.maxsize)), ArgIsConst_)], Kl_String, 
                                                                                               ["if ({L2} >= PyString_GET_SIZE({L1})) {",
                                                                                                "if (({LR} = PyString_FromStringAndSize(NULL, 0)) == 0) goto L0;",
                                                                                                "} else {",
                                                                                                "if (({LR} = PyString_FromStringAndSize(PyString_AS_STRING({L1})+{L2}, PyString_GET_SIZE({L1}) - {L2})) == 0) goto L0;",
                                                                                                "}",                                                                                                
                                                                                               "{LR}"]),
('PySequence_GetSlice', [(Kl_String, None), (Kl_Cardinal, ArgIsConst_), ((int, (-sys.maxsize, -1)), ArgIsConst_)], Kl_String, 
                                                                                               ["if ({L2} >= (PyString_GET_SIZE({L1})+{L3})) {",
                                                                                                "if (({LR} = PyString_FromStringAndSize(NULL, 0)) == 0) goto L0;",
                                                                                                "} else {",
                                                                                                "if (({LR} = PyString_FromStringAndSize(PyString_AS_STRING({L1})+{L2}, ( PyString_GET_SIZE({L1}) + {L3} ) - {L2})) == 0) goto L0;",
                                                                                                "}",                                                                                                
                                                                                               "{LR}"]),
('PySequence_GetSlice', [(Kl_String, None), ((int,(0,0)), ArgIsConst_), ((int, (1, sys.maxsize)), ArgIsConst_)], Kl_String, 
                                                                                               ["if ({L3} >= PyString_GET_SIZE({L1})) {",
                                                                                                "{LR} = {L1};",
                                                                                                "Py_INCREF({LR});",                                                                                                "} else {",
                                                                                                "if (({LR} = PyString_FromStringAndSize(PyString_AS_STRING({L1}), {L3})) == 0) goto L0;",
                                                                                                "}",                                                                                                
                                                                                               "{LR}"]),
('PySequence_GetSlice', [(Kl_String, None), (Kl_Int, None), (Kl_Int, None)], Kl_String,       ["if (({LR} = _PyString_GetSlice( {L1} , {L2} , {L3} )) == 0) goto L0;",
                                                                                               "{LR}"], "_PyString_GetSlice"),

('PyTuple_GetSlice', [(Kl_Tuple, None), (Kl_Cardinal, None), (Kl_Cardinal, None)], Kl_Tuple, ["if (({LR} = PyTuple_GetSlice( {L1} , {L2} , {L3} )) == 0) goto L0;",
                                                                                              "{LR}"]),
('PyTuple_GetSlice', [(Kl_Tuple, None), (Kl_Cardinal, None), ((int, (-1,-1)), None)], Kl_Tuple, ["if (({LR} = PyTuple_GetSlice( {L1} , {L2} , PyIF( PyTuple_GET_SIZE({L1}) >= 1 , PyTuple_GET_SIZE({L1}) - 1 , 0) )) == 0) goto L0;",
                                                                                              "{LR}"]),
('PyTuple_GetSlice', [(Kl_Tuple, None), (Kl_Cardinal, None), ((int, (-2,-2)), None)], Kl_Tuple, ["if (({LR} = PyTuple_GetSlice( {L1} , {L2} , PyIF( PyTuple_GET_SIZE({L1}) >= 2 , PyTuple_GET_SIZE({L1}) - 2 , 0) )) == 0) goto L0;",
                                                                                              "{LR}"]),
('PyTuple_GetSlice', [(Kl_Tuple, None), ((int, (-2,-2)), None), ((int, (sys.maxsize, sys.maxsize)), None)], Kl_Tuple, ["if (({LR} = PyTuple_GetSlice( {L1} , PyIF( PyTuple_GET_SIZE({L1}) >= 2 , PyTuple_GET_SIZE({L1}) - 2 , 0) , {L3} )) == 0) goto L0;",
                                                                                              "{LR}"]),

('PyList_GetSlice', [(Kl_List, None), (Kl_Cardinal, None), (Kl_Cardinal, None)], Kl_List, ["if (({LR} = PyList_GetSlice( {L1} , {L2} , {L3} )) == 0) goto L0;",
                                                                                              "{LR}"]),
('PyList_GetSlice', [(Kl_List, None), (Kl_Cardinal, None), ((int, (-1,-1)), None)], Kl_List, ["if (({LR} = PyList_GetSlice( {L1} , {L2} , PyIF( PyList_GET_SIZE({L1}) >= 1 , PyList_GET_SIZE({L1}) - 1 , 0) )) == 0) goto L0;",
                                                                                              "{LR}"]),
('PyList_GetSlice', [(Kl_List, None), (Kl_Cardinal, None), ((int, (-2,-2)), None)], Kl_List, ["if (({LR} = PyList_GetSlice( {L1} , {L2} , PyIF( PyList_GET_SIZE({L1}) >= 2 , PyList_GET_SIZE({L1}) - 2 , 0) )) == 0) goto L0;",
                                                                                              "{LR}"]),
('PyList_GetSlice', [(Kl_List, None), ((int, (-2,-2)), None), ((int, (sys.maxsize, sys.maxsize)), None)], Kl_List, ["if (({LR} = PyList_GetSlice( {L1} , PyIF( PyList_GET_SIZE({L1}) >= 2 , PyList_GET_SIZE({L1}) - 2 , 0) , {L3} )) == 0) goto L0;",
                                                                                              "{LR}"]),
                                                                               
('PySequence_GetSlice', [(Kl_O, None), (Kl_Int, None), (Kl_Int, None)], Kl_O,                ["if (({LR} = PySequence_GetSlice( {L1} , {L2} , {L3} )) == 0) goto L0;",
                                                                                               "{LR}"]),
 
("Absolute",           Kl_Float,    None, None,     None,               Kl_Float, "(PyIF( {L1} > 0 , {L1} , -({L1}) ))"),
("Absolute",           Kl_SymmetricInt, None, None, None,               Kl_Cardinal,   "(PyIF( {L1} > 0 , {L1} , -({L1}) ))"),
("Absolute",           Kl_IntUndefSize,None, None,  None,               Kl_IntUndefSize, ["if (({LR} = PyNumber_Absolute( {L1} )) == 0) goto L0;",
                                                                                   "{LR}"]),
("isdigit",            Kl_Char, None,     None, None,                   Kl_Boolean, "isdigit({L1})", "ctype"),
("isalnum",            Kl_Char, None,     None, None,                   Kl_Boolean, "isalnum({L1})", "ctype"),
("isalpha",            Kl_Char, None,     None, None,                   Kl_Boolean, "isalpha({L1})", "ctype"),
("isspace",            Kl_Char, None,     None, None,                   Kl_Boolean, "isspace({L1})", "ctype"),

("isupper",            Kl_Char, None,     None, None,                   Kl_Boolean, "isupper({L1})", "ctype"),
("islower",            Kl_Char, None,     None, None,                   Kl_Boolean, "islower({L1})", "ctype"),

("isdigit",            Kl_String, None,     None, None,                 Kl_Boolean, ["for({LI}=0;{LI} < PyString_GET_SIZE({L1}) && isdigit(PyString_AS_STRING({L1})[{LI}]);{LI}++);", "({LI} == PyString_GET_SIZE({L1}))"], "ctype"),
("isalnum",            Kl_String, None,     None, None,                 Kl_Boolean, ["for({LI}=0;{LI} < PyString_GET_SIZE({L1}) && isalnum(PyString_AS_STRING({L1})[{LI}]);{LI}++);", "({LI} == PyString_GET_SIZE({L1}))"], "ctype"),
("isalpha",            Kl_String, None,     None, None,                 Kl_Boolean, ["for({LI}=0;{LI} < PyString_GET_SIZE({L1}) && isalpha(PyString_AS_STRING({L1})[{LI}]);{LI}++);", "({LI} == PyString_GET_SIZE({L1}))"], "ctype"),
("isspace",            Kl_String, None,     None, None,                 Kl_Boolean, ["for({LI}=0;{LI} < PyString_GET_SIZE({L1}) && isspace(PyString_AS_STRING({L1})[{LI}]);{LI}++);", "({LI} == PyString_GET_SIZE({L1}))"], "ctype"),


("Add",                Int(0,0), None, Kl_Int, None,  Kl_Int,   "({L2})"),
("Add",                Kl_Int, None, Int(0,0), None,  Kl_Int,   "({L1})"),
("Add",                Int((-MInt)-1,MInt-1), None, Int(1,1), Kl_Int,  Kl_Int,   "({L1} + 1)"),
("Add",                Int(1,1), None, Int((-MInt)-1,MInt-1), None,  Kl_Int,   "(1 + {L2})"),
("Add",                Int((-MInt)-1,MInt-1), None, Int(0,1), Kl_Int,  Kl_Int,   "({L1} + {L2})"),
("Add",                Int(0,1), None, Int((-MInt)-1,MInt-1), None,  Kl_Int,   "({L1} + {L2})"),
("Add",                Int((-MInt)-1,MInt-1), None, Kl_Boolean, Kl_Int,  Kl_Int,   "({L1} + {L2})"),
("Add",                Kl_Boolean, None, Int((-MInt)-1,MInt-1), None,  Kl_Int,   "({L1} + {L2})"),
("Add",                Kl_Boolean,  None, Kl_Boolean, None,             Int(0,2),   "({L1} + {L2})"),
("Add",                Kl_Boolean,  None, Kl_Short, None,               Kl_Int,   "({L1} + {L2})"),
("Add",                Kl_Float,    None, Kl_Float, None,               Kl_Float, "({L1} + {L2})"),
("Add",                Kl_Float,    None, Kl_Int,   None,               Kl_Float, "({L1} + (double){L2})"),
("Add",                Kl_Int,      None, Kl_Float, None,               Kl_Float, "((double){L1} + {L2})"),
("Add",                Kl_Short,    None, Kl_Boolean,  None,            Kl_Int,   "({L1} + {L2})"),
("Add",                Kl_Short,    None, Kl_Short, None,               Kl_Int,   "({L1} + {L2})"),
("Add",                Int(-MInt/2,MInt/2), None, Int(-MInt/2,MInt/2), None,  Kl_SymmetricInt,   "({L1} + {L2})"),
("Add",                Int(0,MInt-MInt/2), None, Int(0,MInt/2), None,  Kl_Cardinal,   "({L1} + {L2})"),
("Add",                Int(0,MInt-1000), None, Int(0,1000), None,  Kl_Cardinal,   "({L1} + {L2})"),
("Add",                Int(0,1000), None, Int(0,MInt-1000), None,  Kl_Cardinal,   "({L1} + {L2})"),
("Add",                Int(-1,MInt-1), None, Int(1,1), None,       Kl_Cardinal, "({L1} + {L2})"),
("Add",                Int((-MInt)-1,MInt-1), None, Int(1,1), None,  Kl_Int, "({L1} + {L2})"),
("Add",                Int((-MInt)-1,0), None, Int(0,MInt), None,  Kl_Int,   "({L1} + {L2})"),
("Add",                Kl_Int,  None, Kl_Int, None,                      Kl_Int,   "({L1} + {L2})"),

("Add",                Kl_Int, None,      (int, (1,1)), ArgIsConst_,     Kl_IntUndefSize, ["if ({L1} < LONG_MAX) {",
                                                                                    "{LR} = PyInt_FromLong ( {L1} + 1 );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_add( O{L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),

("Add",                Kl_Int, None,      Kl_Cardinal, None,      Kl_IntUndefSize, ["if ({L1} <= (LONG_MAX - {L2})) {",
                                                                                    "{LR} = PyInt_FromLong ( {L1} + {L2} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_add( O{L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("Add",                Kl_Int, None,      Kl_Boolean, None,      Kl_IntUndefSize, ["if ({L1} <= (LONG_MAX - {L2})) {",
                                                                                    "{LR} = PyInt_FromLong ( {L1} + {L2} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_add( O{L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),

("Add",                Kl_Cardinal, None,      Kl_Int, None,      Kl_IntUndefSize, ["if ({L2} <= (LONG_MAX - {L1})) {",
                                                                                    "{LR} = PyInt_FromLong ( {L1} + {L2} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_add( O{L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("Add",                Kl_Cardinal, None,      Kl_Undefined, None,   Kl_Undefined, ["if (PyInt_CheckExact({L2}) && PyInt_AS_LONG({L2}) <= (LONG_MAX - {L1})) {",
                                                                                    "{LR} = PyInt_FromLong ( {L1} + PyInt_AS_LONG({L2}) );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_add( O{L1} , {L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),

("Add",                Kl_Int, None,      Kl_Int, None,            Kl_IntUndefSize, ["{LI} = (long)((unsigned long){L1} + {L2});",
                                                                                     "if (({LI}^{L1}) >= 0 || ({LI}^{L2}) >= 0) {",
                                                                                    "{LR} = PyInt_FromLong ( {LI} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_add( O{L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("Add",                Kl_Int, None,      Kl_Undefined, None,        Kl_Undefined, ["if (PyInt_CheckExact({L2}) && (({LI} = (long)((unsigned long){L1} + PyInt_AS_LONG({L2}))), (({LI}^{L1}) >= 0 || ({LI}^PyInt_AS_LONG({L2})) >= 0))) {",
                                                                                    "{LR} = PyInt_FromLong ( {LI} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_Add( O{L1} , {L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
                                                                                   

("Add",                Kl_IntUndefSize, None, (int, (1,1)),ArgIsConst_, Kl_IntUndefSize, ["if (PyInt_CheckExact({L1}) && PyInt_AS_LONG({L1}) < LONG_MAX) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) + 1 );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_add( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("Add",                Kl_Undefined, None, (int, (1,1)),ArgIsConst_, Kl_Undefined, ["if (PyInt_CheckExact({L1}) && PyInt_AS_LONG({L1}) < LONG_MAX) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) + 1 );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_Add( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("Add",                Kl_IntUndefSize, None, Kl_Cardinal,None,   Kl_IntUndefSize, ["if (PyInt_CheckExact({L1}) && PyInt_AS_LONG({L1}) <= (LONG_MAX - {L2})) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) + {L2} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_add( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("Add",                Kl_Cardinal, None, Kl_IntUndefSize,None,   Kl_IntUndefSize, ["if (PyInt_CheckExact({L2}) && PyInt_AS_LONG({L2}) <= (LONG_MAX - {L1})) {",
                                                                                    "{LR} = PyInt_FromLong ( {L1} + PyInt_AS_LONG({L2}) );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_add( O{L1} , {L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("InPlaceAdd",         Kl_IntUndefSize, None, Kl_Cardinal,None,   Kl_IntUndefSize, ["if (PyInt_CheckExact({L1}) && PyInt_AS_LONG({L1}) <= (LONG_MAX - {L2})) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) + {L2} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_inplace_add( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("InPlaceAdd",         Kl_Cardinal, None, Kl_IntUndefSize,None,   Kl_IntUndefSize, ["if (PyInt_CheckExact({L2}) && PyInt_AS_LONG({L2}) <= (LONG_MAX - {L1})) {",
                                                                                    "{LR} = PyInt_FromLong ( {L1} + PyInt_AS_LONG({L2}) );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_inplace_add( O{L1} , {L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("Add",                Kl_Undefined, None, Kl_Cardinal,None,          Kl_Undefined, ["if (PyInt_CheckExact({L1}) && PyInt_AS_LONG({L1}) <= (LONG_MAX - {L2})) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) + {L2} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_Add( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("InPlaceAdd",         Kl_Undefined, None, Kl_Cardinal,None,          Kl_Undefined, ["if (PyInt_CheckExact({L1}) && PyInt_AS_LONG({L1}) <= (LONG_MAX - {L2})) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) + {L2} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_InPlaceAdd( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("Add",                Kl_Undefined, None,      Kl_Int, None,         Kl_Undefined, ["if (PyInt_CheckExact({L1}) && (({LI} = (long)((unsigned long)PyInt_AS_LONG({L1}) + {L2})),(({LI}^PyInt_AS_LONG({L1})) >= 0 || ({LI}^{L2}) >= 0))) {",
                                                                                    "{LR} = PyInt_FromLong ( {LI} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_Add( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("InPlaceAdd",         Kl_Undefined, None,      Kl_Int, None,         Kl_Undefined, ["if (PyInt_CheckExact({L1}) && (({LI} = (long)((unsigned long)PyInt_AS_LONG({L1}) + {L2})),(({LI}^PyInt_AS_LONG({L1})) >= 0 || ({LI}^{L2}) >= 0))) {",
                                                                                    "{LR} = PyInt_FromLong ( {LI} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_InPlaceAdd( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),

("Add",                  Kl_Char, None,  Kl_String, None,              Kl_String,  ["if (({LR} = PyString_FromStringAndSize(NULL, 1 + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "*PyString_AS_STRING( {LR} ) = {L1};",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + 1, PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "{LR}"]),
("Add",                 Kl_String, None,  Kl_Char, None,              Kl_String,  ["if (({LR} = PyString_FromStringAndSize(NULL, 1 + PyString_GET_SIZE( {L1} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "PyString_AS_STRING( {LR} )[PyString_GET_SIZE( {L1} )] = {L2};",
                                                                                   "{LR}"]),
("Add",                  Kl_Char, None,  Kl_O, None,                  Kl_String,  ["if (PyString_CheckExact( {L2} )) {",
                                                                                   "if (({LR} = PyString_FromStringAndSize(NULL, 1 + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "*PyString_AS_STRING( {LR} ) = {L1};",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + 1, PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_Add(O{L1}, {L2})) == 0) goto L0;",
                                                                                   "}",
                                                                                   "{LR}"]),
("Add",                 Kl_O, None,  Kl_Char, None,                   Kl_String,  ["if (PyString_CheckExact( {L1} )) {",
                                                                                   "if (({LR} = PyString_FromStringAndSize(NULL, 1 + PyString_GET_SIZE( {L1} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "PyString_AS_STRING( {LR} )[PyString_GET_SIZE( {L1} )] = {L2};",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_Add({L1}, O{L2})) == 0) goto L0;",
                                                                                   "}",
                                                                                   "{LR}"]),
("Add",                 Kl_String, None,  Kl_String, None,              Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + PyString_GET_SIZE( {L1} ), PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "{LR}"]),
("Add",                 Kl_Undefined, None,Kl_Char, None,              Kl_Undefined,["if (PyString_CheckExact( {L1} )) {",
                                                                                   "if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + 1)) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "PyString_AS_STRING( {LR} )[PyString_GET_SIZE( {L1} )] = {L2};",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_Add({L1}, O{L2})) == 0) goto L0;",
                                                                                   "}",
                                                                                   "{LR}"]),

("Add",                 Kl_Undefined, None,Kl_Char, None,                    Kl_O,["if (PyString_CheckExact( {L1} )) {",
                                                                                   "if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + 1)) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "PyString_AS_STRING( {LR} )[PyString_GET_SIZE( {L1} )] = {L2};",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_Add({L1}, O{L2})) == 0) goto L0;",
                                                                                   "}",
                                                                                   "{LR}"]),

("Add",                 Kl_Undefined, None,Kl_String, None,            Kl_Undefined,["if (PyString_CheckExact( {L1} )) {",
                                                                                   "if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + PyString_GET_SIZE( {L1} ), PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "}",
                                                                                   "{LR}"]),

("Add",                 Kl_Undefined, None,Kl_String, None,              Kl_String,["if (PyString_CheckExact( {L1} )) {",
                                                                                   "if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + PyString_GET_SIZE( {L1} ), PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "}",
                                                                                   "{LR}"]),

("InPlaceAdd",          Kl_Undefined, None,Kl_Char, None,             Kl_Undefined,["if (PyString_CheckExact( {L1} )) {",
                                                                                   "if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + 1)) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "PyString_AS_STRING( {LR} )[PyString_GET_SIZE( {L1} )] = {L2};",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_InPlaceAdd({L1}, O{L2})) == 0) goto L0;",
                                                                                   "}",
                                                                                   "{LR}"]),

("InPlaceAdd",          Kl_Undefined, None,Kl_String, None,           Kl_Undefined,["if (PyString_CheckExact( {L1} )) {",
                                                                                   "if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + PyString_GET_SIZE( {L1} ), PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_InPlaceAdd({L1}, {L2})) == 0) goto L0;",
                                                                                   "}",
                                                                                   "{LR}"]),

("Add",                 Kl_Char, None,Kl_Undefined, None,                Kl_String,["if (PyString_CheckExact( {L2} )) {",
                                                                                   "if (({LR} = PyString_FromStringAndSize(NULL, 1 + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "PyString_AS_STRING( {LR} )[0] = {L1};",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + 1, PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_Add(O{L1}, {L2})) == 0) goto L0;",
                                                                                   "}",
                                                                                   "{LR}"]),
("Add",                 Kl_String, None,Kl_Undefined, None,              Kl_String,["if (PyString_CheckExact( {L2} )) {",
                                                                                   "if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + PyString_GET_SIZE( {L1} ), PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "}",
                                                                                   "{LR}"]),
("Add",                 Kl_Char, None,Kl_Undefined, None,             Kl_Undefined,["if (PyString_CheckExact( {L2} )) {",
                                                                                   "if (({LR} = PyString_FromStringAndSize(NULL, 1 + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "PyString_AS_STRING( {LR} )[0] = {L1};",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + 1, PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_Add(O{L1}, {L2})) == 0) goto L0;",
                                                                                   "}",
                                                                                   "{LR}"]),

("Add",                 Kl_String, None,Kl_Undefined, None,           Kl_Undefined,["if (PyString_CheckExact( {L2} )) {",
                                                                                   "if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + PyString_GET_SIZE( {L1} ), PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "}",
                                                                                   "{LR}"]),

("Add",                 Kl_Tuple, None,Kl_O, None,                      Kl_Tuple, ["if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
("Add",                 Kl_Tuple, None,Kl_O, None,                      Kl_Undefined, ["if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
("InPlaceAdd",          Kl_Tuple, None,Kl_O, None,                      Kl_Tuple, ["if (({LR} = PyNumber_InPlaceAdd({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
("InPlaceAdd",          Kl_List, None,Kl_List, None,                    Kl_List, ["if (({LR} = PyNumber_InPlaceAdd({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
("Add",                 Kl_List,  None,Kl_O, None,                      Kl_List,  ["if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
("Add",                 Kl_List,  None,Kl_O, None,                      Kl_Undefined,["if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
("Add",                 Kl_O, None,Kl_Tuple, None,                      Kl_Tuple, ["if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
("Add",                 Kl_O, None,Kl_Tuple, None,                      Kl_Undefined, ["if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
("Add",                 Kl_O,  None,Kl_List, None,                      Kl_List,  ["if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
("Add",                 Kl_O,  None,Kl_List, None,                      Kl_Undefined,["if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
("Add",                 Kl_O,  None,Kl_NewInst, ArgIsDerivedFromList,   Kl_Undefined,["if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
("Add",                 [(Kl_Undefined,  None),(Kl_O, None)],   Kl_Undefined,["if (({LR} = PyNumber_Add({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
("Add",                 Kl_Float,    None, ('MayBe', Kl_Float), None,    Kl_Float, "({L1} + PyFloat_AS_DOUBLE({L2}))", None, ('{L2} == Py_None', 'PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for +: ''float'' and ''NoneType''");')),
("Add",               ('MayBe', Kl_Float), None, Kl_Float, None,         Kl_Float, "(PyFloat_AS_DOUBLE({L1}) + {L2})", None, ('{L1} == Py_None', 'PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for +: ''NoneType'' and ''float''");')),

("Add",                 Kl_Int,    None, ('MayBe', Kl_Int), None,        Kl_Int, "({L1} + PyInt_AS_LONG({L2}))", None, ('{L2} == Py_None', 'PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for +: ''int'' and ''NoneType''");')),
("Add",               ('MayBe', Kl_Int), None, Kl_Int, None,             Kl_Int, "(PyInt_AS_LONG({L1}) + {L2})", None, ('{L1} == Py_None', 'PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for +: ''NoneType'' and ''int''");')),

("Add",                 ('MayBe', Kl_String), None,  Kl_String, None,    Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + PyString_GET_SIZE( {L1} ), PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "{LR}"], None, ('{L1} == Py_None', 'PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for +: ''NoneType'' and ''str''");')),


("InPlaceAdd",          [(Kl_Undefined,  None),(Kl_O, None)],   Kl_Undefined,["if (({LR} = PyNumber_InPlaceAdd({L1}, {L2})) == 0) goto L0;",
                                                                                   "{LR}"]),
                                                                                   

("And",                Kl_Short,    None, Kl_Short, None,               Kl_Short, "({L1} & {L2})"),
("And",                Kl_Int,      None, Kl_Short, None,               Kl_Short, "({L1} & {L2})"),
("And",                Kl_Short,    None, Kl_Int,   None,               Kl_Short, "({L1} & {L2})"),
("And",                Kl_Int,      None, Kl_Int,   None,               Kl_Int,   "({L1} & {L2})"),
("And",                Kl_Int,      None, Kl_Int,   None,               Kl_Boolean, "(({L1} & {L2}) != 0)"),
("And",                Kl_Boolean,  None, Kl_Boolean, None,             Kl_Boolean, "({L1} & {L2})"),
("And",                Kl_Undefined, None,      Kl_Int, None,         Kl_Undefined, ["if (PyInt_CheckExact({L1})) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) & {L2} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_And( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),

("Divide",             Kl_Float,    None, Kl_Float, ArgIsConstNotZero, Kl_Float, "({L1} / {L2})"),
("Divide",             Kl_Int,      None, Kl_Float, ArgIsConstNotZero, Kl_Float, "((double){L1} / {L2})"),

("Divide",             Kl_Float,    None, Int(-MInt,-1),   None, Kl_Float, "({L1} / (double){L2})"),
("Divide",             Kl_Float,    None, Int(1, MInt),    None, Kl_Float, "({L1} / (double){L2})"),

("Divide",             Kl_SymmetricInt, None, Int(-MInt,-1), None, Kl_Int, "_PyInt_Div({L1}, {L2})", "_PyInt_Div"),
("Divide",             Kl_Int,      None, Int(-MInt,-2),   None, Kl_Int,   "_PyInt_Div({L1}, {L2})", "_PyInt_Div"),
("Divide",             Kl_Int,      None, Int(1, MInt),    None, Kl_Int,   "_PyInt_Div({L1}, {L2})", "_PyInt_Div"),

("Divide",             Kl_Float,    None, Kl_Float, None              , Kl_Float, "({L1} / {L2})", ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "float divmod()")')),
("Divide",             Kl_Int,      None, Kl_Float, None              , Kl_Float, "((double){L1} / {L2})", ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "float divmod()")')),
("Divide",             Kl_Float,    None, Kl_Int,   None              , Kl_Float, "({L1} / (double){L2})", ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "float divmod()")')),
("Divide",             Kl_Short,    None, Kl_Int,   None              , Kl_Short, "_PyInt_Div({L1}, {L2})", "_PyInt_Div", ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");')),
("Divide",             Kl_Short,    None, Kl_Short, None              , Kl_Short, "_PyInt_Div({L1}, {L2})", "_PyInt_Div", ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");')),
("Divide",             Kl_SymmetricInt,None, Kl_Int,None              , Kl_Int,   "_PyInt_Div({L1}, {L2})", "_PyInt_Div", ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");')),
("Divide",             Kl_IntUndefSize,None, Kl_Float, None           , Kl_Float, ["if (PyInt_CheckExact( {L1} )) {",
                                                                                   "{LF} = PyInt_AS_LONG( {L1} );",
                                                                                   "} else {",
                                                                                   "{LF} = PyLong_AsDouble( {L1} );",
                                                                                   "if ({LF} == -1.0 && PyErr_Occurred()) goto L0;",
                                                                                   "}",                                                                                  
                                                                                   "({LF} / {L2})"], ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "float divmod()")')),
("Divide",             Kl_Float,None, Kl_IntUndefSize, None           , Kl_Float, ["if (PyInt_CheckExact( {L2} )) {",
                                                                                   "{LF} = PyInt_AS_LONG( {L2} );",
                                                                                   "} else {",
                                                                                   "{LF} = PyLong_AsDouble( {L2} );",
                                                                                   "if ({LF} == -1.0 && PyErr_Occurred()) goto L0;",
                                                                                   "}",                                                                                  
                                                                                   "({L1} / {LF})"], ('{LF} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "float divmod()")')),
("Divide",             Kl_Long,None, Kl_Float, None           ,         Kl_Float, ["{LF} = PyLong_AsDouble( {L1} );",
                                                                                   "if ({LF} == -1.0 && PyErr_Occurred()) goto L0;",
                                                                                   "({LF} / {L2})"], ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "float divmod()")')),
("Divide",             Kl_Float,None, Kl_Long, None           ,         Kl_Float, ["{LF} = PyLong_AsDouble( {L2} );",
                                                                                   "if ({LF} == -1.0 && PyErr_Occurred()) goto L0;",
                                                                                   "({L1} / {LF})"], ('{LF} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "float divmod()")')),
("Divide",             Kl_Undefined,None, Kl_Float, None      ,     Kl_Undefined, ["if (PyInt_CheckExact( {L1} )) {",
                                                                                   "{LF} = PyInt_AS_LONG({L1});",
                                                                                   "{LR} = PyFloat_FromDouble({LF} / {L2});",
                                                                                   "} else if (PyLong_CheckExact( {L1} )){",
                                                                                   "{LF} = PyLong_AsDouble( {L1} );",
                                                                                   "if ({LF} == -1.0 && PyErr_Occurred()) goto L0;",
                                                                                   "{LR} = PyFloat_FromDouble({LF} / {L2});",
                                                                                   "} else {",
                                                                                   "if (({LR} = PyNumber_Divide( {L1} , O{L2} )) == 0) goto L0;",
                                                                                   "}",                                                                                   
                                                                                   "{LR}"], ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "float divmod()")')),
("Divide",             Kl_SymmetricInt,None, Kl_Undefined, None,        Kl_Undefined,["if (PyInt_CheckExact({L2}) && PyInt_AS_LONG({L2}) != 0) {",
                                                                                      "{LR} = PyInt_FromLong(_PyInt_Div({L1}, PyInt_AS_LONG({L2})));",
                                                                                      "} else {",
                                                                                      "if (({LR} = PyNumber_Divide( O{L1} , {L2} )) == 0) goto L0;",
                                                                                      "}",
                                                                                    "{LR}"],"_PyInt_Div"),
("Divide",             Kl_Undefined,None, (int, (1, MInt)), None, Kl_Undefined,["if (PyInt_CheckExact({L1})) {",
                                                                                      "{LR} = PyInt_FromLong(_PyInt_Div(PyInt_AS_LONG({L1}), {L2}));",
                                                                                      "} else {",
                                                                                      "if (({LR} = PyNumber_Divide( {L1} , O{L2} )) == 0) goto L0;",
                                                                                      "}",
                                                                                    "{LR}"],"_PyInt_Div"),
("InPlaceDivide",      Kl_Undefined,None, (int, (1, MInt)), None, Kl_Undefined,["if (PyInt_CheckExact({L1})) {",
                                                                                      "{LR} = PyInt_FromLong(_PyInt_Div(PyInt_AS_LONG({L1}), {L2}));",
                                                                                      "} else {",
                                                                                      "if (({LR} = PyNumber_InPlaceDivide( {L1} , O{L2} )) == 0) goto L0;",
                                                                                      "}",
                                                                                    "{LR}"],"_PyInt_Div"),
("Divide",             Kl_Undefined,None, Kl_Undefined, None,           Kl_Undefined,["if (({LR} = PyNumber_Divide( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               


("Float",              Kl_Boolean,  None, None,     None,               Kl_Float, "((double)({L1} != 0))"),
("Float",              Kl_Float,    None, None,     None,               Kl_Float, "{L1}"),
("Float",              Kl_Int,      None, None,     None,               Kl_Float, "((double){L1})"),
("Float",              Kl_Long,     None, None,     None,               Kl_Float, ["{LF} = PyLong_AsDouble( {L1} );",
                                                                                   "if ({LF} == -1.0 && PyErr_Occurred()) goto L0;",
                                                                                   "{LF}"]),
("Float",              Kl_IntUndefSize,None, None,  None,               Kl_Float, ["if (PyInt_CheckExact( {L1} )) {",
                                                                                   "{LF} = PyInt_AS_LONG( {L1} );",
                                                                                   "} else {",
                                                                                   "{LF} = PyLong_AsDouble( {L1} );",
                                                                                   "if ({LF} == -1.0 && PyErr_Occurred()) goto L0;",
                                                                                   "}",
                                                                                   "{LF}"]),
("Float",              Kl_Undefined,None, None,  None,                  Kl_Float, ["if (({LR} = PyNumber_Float( {L1} )) == 0) goto L0;",
                                                                                   "PyFloat_AS_DOUBLE( {LR} )"]),

("FloorDivide",        Kl_SymmetricInt, None, Int(-MInt,-1), None, Kl_Int, "_PyInt_Div({L1}, {L2})", "_PyInt_Div"),
("FloorDivide",        Kl_Int,      None, Int(-MInt,-2),   None, Kl_Int,   "_PyInt_Div({L1}, {L2})", "_PyInt_Div"),
("FloorDivide",        Kl_Int,      None, Int(1, MInt),    None, Kl_Int,   "_PyInt_Div({L1}, {L2})", "_PyInt_Div"),

("FloorDivide",        Kl_Short,    None, Kl_Int,   None              , Kl_Short, "_PyInt_Div({L1}, {L2})", "_PyInt_Div", ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");')),
("FloorDivide",        Kl_Short,    None, Kl_Short, None              , Kl_Short, "_PyInt_Div({L1}, {L2})", "_PyInt_Div", ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");')),
("FloorDivide",        Kl_SymmetricInt,None, Kl_Int,None              , Kl_Int,   "_PyInt_Div({L1}, {L2})", "_PyInt_Div", ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");')),

("Int",                Kl_Boolean,  None, None,     None,               Kl_Int,    "({L1} != 0)"),
("Int",                Kl_Int,      None, None,     None,               Kl_Int,    "{L1}"),
("Int",                Kl_Short,    None, None,     None,               Kl_Short,  "{L1}"),
("Int",                Kl_Undefined,None, None,  None,                  Kl_IntUndefSize, ["if (({LR} = PyNumber_Int( {L1} )) == 0) goto L0;",
                                                                                   "{LR}"]),
("Int",                Kl_IntUndefSize,None, None,  None,               Kl_IntUndefSize, ["if (({LR} = PyNumber_Int( {L1} )) == 0) goto L0;",
                                                                                   "{LR}"]),
("Int",                Kl_String,None, None,  None,                     Kl_IntUndefSize, ["if (({LR} = PyNumber_Int( {L1} )) == 0) goto L0;",
                                                                                   "{LR}"]),

("Invert",             Kl_Int,      None, None,     None,               Kl_Int,    "(~{L1})"),
("Invert",             Kl_Short,    None, None,     None,               Kl_Int,    "(~{L1})"),

("Lshift",             Int(-MInt, MInt), None, Int(0, 0), None, Kl_Int, "({L1})"),
("Lshift",             Int(-MInt>>1, MInt>>1), None, Int(0, 1), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>2, MInt>>2), None, Int(0, 2), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>3, MInt>>3), None, Int(0, 3), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>4, MInt>>4), None, Int(0, 4), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>5, MInt>>5), None, Int(0, 5), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>6, MInt>>6), None, Int(0, 6), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>7, MInt>>7), None, Int(0, 7), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>8, MInt>>8), None, Int(0, 8), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>9, MInt>>9), None, Int(0, 9), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>10, MInt>>10), None, Int(0, 10), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>11, MInt>>11), None, Int(0, 11), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>12, MInt>>12), None, Int(0, 12), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>13, MInt>>13), None, Int(0, 13), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>14, MInt>>14), None, Int(0, 14), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>15, MInt>>15), None, Int(0, 15), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>16, MInt>>16), None, Int(0, 16), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>17, MInt>>17), None, Int(0, 17), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>18, MInt>>18), None, Int(0, 18), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>19, MInt>>19), None, Int(0, 19), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>20, MInt>>20), None, Int(0, 20), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>21, MInt>>21), None, Int(0, 21), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>22, MInt>>22), None, Int(0, 22), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>23, MInt>>23), None, Int(0, 23), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>24, MInt>>24), None, Int(0, 24), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>25, MInt>>25), None, Int(0, 25), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>26, MInt>>26), None, Int(0, 26), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>27, MInt>>27), None, Int(0, 27), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>28, MInt>>28), None, Int(0, 28), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>29, MInt>>29), None, Int(0, 29), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>30, MInt>>30), None, Int(0, 30), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Int(-MInt>>31, MInt>>31), None, Int(0, 31), None, Kl_Int, "({L1} << {L2})"),
("Lshift",             Kl_Undefined, None, Int(0,1), None, Kl_Undefined, ["if (PyInt_CheckExact({L1}) && PyInt_AS_LONG({L1}) <= (LONG_MAX / 2) && PyInt_AS_LONG({L1}) >= (LONG_MIN / 2)) {",
                                                                          "{LR} = PyInt_FromLong( PyInt_AS_LONG({L1}) << {L2} );",
                                                                          "} else {",
                                                                          "if (({LR} = PyNumber_Lshift( {L1} , O{L2} )) == 0) goto L0;",
                                                                          "}",
                                                                          "{LR}"]),                                                                               
                                                                          

("max",                Kl_Int,      None, Kl_Int,   None,               Kl_Int,   "(PyIF( {L1} > {L2} , {L1} , {L2} ))"),
("min",                Kl_Int,      None, Kl_Int,   None,               Kl_Int,   "(PyIF( {L1} < {L2} , {L1} , {L2} ))"),

("max",                Kl_Float,    None, Kl_Float, None,               Kl_Float, "(PyIF( {L1} > {L2} , {L1} , {L2} ))"),
("min",                Kl_Float,    None, Kl_Float, None,               Kl_Float, "(PyIF( {L1} < {L2} , {L1} , {L2} ))"),

("max",                [(Kl_Int, None), (Kl_Int, None), (Kl_Int, None)],Kl_Int,   ["{LI} = {L1};",
                                                                                   "if ({L2} > {LI}) {LI} = {L2};",
                                                                                   "if ({L3} > {LI}) {LI} = {L3};",
                                                                                   "{LI}"]),
("max",                [(Kl_Int, None), (Kl_Int, None), (Kl_Int, None), (Kl_Int, None)],
                                                                        Kl_Int,   ["{LI} = {L1};",
                                                                                   "if ({L2} > {LI}) {LI} = {L2};",
                                                                                   "if ({L3} > {LI}) {LI} = {L3};",
                                                                                   "if ({L4} > {LI}) {LI} = {L4};",
                                                                                   "{LI}"]),
("min",                Kl_Tuple, None, None, None,                      Kl_O,     ["if (({LR} = _PyTuple_Min({L1})) == 0) goto L0;",
                                                                                   "{LR}"], "_PyTuple_Min"),
("max",                Kl_Tuple, None, None, None,                      Kl_O,     ["if (({LR} = _PyTuple_Max({L1})) == 0) goto L0;",
                                                                                   "{LR}"], "_PyTuple_Max"),
("min",                Kl_List, None, None, None,                      Kl_O,     ["if (({LR} = _PyList_Min({L1})) == 0) goto L0;",
                                                                                   "{LR}"], "_PyList_Min"),
("max",                Kl_List, None, None, None,                      Kl_O,     ["if (({LR} = _PyList_Max({L1})) == 0) goto L0;",
                                                                                   "{LR}"], "_PyList_Max"),

("hex",                [(Kl_Int, None)],                                Kl_String, ["{LR} = PyInt_Type.tp_as_number->nb_hex(O{L1});",
                                                                                    "{LR}"]),
("hex",                [(Kl_Undefined, None)],                          Kl_String, ["if (({LR} = _Py_hex({L1})) == 0) goto L0;",
                                                                                    "{LR}"], '_Py_hex'),
("oct",                [(Kl_Undefined, None)],                          Kl_String, ["if (({LR} = _Py_oct({L1})) == 0) goto L0;",
                                                                                    "{LR}"], '_Py_oct'),
("_PyInt_Format",      [(Kl_Int, None), ((int, (10, 10)), None), ((int, (0, 0)), None)], Kl_String, ["if (({LR} = _PyInt_Format((PyIntObject *)O{L1}, 10, 0)) == 0) goto L0;",
                                                                                    "{LR}"]),

("Multiply",           Int(0, 0), None, Kl_Int, None, Kl_Int, "(0)"),
("Multiply",           Kl_Int, None, Int(0,0), None, Kl_Int, "(0)"),
("Multiply",           Int(1, 1), None, Kl_Int, None, Kl_Int, "({L2})"),
("Multiply",           Kl_Int, None, Int(1,1), None, Kl_Int, "({L1})"),
("Multiply",           Int(-MInt,MInt), None, Int(-1,-1), None, Kl_Int, "({L1} * -1)"),
("Multiply",           Int(-1, -1), None, Int(-MInt,MInt), None, Kl_Int, "(-1 * {L2})"),
("Multiply",           Int(-10, 10), None, Int(-MInt/10, MInt/10), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Int(-16, 16), None, Int(-MInt>>4, MInt>>4), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Int(-2, 2),  None, Int(-MInt>>1, MInt>>1), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Int(-4, 4),  None, Int(-MInt>>2, MInt>>2), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Int(-8, 8),  None, Int(-MInt>>3, MInt>>3), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Int(-MInt/256, MInt/256), None, Int(-256, 256), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Int(-MInt/1000, MInt/1000), None, Int(-1000, 1000), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Int(-MInt/10000, MInt/10000), None, Int(-10000, 10000), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Int(-MInt/10, MInt/10), None, Int(-10, 10), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Int(-MInt>>1, MInt>>1), None, Int(-2, 2), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Int(-MInt>>2, MInt>>2), None, Int(-4, 4), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Int(-MInt>>3, MInt>>3), None, Int(-8, 8), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Int(-MInt>>4, MInt>>4), None, Int(-16, 16), None, Kl_Int, "({L1} * {L2})"),
("Multiply",           Kl_Boolean,  None, Kl_Float, None,             Kl_Float, "({L1} * (double){L2})"),
("Multiply",           Kl_Boolean,  None, Kl_Int,   None,             Kl_Int,   "({L1} * {L2})"),
("Multiply",           Kl_Boolean,  None, Kl_ShortChar, None,                Kl_ShortChar,   "({L1} * {L2})"),
("Multiply",           Kl_Boolean,  None, Kl_Short, None,             Kl_Short,   "({L1} * {L2})"),
("Multiply",           Kl_Boolean,  None, Kl_ShortPlus, None,                Kl_ShortPlus,   "({L1} * {L2})"),
("Multiply",           Kl_Float,    None, Kl_Boolean, None,             Kl_Float, "({L1} * (double){L2})"),
("Multiply",           Kl_Float,    None, Kl_Float, None,               Kl_Float, "({L1} * {L2})"),
("Multiply",           Kl_Float,    None, Kl_Int,   None,               Kl_Float, "({L1} * (double){L2})"),
("Multiply",           Kl_Float,    None, Kl_Short, None,               Kl_Float, "({L1} * (double){L2})"),
("Multiply",           Kl_Int,      None, Kl_Boolean, None,             Kl_Int,   "({L1} * {L2})"),
("Multiply",           Kl_Int,      None, Kl_Float, None,               Kl_Float, "((double){L1} * {L2})"),
("Multiply",           Kl_ShortChar,None, Kl_Boolean, None,             Kl_ShortChar,   "({L1} * {L2})"),
("Multiply",           Kl_ShortChar,None, Kl_ShortPlus, None,           Kl_Int,   "({L1} * {L2})"),
("Multiply",           Kl_Short,    None, Kl_Boolean, None,             Kl_Short,   "({L1} * {L2})"),
("Multiply",           Kl_Short,    None, Kl_Float, None,               Kl_Float, "((double){L1} * {L2})"),
("Multiply",           Kl_Short,    None, Kl_Short, None,               Kl_Int,   "({L1} * {L2})"),
("Multiply",           Kl_ShortPlus, None, Kl_Boolean, None,                Kl_ShortPlus,   "({L1} * {L2})"),
("Multiply",           Kl_Float,None, Kl_IntUndefSize, None           , Kl_Float, ["if (PyInt_CheckExact( {L2} )) {",
                                                                                   "{LF} = PyInt_AS_LONG( {L2} );",
                                                                                   "} else {",
                                                                                   "{LF} = PyLong_AsDouble( {L2} );",
                                                                                   "if ({LF} == -1.0 && PyErr_Occurred()) goto L0;",
                                                                                   "}",                                                                                  
                                                                                   "({L1} * {LF})"]),
("Multiply",           Kl_Int, None, Kl_Char, None,                     Kl_String, ["if (({LR} = PyString_FromStringAndSize(NULL, {L1} )) == 0) goto L0;",
                                                                                   "memset(PyString_AS_STRING( {LR} ), {L2}, {L1} );",
                                                                                   "{LR}"]),
("Multiply",           Kl_Char, None, Kl_Int, None,                     Kl_String, ["if (({LR} = PyString_FromStringAndSize(NULL, {L2} )) == 0) goto L0;",
                                                                                   "memset(PyString_AS_STRING( {LR} ), {L1}, {L2} );",
                                                                                   "{LR}"]),
("Multiply",           Kl_Int, None, Kl_Int, None,                Kl_IntUndefSize, ["{LI} = (long)((unsigned long){L1} * {L2});",
                                                                                    "if ( ((double){LI}) == ( ((double){L1}) * ((double){L2}) ) ) {",
                                                                                    "{LR} = PyInt_FromLong({LI});",
                                                                                    "} else {",
                                                                                    "{LR} = PyInt_Type.tp_as_number->nb_multiply(O{L1}, O{L2});",
                                                                                    "}",
                                                                                    "{LR}"]),
("Multiply",           Int(0, 0), None, Kl_Undefined, None, Kl_Undefined, [ "if (PyInt_CheckExact({L2})) {",
                                                                           "{LR} = PyInt_FromLong(0l);",
                                                                           "} else {",
                                                                           "if (({LR} = PyNumber_Multiply(O{L1}, {L2})) == 0) goto L0;",
                                                                           "}",
                                                                           "{LR}"]),
("Multiply",           Int(1, 1), None, Kl_Undefined, None, Kl_Undefined, [ "if (PyInt_CheckExact({L2})) {",
                                                                           "{LR} = {L2};",
                                                                           "Py_INCREF({LR});",
                                                                           "} else {",
                                                                           "if (({LR} = PyNumber_Multiply(O{L1}, {L2})) == 0) goto L0;",
                                                                           "}",
                                                                           "{LR}"]),
("Multiply",           Kl_Undefined, None,Int(0, 0), None, Kl_Undefined, [ "if (PyInt_CheckExact({L1})) {",
                                                                           "{LR} = PyInt_FromLong(0l);",
                                                                           "} else {",
                                                                           "if (({LR} = PyNumber_Multiply({L1}, O{L2})) == 0) goto L0;",
                                                                           "}",
                                                                           "{LR}"]),
("Multiply",           Kl_Undefined, None,Int(1, 1), None, Kl_Undefined, [ "if (PyInt_CheckExact({L1})) {",
                                                                           "{LR} = {L1};",
                                                                           "Py_INCREF({LR});",
                                                                           "} else {",
                                                                           "if (({LR} = PyNumber_Multiply({L1}, O{L2})) == 0) goto L0;",
                                                                           "}",
                                                                           "{LR}"]),
("Multiply",           Kl_Tuple, None,Kl_Undefined, None, Kl_Undefined, ["if (({LR} = PyNumber_Multiply({L1}, {L2})) == 0) goto L0;",
                                                                           "{LR}"]),

("Negative",           Int(0,MInt),   None, None,     None,    Int(-(MInt), 0),    "(-{L1})"),
("Negative",           Int(-(MInt-1), 0),   None, None,     None, Int(0, MInt-1),    "(-{L1})"),
("Negative",           Int(-(MInt-1), MInt-1),   None, None,   None,  Int(-(MInt-1), MInt-1),    "(-{L1})"),
("Negative",           Kl_Float,    None, None,     None,               Kl_Float,  "(-{L1})"),
("Negative",           Kl_Short,    None, None,     None,               Kl_Short,  "(-{L1})"),
("Negative",           Kl_Cardinal,    None, None,  None,               Kl_Int,  "(-{L1})"),
("Negative",           Kl_Long,None, None, None,                        Kl_Long,["if (({LR} = PyNumber_Negative( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               

("Or",                 Kl_Int,      None, Kl_Int,   None,               Kl_Int,   "({L1} | {L2})"),
("Or",                 Kl_Int,      None, Kl_Short, None,               Kl_Int,   "({L1} | {L2})"),
("Or",                 Kl_Short,    None, Kl_Int,   None,               Kl_Int,   "({L1} | {L2})"),
("Or",                 Kl_Short,    None, Kl_Short, None,               Kl_Short, "({L1} | {L2})"),
("Or",                 Kl_Undefined, None, Kl_Int,None,                 Kl_Undefined, ["if (PyInt_CheckExact({L1})) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) | {L2} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_Or( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("M:truediv",          [(New_Kl_Module('operator'), None), (Kl_O, None), (Kl_O, None)], Kl_O, ["if (({LR} = PyNumber_TrueDivide({L2}, {L3})) == 0) goto L0;",
                                                                           "{LR}"]),


("ord",                Kl_Char,     None, None,     None,               (int, (0, 255)), "((long)(unsigned char){L1})"),
("ord",                Kl_String,   None, None,     None,               (int, (0, 255)), "((long)(unsigned char)*PyString_AS_STRING({L1}))", None, ('PyString_GET_SIZE({L1}) != 1', 'PyErr_Format(PyExc_TypeError, "ord() expected string of length 1, but %d found", (int)PyString_GET_SIZE({L1}));')),
("ord",                Kl_Undefined,None, None,     None,               (int, (0, sys.maxunicode)), ["if (({LI} = _Py2C_ord({L1})) == -1) goto L0;",
                                                                                      "{LI}"], "_Py2C_ord"),

("Positive",           Kl_Float,    None, None,     None,               Kl_Float,  "{L1}"),
("Positive",           Kl_Int,      None, None,     None,               Kl_Int,    "{L1}"),
("Positive",           Kl_Short,    None, None,     None,               Kl_Short,  "{L1}"),

("Power",              Kl_Float,    None, Int(2,2), None,               Kl_Float, "({L1} * {L1})"),
("Power",              Kl_Float,    None, Int(3,3), None,               Kl_Float, "({L1} * {L1} * {L1})"),
("Power",              Kl_Int,      None, Int(2,2), None,               Kl_Int,   "({L1} * {L1})"),
("Power",              Kl_Int,      None, Int(3,3), None,               Kl_Int,   "({L1} * {L1} * {L1})"),
("Power",              Kl_Float,    None, Kl_Float, None,               Kl_Float, "pow({L1}, {L2})" ),
("Power",              Kl_Float,    None, Kl_Cardinal, None,            Kl_Float, "pow({L1}, (double){L2})"),
("Power",              Kl_Int,      None, Kl_Cardinal, None,            Kl_Int,   "_PyInt_Power({L1}, {L2})", "_PyInt_Power"),

("Remainder",          Kl_Cardinal, None, Kl_Cardinal, ArgIsConstNotZero, Kl_Cardinal, "({L1} % {L2})"),
("Remainder",          Kl_Cardinal, None, Kl_Cardinal, None             , Kl_Cardinal,   "({L1} % {L2})", ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");')),
("Remainder",          Kl_Int,      None, Kl_Int,   None                , Kl_Int,   "_PyInt_Mod({L1}, {L2})", "_PyInt_Mod", ('{L2} == 0', 'PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");')),
("Remainder",          Kl_Int,      None, Kl_Undefined,   None          , Kl_Undefined, ["if (PyInt_CheckExact({L2}) && PyInt_AS_LONG({L2}) != 0) {",
                                                                                         "{LR} = PyInt_FromLong(_PyInt_Mod({L1}, PyInt_AS_LONG({L2})));",
                                                                                         "} else {",
                                                                                         "if (({LR} = PyNumber_Remainder( O{L1} , {L2} )) == 0) goto L0;",
                                                                                         "}",
                                                                                         "{LR}"], "_PyInt_Mod"),
("Remainder",          Kl_O,      None, Kl_Undefined,   None          , Kl_Undefined, ["if (({LR} = PyNumber_Remainder( {L1} , {L2} )) == 0) goto L0;",
                                                                                         "{LR}"]),
("Remainder",          Kl_Float,      None, Kl_Undefined,   None      , Kl_Undefined, ["if (({LR} = PyNumber_Remainder( O{L1} , {L2} )) == 0) goto L0;",
                                                                                         "{LR}"]),

("Subtract",           Kl_Float,    None, Kl_Float, None,                Kl_Float, "({L1} - {L2})"),
("Subtract",           Kl_Float,    None, Kl_Int,   None,                Kl_Float, "({L1} - (double){L2})"),
("Subtract",           Kl_Int,      None, Kl_Float, None,                Kl_Float, "((double){L1} - {L2})"),
("Subtract",           Kl_Short,    None, Kl_Short, None,                Kl_Int,   "({L1} - {L2})"),
("Subtract",           Int(-MInt/2,MInt/2), None, Int(-MInt/2,MInt/2), None,  Kl_SymmetricInt,   "({L1} - {L2})"),
("Subtract",           Kl_Cardinal, None, Kl_Cardinal, None,  Kl_SymmetricInt,   "({L1} - {L2})"),
("Subtract",           Int(-MInt+1000, MInt), None, Int(0,1000), None,  Kl_Int,   "({L1} - {L2})"),
("Subtract",           Int(-MInt, MInt), None, Kl_Boolean, None,  Kl_Int,   "({L1} - {L2})"),
("Subtract",           Int(-MInt, MInt), None, Int(0,1), None,  Kl_Int,   "({L1} - {L2})"),
("Subtract",           Int(-1, MInt), None, Int(0,MInt), None,  Kl_Int,   "({L1} - {L2})"),

("Subtract",           Kl_Float,    None, ('MayBe', Kl_Float), None,    Kl_Float, "({L1} - PyFloat_AS_DOUBLE({L2}))", None, ('{L2} == Py_None', 'PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: ''float'' and ''NoneType''");')),
("Subtract",           ('MayBe', Kl_Float), None, Kl_Float, None,       Kl_Float, "(PyFloat_AS_DOUBLE({L1}) - {L2})", None, ('{L1} == Py_None', 'PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: ''NoneType'' and ''float''");')),
("Subtract",           Kl_Boolean,  None, Kl_Boolean, None,             (int, (-1, 1)), "({L1} - {L2})"),
("Subtract",           Kl_Float,    None, Kl_Long,   None,              Kl_Float, ["{LF} = PyLong_AsDouble( {L2} );",
                                                                                   "if ({LF} == -1.0 && PyErr_Occurred()) goto L0;",
                                                                                   "({L1} - {LF})"]),
("Subtract",           Kl_Float,None, Kl_IntUndefSize, None           , Kl_Float, ["if (PyInt_CheckExact( {L2} )) {",
                                                                                   "{LF} = PyInt_AS_LONG( {L2} );",
                                                                                   "} else {",
                                                                                   "{LF} = PyLong_AsDouble( {L2} );",
                                                                                   "if ({LF} == -1.0 && PyErr_Occurred()) goto L0;",
                                                                                   "}",                                                                                  
                                                                                   "({L1} - {LF})"]),
("Subtract",           Kl_Int, None, (int, (1,1)),ArgIsConst_, Kl_IntUndefSize, ["if ({L1} > LONG_MIN) {",
                                                                                    "{LR} = PyInt_FromLong ( {L1} - 1 );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_subtract( O{L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("Subtract",           Kl_Int, None, Kl_Cardinal,None,            Kl_IntUndefSize, ["if ({L1} >= (LONG_MIN + {L2})) {",
                                                                                    "{LR} = PyInt_FromLong ( {L1} - {L2} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_subtract( O{L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("Subtract",           Kl_Int, None, Kl_Int,None,                 Kl_IntUndefSize, ["{LI} = (long)((unsigned long){L1} - {L2});",
                                                                                    "if (({LI}^{L1}) >= 0 || ({LI}^~{L2}) >= 0) {",
                                                                                    "{LR} = PyInt_FromLong ( {LI} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_subtract( O{L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("Subtract",           Kl_Int, None, Kl_IntUndefSize,None,        Kl_IntUndefSize, ["if (PyInt_CheckExact( {L2} ) && ( ({LI} = (long)((unsigned long){L1} - PyInt_AS_LONG({L2}))) , (({LI}^{L1}) >= 0 || ({LI}^~PyInt_AS_LONG({L2})) >= 0) )) {",
                                                                                    "{LR} = PyInt_FromLong ( {LI} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_subtract( O{L1} , {L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),

("Subtract",           Kl_IntUndefSize, None, Kl_Cardinal,None,    Kl_IntUndefSize, ["if (PyInt_CheckExact({L1}) && PyInt_AS_LONG({L1}) >= (LONG_MIN + {L2})) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) - {L2} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_subtract( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),

("Subtract",           Kl_IntUndefSize, None, Kl_Int,None,        Kl_IntUndefSize, ["if (PyInt_CheckExact( {L1} ) && ( ({LI} = (long)((unsigned long)PyInt_AS_LONG({L1}) - {L2}) ) , (({LI}^PyInt_AS_LONG({L1})) >= 0 || ({LI}^~{L2}) >= 0))) {",
                                                                                    "{LR} = PyInt_FromLong ( {LI} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_subtract( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),


("Subtract",           Kl_IntUndefSize, None, (int, (1,1)),ArgIsConst_, Kl_IntUndefSize, ["if (PyInt_CheckExact({L1}) && PyInt_AS_LONG({L1}) > LONG_MIN) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) - 1 );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyLong_Type.tp_as_number->nb_subtract( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),

("Subtract",           Kl_Undefined, None, (int, (1,1)),ArgIsConst_, Kl_Undefined, ["if (PyInt_CheckExact({L1}) && PyInt_AS_LONG({L1}) > LONG_MIN) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) - 1 );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_Subtract( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),  
("Subtract",           Kl_Undefined, None, Kl_Cardinal,None,          Kl_Undefined, ["if (PyInt_CheckExact({L1}) && PyInt_AS_LONG({L1}) >= (LONG_MIN + {L2})) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) - {L2} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_Subtract( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
("Subtract",           Kl_Undefined, None, Kl_IntUndefSize,None,      Kl_Undefined, ["if (PyInt_CheckExact( {L1} ) && PyInt_CheckExact( {L2} ) && ( ({LI} = (long)((unsigned long)PyInt_AS_LONG({L1}) - PyInt_AS_LONG({L2})) ) , (({LI}^PyInt_AS_LONG({L1})) >= 0 || ({LI}^~PyInt_AS_LONG({L2})) >= 0))) {",
                                                                                    "{LR} = PyInt_FromLong ( {LI} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_Subtract( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),


("Subtract",           Kl_Int, None, Kl_Undefined,None,               Kl_Undefined, ["if (PyInt_CheckExact( {L2} ) && ( ({LI} = (long)((unsigned long){L1} - PyInt_AS_LONG({L2}))) , (({LI}^{L1}) >= 0 || ({LI}^~PyInt_AS_LONG({L2})) >= 0) )) {",
                                                                                    "{LR} = PyInt_FromLong ( {LI} );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_Subtract( O{L1} , {L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
                                                                                                                                                                 
("Subtract",           Kl_Undefined, None, Kl_Undefined,None,        Kl_Undefined, ["if (({LR} = PyNumber_Subtract( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               

("InPlaceSubtract",    Kl_Undefined, None, (int, (1,1)),ArgIsConst_, Kl_Undefined, ["if (PyInt_CheckExact({L1}) && PyInt_AS_LONG({L1}) > LONG_MIN) {",
                                                                                    "{LR} = PyInt_FromLong ( PyInt_AS_LONG({L1}) - 1 );",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_InPlaceSubtract( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),                                                                               
("InPlaceSubtract",    Kl_Undefined, None, Kl_Undefined,None,        Kl_Undefined, ["if (({LR} = PyNumber_InPlaceSubtract( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               

("ToBase",             Kl_O, None,   Kl_Int, ArgIsConst_,              Kl_String, ["if (({LR} = PyNumber_ToBase( {L1}, {L2} )) == 0) goto L0;",
                                                                                   "{LR}"]),
("ToBase",             Kl_Int, None, Kl_Int, ArgIsConst_,              Kl_String, ["if (({LR} = PyNumber_ToBase( O{L1}, {L2} )) == 0) goto L0;",
                                                                                   "{LR}"]),

("OR_JUMPED_STACKED",  Kl_Float, None, Kl_Float, None,                  Kl_Float, ["{LF} = {L1};",
                                                                                   "if ({LF} == 0) {",
                                                                                   "{LF} = {L2};",
                                                                                   "}",
                                                                                   "{LF}"]),

('PyObject_Type',       Kl_List,    None, None, None,                   (type, Kl_List), "((PyObject *)&PyList_Type)"),
('PyObject_Type',       Kl_None,    None, None, None,                   (type, Kl_None), "(PyObject *)Py_TYPE((PyObject *)Py_None)"),
('PyObject_Type',       Kl_Undefined, None, None, None,                 Kl_Type,      "(PyObject *)Py_TYPE({L1})"),

("PyDict_Contains",    Kl_Dict,     None, Kl_C, None        ,           Kl_Boolean,   ["if (({LB} = PyDict_Contains ( {L1} , O{L2} )) == -1) goto L0;", "{LB}"]),
("PyDict_Contains",    Kl_Dict,     None, Kl_O, None,                   Kl_Boolean,   ["if (({LB} = PyDict_Contains ( {L1} , {L2} )) == -1) goto L0;", "{LB}"]),

("PyDict_Contains,",   [(Kl_Dict, None), (Kl_Undefined, None), (Kl_Undefined, None)], 
                                                                        Kl_Boolean,   
                                                                                    ["{LR} = PyDict_GetItem ( {L1} , {L2} );",
                                                                                    "if ({LR} != 0) {",
                                                                                    "if (({LB} = PyObject_IsTrue( {LR} )) == -1) goto L0;",
                                                                                    "{LR} = 0;",
                                                                                    "} else {",
                                                                                    "{LB} = 1;",
                                                                                    "}"]),

("PySet_Contains",     Kl_Set,      None, Kl_C, None        ,           Kl_Boolean,   ["if (({LB} = PySet_Contains ( {L1} , O{L2} )) == -1) goto L0;", "{LB}"]),
("PySet_Contains",     Kl_Set,      None, Kl_O, None,                   Kl_Boolean,   ["if (({LB} = PySet_Contains ( {L1} , {L2} )) == -1) goto L0;", "{LB}"]),
  
("PySequence_Contains", Kl_FrozenSet, None, Kl_C, None        ,         Kl_Boolean,   ["if (({LB} = PySet_Contains ( {L1} , O{L2} )) == -1) goto L0;", "{LB}"]),
("PySequence_Contains", Kl_FrozenSet, None, Kl_O, None,                 Kl_Boolean,   ["if (({LB} = PySet_Contains ( {L1} , {L2} )) == -1) goto L0;", "{LB}"]),

("PySequence_Contains", Kl_O,   ArgIsConst_TuplInt_, Kl_Int, None,      Kl_Boolean,   Gen_Patt_TuplInt),

("PySequence_Contains", Kl_O,   ArgIsConst_TuplChar_, Kl_Char, None,    Kl_Boolean,   Gen_Patt_TuplChar),

("PySequence_Contains", Kl_O,   ArgIsConst_, Kl_C, None        ,        Kl_Boolean,   ["/* test11 */ if (({LB} = PySequence_Contains ( {L1} , O{L2} )) == -1) goto L0;", "{LB}"]),

("PySequence_Contains", Kl_O,   ArgIsConst_TuplStr_, Kl_O, None,        Kl_Boolean,   Gen_Patt_TuplStr),
("PySequence_Contains", Kl_O,   ArgIsConst_, Kl_O, None,                Kl_Boolean,   ["/* test33 */ if (({LB} = PySequence_Contains ( {L1} , {L2} )) == -1) goto L0;", "{LB}"]),

("PySequence_Contains", Kl_O,   None, Kl_C, None        ,                Kl_Boolean,   ["if (({LB} = PySequence_Contains ( {L1} , O{L2} )) == -1) goto L0;", "{LB}"]),
("PySequence_Contains", Kl_O,   None, Kl_O, None,                        Kl_Boolean,   ["if (({LB} = PySequence_Contains ( {L1} , {L2} )) == -1) goto L0;", "{LB}"]),

("PyObject_IsTrue",     ('MayBe', (bool, False)), None, None, None,     Kl_Boolean,   "0"),
("PyObject_IsTrue",     ('MayBe', (bool, True)), None, None, None,      Kl_Boolean,   "({L1} != Py_None)"),
("PyObject_IsTrue",     ('MayBe', Kl_Boolean), None, None, None,        Kl_Boolean,   "({L1} != Py_None && {L1} == Py_True)"),
("PyObject_IsTrue",     ('MayBe', Kl_List), None, None, None,           Kl_Boolean,   "({L1} != Py_None && PyList_GET_SIZE({L1}) > 0)"),
("PyObject_IsTrue",     ('MayBe', Kl_Tuple), None, None, None,          Kl_Boolean,   "({L1} != Py_None && PyTuple_GET_SIZE({L1}) > 0)"),
("PyObject_IsTrue",     Kl_Tuple, None, None, None,                     Kl_Boolean,   "(PyTuple_GET_SIZE({L1}) > 0)"),
("PyObject_IsTrue",     Kl_List, None, None, None,                      Kl_Boolean,   "(PyList_GET_SIZE({L1}) > 0)"),
("PyObject_IsTrue",     Kl_String, None, None, None,                    Kl_Boolean,   "(PyString_GET_SIZE({L1}) > 0)"),
("PyObject_IsTrue",     Kl_Set, None, None, None,                       Kl_Boolean,   "(PySet_Size({L1}) > 0)"),
("PyObject_IsTrue",     Kl_Int, None, None, None,                       Kl_Boolean,   "({L1} != 0)"),
("PyObject_IsTrue",     Kl_Dict, None, None, None,                      Kl_Boolean,   "(PyDict_Size({L1}) == 0)"),
("PyObject_IsTrue",     Kl_File, None, None, None,                      Kl_Boolean,   "1"),
("PyObject_IsTrue",     (bool, True), None, None, None,                 Kl_Boolean,   "1"),
("PyObject_IsTrue",     (bool, False), None, None, None,                Kl_Boolean,   "0"),
("PyObject_IsTrue",     (bool, None), None, None, None,                 Kl_Boolean,   "{L1}"),
("PyObject_IsTrue",     Kl_None, None, None, None,                      Kl_Boolean,   "0"),
("PyObject_IsTrue",     Kl_IntUndefSize, None, None, None,              Kl_Boolean,   ["if ( PyInt_CheckExact({L1}) ) {",
                                                                                       "{LB} = PyInt_AS_LONG({L1}) != 0;",
                                                                                       "} else {",
                                                                                       "if (({LB} = PyObject_IsTrue( {L1} )) == -1) goto L0;", 
                                                                                       "}",
                                                                                       "{LB}"]),
("PyObject_IsTrue",     Kl_Undefined, None, None, None,                 Kl_Boolean,   ["if (({LB} = PyObject_IsTrue( {L1} )) == -1) goto L0;", "{LB}"]),

("1NOT",                Kl_Undefined, None, None, None,                 Kl_Boolean,   ["if (({LB} = PyObject_Not( {L1} )) == -1) goto L0;", "{LB}"]),
("1NOT",                Kl_NewInst, None, None, None,                   Kl_Boolean,   ["if (({LB} = PyObject_Not( {L1} )) == -1) goto L0;", "{LB}"]),
("1NOT",                ('MayBe', (bool, False)), None, None, None,     Kl_Boolean,   "1"),
("1NOT",                ('MayBe', (bool, True)), None, None, None,      Kl_Boolean,   "({L1} == Py_None)"),
("1NOT",                ('MayBe', Kl_Boolean), None, None, None,        Kl_Boolean,   "({L1} == Py_None || {L1} == Py_False)"),
("1NOT",                ('MayBe', Kl_List), None, None, None,           Kl_Boolean,   "({L1} == Py_None || PyList_GET_SIZE({L1}) == 0)"),
("1NOT",                ('MayBe', Kl_Tuple), None, None, None,          Kl_Boolean,   "({L1} == Py_None || PyTuple_GET_SIZE({L1}) == 0)"),
("1NOT",                Kl_Tuple, None, None, None,                     Kl_Boolean,   "(PyTuple_GET_SIZE({L1}) == 0)"),
("1NOT",                Kl_List, None, None, None,                      Kl_Boolean,   "(PyList_GET_SIZE({L1}) == 0)"),
("1NOT",                Kl_String, None, None, None,                    Kl_Boolean,   "(PyString_GET_SIZE({L1}) == 0)"),
("1NOT",                Kl_Set, None, None, None,                       Kl_Boolean,   "(PySet_Size({L1}) == 0)"),
("1NOT",                Kl_Dict, None, None, None,                      Kl_Boolean,   "(PyDict_Size({L1}) == 0)"),
("1NOT",                (bool, True), None, None, None,                 Kl_Boolean,   "0"),
("1NOT",                (bool, False), None, None, None,                Kl_Boolean,   "1"),
("1NOT",                Kl_None, None, None, None,                      Kl_Boolean,   "1"),
("1NOT",                Kl_IntUndefSize, None, None, None,              Kl_Boolean,   ["if (({LB} = PyObject_Not( {L1} )) == -1) goto L0;", "{LB}"]),

('@PyInt_FromSsize_t',  Kl_All, None,       Kl_Int, None,               Kl_Int,       "{L2}"),
('@PyInt_FromSsize_t',  Kl_Int, None,       Kl_All, None,               Kl_Int,       "{L1}"),
('@PyInt_FromSsize_t',  Kl_All, None,       Kl_All, None,               Kl_Int,       "{L1}"),

("PyObject_IsInstance", Kl_String,    None, (tuple, ((type, Kl_String), (type, Kl_Unicode))), None,  Kl_Boolean,   "1"),

("PyObject_IsInstance", Kl_Undefined, None, Kl_Undefined, None,         Kl_Boolean,   ["if (({LB} = PyObject_IsInstance( {L1} , {L2} )) == -1) goto L0;", "{LB}"]),
("PyObject_IsInstance", Kl_Undefined, None, Kl_NewType, None,           Kl_Boolean,   ["if (({LB} = PyObject_IsInstance( {L1} , {L2} )) == -1) goto L0;", "{LB}"]),
("PyObject_IsInstance", Kl_Undefined, None, Kl_OldType, None,           Kl_Boolean,   ["if (({LB} = PyObject_IsInstance( {L1} , {L2} )) == -1) goto L0;", "{LB}"]),
("PyObject_IsInstance", Kl_Undefined, None, Kl_Tuple, None,             Kl_Boolean,   ["if (({LB} = PyObject_IsInstance( {L1} , {L2} )) == -1) goto L0;", "{LB}"]),
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'int'), Kl_Boolean,  "PyInt_Check({L1})"),
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'long'), Kl_Boolean,  "PyLong_Check({L1})"),
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'str'), Kl_Boolean,  "PyString_Check({L1})"),
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'tuple'), Kl_Boolean,  "PyTuple_Check({L1})"),
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'list'), Kl_Boolean,  "PyList_Check({L1})"),
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'float'), Kl_Boolean,  "PyFloat_Check({L1})"),
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'dict'), Kl_Boolean,  "PyDict_Check({L1})"),
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'slice'), Kl_Boolean,  "PySlice_Check({L1})"),                                                                        
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'unicode'), Kl_Boolean,  "PyUnicode_Check({L1})"),                                                                         
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'type'), Kl_Boolean,  "PyType_Check({L1})"), 
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'bool'), Kl_Boolean,  "PyBool_Check({L1})"), 
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'complex'), Kl_Boolean,  "PyComplex_Check({L1})"),                                                                         
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, ('!LOAD_BUILTIN', 'set'), Kl_Boolean,  "PySet_Check({L1})"), 
("PyObject_IsInstance", Kl_Undefined, None, Kl_Type, None,              Kl_Boolean,   ["if (({LB} = PyObject_IsInstance( {L1} , {L2} )) == -1) goto L0;", "{LB}"]),
("PyObject_IsInstance", Kl_O, None,         Kl_O, None,                 Kl_Boolean,   ["if (({LB} = PyObject_IsInstance( {L1} , {L2} )) == -1) goto L0;", "{LB}"]),
("PyObject_IsInstance", Kl_C, None        , Kl_O, None,                 Kl_Boolean,   ["if (({LB} = PyObject_IsInstance( O{L1} , {L2} )) == -1) goto L0;", "{LB}"]),

("PyObject_IsSubclass", Kl_O, None,         Kl_O, None,                 Kl_Boolean,   ["if (({LB} = PyObject_IsSubclass( {L1} , {L2} )) == -1) goto L0;", "{LB}"]),
("PyObject_IsSubclass", Kl_C, None        , Kl_O, None,                 Kl_Boolean,   ["if (({LB} = PyObject_IsSubclass( O{L1} , {L2} )) == -1) goto L0;", "{LB}"]),

("PyObject_GetAttr",   Kl_Undefined, None, Kl_String, None,             (bool, True),  "1"),
("PyObject_GetAttr",   Kl_Undefined, None, Kl_String, None,             (bool, False),  "0"),

("PyObject_GetAttr",    Kl_NewInst, ArgIsCompiledSlots_,    Kl_String, ArgIsConst_,   Kl_O, Gen_Patt_GetAttr_slots),
("PyObject_GetAttr",    Kl_NewInst, ArgIsCompiledSlots_,    Kl_String, ArgIsConst_,   Kl_Int, Gen_Patt_GetAttr_slots_AS_LONG),
("PyObject_GetAttr",    Kl_NewInst, ArgIsCompiledSlots_,    Kl_String, ArgIsConst_,   Kl_Boolean, Gen_Patt_GetAttr_slots_bool),

("PyObject_GetAttr",    New_Kl_Module('sys'), None, (str, 'executable'), None, Kl_String, ["{LR} = PyString_FromString(Py_GetProgramFullPath());",
                                                                                   "{LR}"]),

("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_name'), None,     Kl_String,["{LR} = (((PyCodeObject *){L1})->co_name);",
                                                                                   "Py_INCREF({LR});",
                                                                                   "{LR}"]),
("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_filename'), None, Kl_String,["{LR} = (((PyCodeObject *){L1})->co_filename);",
                                                                                   "Py_INCREF({LR});",
                                                                                   "{LR}"]),
("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_argcount'), None, Kl_Int,   "(((PyCodeObject *){L1})->co_argcount)"),
("PyObject_GetAttr",   ('MayBe',Kl_Code), None, (str, 'co_flags'), None,Kl_Int,   "(((PyCodeObject *){L1})->co_flags)", None, ('{L1} == Py_None', 'PyErr_Format(PyExc_AttributeError, "''NoneType'' object has no attribute ''co_flags''");')),

("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_flags'), None,    Kl_Int,   "(((PyCodeObject *){L1})->co_flags)")])
if True:
    linear_type_rule.extend([
("exit",               Kl_Short,    None, None,     None,               Kl_None, ["Py_Exit({L1});", "Py_None"]),
("M:exit",             New_Kl_Module('sys'), None, Kl_Short, None,      Kl_None, ["Py_Exit({L2});", "Py_None"]),

("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_firstlineno'), None, Kl_Int,"(((PyCodeObject *){L1})->co_firstlineno)"),
("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_nlocals'), None,  Kl_Int,   "(((PyCodeObject *){L1})->co_nlocals)"),
("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_stacksize'), None,Kl_Int,   "(((PyCodeObject *){L1})->co_stacksize)"),
("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_code'), None,     Kl_String,["{LR} = (((PyCodeObject *){L1})->co_code);",
                                                                                   "Py_INCREF({LR});",
                                                                                   "{LR}"]),
("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_lnotab'), None,   Kl_String,["{LR} = (((PyCodeObject *){L1})->co_lnotab);",
                                                                                   "Py_INCREF({LR});",
                                                                                   "{LR}"]),
("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_cellvars'), None, Kl_Tuple,["{LR} = (((PyCodeObject *){L1})->co_cellvars);",
                                                                                   "Py_INCREF({LR});",
                                                                                   "{LR}"]),
("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_consts'), None,   Kl_Tuple,["{LR} = (((PyCodeObject *){L1})->co_consts);",
                                                                                   "Py_INCREF({LR});",
                                                                                   "{LR}"]),
("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_freevars'), None, Kl_Tuple,["{LR} = (((PyCodeObject *){L1})->co_freevars);",
                                                                                   "Py_INCREF({LR});",
                                                                                   "{LR}"]),
("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_names'), None,    Kl_Tuple,["{LR} = (((PyCodeObject *){L1})->co_names);",
                                                                                   "Py_INCREF({LR});",
                                                                                   "{LR}"]),
("PyObject_GetAttr",    Kl_Code, None,      (str, 'co_varnames'), None, Kl_Tuple,["{LR} = (((PyCodeObject *){L1})->co_varnames);",
                                                                                   "Py_INCREF({LR});",
                                                                                   "{LR}"]),
("PyObject_GetAttr",   ('MayBe',Kl_Code), None, (str, 'co_consts'), None,Kl_Tuple, ["{LR} = (((PyCodeObject *){L1})->co_consts);",
                                                                                   "Py_INCREF({LR});",
                                                                                   "{LR}"], None, ('{L1} == Py_None', 'PyErr_Format(PyExc_AttributeError, "''NoneType'' object has no attribute ''co_consts''");')),

("PyObject_GetAttr",    Kl_Complex, None,   (str, 'real'), None,        Kl_Float, "PyComplex_RealAsDouble( {L1} )"),
("PyObject_GetAttr",    Kl_Complex, None,   (str, 'imag'), None,        Kl_Float, "PyComplex_ImagAsDouble( {L1} )"),

("PyObject_GetAttr",    New_Kl_Module('sys'), None, (str, 'argv'), None,Kl_List, ['{LR} = PySys_GetObject("argv");',
                                                                                  'Py_INCREF({LR});',
                                                                                  '{LR}'] ),
("PyObject_GetAttr",    New_Kl_Module('sys'), None, (str, 'stderr'), None,Kl_File, ['{LR} = PySys_GetObject("stderr");',
                                                                                  'Py_INCREF({LR});',
                                                                                  '{LR}'] ),
("PyObject_GetAttr",    New_Kl_Module('sys'), None, (str, 'stdout'), None,Kl_File, ['{LR} = PySys_GetObject("stdout");',
                                                                                  'Py_INCREF({LR});',
                                                                                  '{LR}'] ),
("PyObject_GetAttr",    New_Kl_Module('sys'), None, (str, 'modules'), None,Kl_Dict, ['{LR} = PySys_GetObject("modules");',
                                                                                  'Py_INCREF({LR});',
                                                                                  '{LR}'] ),

("PyObject_GetAttr",    Kl_Undefined, None, Kl_String, ArgIsConstNotInSlots_, Kl_Undefined,["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    Kl_Undefined, None, (str, '__class__'), None,Kl_O,         ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    Kl_Undefined, None, (str, '__dict__'), None,Kl_Undefined,  ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    Kl_Undefined, None, (str, '__name__'), None,Kl_Undefined,  ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    Kl_O, None, Kl_Undefined, None,              Kl_O,         ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    New_Kl_Module(None), None, (str, '__dict__'), None, Kl_Dict, ["if (({LR} = PyModule_GetDict( {L1} )) == 0) goto L0;",
                                                                                    "Py_INCREF({LR});",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    ('MayBe', New_Kl_Module(None)), None, (str, '__dict__'), None, Kl_Dict, ["if (({LR} = PyModule_GetDict( {L1} )) == 0) goto L0;",
                                                                                    "Py_INCREF({LR});",
                                                                                    "{LR}"], None, ('{L1} == Py_None', 'PyErr_Format(PyExc_AttributeError, "''NoneType'' object has no attribute ''__dict__''");')),
("PyObject_GetAttr",    New_Kl_Module(None), None, (str, '__name__'), None, Kl_String, ["if (({LR} = PyString_FromString( PyModule_GetName( {L1} ))) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    New_Kl_Module(None), None, (str, '__file__'), None, Kl_String, ["if (({LR} = PyString_FromString( PyModule_GetFilename( {L1} ))) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    New_Kl_Module(None), None, Kl_String, None, Kl_BuiltFunc,  ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    New_Kl_Module(None), None, Kl_String, None, Kl_Function,  ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    New_Kl_Module(None), None, Kl_String, None, New_Kl_Module(None),  ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    Kl_Undefined, None, (str, '__file__'), None,    Kl_String, ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    Kl_Undefined, None, Kl_String, None,         Kl_Undefined, ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_GetAttr",    Kl_Type, None, (str, '__name__'), None,      Kl_String,    ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
##("PyObject_GetAttr",    Kl_Module, None, Kl_String, None,            Kl_O,         ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
##                                                                                    "{LR}"]),
("_PyObject_GetAttrRaw",Kl_Undefined, None, Kl_String, None,         Kl_O,         ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("_PyObject_GetAttrRaw",Kl_Undefined, None, Kl_String, None,         Kl_Int,       ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "PyInt_AS_LONG({LR})"]),
("_PyObject_GetAttrRaw",Kl_Undefined, None, Kl_String, None,         Kl_Float,     ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "PyFloat_AS_DOUBLE({LR})"]),
("_PyObject_GetAttrRaw",Kl_Undefined, None, Kl_String, None,         Kl_Boolean,   ["if (({LR} = PyObject_GetAttr( {L1}, {L2} )) == 0) goto L0;",
                                                                                    "({LR} == Py_True)"]),
("PyObject_HasAttr",    Kl_O, None, Kl_O, None,                      Kl_Boolean,   ["if (({LB} = PyObject_HasAttr( {L1}, {L2} )) == -1) goto L0;",
                                                                                    "{LB}"]),

("PyObject_Hash",       Kl_Float, None,       None, None,               Kl_Int,   ["if (({LI} = _Py_HashDouble( {L1} )) == -1) goto L0;", "{LI}"]),
("PyObject_Hash",       Kl_Int, None,       None, None,                 Kl_Int,   "PyIF({L1} == -1, -2, {L1})"),

("PyObject_Hash",       Kl_C, None        , None, None,                 Kl_Int,   ["if (({LI} = PyObject_Hash( {L1} )) == -1) goto L0;", "{LI}"]),
("PyObject_Hash",       Kl_O, None,       None, None,                   Kl_Int,   ["if (({LI} = PyObject_Hash( {L1} )) == -1) goto L0;", "{LI}"]),

("_PyList_Extend",      Kl_O, None,       Kl_O, None,                   Kl_None,  ["if (({LR} = _PyList_Extend( (PyListObject *){L1}, {L2} )) == 0) goto L0;", "{LR}"]),
("STR_CONCAT",          Kl_Char, None,  Kl_Char, None,                Kl_String,  ["if (({LR} = PyString_FromStringAndSize(NULL, 2)) == 0) goto L0;",
                                                                                   "PyString_AS_STRING( {LR} )[0] = {L1};",
                                                                                   "PyString_AS_STRING( {LR} )[1] = {L2};",
                                                                                   "{LR}"]),
("STR_CONCAT",          Kl_Char, None,  Kl_String, None,              Kl_String,  ["if (({LR} = PyString_FromStringAndSize(NULL, 1 + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "*PyString_AS_STRING( {LR} ) = {L1};",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + 1, PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "{LR}"]),
("STR_CONCAT",          Kl_String, None,  Kl_Char, None,              Kl_String,  ["if (({LR} = PyString_FromStringAndSize(NULL, 1 + PyString_GET_SIZE( {L1} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "PyString_AS_STRING( {LR} )[PyString_GET_SIZE( {L1} )] = {L2};",
                                                                                   "{LR}"]),
("STR_CONCAT",          Kl_String, None,  Kl_String, None,              Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + PyString_GET_SIZE( {L1} ), PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "{LR}"]),
("STR_CONCAT",          [(Kl_Char, None),  (Kl_Char, None),  (Kl_Char, None)],
                                                                        Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, 3)) == 0) goto L0;",
                                                                                   "PyString_AS_STRING( {LR} )[0] = {L1};",
                                                                                   "PyString_AS_STRING( {LR} )[1] = {L2};",
                                                                                   "PyString_AS_STRING( {LR} )[2] = {L3};",
                                                                                   "{LR}"]),
("STR_CONCAT",          [(Kl_Char, None),  (Kl_String, None),  (Kl_Char, None)],
                                                                        Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L2} ) + 2)) == 0) goto L0;",
                                                                                   "PyString_AS_STRING( {LR} )[0] = {L1};",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + 1, PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "PyString_AS_STRING( {LR} )[PyString_GET_SIZE( {L2} ) + 1] = {L3};",
                                                                                   "{LR}"]),
("STR_CONCAT",          [(Kl_String, None),  (Kl_String, None),  (Kl_Char, None)],
                                                                        Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ) + 1)) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "{LI} = PyString_GET_SIZE( {L1} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "{LI} += PyString_GET_SIZE( {L2} );",
                                                                                   "PyString_AS_STRING( {LR} )[{LI}] = {L3};",
                                                                                   "{LR}"]),
("STR_CONCAT",          [(Kl_String, None),  (Kl_String, None),  (Kl_String, None)],
                                                                        Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ) + PyString_GET_SIZE( {L3} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "{LI} = PyString_GET_SIZE( {L1} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "{LI} += PyString_GET_SIZE( {L2} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L3} ), PyString_GET_SIZE( {L3} ));",
                                                                                   "{LR}"]),
("STR_CONCAT",          [(Kl_String, None),  (Kl_Undefined, None),  (Kl_String, None)],
                                                                        Kl_String, ["if (({LR} = STR_CONCAT3( {L1}, {L2}, {L3} )) == 0)  goto L0;",
                                                                                    "{LR}"], None, 'STR_CONCAT3'),
("STR_CONCAT",          [(Kl_Char, None),  (Kl_Char, None),  (Kl_Char, None),  (Kl_Char, None)],
                                                                        Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, 4)) == 0) goto L0;",
                                                                                   "PyString_AS_STRING( {LR} )[0] = {L1};",
                                                                                   "PyString_AS_STRING( {LR} )[1] = {L2};",
                                                                                   "PyString_AS_STRING( {LR} )[2] = {L3};",
                                                                                   "PyString_AS_STRING( {LR} )[3] = {L4};",
                                                                                   "{LR}"]),
("STR_CONCAT",          [(Kl_String, None),  (Kl_String, None),  (Kl_String, None),  (Kl_String, None)],
                                                                        Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ) + PyString_GET_SIZE( {L3} ) + PyString_GET_SIZE( {L4} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "{LI} = PyString_GET_SIZE( {L1} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "{LI} += PyString_GET_SIZE( {L2} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L3} ), PyString_GET_SIZE( {L3} ));",
                                                                                   "{LI} += PyString_GET_SIZE( {L3} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L4} ), PyString_GET_SIZE( {L4} ));",
                                                                                   "{LR}"]),
("STR_CONCAT",          [(Kl_Char, None),  (Kl_Char, None),  (Kl_Char, None),  (Kl_Char, None),  (Kl_Char, None)],
                                                                        Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, 5)) == 0) goto L0;",
                                                                                   "PyString_AS_STRING( {LR} )[0] = {L1};",
                                                                                   "PyString_AS_STRING( {LR} )[1] = {L2};",
                                                                                   "PyString_AS_STRING( {LR} )[2] = {L3};",
                                                                                   "PyString_AS_STRING( {LR} )[3] = {L4};",
                                                                                   "PyString_AS_STRING( {LR} )[4] = {L5};",
                                                                                   "{LR}"]),

("STR_CONCAT",          [(Kl_String, None),  (Kl_String, None),  (Kl_String, None),  (Kl_String, None),  (Kl_String, None)],
                                                                        Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ) + PyString_GET_SIZE( {L3} ) + PyString_GET_SIZE( {L4} ) + PyString_GET_SIZE( {L5} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "{LI} = PyString_GET_SIZE( {L1} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "{LI} += PyString_GET_SIZE( {L2} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L3} ), PyString_GET_SIZE( {L3} ));",
                                                                                   "{LI} += PyString_GET_SIZE( {L3} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L4} ), PyString_GET_SIZE( {L4} ));",
                                                                                   "{LI} += PyString_GET_SIZE( {L4} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L5} ), PyString_GET_SIZE( {L5} ));",
                                                                                   "{LR}"]),
("STR_CONCAT",          [(Kl_Char, None),  (Kl_Char, None),  (Kl_Char, None),  (Kl_Char, None),  (Kl_Char, None),  (Kl_Char, None)],
                                                                        Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, 6)) == 0) goto L0;",
                                                                                   "PyString_AS_STRING( {LR} )[0] = {L1};",
                                                                                   "PyString_AS_STRING( {LR} )[1] = {L2};",
                                                                                   "PyString_AS_STRING( {LR} )[2] = {L3};",
                                                                                   "PyString_AS_STRING( {LR} )[3] = {L4};",
                                                                                   "PyString_AS_STRING( {LR} )[4] = {L5};",
                                                                                   "PyString_AS_STRING( {LR} )[5] = {L6};",
                                                                                   "{LR}"]),

("STR_CONCAT",          [(Kl_String, None),  (Kl_String, None),  (Kl_String, None),  (Kl_String, None),  (Kl_String, None),  (Kl_String, None)],
                                                                        Kl_String,["if (({LR} = PyString_FromStringAndSize(NULL, PyString_GET_SIZE( {L1} ) + PyString_GET_SIZE( {L2} ) + PyString_GET_SIZE( {L3} ) + PyString_GET_SIZE( {L4} ) + PyString_GET_SIZE( {L5} ) + PyString_GET_SIZE( {L6} ))) == 0) goto L0;",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ), PyString_AS_STRING( {L1} ), PyString_GET_SIZE( {L1} ));",
                                                                                   "{LI} = PyString_GET_SIZE( {L1} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L2} ), PyString_GET_SIZE( {L2} ));",
                                                                                   "{LI} += PyString_GET_SIZE( {L2} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L3} ), PyString_GET_SIZE( {L3} ));",
                                                                                   "{LI} += PyString_GET_SIZE( {L3} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L4} ), PyString_GET_SIZE( {L4} ));",
                                                                                   "{LI} += PyString_GET_SIZE( {L4} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L5} ), PyString_GET_SIZE( {L5} ));",
                                                                                   "{LI} += PyString_GET_SIZE( {L5} );",
                                                                                   "memcpy(PyString_AS_STRING( {LR} ) + {LI}, PyString_AS_STRING( {L6} ), PyString_GET_SIZE( {L6} ));",
                                                                                   "{LR}"]),


("CHR_BUILTIN",         (int, (0,255)), ArgIsConst_, None,  None,              Kl_Char,   ConstIntToConstChar),
("CHR_BUILTIN",         (int, (0,255)), None, None,  None,              Kl_Char,   "((unsigned char)({L1}))"),
("CHR_BUILTIN",         Kl_Int, None, None,  None,                      Kl_Char,   "((unsigned char)({L1}))", ('((unsigned long){L1}) >= 255', 'PyErr_SetString(PyExc_ValueError, "chr() arg not in range(256)");')),
("CHR_BUILTIN",         Kl_IntUndefSize, None, None,  None,             Kl_Char,   ["if ( PyInt_CheckExact({L1}) ) {",
                                                                                    "{LI} = PyInt_AS_LONG({L1});",
                                                                                    "} else {",
                                                                                    "{LI} = PyLong_AsLong({L1});",
                                                                                    "if ({LI} == -1 && PyErr_Occurred()) goto L0;",
                                                                                    "}",
                                                                                    "if ({LI} < 0 || {LI} >= 256) {",
                                                                                    'PyErr_SetString(PyExc_ValueError, "chr() arg not in range(256)");',
                                                                                    "goto L0;",
                                                                                    "}",
                                                                                    "((unsigned char)({LI}))"]),

("Xor",                Kl_Boolean,  None, Kl_Boolean, None,             Kl_Boolean, "({L1} ^ {L2})"),
("Xor",                Kl_Int,      None, Kl_Int,   None,               Kl_Int,   "({L1} ^ {L2})"),
("Xor",                Kl_Int,      None, Kl_Short, None,               Kl_Int,   "({L1} ^ {L2})"),
("Xor",                Kl_Short,    None, Kl_Int,   None,               Kl_Int,   "({L1} ^ {L2})"),
("Xor",                Kl_Short,    None, Kl_Short, None,               Kl_Short, "({L1} ^ {L2})"),

("Xor",                Kl_Undefined,None, Kl_Undefined, None,           Kl_Undefined,["if (({LR} = PyNumber_Xor( {L1} , {L2} )) == 0) goto L0;",
                                                                                     "{LR}"]),
("And",                Kl_Set,None, Kl_Set, None,                       Kl_Set      ,["if (({LR} = PyNumber_And( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Or",                 Kl_Set,None, Kl_Set, None,                       Kl_Set      ,["if (({LR} = PyNumber_Or( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("InPlaceOr",          Kl_Undefined,None, Kl_Set, None,                 Kl_Undefined ,["if (({LR} = PyNumber_InPlaceOr( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("InPlaceOr",          Kl_Set,None, Kl_Undefined, None,                 Kl_Undefined ,["if (({LR} = PyNumber_InPlaceOr( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("InPlaceOr",          Kl_Undefined,None, Kl_Undefined, None,           Kl_Undefined ,["if (({LR} = PyNumber_InPlaceOr( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("And",                Kl_Undefined,None, Kl_Undefined, None,           Kl_Undefined,["if (({LR} = PyNumber_And( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Or",                 Kl_Undefined,None, Kl_Undefined, None,           Kl_Undefined,["if (({LR} = PyNumber_Or( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Rshift",             Kl_Undefined,None, Kl_Undefined, None,           Kl_Undefined,["if (({LR} = PyNumber_Rshift( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Lshift",             Kl_Undefined,None, Kl_Undefined, None,           Kl_Undefined,["if (({LR} = PyNumber_Lshift( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("InPlaceRshift",      Kl_Undefined,None, Kl_Undefined, None,           Kl_Undefined,["if (({LR} = PyNumber_InPlaceRshift( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("InPlaceLshift",      Kl_Undefined,None, Kl_Undefined, None,           Kl_Undefined,["if (({LR} = PyNumber_InPlaceLshift( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Remainder",          Kl_Undefined,None, Kl_Undefined, None,           Kl_Undefined,["if (({LR} = PyNumber_Remainder( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("FloorDivide",        Kl_Undefined,None, Kl_Undefined, None,           Kl_Undefined,["if (({LR} = PyNumber_FloorDivide( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Power",              Kl_Undefined,None, Kl_Undefined, None,           Kl_Undefined,["if (({LR} = PyNumber_Power( {L1} , {L2} , Py_None )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Multiply",           Kl_Undefined,None, Kl_Undefined, None,           Kl_O,        ["if (({LR} = PyNumber_Multiply( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Multiply",           Kl_Undefined,None, Kl_C, None,           Kl_Undefined,        ["if (({LR} = PyNumber_Multiply( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("InPlaceMultiply",    Kl_Undefined,None, Kl_Undefined, None,           Kl_O,        ["if (({LR} = PyNumber_InPlaceMultiply( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Invert",             Kl_Undefined,None, None, None,                   Kl_Undefined,["if (({LR} = PyNumber_Invert( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Negative",           Kl_Undefined,None, None, None,                   Kl_Undefined,["if (({LR} = PyNumber_Negative( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Positive",           Kl_Undefined,None, None, None,                   Kl_Undefined,["if (({LR} = PyNumber_Positive( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Absolute",           Kl_Undefined,None, None, None,                   Kl_Undefined,["if (({LR} = PyNumber_Absolute( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("Long",               Kl_Undefined,None, None, None,                   Kl_Long,     ["if (({LR} = PyNumber_Long( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),                                                                               
("PyList_AsTuple",     Kl_List, None, None, None,                       Kl_Tuple,    ["if (({LR} = PyList_AsTuple( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_Repr",      Kl_O, None, None, None,                          Kl_String,   ["if (({LR} = PyObject_Repr( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_Str",       Kl_O, None, None, None,                          Kl_String,   ["if (({LR} = PyObject_Str( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_Repr",      Kl_Float, None, None, None,                      Kl_String,   ["if (({LR} = PyObject_Repr( O{L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_Str",       Kl_Float, None, None, None,                      Kl_String,   ["if (({LR} = PyObject_Str( O{L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_Repr",      Kl_Char, None, None, None,                       Kl_String,   ["if (({LR} = PyObject_Repr( O{L1} )) == 0) goto L0;",
                                                                                     "{LR}"]),
("PyObject_Str",       Kl_Char, None, None, None,                       Kl_String,   ["if (({LR} = PyObject_Str( O{L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PySequence_Repeat",  Kl_Char, ArgIsConst_, Kl_Cardinal, ArgIsConst_,  Kl_String,   ["if (({LR} = PyString_FromStringAndSize( NULL , {L2} )) == 0) goto L0;",
                                                                                      "for({LB}=0; {LB} < {L2}; {LB}++) { PyString_AS_STRING({LR})[{LB}] = {L1}; }",
                                                                                      "{LR}"]),
("PySequence_Repeat",  Kl_Char, ArgIsConst_, Kl_Cardinal, None,         Kl_String,   ["if (({LR} = PyString_FromStringAndSize( NULL , {L2} )) == 0) goto L0;",
                                                                                      "for({LB}=0; {LB} < PyString_GET_SIZE({LR}); {LB}++) { PyString_AS_STRING({LR})[{LB}] = {L1}; }",
                                                                                      "{LR}"]),
("PySequence_List",    Kl_List, None, None, None,                       Kl_List,     "{L1}"),
("PySequence_List",    Kl_O, None, None, None,                          Kl_List,     ["if (({LR} = PySequence_List( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PySequence_Tuple",   Kl_Tuple, None, None, None,                      Kl_Tuple,    "{L1}"),
("PySequence_Tuple",   Kl_O, None, None, None,                          Kl_Tuple,    ["if (({LR} = PySequence_Tuple( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyInt_Type.tp_str",   Kl_O, None, None, None,                         Kl_String,   ["if (({LR} = PyInt_Type.tp_str( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyInt_Type.tp_str",   Kl_C, None, None, None,                         Kl_String,   ["if (({LR} = PyInt_Type.tp_str( O{L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyDict_Items",       Kl_Dict, None, None, None,                       Kl_List,     ["if (({LR} = PyDict_Items( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyDict_Keys",        Kl_Dict, None, None, None,                       Kl_List,     ["if (({LR} = PyDict_Keys( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyDict_Values",      Kl_Dict, None, None, None,                       Kl_List,     ["if (({LR} = PyDict_Values( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyDict_Copy",        Kl_Dict, None, None, None,                       Kl_Dict,     ["if (({LR} = PyDict_Copy( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PySet_New",          Kl_O, None, None, None,                          Kl_Set,      ["if (({LR} = PySet_New( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyObject_Dir",       Kl_O, None, None, None,                          Kl_List,     ["if (({LR} = PyObject_Dir( {L1} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("_PyString_Join",     Kl_String, None, Kl_List, None,                  Kl_String,   ["if (({LR} = _PyString_Join( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyString_Format",    Kl_String, None, Kl_C, None,                     Kl_String,   ["if (({LR} = PyString_Format( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyString_Format",    Kl_String, None, Kl_Tuple, None,                 Kl_String,   ["if (({LR} = PyString_Format( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyString_Format",    Kl_String, None, Kl_String, None,                Kl_String,   ["if (({LR} = PyString_Format( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("PyString_Format",    Kl_String, None, Kl_Undefined, None,             Kl_String,   ["if (({LR} = PyString_Format( {L1} , {L2} )) == 0) goto L0;",
                                                                                    "{LR}"]),
("CLASS_CALC_CONST_NEW", [(Kl_NewType, None), ((bool, True), None), ((tuple, ()), None)], Kl_O,
                                                                                     ["{LR} = ((PyTypeObject *){L1})->tp_new(((PyTypeObject *){L1}) , {L3} , NULL);", 
                                                                                     "{LR}"]),      
("_PyEval_ApplySlice", [(Kl_O, None), (Kl_Int, None), (Kl_O, None)],    Kl_O,        ["if (({LR} = _PyEval_ApplySlice( {L1} , O{L2} , {L3} )) == 0) goto L0;",
                                                                                      "{LR}"], "_PyEval_ApplySlice") ,                                                      
("_PyEval_ApplySlice", [(Kl_O, None), (Kl_O, None), (Kl_Int, None)],    Kl_O,        ["if (({LR} = _PyEval_ApplySlice( {L1} , {L2} , O{L3} )) == 0) goto L0;",
                                                                                      "{LR}"], "_PyEval_ApplySlice") ,                                                      
("_PyEval_ApplySlice", [(Kl_O, None), (Kl_O, None), (Kl_O, None)],      Kl_O,        ["if (({LR} = _PyEval_ApplySlice( {L1} , {L2} , {L3} )) == 0) goto L0;",
                                                                                       "{LR}"], "_PyEval_ApplySlice") ,    
("M:insert",           [(Kl_List, None), (Kl_Int, None), (Kl_O, None)], Kl_None,     ["if (PyList_Insert( {L1} , {L2} , {L3} ) == -1) goto L0;",
                                                                                      "Py_None"]),
("PyObject_Call_nokey",Kl_BuiltFunc, None, Kl_Tuple, None,              Kl_O,        ["if (({LR} = PyCFunction_Call( {L1} , {L2} , NULL )) == 0) goto L0;",
                                                                                      "{LR}"] ),
("PyObject_Call_nokey",Kl_BuiltFunc, None, Kl_Tuple, None,              Kl_Float,    ["if (({LR} = PyCFunction_Call( {L1} , {L2} , NULL )) == 0) goto L0;",
                                                                                      "PyFloat_AS_DOUBLE( {LR} )"] ),
("PyObject_Call_nokey",Kl_Function, None, Kl_Tuple, None,               Kl_O,        ["if (({LR} = PyObject_Call( {L1} , {L2} , NULL )) == 0) goto L0;",
                                                                                      "{LR}"] ),
("PyObject_Call_nokey",(type, unicode), None, (tuple, (Kl_Undefined, Kl_Undefined)), None, Kl_Unicode, ["if (({LR} = PyObject_Call( {L1} , {L2} , NULL )) == 0) goto L0;",
                                                                                      "{LR}"] ),
("PyObject_Call_nokey",(type, reversed), None, Kl_Tuple, None,          Kl_Reversed, ["if (({LR} = PyObject_Call( {L1} , {L2} , NULL )) == 0) goto L0;",
                                                                                      "{LR}"] ),
("PyObject_Call_nokey",(type, dict), None, (tuple, (None,)), None,      Kl_Dict,     ["if (({LR} = PyObject_Call( {L1} , {L2} , NULL )) == 0) goto L0;",
                                                                                      "{LR}"] ),
("PyObject_Call_nokey",Kl_OperatorMethodCaller, None, Kl_Tuple, None,   Kl_O,        ["if (({LR} = PyObject_Call( {L1} , {L2} , NULL )) == 0) goto L0;",
                                                                                      "{LR}"] ),
("PyObject_Call_nokey",Kl_Undefined, None, Kl_Tuple, None,              Kl_Undefined,["if (({LR} = PyObject_Call( {L1} , {L2} , NULL )) == 0) goto L0;",
                                                                                      "{LR}"] ),

("PyObject_Call",      [(Kl_Undefined, None), (Kl_Tuple, None), (Kl_Dict, None)],Kl_O,["if (({LR} = PyObject_Call( {L1} , {L2} , {L3} )) == 0) goto L0;",
                                                                                      "{LR}"] ),
("all",                Kl_List, IsNotListCompr, None, None,             Kl_Boolean,   ["if (({LB} = _PyList_All( {L1} )) == -1) goto L0;",
                                                                                       "{LB}"], "_PyList_All"),
("any",                Kl_List, IsNotListCompr, None, None,              Kl_Boolean,   ["if (({LB} = _PyList_Any( {L1} )) == -1) goto L0;",
                                                                                       "{LB}"], "_PyList_Any"),
                                                                                        
#("PyObject_Call",      [(Kl_Undefined, None), (Kl_Tuple, None), (Kl_O, None)],   Kl_O,["if (({LR} = PyObject_Call( {L1} , {L2} , {L3} )) == 0) goto L0;",
#                                                                                      "{LR}"] ),
('FastCall0',          Kl_Undefined, None, None, None,                  Kl_O,        ["if (({LR} = FastCall0( {L1} )) == 0) goto L0;",
                                                                                       "{LR}"], "FastCall0"),
('FastCall',           Kl_Undefined, None, Kl_O, None,                  Kl_O,        ["if (({LR} = FastCall( 1 , {L1} , {L2} )) == 0) goto L0;",
                                                                                       "{LR}"], "FastCall"),
('FastCall',           Kl_Undefined, None, Kl_C, None,                  Kl_O,        ["if (({LR} = FastCall( 1 , {L1} , O{L2} )) == 0) goto L0;",
                                                                                       "{LR}"], "FastCall"),
('FastCall',           [(Kl_Undefined, None), (Kl_O, None), (Kl_O, None)],Kl_O,      ["if (({LR} = FastCall( 2 , {L1} , {L2} , {L3} )) == 0) goto L0;",
                                                                                       "{LR}"], "FastCall"),
('FastCall',           [(Kl_Undefined, None), (Kl_C, None), (Kl_O, None)],Kl_O,      ["if (({LR} = FastCall( 2 , {L1} , O{L2} , {L3} )) == 0) goto L0;",
                                                                                       "{LR}"], "FastCall"),
('FastCall',           [(Kl_Undefined, None), (Kl_O, None), (Kl_C, None)],Kl_O,      ["if (({LR} = FastCall( 2 , {L1} , {L2} , O{L3} )) == 0) goto L0;",
                                                                                       "{LR}"], "FastCall"),
('FastCall',           [(Kl_Undefined, None), (Kl_C, None), (Kl_C, None)],Kl_O,      ["if (({LR} = FastCall( 2 , {L1} , O{L2} , O{L3} )) == 0) goto L0;",
                                                                                       "{LR}"], "FastCall"),
('FastCall',           [(Kl_Undefined, None), (Kl_O, None), (Kl_O, None), (Kl_O, None)],Kl_O, ["if (({LR} = FastCall( 2 , {L1} , {L2} , {L3} , {L4} )) == 0) goto L0;",
                                                                                       "{LR}"], "FastCall"),
('FastCall',           [(Kl_Undefined, None), (Kl_O, None), (Kl_O, None), (Kl_C, None)],Kl_O, ["if (({LR} = FastCall( 2 , {L1} , {L2} , {L3} , O{L4} )) == 0) goto L0;",
                                                                                       "{LR}"], "FastCall"),
('FastCall',           Kl_Undefined, None, Kl_O, None,                  Kl_Boolean,  ["if (({LR} = FastCall( 1 , {L1} , {L2} )) == 0) goto L0;",
                                                                                      "({LR} == Py_True)"], "FastCall"),
('FastCall',           Kl_Undefined, None, Kl_C, None,                  Kl_Boolean,  ["if (({LR} = FastCall( 1 , {L1} , O{L2} )) == 0) goto L0;",
                                                                                      "({LR} == Py_True)"], "FastCall"),
## ("PyObject_Call_nokey",Kl_Undefined, None, Kl_Tuple, None,              Kl_Undefined,["if (({LR} = PyObject_Call( {L1} , {L2} , NULL )) == 0) goto L0;",
                                                                                       ## "{LR}"] ),
('cmp',                Kl_Int,      None, Kl_Int,   None,               (int, (-1, 1)),   '(({L1} < {L2}) ? -1 : ({L1} > {L2}) ? 1 : 0)'),
('cmp',                Kl_Boolean,  None, Kl_Boolean,None,              (int, (-1, 1)),   '(({L1} < {L2}) ? -1 : ({L1} > {L2}) ? 1 : 0)'),
('cmp',                Kl_Float,    None, Kl_Float, None,               (int, (-1, 1)),   '(({L1} < {L2}) ? -1 : ({L1} > {L2}) ? 1 : 0)'),
('cmp',                Kl_All,      None, Kl_Int,   None,               (int, (-1, 1)),   ['if ( PyObject_Cmp ( {L1} , O{L2} , &{LB} ) == -1) goto L0;', "{LB}"]),
('cmp',                Kl_Int,      None, Kl_All,   None,               (int, (-1, 1)),   ['if ( PyObject_Cmp ( O{L1} , {L2} , &{LB} ) == -1) goto L0;', "{LB}"]),
('cmp',                Kl_All,      None, Kl_All,   None,               (int, (-1, 1)),   ['if ( PyObject_Cmp ( {L1} , {L2} , &{LB} ) == -1) goto L0;', "{LB}"])
])

if True:
    linear_type_rule_rshift = [
    ("Rshift",      Kl_Short, None, Kl_Short, ArgIsConstFrom1To31, Kl_Short, "Py_ARITHMETIC_RIGHT_SHIFT(long, {L1}, {L2})"),
    ("Rshift",      Kl_Int,   None, Kl_Short, ArgIsConstFrom1To31, Kl_Int,   "Py_ARITHMETIC_RIGHT_SHIFT(long, {L1}, {L2})"),
    ("Rshift",      Kl_Int,   None, Kl_Int,   ArgIsConstCardinal,  Kl_Int,   "_PyInt_Rshift({L1}, {L2})", "_PyInt_Rshift"),
    ("Rshift",      Kl_Int,   None, Int(0, MInt),   None,Kl_Int,   "_PyInt_Rshift({L1}, {L2})", "_PyInt_Rshift"),
    ("Rshift",      Kl_Int,   None, Int(-MInt, -1), None,None,     False),
    ("Rshift",      Kl_Int,   None, Kl_Int,   None,                Kl_Int,   "_PyInt_Rshift({L1}, {L2})", "_PyInt_Rshift", ('{L2} < 0', 'PyErr_SetString(PyExc_ValueError, "negative shift count");')),
    ("Rshift",      Kl_Undefined,None, Kl_Short, ArgIsConstFrom1To31, Kl_Undefined,["if (PyInt_CheckExact({L1})) {",
                                                                                    "{LR} = PyInt_FromLong(Py_ARITHMETIC_RIGHT_SHIFT(long, PyInt_AS_LONG({L1}), {L2}));",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_Rshift( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
    ("InPlaceRshift",      Kl_Undefined,None, Kl_Short, ArgIsConstFrom1To31, Kl_Undefined,["if (PyInt_CheckExact({L1})) {",
                                                                                    "{LR} = PyInt_FromLong(Py_ARITHMETIC_RIGHT_SHIFT(long, PyInt_AS_LONG({L1}), {L2}));",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_InPlaceRshift( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
    
    ## ("Rshift",             Kl_Short, None, Kl_Short, ArgIsConstFrom1To31, Kl_Short, "Py_ARITHMETIC_RIGHT_SHIFT(long, {L1}, {L2})"),
    ## ("Rshift",             Kl_Int,   None, Kl_Short, ArgIsConstFrom1To31, Kl_Int,   "Py_ARITHMETIC_RIGHT_SHIFT(long, {L1}, {L2})"),
    ## ("Rshift",             Kl_Int,   None, Kl_Int,   ArgIsConstCardinal,  Kl_Int,   "_PyInt_Rshift({L1}, {L2})", "_PyInt_Rshift"),
##    ("Rshift",             Kl_Int,   None, Int(0, MInt),   None,Kl_Int,   "_PyInt_Rshift({L1}, {L2})", "_PyInt_Rshift"),
##    ("Rshift",             Kl_Int,   None, Int(-MInt, -1), None,None,     False),
##    ("Rshift",             Kl_Int,   None, Kl_Int,   None,                Kl_Int,   "_PyInt_Rshift({L1}, {L2})", "_PyInt_Rshift", ('{L2} < 0', 'PyErr_SetString(PyExc_ValueError, "negative shift count");')),
    ]                           
else:
    linear_type_rule_rshift = [
    ("Rshift",      Kl_Short, None, Kl_Short, ArgIsConstFrom1To31, Kl_Short, "({L1} >> {L2})"),
    ("Rshift",      Kl_Int,   None, Kl_Short, ArgIsConstFrom1To31, Kl_Int,   "({L1} >> {L2})"),
    ("Rshift",      Kl_Int,   None, Kl_Int,   ArgIsConstCardinal,  Kl_Int,   "_PyInt_Rshift({L1}, {L2})", "_PyInt_Rshift"),
    ("Rshift",      Kl_Int,   None, Int(0, MInt),   None,Kl_Int,   "_PyInt_Rshift({L1}, {L2})", "_PyInt_Rshift"),
    ("Rshift",      Kl_Int,   None, Int(-MInt, -1), None,None,     False),
    ("Rshift",      Kl_Int,   None, Kl_Int,   None,                Kl_Int,   "_PyInt_Rshift({L1}, {L2})", "_PyInt_Rshift", ('{L2} < 0', 'PyErr_SetString(PyExc_ValueError, "negative shift count");')),
    ("Rshift",      Kl_Undefined,None, Kl_Short, ArgIsConstFrom1To31, Kl_Undefined,["if (PyInt_CheckExact({L1})) {",
                                                                                    "{LR} = PyInt_FromLong(PyInt_AS_LONG({L1}) >> {L2});",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_Rshift( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
    ("InPlaceRshift",      Kl_Undefined,None, Kl_Short, ArgIsConstFrom1To31, Kl_Undefined,["if (PyInt_CheckExact({L1})) {",
                                                                                    "{LR} = PyInt_FromLong(PyInt_AS_LONG({L1}) >> {L2});",
                                                                                    "} else {",
                                                                                    "if (({LR} = PyNumber_InPlaceRshift( {L1} , O{L2} )) == 0) goto L0;",
                                                                                    "}",
                                                                                    "{LR}"]),
    
    ## ("Rshift",             Kl_Short, None, Kl_Short, ArgIsConstFrom1To31, Kl_Short, "({L1} >> {L2})"),
    ## ("Rshift",             Kl_Int,   None, Kl_Short, ArgIsConstFrom1To31, Kl_Int,   "({L1} >> {L2})"),
    ## ("Rshift",             Kl_Int,   None, Kl_Int,   ArgIsConstCardinal,  Kl_Int,   "_PyInt_Rshift({L1}, {L2})", "_PyInt_Rshift"),
##    ("Rshift",             Kl_Int,   None, Int(0, MInt),   None,Kl_Int,   "_PyInt_Rshift({L1}, {L2})", "_PyInt_Rshift"),
##    ("Rshift",             Kl_Int,   None, Int(-MInt, -1), None,None,     False),
##    ("Rshift",             Kl_Int,   None, Kl_Int,   None,                Kl_Int,   "_PyInt_Rshift({L1}, {L2})", "_PyInt_Rshift", ('{L2} < 0', 'PyErr_SetString(PyExc_ValueError, "negative shift count");')),
    ]                           
    
linear_type_rule += linear_type_rule_rshift
linear_type_rule = tuple(linear_type_rule)

def compress_linear_type_rule2():
##    d2 = {}
    d = {}
    for v in linear_type_rule:
        d[v[0]] = []
    for v in linear_type_rule:
        v2 = list(v[1:])
        if type(v2[0]) is list:
            v2 = [v2[0], None, None, None] + v2[1:]
        elif v2[2] is None and v2[3] is None:
            v2[0] = [(v2[0], v2[1])]
            v2[1] = None        
            v2[2] = None
            v2[3] = None
        else:
            v2[0] = [(v2[0], v2[1]), (v2[2], v2[3])]
            v2[1] = None        
            v2[2] = None
            v2[3] = None
  #      v25 = v2[5]
  #      if type(v25) is list:
  #          v25 = tuple(v25)
  #      if (v[0], v25) not in d2:    
  #          d2[(v[0], v25)] = []              
  #      d2[(v[0], v25)].append(v2)
        if tuple(v2) in d[v[0]]:
            pp('           Dublicate Case', tuple(v2))
        else:
            for old in d[v[0]]:
                if old[:5] == tuple(v2[:5]):
                    pp('redefine1', v[0], old)
                    pp('redefine2', v[0], v2)
                    print
        d[v[0]].append(tuple(v2))
  #  k1 = [(len(d2[k]), k) for k in d2.keys()]
  #  k1.sort()
  #  for n, k in k1:

  #      for i in range(n):

    
    return d
        
global dict_type_rule2 
dict_type_rule2 = compress_linear_type_rule2()

def attempt_direct_type_generation(it, o, forcenewg):
    assert type(it) is tuple
    assert type(o) is Out   
    t = TypeExpr(it)
    o2, s, ty, checktupl, checktuplerr = attempt_str_direct_type_generation(it, t, None, None, None, forcenewg)
    assert type(ty) is set
    if s is None:
        return None

    labl_err = add_check_message(checktupl, checktuplerr, o2)
    if IsC(t):
        if forcenewg is not None:
            new = forcenewg
        else:
            new = New()  

        if IsInt(t):
            o2.PushInt(new, s)
        elif IsFloat(t):
            if type(s) is str and s == 'nan':
                s = 'Py_NAN'
            o2.Raw(new, ' = PyFloat_FromDouble ( ', s, ' );')
        elif IsBool(t):
            o2.Raw(new, ' = PyBool_FromLong ( ', s, ' );')        
        elif IsChar(t):
            o2.Raw(new, ' = PyString_FromStringAndSize ( NULL , 1 );')  
            assert '*PyString_AS_STRING(*PyString_AS_STRING' not in s
            o2.Raw('PyString_AS_STRING(', new, ')[0] = ', s, ';')     
        else:
            pp(t, it)
            assert False
    elif s.startswith('PyList_GET_ITEM') or s.startswith('PyTuple_GET_ITEM') or s.startswith('(PyObject *)Py_TYPE'):
        if s.startswith('temp[') and s.endswith(']') and forcenewg is None:
            new = reactivate_tempref(s)
        else:
            if forcenewg is not None:
                new = forcenewg
            else:
                new = New() 
        if s != CVar(new):
            o2.Raw(new, ' = ', s, ';')  
            o2.INCREF(new)   
        ##    if s.startswith('temp['):
        ##    pprint(o2)
    elif t == Kl_None:
        new = ('CONST', None)
    elif IsO(t):
        ## print '//s,=', s, t
        ## pprint(it)
        ## pprint(o2)
        ## pprint(o2)
        new = reactivate_tempref(s)

        ## pprint(it)
        ## pprint(o2)
    else:
        pprint(o)
        pprint(o2)
        pprint(it)
        pp(s, TypeExpr(it[1]))
        Fatal('Undefined push type', t, it, s)
        pprint(o2)
        assert False
    for v in ty:
        if v != new:
            o2.Cls(v)
    o2.Cls(s)
    o.extend(o2)
    return new
    
def generate_int_expr(it, o, check = False):
    assert type(it) is tuple
    assert type(o) is Out    
    t = TypeExpr(it)
    if t == (bool, True):
        it = ('CONST', 1)
    if t == (bool, False):
        it = ('CONST', 0)
    t = TypeExpr(it)
    if not check:
        assert IsInt(t)  
    check = check and not IsInt(t)  
    if IsInt(t): 
        if t[1][1] == t[1][0]:
            return t[1][1]
        if it[0] == '!@PyInt_FromSsize_t':
            if IsInt(TypeExpr(it[2])):
                return generate_int_expr(it[2], o, check)
            return it[1]

        if it[0] == 'PY_TYPE' and it[1] is int and it[3][0] == 'FAST':
            if not g_co.IsCVar(it[3]):
                return ConC('PyInt_AS_LONG ( ', it[3], ' )')
            else:
                return CVarName(it[3])
        if it[0] == 'FAST':
            if not g_co.IsCVar(it):
                return ConC('PyInt_AS_LONG ( ', it, ' )')
            else:
                return CVarName(it)        
        if it[0] == 'PY_TYPE' and it[1] is int and it[3][0] == '!LOAD_GLOBAL':
            if not g_co.IsCVar(it[3]):
                return ConC('PyInt_AS_LONG ( ', it[3], ' )')
            else:
                return CVarName(it[3])
        if it[0] == '!LOAD_GLOBAL':
            if not IsCVar(it):
                if (build_executable and fast_globals):
                    return ConC('PyInt_AS_LONG ( ', it, ' )')
            else:
                return CVarName(it)        
    o2, s, ty, checktupl, checktuplerr = attempt_str_direct_type_generation(it, Kl_Int)
    assert type(ty) is set
    if s is None:
        if IsInt(t):
            if it[0] == 'CONST':
                return it[1]
            if it[0] == '!PyObject_GetAttr' and it[1][0] == 'PY_TYPE':
                o3 = Out()
                ref1 = Expr1(it, o3)
                assign_ref = ConC(CVar(ref1), ' = ')
                if len(o3) == 2 and o3[1].startswith('Py_INCREF(temp[') and o3[0].startswith(assign_ref):                    
                    assign_ref = 'PyInt_AS_LONG ( ' + o3[0][len(assign_ref):-1] + ' )'
                    o3.Cls(ref1)
                    return assign_ref
                o3.Cls(ref1)
                    
        if it[0] == 'FAST' and not IsCVar(it):
            assert check
            if not check:
                assert IsInt(t) 
                return 'PyInt_AS_LONG ( GETLOCAL(' + nmvar_to_loc(it[1]) + ') )'
            ind1 = New('long')
            o.Stmt(ind1, '=', 'PyInt_AsLong', it)
            return ind1
            
        return None

    labl_err = add_check_message(checktupl, checktuplerr, o2)     
    ## if not IsInt(t):

        ## pprint(o2)
        ## pprint(it)

#        s = 'PyInt_ASL_LONG(' + s + ')'
#    assert IsInt(t)
    if len([v for v in ty if istempref(v)]) > 0:
        ind1 = New('long')
        o2.Raw(ind1, ' = ', s, ';')
        for v in ty:
            o2.Cls(v)
        o.extend(o2)
        s = ind1
    else:
        for v in ty:
            o2.Cls(v)
        o.extend(o2)
    return s

def istemp(v):
    return istempref(v) or istemptyped(v)

def IsC(t):
    global Kl_C
    return type(t) is tuple and (IsChar(t) or IsInt(t) or IsFloat(t) or IsBool(t) or bool(t == Kl_C))

def IsO(t):
    return not IsC(t)

def IsProbablyInt(t):
    if t is None:
        return True
    assert type(t) is tuple and len(t) == 2
    if IsMayBe(t):
        return IsInt(t[1]) or IsIntUndefSize(t[1])
    if IsIntUndefSize(t):
        return True
    return False

def _match_type(typ_comp, type_expr):
    if type_expr is None:
        if typ_comp is Kl_Undefined or typ_comp is Kl_O or typ_comp is Kl_O or typ_comp is Kl_ProbablyInt or typ_comp is Kl_All:
            return True
        return False
    assert type(typ_comp) is tuple and len(typ_comp) == 2
    assert type(type_expr) is tuple and len(type_expr) == 2
    if type_expr is typ_comp:
        return True
    typ_comp0 = typ_comp[0]
    if type(typ_comp0) is str:
        if type(type_expr[0]) is str and type_expr[0] == typ_comp0 and type_expr[1] == typ_comp[1]:
            return True
        if typ_comp is Kl_All: 
            return True
        if typ_comp is Kl_O:
            return IsO(type_expr)  
        if typ_comp is Kl_ProbablyInt: 
            return IsProbablyInt(type_expr)  
        if typ_comp is Kl_C: # or typ_comp == Kl_C:
            return IsC(type_expr)       
        if typ_comp is Kl_MayBe: # or typ_comp == Kl_MayBe:
            return IsMayBe(type_expr) 
        if typ_comp is Kl_OString: # or typ_comp == Kl_OString:
            return IsStr(type_expr) and not IsC(type_expr)      
        if typ_comp is Kl_NewType: # or typ_comp == Kl_NewType:
            return IsNewType(type_expr)
        if typ_comp is Kl_OldType: # or typ_comp == Kl_OldType:
            return IsOldType(type_expr)        
        if typ_comp is Kl_NewInst: # or typ_comp == Kl_NewInst:
            return IsNewInst(type_expr)
        if typ_comp is Kl_OldInst: # or typ_comp == Kl_OldInst:
            return IsOldInst(type_expr)
        if IsMayBe(typ_comp):
            if type_expr == Kl_None:
                return True
            if IsMayBe(type_expr):
                return _match_type(typ_comp[1], type_expr[1])        
            if typ_comp[1] is not None:
                return _match_type( typ_comp[1], type_expr )
            return False
    else:
        if type_expr[0] is typ_comp0 and type_expr[1] == typ_comp[1]:
            return True    
        if typ_comp is Kl_Tuple:# or typ_comp == Kl_Tuple:
            return IsTuple(type_expr)
        if typ_comp is Kl_Boolean:
            return IsBool(type_expr)
        if typ_comp is Kl_List:
            return IsList(type_expr)
        if typ_comp is Kl_Char: # or typ_comp == Kl_Char:
            return IsChar(type_expr)       
        if typ_comp is Kl_UnicodeChar: # or typ_comp == Kl_UnicodeChar:
            return IsUnicodeChar(type_expr)       
        if typ_comp is Kl_File: # or typ_comp == Kl_File:
            return IsFile(type_expr)   
        if typ_comp is Kl_String: # or typ_comp == Kl_String:
            return IsStr(type_expr)       
        if typ_comp is Kl_Unicode: # or typ_comp == Kl_Unicode:
            return IsUnicode(type_expr)       
        if typ_comp is Kl_Code: # or typ_comp == Kl_Code:
            return IsCode(type_expr)       
        if typ_comp is Kl_Function: # or typ_comp == Kl_Function:
            return IsFunction(type_expr)
        if typ_comp is Kl_Type: # or typ_comp == Kl_Type:
            return IsType(type_expr)   
        if typ_comp is Kl_Int: # or typ_comp == Kl_Type:
            return IsInt(type_expr)  
        if typ_comp is Kl_BuiltFunc:
            return IsBuiltFunc(type_expr) 
        if IsInt(typ_comp) and IsInt(type_expr):
            return IsIntInAnotherInt(type_expr, typ_comp)
        if IsType(typ_comp) and IsType(type_expr):
            if type_expr[1] is None:
                if typ_comp[1] is None:
                    return True
                else:
                    return False  
            if type(typ_comp[1]) is not tuple and type(type_expr[1]) is tuple:
                    return _match_type((typ_comp[1], None), type_expr[1])
            if type(typ_comp[1]) is type and type(type_expr[1]) is type:
                return bool(typ_comp[1] == type_expr[1])
            return _match_type(typ_comp[1], type_expr[1])
        if IsModule(typ_comp) and IsModule(type_expr):
            return typ_comp[1] is None or bool(typ_comp[1] == type_expr[1])
        if IsTuple(typ_comp):
            if type(typ_comp[1]) is int:
                if IsTuple(type_expr):
                    if type(type_expr[1]) is tuple:
                        return bool(typ_comp[1] == len(type_expr[1]))
                    if type(type_expr[1]) is int:
                        return bool(typ_comp[1] == type_expr[1])
            elif type(typ_comp[1]) is tuple:
                if IsTuple(type_expr):
                    if type(type_expr[1]) is tuple and len(type_expr[1]) >= len(typ_comp[1]):
                        return all([_match_type(comp1, type_expr[1][i]) if comp1 is not None else True for i, comp1 in enumerate(typ_comp[1])])
                    elif type(type_expr[1]) is int:
                        return bool(len(typ_comp[1]) == type_expr[1]) and bool(typ_comp[1] == tuple([None for i in range(type_expr[1])]))
    return False

def match_type(typ_comp, check_comp, type_expr, expr):
    if not _match_type(typ_comp, type_expr):
        return False
    if check_comp is not None:
        if type(expr) is tuple:
            if type(check_comp) is str:
                if expr[0] == check_comp:
                    return True
                return False
            if type(check_comp) is tuple:
                return check_comp == expr
        if not check_comp(expr, type_expr):
            return False
    return True    

def andor_attempt_str_direct_type_generation(it, op):
    li = []
    success = True
    for i, x in enumerate(it[1:]):
        t00 = TypeExpr(x)
        if not IsBool(t00):
            if t00 is None and (x[0] == '!PyObject_RichCompare' or x[0] == '!PyObject_RichCompare('):
                pass
            else:
                x = ('!PyObject_IsTrue', x)
        o, patt, ty, checktupl, checktuplerr = attempt_str_direct_type_generation(x, Kl_Boolean)
        assert type(ty) is set
        if i == 0 and patt is None:
            success = False
            break
        if i > 0 and patt is None:
            success = False
            break
        if i > 0 and ((o is not None and len(o) > 0) or checktupl is not None or checktuplerr is not None):
            li.append((o, patt, ty, checktupl, checktuplerr))
            success = False
            break
        li.append((o, patt, ty, checktupl, checktuplerr))
    if not success:
        for o, patt, ty, checktupl, checktuplerr in li:
            if ty is not None:
                o.Cls(*ty)
        return None, None, set(), None, None     
    o2 = Out()
    ty2 = set()    
    patt2 = '(' + op.join([patt for o, patt, ty, checktupl, checktuplerr in li]) + ')'
    for o, patt, ty, checktupl, checktuplerr in li:
        o2.extend(o)
        ty2 = ty2 | ty
        
    return o2, patt2, ty2, li[0][3], li[0][4]

_tagvars =set (('CONST', 'FAST', 'CONST', 'LOAD_GLOBAL', 'CALC_CONST', 
                'LOAD_BUILTIN', 'glob', 'PY_TEMP', 'TEMP_TYPED', 'NULL',
                'LOAD_NAME', '!LOAD_NAME', 'BUILD_TUPLE', '!BUILD_TUPLE', 
                'BUILD_LIST', '!BUILD_LIST'))

def GenericType(t, it = None):
    S = ''
    if IsC(t) and it is not None:
        if ArgNotIsCVar(it, t):
            S = ',O'
        else:
            S = ',C'
    if IsType(t):
        return 'Kl_Type'
    if IsInt(t):
        if t[1] == ((MInt * -1)-1, (MInt * -1)-1):
            return 'Kl_MinimalInt' + S
        return 'Kl_Int' + S
    if IsTuple(t):
        if it is not None:
            if it[0] in ('!BUILD_TUPLE', 'CONST'):
                return 'Kl_Tuple,C'
        return 'Kl_Tuple'
    if IsList(t):
        return 'Kl_List'
    if IsBool(t):
        if t == (bool, True):
            return 'Kl_Boolean_True'
        if t == (bool, False):
            return 'Kl_Boolean_False'
        return 'Kl_Boolean' + S
    if IsFloat(t):
        return 'Kl_Float' + S
    if IsDict(t):
        return 'Kl_Dict'
    if IsChar(t):
        return 'Kl_Char' + S
    if IsStr(t):
        return 'Kl_String'
    if IsLong(t):
        return 'Kl_Long'
    if t is None:
        return '{*}'
    if type(t) is tuple and t[0] == 'MayBe':
        arg = GenericType(t[1], it)
        if type(arg) is not str:
            arg = str(arg)
        return 'MayBe(' + arg + ')'
    return t

def is_nano(x):
    if type(x) is tuple and len(x) == 2 and x[0] == 'CONST':
        x1 = x[1]
        if type(x1) is float:
            if math.isinf(x1) or math.isnan(x1):
                return True
    return False
 
def reorg_before(it, t0):
    assert type(it) is tuple

    it_ = it
    head = it[0]
    assert type(head) is str
    if head[0] == '!':
        head = head[1:]
    while True:
        assert type(head) is str
        if head == 'PyObject_Call':
            if it[1][0] == '!LOAD_BUILTIN' and it[3] == ('NULL',):
                if it[2][0] == '!BUILD_TUPLE':
                    if it[1][1] in ('min', 'max', 'dict', 'open', 'round', 'exit', 'unichr') and len(it[2][1]) == 1 and TypeExpr(it[2][1][0]) is None:
                        pass
                    elif it[1][1] in ('unicode', 'filter', 'reduce', 'range') and len(it[2][1]) == 2 and TypeExpr(it[2][1][0]) is None and TypeExpr(it[2][1][1]) is None:
                        pass
                    elif it[1][1] in ('coerce', 'open', 'sum', 'round', 'reversed', 'compile'):
                        pass                        
                    else:
                        head = it[1][1]
                        it = (head,) + it[2][1]
                        continue
                if it[2][0] == 'CONST':
                    head = it[1][1]
                    it = (head,) + tuple([('CONST', x) for x in it[2][1]])
                    continue
            elif  it[1][0] == '!PyObject_GetAttr' and it[3] == ('NULL',):
                if (it[1][2][0] == 'CONST' or it[1][2][0] == '!LOAD_BUILTIN') and type(it[1][2][1]) is str:
                    args = None
                    if it[2][0] == 'CONST':
                        args = tuple([('CONST', x) for x in it[2][1]])
                    elif it[2][0] == '!BUILD_TUPLE':    
                        args = tuple([x for x in it[2][1]])
                    if args is not None:
                        if TypeExpr(it[1][1]) is not None:
                            it = ('!M:'+it[1][2][1],) + (it[1][1],) + args
                            head = it[0]
                            if head[0] == '!':
                                head = head[1:] 
                            continue           
            elif  it[1][0] == 'CALC_CONST' and it[3] == ('NULL',):
                args = None
                tuplcall = None
                if it[2][0] == 'CONST':
                    args = tuple([('CONST', x) for x in it[2][1]])
                elif it[2][0] == '!BUILD_TUPLE':    
                    args = tuple([x for x in it[2][1]]) 
                nm = it[1][1]
                if type(nm) is str and nm in ImportedM:
                    tuplcall = ImportedM[nm]
                    if type(tuplcall) is tuple:
                        tuplcall +=  ('()',)
                        if tuplcall not in t_imp:
                            tuplcall = None
                elif type(nm) is tuple and len(nm) == 2 and args is not None:
                    it = ('!M:'+nm[1],) + (('CALC_CONST', nm[0]),) + args
                    head = it[0]
                    if head[0] == '!':
                        head = head[1:] 
                    continue
                if tuplcall is not None and args is not None:
                    it = ('!M:'+tuplcall[1],) + (('PY_TYPE', ) + New_Kl_Module(tuplcall[0]) + (('CALC_CONST', tuplcall[0]),None),) + args
                    head = it[0]
                    if head[0] == '!':
                        head = head[1:] 
                    continue
            if it[3] == ('NULL',) and TypeExpr(it[1]) is None:
                if it[2][0] in ('!BUILD_TUPLE', 'CONST'):
                    if len(it[2][1]) == 0:
                        it = ('FastCall0', it[1])
                        head = it[0]
                        continue    
                    # elif len(it[2][1]) == 1:
                    #     it = ('FAST_CALL1', it[1], it[2][1][0])
                    #     head = it[0]
                    #     continue    
                    else:
                        if it[2][0]  == '!BUILD_TUPLE':
                            tupl = it[2][1]
                        elif it[2][0]  == 'CONST':
                            tupl = tuple([('CONST', x) for x in it[2][1]])
                        else:
                            assert False    
                        it = ('FastCall', it[1]) + tupl
                        head = it[0]
                        continue  
            if it[3] == ('NULL',):
                head = 'PyObject_Call_nokey'  
                it = (head, it[1], it[2])
                continue

        if head in ('all', 'any', 'PyList_GET_SIZE', 'sum'):
            if len(it) == 2 and it[1][0] == '!LIST_COMPR':
                if len(it[1][1]) == 1:
                    head =  head + ',LIST_COMPR_Simple'
                    it  = (head,) + it[1][1] + it[1][2:]
                    assert len(it) == 3
                    it = it[:2] + it[2]
                    ##print '--', [TypeExpr(x) for x in it[1:]]
                    it = list(it)
                    assert len(it[3]) == 1
                    it[3] = it[3][0]
                    if it[4] is not None:
                        assert len(it[4]) == 1
                        it[4] = it[4][0]
                    else:
                        del it[4]
                    it = tuple(it)
                else:
                    head =  head + ',LIST_COMPR'
                    it  = (head,) + it[1][1:]
                ## pprint(it)
                continue
        if head in ('max', 'min') and len(it) > 2:
            ty = [TypeExpr(x) for x in it[1:]]
            if (any([IsC(x) for x in ty]) and any([IsO(x) for x in ty])) or None in ty: 
                if all([x[0] == 'CONST' for x in it[1:]]):
                    it = (head, ('CONST', tuple ([x[1] for x in it[1:]])))
                    continue
                it = (head, ('!BUILD_TUPLE', tuple ([x for x in it[1:]])))
                continue
                
        if head == 'PY_SSIZE_T':
            it = it[1]
            head = it[0]
            if head[0] == '!':
                head = head[1:] 
            if t0 is None:
                t0 = Kl_Cardinal
            continue
        if head == 'BOOLEAN':
            it = it[1]
            head = it[0]
            if head[0] == '!':
                head = head[1:]
            if t0 is None:
                t0 = Kl_Boolean
            continue
        if head.startswith('c_Py_') and head.endswith('_String'):
            it = ('!PyObject_RichCompare', it[1], it[2], 'Py_' + head[5:7])
            assert type(it[2]) is not str
            head = it[0]
            if head[0] == '!':
                head = head[1:]            
            continue
        if head.startswith('c_Py_') and head.endswith('_Int'):
            assert type(it[2]) is not int
            it = ('!PyObject_RichCompare', it[1], it[2], 'Py_' + head[5:7])
            head = it[0]
            if head[0] == '!':
                head = head[1:]            
            continue
        if head.startswith('SSIZE_T') and head[7:] in op_2_c_op:
            assert type(it[2]) is int
            it = ('!PyObject_RichCompare', it[1], ('CONST', it[2]), op_2_c_op[head[7:]])
            head = it[0]
            if head[0] == '!':
                head = head[1:]            
            continue 
        if head == '_PyString_ctype':
            it = (it[2], it[1])           
            head = it[0]
            if head[0] == '!':
                head = head[1:]            
            continue 
        if head == 'PyBool_Type.tp_new':
            t_temp = TypeExpr(it[2])
            if IsTuple(t_temp) and type(t_temp) is tuple and len(t_temp[1]) == 1:
                is_const = bool(it[2][0] == 'CONST')
                if IsBool(t_temp[1][0]):
                    assert not is_const 
                    it = it[2][1][0]
                    head = it[0]
                    if head[0] == '!':
                        head = head[1:]            
                    continue 
                else:
                    if is_const: 
                        it = ('!PyObject_IsTrue', ('CONST', it[2][1][0]))
                    else:
                        it = ('!PyObject_IsTrue', it[2][1][0])
                    head = it[0]
                    if head[0] == '!':
                        head = head[1:]            
                    continue 
        if head == 'PyInt_Type.tp_new':
            t_temp = TypeExpr(it[2])
            if IsTuple(t_temp) and type(t_temp) is tuple and len(t_temp[1]) == 1:
                is_const = bool(it[2][0] == 'CONST')
                if IsInt(t_temp[1][0]): 
                    assert not is_const 
                    it = it[2][1][0]
                    head = it[0]
                    if head[0] == '!':
                        head = head[1:]            
                    continue 
                else:
                    assert not is_const 
                    it = ('Int', it[2][1][0])
                    head = it[0]
                    if head[0] == '!':
                        head = head[1:]            
                    continue 

        if head == 'NCMP':
            li = []
            ops = []
            i = 1
            li.append(it[1][0])
            while i < len(it[1]):
                ops.append(it[1][i]) 
                li.append(it[1][i+1])
                i += 2
            head = ','.join(ops)
            it = (head,) + tuple(li)
            continue
        if IsStr(TypeExpr(it_)):
            if head == 'PyNumber_Add' and any([x[0] == '!PyNumber_Add' for x in it[1:]]):
                li = []
                for x in it[1:]:
                    if x[0] == '!PyNumber_Add':
                        li.append(x[1])
                        li.append(x[2])
                    else:
                        li.append(x)
                assert len(li) >= len(it)
                it = (head,) + tuple(li)
                continue    
            if head == 'PyNumber_Multiply' and any([x[0] == '!PyNumber_Multiply' for x in it[1:]]):
                li = []
                for x in it[1:]:
                    if x[0] == '!PyNumber_Multiply':
                        li.append(x[1])
                        li.append(x[2])
                    else:
                        li.append(x)
                it = (head,) + tuple(li)
                continue    

        if head in ('PyObject_RichCompare(', 'PyObject_RichCompare'):
            head = it[3]
            it = (head, it[1], it[2])
            if it[2][0] == '!PyNumber_Subtract' and not IsInt(TypeExpr(it[2])) and IsInt(TypeExpr(it[1])):
                if IsInt(TypeExpr(it[2][2])):
                    tupl = ('!PyNumber_Add', it[1], it[2][2])
                    if IsInt(TypeExpr(tupl)):
                        it = (head, tupl, it[2][1])
            continue
        if head.endswith('('):
            head = head[:-1]
            it = (head,) + it[1:] 
            continue
        if head.startswith('Py_') and IsBool(TypeExpr(it_)) and it[1][0] == '!PyNumber_Add' and IsIntUndefSize(TypeExpr(it[1])):
            tupl = ('!PyNumber_Subtract', it[2], it[1][2])
            if IsInt(TypeExpr(tupl)):
                it = (head, it[1][1], tupl)
                continue
            head = 'Add,' + head
            it = (head, it[1][1], it[1][2], it[2])
            continue  
        if head == 'CLASS_CALC_CONST_NEW' and type(it[1]) is str and len(it) == 3:
            it = (head, ('CALC_CONST', it[1]), ('CONST', CodeInit(it[1]) is None), it[2])
            continue
        if head == 'IMPORT_NAME':
            importer = ('!PyDict_GetItem', 'bdict', ('CONST', '__import__')) 
            if g_co.c_name == 'Init_filename':
                loc = 'glob'
            elif is_current & IS_DICTIONABLE_CFUNC:
                loc = '_f_locals'
            else:
                loc = 'f->f_locals == 0 ? Py_None : f->f_locals'

            if it[2][0] == 'CONST' and it[2][1] == -1:
                it3 = it[3]
                if it3 == ('CONST', None):
                    it3 = ('Py_None',)
                tupl = ('!BUILD_TUPLE', ( ('CONST',it[1]), \
                                            ('glob',), \
                                            (loc,),\
                                            it3))  

            else:        
                tupl = ('!BUILD_TUPLE', ( ('CONST',it[1]), \
                                            ('glob',), \
                                            (loc,),\
                                            it[3], it[2]))  
    
            it = ('PY_TYPE', types.ModuleType, it[1], ('!PyEval_CallObject', importer, tupl), None)    
            head = it[0]
            continue
        if head == 'PySequence_List' and IsList(TypeExpr(it[1])):
            it = it[1]
            head = it[0]
            if head[0] == '!':
                head = head[1:]
            continue

        break
    if  head in ('STR_CONCAT2', 'STR_CONCAT3'):
        head = 'STR_CONCAT'
        it = (head,) + it[1:]
    elif  head in ('STR_CONCAT_N',):
        head = 'STR_CONCAT'
        it = (head,) + it[2:]
    if head == 'STR_CONCAT':
        li = [head]
        for x in it[1:]:
            if x[0] in ('!STR_CONCAT','!STR_CONCAT2', '!STR_CONCAT3', '!PyNumber_Add'):
                li.extend(x[1:])
            elif x[0] == '!STR_CONCAT_N':
                li.extend(x[2:])
            else:
                li.append(x)
        it = tuple(li)

    if head == 'STR_CONCAT':
        is_only_str = all([IsStr(TypeExpr(x)) for x in it[1:]])
        if is_only_str and len(it) > 6:
            while len(it) > 6:
                it_new = resemble_str_concat(it[1:])
                if tuple(it_new) != it[1:]:
                    it = (head,) + tuple(it_new) 
                else:
                    pprint(it)
                    assert False
        elif not is_only_str:
            li = list(it[1:])
            li2 = [(IsStr(TypeExpr(x)), i3) for i3,x in enumerate(li)]
            gr2 = []
            for k, g in groupby( li2 ,key=lambda x:x[0]):
                if k:
                    g = [x[1] for x in g] 
                    if len(g) > 1:
                        gr2.append((g[0], len(g))) 
            for i, l in reversed(gr2):
                li_new = list(resemble_str_concat(tuple(li[i: i+l])))
                if len(li_new) > 1:
                    li_new = [('!' + head,) + tuple(li_new)]
                li = li[:i] + li_new + li[i+l:]
            it = (head,) + tuple(li) 
        if head == 'STR_CONCAT' and len(it) == 3 and not IsStr(TypeExpr(it[1])) and not IsStr(TypeExpr(it[2])):
            pprint(it_)
            pprint(it)
            assert False

    if head == 'STR_CONCAT':
        li = [IsStr(TypeExpr(x)) for x in it[1:]]
        if not all(li):
            if li == [True, False] or li == [False, True]:
                head = 'PyNumber_Add'
                it = ('!' + head,  it[1], it[2])
            elif len(li) == 3:
                head = 'PyNumber_Add'
                it = ('!' + head, ('!' + head, it[1], it[2]), it[3])
            elif len(li) > 2:
                n_it = None
                head = 'PyNumber_Add'
                for i in range(len(li)-1):
                    if i == 0:
                        n_it = ('!' + head, it[i+1], it[i+2])
                    else:
                        n_it = ('!' + head, n_it, it[i+2])
                it = n_it

    assert type(head) is str
    if head == 'PyNumber_Add' and len(it) > 3 and not IsC(TypeExpr(it_)):
        while len(it) > 3:
            tupl = ('!PyNumber_Add', it[-2], it[-1])
            if not IsInt(TypeExpr(tupl)):
                break
            it = it[:-2] + (tupl,)
        if IsIntUndefSize(TypeExpr(it_)) and len(it) > 3:
            while len(it) > 3:
                tupl = ('!PyNumber_Add', it[1], it[2])
                it = it[:1] + (tupl,) + it[3:]
    elif head == 'PyNumber_Subtract' and not IsC(TypeExpr(it_)):
        while it[1][0] == '!PyNumber_Subtract':
            tupl = ('!PyNumber_Add', it[1][2], it[2])
            if not IsInt(TypeExpr(tupl)):
                break
            it = ('PyNumber_Subtract', it[1][1], tupl)
    if head in ('PySequence_GetSlice', 'PyTuple_GetSlice', 'PyList_GetSlice', '_PyEval_ApplySlice'):
        li = list(it)
        if type(li[2]) is int:
            li[2] = ('CONST', li[2])
        elif li[2] == 'NULL':
            li[2] = ('CONST', 0)
        elif li[2] == 'PY_SSIZE_T_MAX':
            li[2] = ('CONST', sys.maxsize)
        if type(li[3]) is int:
            li[3] = ('CONST', li[3])
        elif li[3] in ('PY_SSIZE_T_MAX', 'NULL'):
            li[3] = ('CONST', sys.maxsize)
        if head == '_PyEval_ApplySlice':
            if IsCardinal(TypeExpr(li[2])) and IsCardinal(TypeExpr(li[3])):
                t = TypeExpr(li[1])
                if IsList(t):
                    li[0] = 'PyList_GetSlice'
                    head = 'PyList_GetSlice'
                elif IsTuple(t):
                    li[0] = 'PyTuple_GetSlice'
                    head = 'PyTuple_GetSlice'
        if head == '_PyEval_ApplySlice':
            if IsInt(TypeExpr(li[2])) and IsInt(TypeExpr(li[3])):
                li[0] = 'PySequence_GetSlice'
                head = 'PySequence_GetSlice'
        it = tuple(li)

    if head.startswith('PyNumber_'):
        head = head[9:]
    assert type(head) is str
    if head.startswith('InPlace') and IsC(TypeExpr(it[1])):
        head = head[7:]
    assert type(head) is str        
    if head == 'Power':
        if len(it) > 3 and it[3] == 'Py_None':
            it = (head, it[1], it[2])  
    if IsList(t0):
        t0 = Kl_List
    # if '!PyDict_Contains' in repr(it) and 'AND' in it[0]:
    ## if it[0] in ('!AND_JUMP', '!AND_BOOLEAN'):
        ## it2 = in_dict_contains(it[1])
        ## if it2 is not None and it[2][0] != '!CALL_CALC_CONST' :
            ## it_a = find_use_dict_item(it2, it[1], it[2])
            ## if it_a is not None:
                ## if len(it) != 3:
                    ## it_a = (it[0], ('!BOOLEAN', it_a)) + it[3:]
                ## return it_a[0][1:], it_a, t0
    return head, it, t0 

def resemble_str_concat(li):
    assert type(li) is tuple
    if len(li) <= 5:
        return li
    if len(li) > 5 and len(li) < 10:
        lim = int(len(li)/2)
        return (('!STR_CONCAT',) + li[:lim], ('!STR_CONCAT',) + li[lim:])
    if len(li) >= 10:
        li2 = []
        while len(li) >= 10:
            li2.append(('!STR_CONCAT',) + li[:5])
            li = li[5:]
        if len(li) <= 5:
            li2.append(('!STR_CONCAT',) + li)
            li = ()
        elif len(li) > 5 and len(li) < 10:
            lim = int(len(li)/2)
            li2.extend( [('!STR_CONCAT',) + li[:lim], ('!STR_CONCAT',) + li[lim:]])
            li = ()
        else:
            assert False
        return tuple(li2)
    assert False

    
def IsTracedType(t):
    global codegen_type
    if codegen_type == 0:
        return False
    elif codegen_type == 1:
        return IsC(t)
    elif codegen_type == 2:
        return IsC(t) or IsIntUndefSize(t)
    elif codegen_type == 3:
        return IsC(t) or IsIntUndefSize(t) or IsStr(t)
    elif codegen_type == 4:
        return t is not None
    elif codegen_type == 5:
        return True
    elif codegen_type >= 6:
        return t is None    
    
def attempt_str_direct_type_generation(it, t0 = None, _lb = None, _li = None, _le = None, _lr = None, _lf = None):
    assert type(it) is tuple
 
    if len(it) == 2 and it[0] == 'CONST':
        pass
    else:
        it = repl(it)

    assert type(it) is tuple
    it_ = it
    if t0 is None:
        t0 = TypeExpr(it)
    head, it, t0 = reorg_before(it, t0)
    assert type(head) is str
    assert type(it) is tuple
    if head[0] == '!':
        head = head[1:]
    assert type(head) is str
    if head == 'CALL_CALC_CONST' and IsCType(t0):
        o2 = Out()
        t0_native = TypeExpr(it_)
        if t0_native is not None:
            t0 = combine_type(t0, t0_native)
        if IsInt(t0) and t0[1][0] == t0[1][1]:
            _ty1 = t0[1][1]
        elif IsBool(t0) and t0[1] is not None:
            _ty1 = t0[1]
        elif IsChar(t0) and t0[1] is not None:
            _ty1 = t0[1]
        else:
            _ty1 = New(Type2CType(t0))
        ret_ = generate_call_calc_const(it, o2, None, _ty1)
        ty1 = set()
        o2, _ty1 = shortage((o2, _ty1)) 
        if type(ret_) is list:
            ty1 = set(ret_)
        elif istemptyped(_ty1):
            ty1 = set([_ty1]) 
        elif type(_ty1) is str:
            li = list_all_typed()
            assert type(ty1) is set
            for temp_ty in li:
                str_ty = ConC(temp_ty).strip()
                if name_in(str_ty, _ty1):
                    reactivate_typed(str_ty)
                    ty1.add(temp_ty)   
        elif (type(_ty1) is int or type(_ty1) is bool or (type(_ty1) is str and len(_ty1) == 1)) or (type(_ty1) is tuple and _ty1[0] == 'CONST') :
            pass
        else:
            assert False
        assert type(ty1) is set
        return o2, ConC(_ty1), ty1, None, None

    ## if head == 'Power':
        ## ## if it[3] != 'Py_None':
            ## ## return None, None, set(), None, None             
        ## if len(it) > 3 and it[3] == 'Py_None':
            ## ## pp(it)
            ## ## pprint(it_)
            ## ## assert it[3] == 'Py_None'
            ## it = (head, it[1], it[2])

    if head == 'PY_TYPE':
        if not true_attempt_direct(it[3]) and not IsCType(it[1:3]):
            return None, None, set(), None, None     
        return attempt_str_direct_type_generation(it[3], TypeExpr(it), _lb, _li, _le, _lr, _lf)

    t_it0 = [x for x in it[1:]]
    if type(it[0]) is str and it[0].endswith('.tp_new'):
        t_it0 = t_it0[1:]
    ## if len(t_it0) >= 1 and all([ is_calc_arg(x)[0] \
                                ## for x in t_it0]) and \
                            ## it[0] not in not_d_built and \
                            ## it[0] not in ( '!PyObject_GetAttr', \
                                          ## 'AssertionError', 'SystemError', 'SystemExit', \
                                          ## 'TypeError', 'RuntimeError', 'open', 'AttributeError', '!M:close',\
                                          ## 'ValueError', 'UnicodeError', '!GET_ITER', '!PyObject_GetIter', 'iter', \
                                          ## '!PySlice_New', 'KeyError', 'compile', '!M:encode', 'OSError', 'OverflowError', \
                                          ## 'ImportError', 'Exception', 'NotImplementedError', '!M:__getformat__',\
                                          ## 'ZeroDivisionError', 'UserWarning', '!M:decode', '!M:format', '!M:fromkeys',\
                                          ## 'UnicodeTranslateError', 'UnicodeEncodeError', '!PyLong_FromVoidPtr', '!M:read', \
                                          ## '!M:attrgetter', '!M:itemgetter', '!M:methodcaller', \
                                          ## 'UnicodeDecodeError', 'StandardError', 'IOError', '!M:__setformat__', 'execfile', \
                                          ## 'StopIteration', 'SyntaxError', 'BaseException', 'GeneratorExit'):
        ## if it[0] == '!PyObject_Call' and it[1][0] == '!LOAD_BUILTIN' and \
            ## it[1][1] in ('compile', '__import__'):
                ## pass
        ## else:

        


    if IsCType(t0):
        if g_co.IsCVar(it) or CVarName(it) is not None:
            return Out(), CVarName(it), set(), None, None
        elif it[0] in ('FAST', 'CALC_CONST', 'CONST'):
            return Out(), Obj2C(it, t0), set(), None, None
        if g_co.IsCVar(it) or CVarName(it) is not None:
            return Out(), CVarName(it), set(), None, None
        if head == 'CALC_CONST' or head == 'FAST' or head == 'CONST':
            return Out(), Obj2C(it, t0), set(), None, None
        if head == 'LOAD_GLOBAL' or head == '!LOAD_GLOBAL':
            n_it = ('!LOAD_GLOBAL', it[1])

            if g_co.IsCVar(n_it) or IsCVar(n_it):
                return Out(), CVarName(n_it), set(), None, None 
        if head == 'TYPED_TEMP':
            return Out(), CVar(it), set([it]), None, None

            ## pp(it)
#            assert False
    if it[0] in set_not_attempt:
        return None, None, set(), None, None     
    
    if head == 'OR_BOOLEAN' or head == 'OR_JUMP':
        return andor_attempt_str_direct_type_generation(it, ' || ')
    if head == 'AND_BOOLEAN' or head == 'AND_JUMP':
        return andor_attempt_str_direct_type_generation(it, ' && ')  
 
    if head == 'CONST':
        return None, None, set(), None, None     

    t = [None for x in it[1:]]
    if head == 'TYPED_TEMP':
        pp(head, it, t0)
        assert head != 'TYPED_TEMP'
    if head not in dict_type_rule2: 
        if head == 'PY_TYPE':
            t[0] = TypeExpr(it[3])
        else:
            t = [TypeExpr(x) for x in it[1:]]
            fe = [GenericType(TypeExpr(x), x) for x in it[1:]]
            if IsTracedType(t0):
                if codegen_notexist > 0:
                    fe = [GenericType(TypeExpr(x), x) for x in it[1:]]
                    if codegen_notexist == 1:
                        pp('NotExist', head + '#' + str(len(it) - 1).strip())
                    elif codegen_notexist == 2:
                        pp('NotExist', head + '#' + str(len(it) - 1).strip(), '->', GenericType(t0, it_))
                    elif codegen_notexist == 3:
                        pp('NotExist', head + '#' + str(len(it) - 1).strip(), fe, '->', GenericType(t0, it_))
                    elif codegen_notexist == 4:
                        pp('NotExist', head + '#' + str(len(it) - 1).strip(), [TypeExpr(x) for x in it[1:]], '->', t0)
                    elif codegen_notexist == 5:
                        pp('NotExist', head + '#' + str(len(it) - 1).strip(), [TypeExpr(x) for x in it[1:]], '->', t0, '## ', it_)
                    elif codegen_notexist >= 6:
                        pp('NotExist', head + '#' + str(len(it) - 1).strip(), [TypeExpr(x) for x in it[1:]], '->', t0, '## ', it_, '##', it)
            
        if head == 'FAST' and t0 == Kl_List:
            pp(head)
            pp(it)
            pp(t0)
            pp(set_not_attempt)
            assert False
        return None, None, set(), None, None     
    li = dict_type_rule2[head]
    assert type(li) is list
    t = [TypeExpr(x) for x in it[1:]]
    it0 = [x for x in it[1:]]
    if any([is_nano(x) for x in it0]):
        return None, None, set(), None, None      
    patt = None
    touse = None
    checktupl = None
    checktuplerr = None
    is_obj = None
    for tupl in li:
        assert type(tupl) is tuple
        patt = None
        it0 = [x for x in it[1:]]
        tupl0 = tupl[0]
        assert type(tupl0) is list
        if len(tupl0) != len(it0):
            continue
        m = [match_type(tupl0[i][0], tupl0[i][1], t[i], x) for i, x in enumerate(it0)]
        ## if  repr(('FAST', 'ret0')) in repr(it) and repr(('CONST', 'TYPED_TEMP')) in repr(it):

        if not all(m):
            continue
        for i,x in enumerate(it0):
            if type(tupl0[i][1]) is str:
                if x[0] == tupl0[i][1]:
                    it0[i] = x[1]
                    t[0] = TypeExpr(x[1])
                else:
                    it0[i] = None
        if None in it0:
            continue

        mr = match_type(tupl[4], None, t0, it)
        if mr is False:
            continue  

        patt = tupl[5]
        if len(tupl) > 6:
            touse = tupl[6]
        if len(tupl) > 7 and type(tupl[7]) is tuple:
            checktupl, checktuplerr = tupl[7]  
        is_obj = [not IsCType(x[0]) for x in tupl0]
        break


    if type(patt) is bool and patt is False:
        pp('-=-*', head, t, '->', t0)
        pprint(it)      
        pp('')
        return None, None, set(), None, None     
    if patt is None: 
#        if IsCType(t0) or t0 is not None:
        if IsTracedType(t0):
            if codegen_notfound > 0:
                ## if it_ == ('!PyNumber_Multiply', ('PY_TYPE', int, Kl_Int[1], ('FAST', 'c'), None), ('PY_TYPE', int, Kl_Int[1], ('FAST', 'c'), None)):

                    ## assert False
                fe = [GenericType(TypeExpr(x), x) for x in it[1:]]
                if codegen_notfound == 1:
                    pp('NotFound', head + '#' + str(len(it) - 1).strip())
                elif codegen_notfound == 2:
                    pp('NotFound', head + '#' + str(len(it) - 1).strip(), '->', GenericType(t0, it_))
                elif codegen_notfound == 3:
                    pp('NotFound', head + '#' + str(len(it) - 1).strip(), fe, '->', GenericType(t0, it_))
                elif codegen_notfound == 4:
                    ## if head == 'PyObject_Call_nokey' and [TypeExpr(x) for x in it[1:]] == [(list, None), (tuple, ((str, ')ENDIF'),))]:
                        ## assert False
                    pp('NotFound', head + '#' + str(len(it) - 1).strip(), [TypeExpr(x) for x in it[1:]], '->', t0)
                elif codegen_notfound == 5:
                    pp('NotFound', head + '#' + str(len(it) - 1).strip(), [TypeExpr(x) for x in it[1:]], '->', t0, '## ', it_)
                elif codegen_notfound >= 6:
                    pp('NotFound', head + '#' + str(len(it) - 1).strip(), [TypeExpr(x) for x in it[1:]], '->', t0, '## ', it_, '##', it)
                

            ## if it == ('!PyNumber_And', ('!PyObject_GetAttr', ('FAST', 'co'), ('CONST', 'co_flags')), ('CONST', 4)):
                ## assert False
            ## if it == ('!BINARY_SUBSCR_Int', ('PY_TYPE', tuple, None, ('FAST', 'it1'), None), ('CONST', 1)) and t0 == (bool, None):
                ## assert False
                
        return None, None, set(), None, None     
    else:
        if IsTracedType(t0):
            if codegen_found > 0:
                fe = [GenericType(TypeExpr(x), x) for x in it[1:]]
                if codegen_found == 1:
                    pp('CodFound', head + '#' + str(len(it) - 1).strip())
                elif codegen_found == 2:
                    pp('CodFound', head + '#' + str(len(it) - 1).strip(), '->', GenericType(t0, it_))
                elif codegen_found == 3:
                    pp('CodFound', head + '#' + str(len(it) - 1).strip(), fe, '->', GenericType(t0, it_))
                elif codegen_found == 4:
                    pp('CodFound', head + '#' + str(len(it) - 1).strip(), fe, '/', tupl0, '->', GenericType(t0, it_), '/', tupl[4], '==>', patt)
                elif codegen_found == 5:
                    pp('CodFound', head + '#' + str(len(it) - 1).strip(), [TypeExpr(x) for x in it[1:]], '->', t0)
                elif codegen_found == 6:
                    pp('CodFound', head + '#' + str(len(it) - 1).strip(), [TypeExpr(x) for x in it[1:]], '->', t0)
                    pp('CodFound2', patt)
                elif codegen_found == 7:
                    pp('CodFound', head + '#' + str(len(it) - 1).strip(), [TypeExpr(x) for x in it[1:]], '->', t0, '#', patt, '## ', it_)
                    pp('CodFound2', patt)
                    pp('CodFound3', it_)
                elif codegen_found >= 8:
                    pp('CodFound', head + '#' + str(len(it) - 1).strip(), [TypeExpr(x) for x in it[1:]], '->', t0, '#', patt, '## ', it_)
                    pp('CodFound1', tupl)
                    pp('CodFound2', patt)
                    pp('CodFound3', it_)
        
    if type(patt) is not str and type(patt) is not list:
        patt = patt(it0, t)
      
    ty_ = []
    o_ = []
    ty1 = set()
    if len(it0) == 0 and in_patt('L0', patt):
        patt = patt[:]
        patt = patt_replace(patt, 'L0', CVar(labl))
        UseLabl()  
    assert type(it0) is list  
     
    for i, x in enumerate(it0):     
        it1, patt, o1, ty1, checktupl, checktuplerr = expr_to_s(x, patt, '{L' + str(i+1).strip() +'}', t[i], checktupl, checktuplerr, is_obj[i])
        assert type(ty1) is set
        ty1 = set([x for x in ty1 if istemp(x) or istemptyped(x)])
        if it1 is not None:
            return None, None, set(), None, None     
        o_.append(o1)
        ty_.append(ty1)
    assert type(ty1) is set
    global g_typed_stack

    assert type(ty_) is list
    assert type(o_) is list
    for i in range(len(it0)):
        ty1 = ty_[i]
        assert type(ty1) is set
        for x in g_typed_stack:
            if x in ty1:
                ty1.remove(x)
        o1 = o_[i]
        assert type(o1) is Out
        if len(o1) > 0 and len(ty1) > 0:
            temp01 = o1[-1]
            assert type(temp01) is str
            if temp01.startswith('CLEARTEMP('):
                temp1 = ('TYPED_TEMP', int(temp01[10:-2]))
                if temp1 in ty1:
                    print 'ty1.remove', temp1, it0[i]
                    ty1.remove(temp1)        
    if len(it0) == 2:
        ty1 = ty_[0]
        ty2 = ty_[1]
        o1 = o_[0]
        o2 = o_[1]
        assert type(ty2) is set
        ty1 = [x for x in ty1 if istemp(x)]
        ty2 = [x for x in ty2 if istemp(x)]
        ty3 = [x for x in ty1 if x in ty2 and istemptyped(x)]
        ty3 = [x for x in ty3 if x not in g_typed_stack]
        if len(ty3) > 0:
            if ty3 == ty1 and ty1 == ty2  and len(ty1) == 1 and expr_in_expr(ty1[0], it[1]) and expr_in_expr(ty1[0], it[2]):
                pass
            else:
                pp(expr_in_expr(ty1[0], it[1]), ty1[0], it[1])
                pp(expr_in_expr(ty1[0], it[2]), ty1[0], it[2])
                pp(ty3)
                pp('/1')
                pp(ty1)
                pp('/2')
                pp(ty2)
                pp('/3')
                pprint(it)
                pp('/4')
                pprint(o1)
                pprint(o2)
                pp('/6')
                pprint(patt)   
                pp('--------')
                pprint(it)
                pp('===')
                pprint(ty3)  
                print g_typed_stack
                assert len(ty3) == 0
    o = Out()
    if touse is not None:
        Used(touse)        
    li = set()
    ty = set()
    for x in ty_:
        for x2 in x:
            ty.add(x2) 
    if in_patt('{LR}', patt):
        if _lr is None:
            _lr = New()
        if _lr not in li:
            li.add(_lr)
        patt = patt_replace(patt, '{LR}', CVar(_lr))
    if in_patt('{LI}', patt):
        if _li is None:
            _li = New('long')
        if _li not in li:
            li.add(_li)
        patt = patt_replace(patt, '{LI}', CVar(_li))
    if in_patt('{LB}', patt):
        if _lb is None:
            _lb = New('int')
        if _lb not in li:
            li.add(_lb)
        patt = patt_replace(patt, '{LB}', CVar(_lb))        
    if in_patt('{LF}', patt):
        if _lf is None:
            _lf = New('double')
        if _lf not in li:
            li.add(_lb)
        patt = patt_replace(patt, '{LF}', CVar(_lf))        
    if in_patt('{LE}', patt):
        if _le is None:
            assert checktuplerr is not None
            _le = add_check_message(None, checktuplerr, None)
        assert _le is not None
        patt = patt_replace(patt, '{LE}', CVar(_le))        

    o = Out()

    if in_patt('S{L', patt):
        for i,x in enumerate(o_):
            patt = patt_replace(patt, 'S{L' + str(i+1).strip() + '}', x)
            o_[i] = Out()
        # pprint(patt)
        ##assert False
    else:
        for x in o_: 
            o.extend(x)
    if type(patt) is list:
        for x in patt[:-1]:
            o.append(x)
        patt = patt[-1]
    if patt == ConC(_lr) or patt == ConC(_li) or patt == ConC(_lb) or patt == ConC(_lf):
        for v in ty.copy():
            if istempref(v) and ConC(v) != patt:
                o.Cls(v)
                ty.remove(v)
    return o, patt, ty | li, checktupl, checktuplerr

def patt_replace(patt, a, b):
    assert type(a) is str
    if type(patt) is str:
        return patt.replace(a,b)
    assert type(patt) is list
    if a.startswith('S{L'):
        patt2 = []
        for x in patt:
            if x == a:
                patt2.extend(b)
            else:
                patt2.append(x)
        return patt2        
    return [x if x.startswith('S{L') else x.replace(a,b) for x in patt]

def in_patt(s, patt):
    if type(patt)is str:
        return s in patt
    return any([s in x for x in patt])

def is_not_applicable_patt(patt):
    return in_patt('OPyString_AS_STRING', patt) or in_patt('OPyInt_AS_LONG', patt) or in_patt('Olong_', patt) or in_patt('OPy_ssize_t_', patt) or in_patt('O*', patt) or in_patt('OGETLOCAL(', patt) or in_patt('Otemp[', patt)  or in_patt(' O(', patt)

def New_ref(s_patt):
    li = []
    while True:
        ref3 = New()
        if in_patt(CVar(ref3), s_patt):
            li.append(ref3)
            continue
        break
    if len(li) > 0:    
        o3 = Out()
        o3.Cls(*li)
    return ref3

def repl_L1(patt, L1, s, checktupl, checktuplerr, listch = None, typ = None, ty1 = None):

    assert type(s) is str
    assert s.strip() != ''
    assert type(ty1) is set
##    pprint((patt, L1, s, checktupl, checktuplerr, listch, typ, ty1))
    
    if listch is not None:
        for a,b in listch:
            patt = patt_replace(patt, a, b)
    if in_patt(('O' + L1), patt):
        if s.startswith('PyInt_AS_LONG( ') and s.endswith(' )'):
            patt = patt_replace(patt, 'O' + L1, s[15:-2])
        elif s.startswith('PyInt_AS_LONG ( ') and s.endswith(' )'):
            patt = patt_replace(patt, 'O' + L1, s[16:-2])
        elif s.startswith('PyFloat_AS_DOUBLE( ') and s.endswith(' )'):
            patt = patt_replace(patt, 'O' + L1, s[19:-2])
        elif s.startswith('PyFloat_AS_DOUBLE ( ') and s.endswith(' )'):
            patt = patt_replace(patt, 'O' + L1, s[20:-2])
        elif s.startswith('*PyString_AS_STRING ( ') and s.endswith(' )'): 
            patt = patt_replace(patt, 'O' + L1, s[22:-2])
        elif s.startswith('*PyString_AS_STRING( ') and s.endswith(' )'): 
            patt = patt_replace(patt, 'O' + L1, s[22:-2])         
        elif IsInt(typ): # and ' ' not in s : #s.startswith('Loc_long_'):
            if type(patt) is str:
                patt = [patt]            
            assert type(patt) is list
            if s.isdigit():
                v = int(s)
                assert type(v) is int
                const_to(v)
                patt = patt_replace(patt, 'O' + L1, CVar(('CONST', v)))
            else:
#            pprint((patt, L1, s, checktupl, checktuplerr, listch, typ, ty1))
                assert not s.isdigit()
                patt = patt[:]
                i = 0
                while i < len(patt):
                    s_patt = patt[i]
                    assert type(s_patt) is str
                    if ('O' + L1) in s_patt:
                        o3 = Out()
                        ref3 = New_ref(s_patt)
                        assert not s.startswith('temp[')
                        o3.Raw(ref3, ' = PyInt_FromLong( ', s, ' );')
                        o3.Cls(ref3)
                        assert len(o3) == 2
                        assert CVar(ref3) not in s_patt
                        reactivate_tempref(ref3)
                        assert type(ty1) is set
                        ty1.add(ref3)
                        patt[i:i+1] = [o3[0], s_patt.replace(('O' + L1), CVar(ref3)), o3[-1]] #insert(i+2, o3[-1])
                        i+=3
                    else:
                        i+=1
        elif IsFloat(typ): # and ' ' not in s : #s.statswith('Loc_long_'):
            if type(patt) is str:
                patt = [patt]            
            assert type(patt) is list
            assert not s.isdigit()
            patt = patt[:]
            i = 0
            while i < len(patt):
                s_patt = patt[i]
                assert type(s_patt) is str
                if ('O' + L1) in s_patt:
                    o3 = Out()
                    ref3 = New_ref(s_patt)
                    assert not s.startswith('temp[')
                    o3.Raw(ref3, ' = PyFloat_FromDouble( ', s, ' );')
                    o3.Cls(ref3)
                    assert len(o3) == 2
                    reactivate_tempref(ref3)
                    ty1.add(ref3)
                    assert CVar(ref3) not in s_patt
                    patt[i:i+1] = [o3[0], s_patt.replace(('O' + L1), CVar(ref3)), o3[-1]] #insert(i+2, o3[-1])
                    i+=3
                else:
                    i+=1
        elif IsChar(typ): # and ' ' not in s : #s.statswith('Loc_long_'):
            if type(patt) is str:
                patt = [patt]            
            assert type(patt) is list
            assert not s.isdigit()
            patt = patt[:]
            i = 0
            while i < len(patt):
                s_patt = patt[i]
                assert type(s_patt) is str
                if ('O' + L1) in s_patt:
                    o3 = Out()
                    ref3 = New_ref(s_patt)
                    assert not s.startswith('temp[')
                    o3.Raw(ref3, ' = PyString_FromStringAndSize( NULL, 1 );') #, s, ');')
                    o3.Raw('PyString_AS_STRING(', ref3, ')[0] = ', s, ';')
                    o3.Cls(ref3)
                    assert len(o3) == 3
                    reactivate_tempref(ref3)
                    ty1.add(ref3)
                    assert CVar(ref3) not in s_patt
                    patt[i:i+1] = [o3[0], o3[1], s_patt.replace(('O' + L1), CVar(ref3)), o3[-1]] #insert(i+2, o3[-1])
                    i+=4
                else:
                    i+=1
        elif IsBool(typ): # and ' ' not in s : #s.statswith('Loc_long_'):
            ##assert type(patt) is list
            assert not s.isdigit()
            assert not s.startswith('temp[')
            if type(patt) is str:
                patt = [patt]
            assert type(patt) is list
            assert not s.isdigit()
            patt = patt[:]
            i = 0
            while i < len(patt):
                s_patt = patt[i]
                assert type(s_patt) is str
                if ('O' + L1) in s_patt:
                    s2 = '((' + s + ')?Py_True:Py_False)'
                    patt[i] = s_patt.replace(('O' + L1), s2)
                i+=1
        else:
            pp(typ, (patt, L1, s, checktupl, checktuplerr, listch, typ, ty1))
            assert False
            
    if is_not_applicable_patt(patt):
        pp(patt, L1, s, listch)
        assert False
    if s.startswith('temp[') and in_patt(L1, patt) and L1 != s:
        if in_patt(s, patt):
            pp(s)
            pp(L1)
            pp(typ)
            pprint(patt)
        assert not in_patt(s, patt)
    patt = patt_replace(patt, L1, s)
    if is_not_applicable_patt(patt):
        pp(patt, L1, s, listch)
        assert False

    if in_patt('L0', patt):
        patt = patt_replace(patt, 'L0', CVar(labl))
        UseLabl()
    if checktupl is not None:
        assert type(checktupl) is str
        checktupl = checktupl.replace(L1, s)
    if checktuplerr is not None:
        if type(checktuplerr) is str:
            checktuplerr = checktuplerr.replace(L1, s)
        elif type(checktuplerr) is tuple:
            checktuplerr = tuple([x.replace(L1,s) for x in checktuplerr])
    return patt, checktupl, checktuplerr

def expr_to_s(it1, patt, L1, t1, checktupl, checktuplerr, is_obj):
    if not in_patt(L1, patt):
        ty1 = set()
        it1 = None
        assert type(ty1) is set
        if in_patt('L0', patt):
            patt = patt[:]
            patt = patt_replace(patt, 'L0', CVar(labl))
            UseLabl()        
        return it1, patt, Out(), ty1, checktupl, checktuplerr        
    if type(patt) is not str and type(patt) is not list:
        pp(it1)
        pp(patt)
        pp(L1)
        pp(t1)
        pp(checktupl)
        pp(checktuplerr)
    assert type(patt) is str or type(patt) is list
    if type(it1) is str: ## and (it1 == 'bdict' or it1.startswith('PyList_GET_ITEM')  or it1.startswith('PyTuple_GET_ITEM')):
        s = it1
        ty1 = set()
        patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], Kl_Dict, ty1)
        it1 = None
        assert type(ty1) is set
        return it1, patt, Out(), ty1, checktupl, checktuplerr
    if type(it1) is tuple and istempref(it1):
        s = CVar(it1)
        ty1 = set()
        patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], Kl_Dict, ty1)
        it1 = None
        assert type(ty1) is set
        return it1, patt, Out(), ty1, checktupl, checktuplerr

    if not type(it1) is tuple:
        pp((it1, patt, L1, t1, checktupl, checktuplerr, is_obj))
    assert type(it1) is tuple
    assert type(L1) is str
    o2, s, ty1, checktupl1, checktuplerr1 = attempt_str_direct_type_generation(it1, t1)
    assert type(ty1) is set
    ot1 = TypeExpr(it1)
    
    if s is not None:
        labl_err = add_check_message(checktupl1, checktuplerr1, o2)
        listch = []
        if it1 is not None:
            if it1[0] == 'PY_TYPE':
                if it1[3][0] == 'FAST' and not IsCVar(it1[3]) and IsCType(t1):
                    listch.append(('O' + L1,  ConC(it1[3])))    
                if it1[3][0] == '!@PyInt_FromSsize_t':
                    if not IsCVar(it1[3][2]) and it1[3][2][0] == 'FAST':
                        listch.append(('O' + L1,  ConC(it1[3][2])))
            if it1[0] == '!@PyInt_FromSsize_t':
                if not IsCVar(it1[2]) and it1[2][0] == 'FAST':
                    listch.append(('O' + L1,  ConC(it1[2])))   
                    
            if it1[0] == 'CONST':
                s = str(it1[1])
                t_it1 = TypeExpr(it1)
                if IsInt( t_it1) and type(it1[1] * it1[1]) is long and not s.endswith('l') and not s.endswith('L'):
                    s = s + 'L'
                    if it1[1] == ((MInt * -1) - 1):
                        s = 'LONG_MIN'
                elif IsChar(t_it1):
                    if not is_obj:
                        s = repr(it1[1])[1:-1]
                        if s == "'":
                            s = '\\\''
                        s = "'" + s + "'"
                    else:
                        ind_const = index_const_to(it1[1])
                        add_predeclaration_char_const(ind_const)
                        cref_nm = ConC('consts[', ind_const, ']')
                        listch.append(('O' + L1,  cref_nm))    
                        s = cref_nm                           
                elif IsBool( t_it1):
                    if it1[1]:
                        s = '1'
                    else:
                        s = '0'
                assert type(s) is str
                if type(it1[1]) == str:
                    ind_const = index_const_to(it1[1])
                    add_predeclaration_char_const(ind_const)
                    cref_nm = ConC('const_string_', ind_const)
                    cref_sz = ConC(len(it1[1]))
                    
                    append_four(listch, 'PyString_GET_SIZE', L1, cref_sz)
                    append_four(listch, 'PyString_AS_STRING', L1, cref_nm)
                    
                    cref_nm = ConC('consts[', ind_const, ']')
                    listch.append(('O' + L1,  cref_nm))    
                    if s.strip() == '':
                        s == cref_nm  
                  
                if type(it1[1]) == int or type(it1[1]) == float:
                    ind_const = index_const_to(it1[1])

                    cref_nm = ConC('consts[', ind_const, ']')
                    listch.append(('O' + L1,  cref_nm))   
                if type(it1[1]) == bool:
                    if it1[1]:
                        listch.append(('O' + L1,  'Py_True'))   
                    else:
                        listch.append(('O' + L1,  'Py_False'))   

        patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, listch, ot1, ty1)
        it1 = None
        assert type(ty1) is set
        return it1, patt, o2, ty1, checktupl, checktuplerr
    o2 = Out()
    ty1 = set()
    ot1 = TypeExpr(it1)
    if is_obj:
        listch = []
        if it1[0] in len_family:
            o2, _ty1 = short_gen_size_t((it1))
            ref1 = New()
            o2.Raw(ref1, ' = PyInt_FromLong ( ', _ty1, ' );')
            s = ConC(ref1)
            patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, ot1, ty1)
            return None, patt, o2, set([_ty1, ref1]), checktupl, checktuplerr
        else:
            o2 = Out()
            ref1 = LikeExpr1(it1, o2)
            if istempref(ref1) and in_patt(CVar(ref1), patt): # hack !!!
                ref1_ = ref1
                o2_ = o2
                o2 = Out()
                ref1 = LikeExpr1(it1, o2)
                o2_.Cls(ref1_)
            s = ConC(ref1)
            if ref1[0] == 'CONST' and type(ref1[1]) == str:
                ind_const = index_const_to(ref1[1])
                add_predeclaration_char_const(ind_const)
                cref_nm = ConC('const_string_', ind_const)
                cref_sz = ConC(len(ref1[1]))
                
                append_four(listch, 'PyString_GET_SIZE', L1, cref_sz)
                append_four(listch, 'PyString_AS_STRING', L1, cref_nm)

            if ref1[0] == 'CONST' and type(ref1[1]) == tuple:
                cref_nm1 = ConC(ref1)
                cref_nm = str(len(ref1[1])).strip()
                listch.append(('PyTuple_GET_SIZE(' + cref_nm1 + ')', cref_nm))
                listch.append(('PyTuple_GET_SIZE(' + L1 + ')', cref_nm))
                for i, iit in enumerate(ref1[1]):
                    cref_nm = const_to(iit)
                    listch.append(('PyTuple_GET_ITEM ( ' + cref_nm1 + ' , ' + str(i) + ' )', cref_nm))
                    listch.append(('PyTuple_GET_ITEM ( ' + L1 + ' , ' + str(i) + ' )', cref_nm))
                    if type(iit) is str:
                        ind_const = index_const_to(iit)
                        add_predeclaration_char_const(ind_const)
                        cref_nm1 = ConC('const_string_', ind_const)
                        cref_sz = ConC(len(iit))
                        
                        append_four(listch, 'PyString_GET_SIZE', cref_nm, cref_sz)
                        append_four(listch, 'PyString_AS_STRING', cref_nm, cref_nm1)                       

            if ref1[0] == 'CALC_CONST' and IsTuple(t1) and type(t1[1]) is tuple:
                cref_nm1 = ConC(ref1)
                cref_nm = str(len(t1[1])).strip()
                listch.append(('PyTuple_GET_SIZE(' + cref_nm1 + ')', cref_nm))
                listch.append(('PyTuple_GET_SIZE(' + L1 + ')', cref_nm))

            patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, listch, ot1, ty1)
        return None, patt, o2, set([ref1]), checktupl, checktuplerr
    if it1 is not None and it1[0] == 'CONST':
        s = str(it1[1])
        t_it1 = TypeExpr(it1)
        if IsInt( t_it1) and type(it1[1] * it1[1]) is long and not s.endswith('l') and not s.endswith('L'):
            s = s + 'L'
        elif IsChar(t_it1):
            s = repr(it1[1])[1:-1]
            if s == "'":
                s = '\\\''
            s = "'" + s + "'"
        elif IsBool( t_it1):
            if it1[1]:
                s = '1'
            else:
                s = '0'
        listch = []
        if type(it1[1]) == int:
            ind_const = index_const_to(it1[1])

            cref_nm = ConC('consts[', ind_const, ']')
            listch.append(('O' + L1,  cref_nm))                
        patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, listch, ot1, ty1)
        it1 = None
    if it1 is not None and IsCVar(it1):
        s = CVarName(it1)
        patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
        it1 = None        
    if it1 is not None and it1[0] == '!@PyInt_FromSsize_t':
        if IsCVar(it1[2]):
            s = CVarName(it1[2])
            patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
        else:  
            g = it1[1]
            s = typed_gen[g[1]][1] + '_' + str(g[1])
            listch = []
            if it1[2][0] == 'FAST':
                listch.append(('O' + L1,  ConC(it1[2])))
            patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, listch, ot1, ty1)
        it1 = None        
    if it1 is not None and it1[0] == 'PY_TYPE':
        listch = []
        if it1[3][0] == 'FAST' and not IsCVar(it1[3]):
            if IsCType(t1):
                s = Obj2C(it1[3], t1)
                listch.append(('O' + L1,  ConC(it1[3])))
            elif IsStr(t1) or IsList(t1) or IsTuple(t1) or IsDict(t1) or IsUnicode(t1):
                assert False
            else:
                pprint(it1)
                pp(t1)
                assert False
            if s is not None:
                patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, listch, ot1, ty1)
                it1 = None   

    if it1 is not None and it1[0] == '!PY_SSIZE_T':
        o2, _ty1 = short_gen_size_t((it1[1]))
        s = ConC(_ty1)
        patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
        it1 = None
        return it1, patt, o2, set([_ty1]), checktupl, checktuplerr
    if it1 is not None:
        o2, s, ty1, checktupl1, checktuplerr1 = attempt_str_direct_type_generation(it1)
        assert type(ty1) is set
        if s is not None:
            labl_err = add_check_message(checktupl1, checktuplerr1, o2)
            patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
            it1 = None
            assert type(ty1) is set
            return it1, patt, o2, ty1, checktupl, checktuplerr
    if it1 is not None and IsBool(t1):
        o2, _ty1 = shortage(generate_logical_expr(it1))
        if istemptyped(_ty1):
            ty1 = set([_ty1])
        elif type(_ty1) is str:
            li = list_all_typed()
            for temp_ty in li:
                str_ty = ConC(temp_ty).strip()
                if name_in(str_ty, _ty1):
                    reactivate_typed(str_ty)
                    ty1.add(temp_ty)

        s = ConC(_ty1)
        patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
        it1 = None
        assert type(ty1) is set
        return it1, patt, o2, ty1, checktupl, checktuplerr    
    if it1 is not None and it1[0] == '!PyObject_Call' and it1[1][0] == 'CALC_CONST':
        t = it1[1][1] 
        if type(t) is str and t in ImportedM:
            t = ImportedM[t]
        elif len(t) == 2 and t[0] in ImportedM:
            t = (ImportedM[t[0]], t[1])
        if t in CFuncFloatOfFloat and IsFloat(TypeExpr(it1[2][1][0])):
            o2, s, ty1, checktupl1, checktuplerr1 = attempt_str_direct_type_generation(it1[2][1][0])
            assert type(ty1) is set
            if s is not None:
                labl_err = add_check_message(checktupl1, checktuplerr1, o2)
                _s = ConC(CFuncFloatOfFloat[t], '( ', s, ' )')
                patt, checktupl, checktuplerr = repl_L1(patt, L1, _s, checktupl, checktuplerr, [], ot1, ty1)
                it1 = None
                assert type(ty1) is set
                return it1, patt, o2, ty1, checktupl, checktuplerr            

    assert type(ty1) is set
    if it1 is not None and it1[0] in len_family:
        o2, _ty1 = short_gen_size_t((it1))
        s = ConC(_ty1)
        patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
        it1 = None
        return it1, patt, o2, set([_ty1]), checktupl, checktuplerr

    if it1 is not None:
        o2 = Out()
        ref1 = LikeExpr1(it1, o2)
        last = len(o2) - 1
        while last >= 0:
            o2_last = o2[last]
            assert type(o2_last) is str
            if o2_last.startswith('CLEARTEMP'):
                last -= 1
                continue
            if o2_last.startswith('Py_CLEAR'):
                last -= 1
                continue
            if o2_last.startswith('temp[') and o2_last.endswith(' = 0;'):
                last -= 1
                continue
            break
        assert type(last) is int 
        if last >= 0 and 'From' in o2[last] and last == len(o2) - 1:
            pprint(o2)
            ## pprint(it1)
            v2 = {}
            if TxMatch(o2, last, 'temp[$0] = PyInt_FromLong ( $2 );', v2):     
                o2, _ty1, ty1 = shortage2(o2, v2[2].strip(), last, ref1)
                s = ConC(_ty1)
                patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
                it1 = None
                return it1, patt, o2, set(ty1), checktupl, checktuplerr
            elif TxMatch(o2, last, 'if ((temp[$0] = PyFloat_FromDouble ( $2 )) == 0) goto label_$10;', v2): 
                o2, _ty1, ty1 = shortage2(o2, v2[2].strip(), last, ref1)
                s = ConC(_ty1)
                patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
                it1 = None
                return it1, patt, o2, set(ty1), checktupl, checktuplerr
            elif TxMatch(o2, last, 'temp[$0] = PyFloat_FromDouble ($2);', v2): 
                o2, _ty1, ty1 = shortage2(o2, v2[2].strip(), last, ref1)
                s = ConC(_ty1)
                patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
                it1 = None
                return it1, patt, o2, set(ty1), checktupl, checktuplerr 
            elif TxMatch(o2, last, "if ((temp[$0] = PyBool_FromLong ( $2 )) == 0) goto label_$10;", v2):     
                o2, _ty1, ty1 = shortage2(o2, v2[2].strip(), last, ref1)
                s = ConC(_ty1)
                patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
                it1 = None
                assert type(ty1) is set
                return it1, patt, o2, ty1, checktupl, checktuplerr 
            elif TxMatch(o2, last, "temp[$0] = PyString_FromStringAndSize($2, 1);", v2):
                o2, _ty1, ty1 = shortage2(o2, v2[2].strip(), last, ref1)
                s = ConC('*(', _ty1, ')')
                patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
                it1 = None
                return it1, patt, o2, set(ty1), checktupl, checktuplerr   
            elif TxMatch(o2, last, 'if ((temp[$0] = PyInt_FromLong ( $2 )) == 0) goto label_$10;', v2): 
                o2, _ty1, ty1 = shortage2(o2, v2[2].strip(), last, ref1)
                s = ConC(_ty1)
                patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
                it1 = None
                return it1, patt, o2, set(ty1), checktupl, checktuplerr
            pprint(o2)
            pprint(it1)
            assert False
        
        assert ref1[1] != 'CONST'
        if istempref(ref1):
            ty1 = set([ref1])
        if IsCType(t1):
            s = Obj2C(ref1, t1)
        else: # IsType(t1): ## and it1[0] == 'CALC_CONST':
            s = ConC(ref1)
        assert type(ty1) is set
        patt, checktupl, checktuplerr = repl_L1(patt, L1, s, checktupl, checktuplerr, [], ot1, ty1)
        it1 = None
        assert type(ty1) is set
        return it1, patt, o2, ty1, checktupl, checktuplerr          
##    assert type(ty1) is list
    assert type(ty1) is set
    return it1, patt, o2, ty1, checktupl, checktuplerr

def append_four(listch, nm, L1, cref_sz):
    listch.append((nm + '(' + L1 + ')',    cref_sz))
    listch.append((nm + ' ( ' + L1 + ' )', cref_sz))
    listch.append((nm + '( ' + L1 + ' )',  cref_sz))
    listch.append((nm + ' (' + L1 + ')',   cref_sz))
    
def shortage2(o2, _ty1, last, ref1):
    assert last == len(o2) - 1
    o2, _ty1 = shortage((o2, _ty1), False)

    if len(o2) - 1 == last:
        o2.Cls(ref1)
        while len(o2) > last:
            del o2[-1]
    else:
        assert False
    if istemptyped(_ty1):
        ty1 = [_ty1] 
    elif type(_ty1) is str:
        ty1 = []
        li = list_all_typed()
        for temp_ty in li:
            str_ty = ConC(temp_ty).strip()
            if name_in(str_ty, _ty1):
                reactivate_typed(str_ty)
                ty1.append(temp_ty)  
    else:
        ty1 = []
        assert False
    return o2, _ty1, set(ty1)

def add_check_message(checktupl, checktuplerr, o2):
    tolabl = None
    if checktuplerr is not None:
        o_2 = Out() 
        o_2.Raw(checktuplerr)
        o_2.Raw('goto ', labl, ';')
        tolabl = append_to_exception(o_2)                   
        UseLabl() 
    if checktupl is not None:
        assert checktuplerr is not None
        o2.Raw('if (', checktupl, ') goto ', tolabl, ';')  
    return tolabl
       

class CalcConst(object):
    def __init__(self, k, n):
        self.nm = k
        self.no = n
        self.is_mnemonic_constant = False
        self.mnemonic_constant_value = None
        self.all_calc_value = None
        self.value = None
        self.generate = True
        self.isoldclass = False
        self.isnewclass = False
        self.isanyclass = False
        self.derived_from = {}
        self.store_calced = False
        self.count_fathers = None
        self.know_all_fathers = None
        
def IsAnyClass(nm):
    if nm not in calculated_const:
        return False
    cl = calculated_const[nm]
    return bool(cl.isoldclass) or bool(cl.isnewclass) or bool(cl.isanyclass)

def IsNewClass(nm):
    if nm not in calculated_const:
        return False
    return bool(calculated_const[nm].isnewclass)

def IsOldClass(nm):
    if nm not in calculated_const:
        return False
    return bool(calculated_const[nm].isoldclass)

def RegisterAnyClass(cl_nm):
    RegClass(cl_nm, False, False, None)
        
def RegisterNewClass(cl_nm, father, cnt_fathers = None, know_all_fathers = None):
    RegClass(cl_nm, False, True, father, cnt_fathers, know_all_fathers)
        
def RegisterOldClass(cl_nm, father, cnt_fathers = None, know_all_fathers = None):
    RegClass(cl_nm, True, False, father, cnt_fathers, know_all_fathers)
        
def RegClass(nm, is_old, is_new, derived_from, cnt_fathers = None, know_all_fathers = None):
    assert nm in calculated_const
    assert type(is_old) is bool
    assert type(is_new) is bool

    c = calculated_const[nm]
    if is_old and not Is3(nm, 'HaveMetaClass') and not Is3('Init_filename', 'HaveMetaClass'):
        c.isoldclass = is_old
    if is_new:
        c.isnewclass = is_new
    c.isanyclass = True
    c.count_fathers = cnt_fathers
    c.know_all_fathers = know_all_fathers
    if derived_from is not None and len(derived_from) > 0:
        for k in derived_from:
            c.derived_from[k] = True
            all_derived[(nm, k)] = True  
    elif (derived_from is None or len(derived_from) == 0) and is_old:
        pass
    else:
        if know_all_fathers is None or know_all_fathers is True:
            pp(nm), derived_from, cnt_fathers, know_all_fathers, is_old, is_new
            assert False

def is_mnemonic_const(k):
    return k in calculated_const and calculated_const[k].is_mnemonic_constant

def set_mnemonic_const(k, v):
    if k not in calculated_const:
        calc_const_to(k)

    assert v[0] == 'CONST' or v[0][0] == '!'
    calculated_const[k].mnemonic_constant_value = v
    calculated_const[k].is_mnemonic_constant = True
    calculated_const[k].all_calc_value = v
    calculated_const[k].value = v
    calculated_const[k].generate = False

def set_all_calc_const(k, v):
    if k not in calculated_const:
        calc_const_to(k)
    calculated_const[k].all_calc_value = v
    calculated_const[k].value = v

def get_all_calc_const(k):
    return calculated_const[k].all_calc_value

def get_value_calc_const(k):
    return calculated_const[k].value
    
def found_all_calc_const(k):
    return k in calculated_const and calculated_const[k].all_calc_value is not None   

def found_value_calc_const(k):
    return k in calculated_const and calculated_const[k].value is not None   
    
def calc_const_to(k):
    global calculated_const
    if k in calculated_const:
        if calculated_const[k].is_mnemonic_constant:
            return calculated_const[k].mnemonic_constant_value
        return ('CALC_CONST', k)
    calculated_const[k] = CalcConst(k, len(calculated_const)) 
    return ('CALC_CONST', k)

if __name__ == '__main__':
    main ()
    ## aa = []
    ## for k,v in stats__.iteritems():
        ## aa.append((v, k))
    ## aa.sort()
    ## pprint(aa, 2, 200)
